# -*- coding: mbcs -*-
typelib_path = u'C:\\Program Files (x86)\\ArcGIS\\Engine10.2\\com\\esriGeoDatabase.olb'
_lcid = 0 # change this if required
from ctypes import *
from comtypes import GUID
from comtypes import CoClass
import comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0
import comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2
from ctypes import HRESULT
from comtypes.automation import VARIANT
from comtypes import helpstring
from comtypes import COMMETHOD
from comtypes import dispid
from ctypes.wintypes import VARIANT_BOOL
from comtypes import BSTR
import comtypes.gen._18F2FC71_6B30_45B9_B101_037A8B868B66_0_10_2
import comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2
from comtypes.automation import _midlSAFEARRAY
import comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2
from comtypes import IUnknown


class RecordNumberSet(CoClass):
    u'A collection of record numbers. Record number sets are used in selections with file based data.'
    _reg_clsid_ = GUID('{F59CCD31-46C6-11D4-A124-00C04F6BDF0E}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IFIDSet(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the FID Set.'
    _iid_ = GUID('{D79BDAF1-CAA8-11D2-B2BE-0000F878229E}')
    _idlflags_ = ['oleautomation']
class IFIDSet2(IFIDSet):
    _case_insensitive_ = True
    u'Provides access to members that control the FID Set.'
    _iid_ = GUID('{6EBAADC0-7541-46A4-82D7-4842EC9B1E55}')
    _idlflags_ = ['oleautomation']
class IFIDSetOperator(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the collection of feature ids, and to combine feature id collections.'
    _iid_ = GUID('{ED3C0C61-0C11-49E1-9D71-F3D2CAFF085F}')
    _idlflags_ = ['oleautomation']
class IRecordNumberSet(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the collection of record numbers, and to compare record number collections. Record number sets are used in selections with file based data.'
    _iid_ = GUID('{33572F5A-46C7-11D4-A124-00C04F6BDF0E}')
    _idlflags_ = ['oleautomation']
RecordNumberSet._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IFIDSet, IFIDSet2, IFIDSetOperator, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, IRecordNumberSet]

class DEGeometryServer(CoClass):
    u'GeometryServer Object Data Element object.'
    _reg_clsid_ = GUID('{1388334D-11A5-4BC0-8C5E-77F8123DA43B}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDEGeometryServer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe GlobeServer objects.'
    _iid_ = GUID('{CE77B268-A9F3-4454-8B91-9B24BCE35448}')
    _idlflags_ = ['oleautomation']
class IDEServerObject(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe ArcGIS server objects.'
    _iid_ = GUID('{97FCF277-10A5-4DCD-B098-8A3934A258A1}')
    _idlflags_ = ['oleautomation']
class IDataElement(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the Basic Data Element.'
    _iid_ = GUID('{E2C87DF0-33D9-4A47-9B67-FA54B2FD7966}')
    _idlflags_ = ['oleautomation']
class IMetadata(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage and update metadata.'
    _iid_ = GUID('{5DE04A82-24E4-11D3-A641-0008C7D3AE50}')
    _idlflags_ = ['oleautomation']
class IGPValue(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members of a GPValue.'
    _iid_ = GUID('{92EE08B6-C757-4178-803C-67CD665AC801}')
    _idlflags_ = ['oleautomation']
class IGPDescribe(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a Geoprocessing description.'
    _iid_ = GUID('{63C74CF4-C042-433E-840D-C66B6C813031}')
    _idlflags_ = ['oleautomation']
DEGeometryServer._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEGeometryServer, IDEServerObject, IDataElement, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDocumentVersionSupportGEN, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class RelationshipRule(CoClass):
    u'Esri relationship rule object.'
    _reg_clsid_ = GUID('{F84C6C1E-47FF-11D2-9933-0000F80372B4}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IRule(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about rules.'
    _iid_ = GUID('{236F4DE4-4761-11D2-9932-0000F80372B4}')
    _idlflags_ = ['oleautomation']
class IRelationshipRule(IRule):
    _case_insensitive_ = True
    u'Provides access to members that supply information about, modify and manage relationship rules.'
    _iid_ = GUID('{EB3B2F82-7E5C-11D2-AAB5-00C04FA37B82}')
    _idlflags_ = ['oleautomation']
RelationshipRule._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRule, IRelationshipRule, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class DEFeatureDataset(CoClass):
    u'Feature Dataset Data Element object.'
    _reg_clsid_ = GUID('{6AC619FE-191F-432D-B1A3-28CE85A591AF}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDEFeatureDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Indicator interface for feature dataset data elements.'
    _iid_ = GUID('{0111D945-785C-4E4D-88FB-BF925644A959}')
    _idlflags_ = ['oleautomation']
class IDEGeoDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about a geographic dataset data element.'
    _iid_ = GUID('{5ED64E50-A2F2-11D5-931B-0080C71A3226}')
    _idlflags_ = ['oleautomation']
class IDEDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that supply dataset data element information.'
    _iid_ = GUID('{29FBED10-A332-11D5-931B-0080C71A3226}')
    _idlflags_ = ['oleautomation']
class IDEDataset2(IDEDataset):
    _case_insensitive_ = True
    u'Provides access to members that supply dataset data element information.'
    _iid_ = GUID('{90532B92-762B-4D10-B2A7-C42C852991AD}')
    _idlflags_ = ['oleautomation']
DEFeatureDataset._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEFeatureDataset, IDEGeoDataset, IDEDataset2, IDataElement, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe]

class RangeDomain(CoClass):
    u'Esri Range Domain object.'
    _reg_clsid_ = GUID('{F84C6C1A-47FF-11D2-9933-0000F80372B4}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDomain(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return and modify domains and their merge and split policies.'
    _iid_ = GUID('{DF18FE0A-84BA-11D2-AB61-000000000000}')
    _idlflags_ = ['oleautomation']
class IRangeDomain(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return and modify range domain values.'
    _iid_ = GUID('{FCB6BF32-475D-11D2-9932-0000F80372B4}')
    _idlflags_ = ['oleautomation']
class ISchemaLock(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for accessing schema locking functionality.'
    _iid_ = GUID('{DCA648E5-0FBB-11D3-80A5-00C04F686238}')
    _idlflags_ = ['oleautomation']
RangeDomain._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDomain, IRangeDomain, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, ISchemaLock, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize]

class DEGPServerType(CoClass):
    u'MapServer Object Data Element object type.'
    _reg_clsid_ = GUID('{8A479029-0746-4A99-B443-BBF390F82E0C}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDEGPServerType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the GPServer Data Element Type.'
    _iid_ = GUID('{A287264F-E612-4E00-B0BF-12FBA71A4F90}')
    _idlflags_ = ['oleautomation']
class IDEServerObjectType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the ArcGIS Server Object Data Element Type.'
    _iid_ = GUID('{F0600029-8EE8-4ACC-8AE9-F7791572807F}')
    _idlflags_ = ['oleautomation']
class IGxFilterInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to methods that return open and save filters for datasets of a given type.'
    _iid_ = GUID('{691BE63C-024F-4958-8F9B-D8252342E915}')
    _idlflags_ = ['oleautomation']
class IDataElementType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the Data Element Type.'
    _iid_ = GUID('{4926A958-7885-484C-811B-2C8B12B0C1A2}')
    _idlflags_ = ['oleautomation']
class IGPDataType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members of a GP Data Type.'
    _iid_ = GUID('{172A93A9-AFC1-432D-8F04-54B7309BA432}')
    _idlflags_ = ['oleautomation']
DEGPServerType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEGPServerType, IDEServerObjectType, IGxFilterInfo, IDataElementType, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class DEGeometryServerType(CoClass):
    u'GeometryServer Object Data Element object type.'
    _reg_clsid_ = GUID('{99E8C17A-259F-4A66-A3A1-E0A24E1B461B}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDEGeometryServerType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the GeometryServer Data Element Type.'
    _iid_ = GUID('{71C3F685-E392-4A7C-B105-E88FD8E744B9}')
    _idlflags_ = ['oleautomation']
DEGeometryServerType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEGeometryServerType, IDEServerObjectType, IGxFilterInfo, IDataElementType, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class ObjectClassValidator(CoClass):
    u'Esri ObjectClassValidator object.'
    _reg_clsid_ = GUID('{F84C6C21-47FF-11D2-9933-0000F80372B4}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IValidation(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage rules and validate them.'
    _iid_ = GUID('{D410A9BA-475A-11D2-9932-0000F80372B4}')
    _idlflags_ = ['oleautomation']
class IValidation2(IValidation):
    _case_insensitive_ = True
    u'Provides access to members that manage rules and validate them.'
    _iid_ = GUID('{48469230-851C-11D4-A0C9-00C04F6BDD84}')
    _idlflags_ = ['oleautomation']
ObjectClassValidator._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IValidation, IValidation2]

class DEGPServer(CoClass):
    u'MapServer Object Data Element object.'
    _reg_clsid_ = GUID('{A8177ADA-390D-420C-A433-EE67DD2E8638}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDEGPServer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe GPServer objects.'
    _iid_ = GUID('{10612C92-49BE-43B1-907D-81661A62DCB6}')
    _idlflags_ = ['oleautomation']
DEGPServer._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEGPServer, IDEServerObject, IDataElement, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDocumentVersionSupportGEN, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class DEServerConnection(CoClass):
    u'ServerConnection Object Data Element object.'
    _reg_clsid_ = GUID('{887D4940-9343-42A3-8C8F-5C41D4DCFAFD}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDEServerConnection(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provide access to theArcGIS Server Connection Data Element.'
    _iid_ = GUID('{668AFA47-33F8-4902-9737-72F01C5FC6C4}')
    _idlflags_ = ['oleautomation']
DEServerConnection._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEServerConnection, IDataElement, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDocumentVersionSupportGEN, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class TransformGroup(CoClass):
    u'Esri TransformGroup object.'
    _reg_clsid_ = GUID('{FCDDE1F8-E93C-11D2-9F55-00C04F6BDD84}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ITransformGroup(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage a transform group.'
    _iid_ = GUID('{77118148-E91D-11D2-9F55-00C04F6BDD84}')
    _idlflags_ = ['oleautomation']
TransformGroup._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITransformGroup]

class DEServerConnectionType(CoClass):
    u'ServerConnection Object Data Element object type.'
    _reg_clsid_ = GUID('{0E88A630-36B2-4623-9A54-A1CF4D654D63}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDEServerConnectionType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the ArcGIS Server Connection Data Element Type.'
    _iid_ = GUID('{9EABF516-88A8-4F31-9693-785F23D94A34}')
    _idlflags_ = ['oleautomation']
DEServerConnectionType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEServerConnectionType, IGxFilterInfo, IDataElementType, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class ResultPortionInfo(CoClass):
    u'A class used to define query result portion options.'
    _reg_clsid_ = GUID('{EF14FD40-8890-4674-9941-D00EB91B0E44}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IResultPortionInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe a result portion.'
    _iid_ = GUID('{DB5E4E17-E15F-4EB1-A600-75E66376159C}')
    _idlflags_ = ['oleautomation']
ResultPortionInfo._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IResultPortionInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class TopologyClassEvents(CoClass):
    u'Helper coclass for working with the outbound interface ITopologyClassEvents.'
    _reg_clsid_ = GUID('{CA92C58E-431F-4C1C-AA44-853EDE7FC834}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ITopologyClassEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that occur with a topology class.'
    _iid_ = GUID('{AB85A26E-2CEB-41D0-9EE6-7030A8DA9174}')
    _idlflags_ = ['oleautomation']
TopologyClassEvents._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown]
TopologyClassEvents._outgoing_interfaces_ = [ITopologyClassEvents]

class DataStatistics(CoClass):
    u'Esri Data Statistics object.'
    _reg_clsid_ = GUID('{BF64319C-9062-11D2-AE71-080009EC732A}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDataStatistics(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members to generate statistics on a field.'
    _iid_ = GUID('{CA691DD5-8A14-11D2-AE6C-080009EC732A}')
    _idlflags_ = ['oleautomation']
DataStatistics._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDataStatistics]

class ObjectClassEvents(CoClass):
    u'Helper coclass for working with the outbound interface on noncreatable object classes in VB.'
    _reg_clsid_ = GUID('{E53AFB0F-E6D4-11D2-9F29-00C04F6BC979}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IObjectClassEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that occur with an object class.'
    _iid_ = GUID('{E53AFB0E-E6D4-11D2-9F29-00C04F6BC979}')
    _idlflags_ = ['oleautomation']
ObjectClassEvents._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown]
ObjectClassEvents._outgoing_interfaces_ = [IObjectClassEvents]

class DERasterDatasetType(CoClass):
    u'RasterDataset Data Element object Type.'
    _reg_clsid_ = GUID('{71414275-578C-466D-B0BE-699747D0D502}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDERasterDatasetType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the Raster Dataset Data Element Type.'
    _iid_ = GUID('{4A4A7C1E-7133-456B-85CF-47724861D8A3}')
    _idlflags_ = ['oleautomation']
class IDEGeoDatasetType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the GeoDataset Data Element Type.'
    _iid_ = GUID('{264D4C00-A628-11D5-931D-0080C71A3226}')
    _idlflags_ = ['oleautomation']
class IDEDatasetType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the Dataset Data Element Type.'
    _iid_ = GUID('{2EA85780-A626-11D5-931D-0080C71A3226}')
    _idlflags_ = ['oleautomation']
DERasterDatasetType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDERasterDatasetType, IDEGeoDatasetType, IDEDatasetType, IDataElementType, IGxFilterInfo, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class GPMessageManager(CoClass):
    u'Esri GPMessageManager object.'
    _reg_clsid_ = GUID('{E1A80771-862A-494B-8AED-6D9125F5AFAC}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGPMessageManager(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the properties/methods of a geoprocessing message manager object.'
    _iid_ = GUID('{A440EC5F-34B5-45B3-BCD1-AE631CF84214}')
    _idlflags_ = ['oleautomation']
GPMessageManager._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPMessageManager]

class RelationshipClassEvents(CoClass):
    u'Helper coclass for working with the outbound interface on noncreatable relationship classes in VB.'
    _reg_clsid_ = GUID('{56D897B7-3B15-4AD8-BD77-B3940DDC28DA}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IRelationshipClassEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that occur with a relationship class.'
    _iid_ = GUID('{A6693F58-EFF3-11D4-9FEF-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
RelationshipClassEvents._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown]
RelationshipClassEvents._outgoing_interfaces_ = [IRelationshipClassEvents]

class DERasterBandType(CoClass):
    u'RasterBand Data Element object Type.'
    _reg_clsid_ = GUID('{14114930-A62A-11D5-931D-0080C71A3226}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDERasterBandType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to methods that control the Raster Band Data Element Type.'
    _iid_ = GUID('{CD3998C0-A631-11D5-931D-0080C71A3226}')
    _idlflags_ = ['oleautomation']
class IDETableType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the Table Data Element Type.'
    _iid_ = GUID('{694B287C-7297-4B99-BB59-C2DFAF48F6A0}')
    _idlflags_ = ['oleautomation']
DERasterBandType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDERasterBandType, IDEGeoDatasetType, IDETableType, IDEDatasetType, IDataElementType, IGxFilterInfo, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]


# values for enumeration 'esriSynchronizationOperations'
esriSOImportDataChanges = 1
esriSOExportDataChanges = 2
esriSynchronizationOperations = c_int # enum
class ObjectClassSchemaEvents(CoClass):
    u'Helper coclass for working with the nondefault outbound interface IObjectClassSchemaEvents in VB.'
    _reg_clsid_ = GUID('{426D599D-6BC9-11D3-A021-00C04F6BDF0E}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IObjectClassSchemaEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to events that occur with an object class' schema."
    _iid_ = GUID('{F1E8911B-6BC5-11D3-A021-00C04F6BDF0E}')
    _idlflags_ = ['oleautomation']
ObjectClassSchemaEvents._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown]
ObjectClassSchemaEvents._outgoing_interfaces_ = [IObjectClassSchemaEvents]

class VersionEvents(CoClass):
    u'Helper coclass for working with the outbound interface IVersionEvents.'
    _reg_clsid_ = GUID('{849FC783-8D9E-11D4-9FD8-00C04F6BDF0C}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IVersionEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that occur on a version.'
    _iid_ = GUID('{0B437961-89F9-11D4-8B5F-000000000000}')
    _idlflags_ = ['oleautomation']
VersionEvents._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown]
VersionEvents._outgoing_interfaces_ = [IVersionEvents]

class IEnumReplicaLog(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through replica log.'
    _iid_ = GUID('{B8135E54-22E8-4344-B7B6-1EEFEDBAF83D}')
    _idlflags_ = ['oleautomation']
class IReplicaLog(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that get information about a replica log.'
    _iid_ = GUID('{A4A65136-5756-4F8D-AB9F-88ACA53F2F6F}')
    _idlflags_ = ['oleautomation']
IEnumReplicaLog._methods_ = [
    COMMETHOD([helpstring(u'Retreives the next replica in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IReplicaLog)), 'replicaLog' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
    COMMETHOD(['propput', helpstring(u'Defines time to query the replica log for rows after a particular date.')], HRESULT, 'QueryAfter',
              ( ['in'], VARIANT, 'rhs' )),
]
################################################################
## code template for IEnumReplicaLog implementation
##class IEnumReplicaLog_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def _set(self, rhs):
##        u'Defines time to query the replica log for rows after a particular date.'
##    QueryAfter = property(fset = _set, doc = _set.__doc__)
##
##    def Next(self):
##        u'Retreives the next replica in the enumeration sequence.'
##        #return replicaLog
##

class IRelationshipClassInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return relationship class settings for the replica.'
    _iid_ = GUID('{713A5CEF-A814-47AA-AAE2-EE8937C4613B}')
    _idlflags_ = ['oleautomation']
class IRelationshipClassName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about the relationship class.'
    _iid_ = GUID('{311C2EE2-DA65-11D2-8A54-000000000000}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriRelExtractDirection'
esriRelExtractDirectionForward = 0
esriRelExtractDirectionBackward = 1
esriRelExtractDirectionNone = 2
esriRelExtractDirection = c_int # enum
IRelationshipClassInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'The relationship classes to replicate.')], HRESULT, 'RelationshipClassName',
              ( ['retval', 'out'], POINTER(POINTER(IRelationshipClassName)), 'RelationshipClassName' )),
    COMMETHOD(['propput', helpstring(u'Indicates the direction of the relationship class to checkout.')], HRESULT, 'RelExtractDirection',
              ( ['in'], esriRelExtractDirection, 'RelExtractDirection' )),
    COMMETHOD(['propget', helpstring(u'Indicates the direction of the relationship class to checkout.')], HRESULT, 'RelExtractDirection',
              ( ['retval', 'out'], POINTER(esriRelExtractDirection), 'RelExtractDirection' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the relationship class to be excluded from the replica description.')], HRESULT, 'Excluded',
              ( ['in'], VARIANT_BOOL, 'RelExcluded' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the relationship class to be excluded from the replica description.')], HRESULT, 'Excluded',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'RelExcluded' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the targetID of the child replica.')], HRESULT, 'TargetID',
              ( ['retval', 'out'], POINTER(c_int), 'TargetID' )),
]
################################################################
## code template for IRelationshipClassInfo implementation
##class IRelationshipClassInfo_Impl(object):
##    @property
##    def TargetID(self):
##        u'Indicates if the targetID of the child replica.'
##        #return TargetID
##
##    @property
##    def RelationshipClassName(self):
##        u'The relationship classes to replicate.'
##        #return RelationshipClassName
##
##    def _get(self):
##        u'Indicates the direction of the relationship class to checkout.'
##        #return RelExtractDirection
##    def _set(self, RelExtractDirection):
##        u'Indicates the direction of the relationship class to checkout.'
##    RelExtractDirection = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the relationship class to be excluded from the replica description.'
##        #return RelExcluded
##    def _set(self, RelExcluded):
##        u'Indicates if the relationship class to be excluded from the replica description.'
##    Excluded = property(_get, _set, doc = _set.__doc__)
##

class MetadataCopyHelper(CoClass):
    u'Metadata Copy Helper.'
    _reg_clsid_ = GUID('{375A6DF7-81B0-4278-B83F-D2BE99694E56}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ICopyHelper(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to helper functions for post-processing copied metadata.'
    _iid_ = GUID('{7E3D4A40-727C-4D4F-9C06-B0E93C8DFE0A}')
    _idlflags_ = ['oleautomation']
MetadataCopyHelper._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ICopyHelper]

class VersionEvents2(CoClass):
    u'Helper coclass for working with the outbound interface IVersionEvents2.'
    _reg_clsid_ = GUID('{5F1CEB3C-9D61-4A5A-9A87-14CB54BF3CEC}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IVersionEvents2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that occur on a version.'
    _iid_ = GUID('{97469719-829A-40D7-82D5-A8408E5C276E}')
    _idlflags_ = ['oleautomation']
VersionEvents2._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown]
VersionEvents2._outgoing_interfaces_ = [IVersionEvents2]


# values for enumeration 'esriSyncDirection'
esriSyncDirectionUpload = 0
esriSyncDirectionDownload = 1
esriSyncDirectionBiDirectional = 2
esriSyncDirectionSnapshot = 3
esriSyncDirectionNone = 4
esriSyncDirection = c_int # enum
class DERasterDataset(CoClass):
    u'RasterDataset Data Element object.'
    _reg_clsid_ = GUID('{8295BB68-F200-4CA6-803F-979952D732BD}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDERasterDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the RasterDataset Data Element.'
    _iid_ = GUID('{533C75E5-7CA0-40B5-9B20-5F6C1D4B4019}')
    _idlflags_ = ['oleautomation']
class IDERasterDatasetEx(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the RasterDataset Data Element - optional properties.'
    _iid_ = GUID('{7622A8D7-7D51-4192-8FC6-74A4E10C6F9E}')
    _idlflags_ = ['oleautomation']
DERasterDataset._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDERasterDataset, IDERasterDatasetEx, IDEGeoDataset, IDEDataset2, IDataElement, IMetadata, IGPValue, IGPDescribe, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

class RelationshipClass(CoClass):
    u'Esri Relationship Class object.'
    _reg_clsid_ = GUID('{AF10D71D-A61B-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IRelationshipClass(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about the relationship class, create relationships, relationship rules and get related objects.'
    _iid_ = GUID('{22B00693-8895-11D2-8A0D-006097AFF44E}')
    _idlflags_ = ['oleautomation']
class IDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that supply dataset information.'
    _iid_ = GUID('{2D04C042-7766-11D0-B77D-00805F7CED21}')
    _idlflags_ = ['oleautomation']
class IRelationshipClass2(IRelationshipClass):
    _case_insensitive_ = True
    u'Provides access to members that get related object row pairs within a query filter specification.'
    _iid_ = GUID('{C9C39723-40B6-454F-A7FF-A25491C72256}')
    _idlflags_ = ['oleautomation']
class IRelClassSchemaEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to members that modify a relationship class's properties."
    _iid_ = GUID('{BB7071F4-1678-4029-A358-14B5D33AD7CF}')
    _idlflags_ = ['oleautomation']
RelationshipClass._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRelationshipClass, IDataset, IRelationshipClass2, IRelClassSchemaEdit]

class IDEWorkspace(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about a workspace data element.'
    _iid_ = GUID('{C7B1FC10-308F-4FB5-890C-8B5293EAD096}')
    _idlflags_ = ['oleautomation']
class IDEWorkspace2(IDEWorkspace):
    _case_insensitive_ = True
    u'Provides access to members that return information about the Geodatabase release number.'
    _iid_ = GUID('{43C1D06B-0277-4B84-96F5-D4D3AB1173EA}')
    _idlflags_ = ['oleautomation']
class IDEWorkspace3(IDEWorkspace2):
    _case_insensitive_ = True
    u'Provides access to members that return information about a workspace data element.'
    _iid_ = GUID('{E9D1755A-01AF-43D7-9C6C-B10EF3E6B785}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriWorkspaceType'
esriFileSystemWorkspace = 0
esriLocalDatabaseWorkspace = 1
esriRemoteDatabaseWorkspace = 2
esriWorkspaceType = c_int # enum
IDEWorkspace._methods_ = [
    COMMETHOD(['propget', helpstring(u'The workspace type.')], HRESULT, 'WorkspaceType',
              ( ['retval', 'out'], POINTER(esriWorkspaceType), 'WorkspaceType' )),
    COMMETHOD(['propput', helpstring(u'The workspace type.')], HRESULT, 'WorkspaceType',
              ( ['in'], esriWorkspaceType, 'WorkspaceType' )),
    COMMETHOD(['propget', helpstring(u'The workspace factory prog id.')], HRESULT, 'WorkspaceFactoryProgID',
              ( ['retval', 'out'], POINTER(BSTR), 'progID' )),
    COMMETHOD(['propput', helpstring(u'The workspace factory prog id.')], HRESULT, 'WorkspaceFactoryProgID',
              ( ['in'], BSTR, 'progID' )),
    COMMETHOD(['propget', helpstring(u'The connection string.')], HRESULT, 'ConnectionString',
              ( ['retval', 'out'], POINTER(BSTR), 'connection' )),
    COMMETHOD(['propput', helpstring(u'The connection string.')], HRESULT, 'ConnectionString',
              ( ['in'], BSTR, 'connection' )),
    COMMETHOD(['propget', helpstring(u'The connection information of the database.')], HRESULT, 'ConnectionProperties',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'ConnectionProperties' )),
    COMMETHOD(['propputref', helpstring(u'The connection information of the database.')], HRESULT, 'ConnectionProperties',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'ConnectionProperties' )),
    COMMETHOD(['propget', helpstring(u'The list of Domains.')], HRESULT, 'Domains',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'Domains' )),
    COMMETHOD(['propputref', helpstring(u'The list of Domains.')], HRESULT, 'Domains',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'Domains' )),
]
################################################################
## code template for IDEWorkspace implementation
##class IDEWorkspace_Impl(object):
##    def Domains(self, Domains):
##        u'The list of Domains.'
##        #return 
##
##    def _get(self):
##        u'The workspace type.'
##        #return WorkspaceType
##    def _set(self, WorkspaceType):
##        u'The workspace type.'
##    WorkspaceType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The connection string.'
##        #return connection
##    def _set(self, connection):
##        u'The connection string.'
##    ConnectionString = property(_get, _set, doc = _set.__doc__)
##
##    def ConnectionProperties(self, ConnectionProperties):
##        u'The connection information of the database.'
##        #return 
##
##    def _get(self):
##        u'The workspace factory prog id.'
##        #return progID
##    def _set(self, progID):
##        u'The workspace factory prog id.'
##    WorkspaceFactoryProgID = property(_get, _set, doc = _set.__doc__)
##

IDEWorkspace2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The major version of the release.')], HRESULT, 'MajorVersion',
              ( ['retval', 'out'], POINTER(c_int), 'number' )),
    COMMETHOD(['propget', helpstring(u'The minor version of the release.')], HRESULT, 'MinorVersion',
              ( ['retval', 'out'], POINTER(c_int), 'number' )),
    COMMETHOD(['propget', helpstring(u'The bugfix version of the release.')], HRESULT, 'BugfixVersion',
              ( ['retval', 'out'], POINTER(c_int), 'number' )),
]
################################################################
## code template for IDEWorkspace2 implementation
##class IDEWorkspace2_Impl(object):
##    @property
##    def BugfixVersion(self):
##        u'The bugfix version of the release.'
##        #return number
##
##    @property
##    def MajorVersion(self):
##        u'The major version of the release.'
##        #return number
##
##    @property
##    def MinorVersion(self):
##        u'The minor version of the release.'
##        #return number
##

IDEWorkspace3._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the geodatabase is at the current release.')], HRESULT, 'CurrentRelease',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isCurrent' )),
    COMMETHOD(['propget', helpstring(u'The qualifier used to create fully qualified names for Editor Tracking.')], HRESULT, 'Realm',
              ( ['retval', 'out'], POINTER(BSTR), 'Realm' )),
    COMMETHOD(['propput', helpstring(u'The qualifier used to create fully qualified names for Editor Tracking.')], HRESULT, 'Realm',
              ( ['in'], BSTR, 'Realm' )),
]
################################################################
## code template for IDEWorkspace3 implementation
##class IDEWorkspace3_Impl(object):
##    def _get(self):
##        u'The qualifier used to create fully qualified names for Editor Tracking.'
##        #return Realm
##    def _set(self, Realm):
##        u'The qualifier used to create fully qualified names for Editor Tracking.'
##    Realm = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def CurrentRelease(self):
##        u'Indicates if the geodatabase is at the current release.'
##        #return isCurrent
##

class XmlPropertySet(CoClass):
    u'Esri XML PropertySet object.'
    _reg_clsid_ = GUID('{99F50761-C137-11D2-9F83-00C04F8ED211}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IPersistStreamInit(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist):
    _case_insensitive_ = True
    _iid_ = GUID('{7FD52380-4E07-101B-AE2D-08002B2EC713}')
    _idlflags_ = []
class IXmlPropertySet(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage metadata.'
    _iid_ = GUID('{121BD4BC-2508-11D3-A641-0008C7D3AE50}')
    _idlflags_ = ['oleautomation']
class IXmlPropertySet2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage metadata.'
    _iid_ = GUID('{01700025-EF62-47E3-BD1E-7A47D0696541}')
    _idlflags_ = ['oleautomation']
XmlPropertySet._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IPersistStreamInit, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet, IXmlPropertySet, IXmlPropertySet2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize]

class DERasterBand(CoClass):
    u'RasterBand Data Element object.'
    _reg_clsid_ = GUID('{37C63B33-C7D6-4311-91D5-9E98A2A0E39A}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDERasterBand(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the RasterBand Data Element.'
    _iid_ = GUID('{6CB0DAF7-1E85-4822-850A-297F0FB76B1F}')
    _idlflags_ = ['oleautomation']
class IDETable(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about table data elements.'
    _iid_ = GUID('{D7FCBB04-8E59-4FFB-9EE5-EC670AA892E0}')
    _idlflags_ = ['oleautomation']
DERasterBand._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDERasterBand, IDEGeoDataset, IDEDataset2, IDETable, IDataElement, IMetadata, IGPValue, IGPDescribe, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

class GPHistoricalMarker(CoClass):
    u'The (GP) Historical Marker Object.'
    _reg_clsid_ = GUID('{177BAF01-FF42-4E08-B1E9-866C4E61CD1E}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGPHistoricalMarker(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'.'
    _iid_ = GUID('{AC0CAC11-2109-4F21-B98F-237B26DA9802}')
    _idlflags_ = ['oleautomation']
GPHistoricalMarker._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPValue, IGPHistoricalMarker, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class XmlPropertySetEdit(CoClass):
    u'Esri XML PropertySet Edit object.'
    _reg_clsid_ = GUID('{B2676166-2396-11D3-A63E-0008C7D3AE50}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IXmlPropertySetEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that edit metadata.'
    _iid_ = GUID('{B2676165-2396-11D3-A63E-0008C7D3AE50}')
    _idlflags_ = ['oleautomation']
XmlPropertySetEdit._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IXmlPropertySetEdit]

class IEnumObject(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through the objects.'
    _iid_ = GUID('{3322EB49-7679-4EA0-A7BF-7404C01FF313}')
    _idlflags_ = ['oleautomation']
class IRowBuffer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members used for getting and modifying a rows values and for getting the fields in the row.'
    _iid_ = GUID('{93684651-1A83-11D1-8802-0000F877762D}')
    _idlflags_ = ['oleautomation']
class IRow(IRowBuffer):
    _case_insensitive_ = True
    u'Provides access to members that return information about the row, the table the row belongs to and storing and deleting the row.'
    _iid_ = GUID('{FCB01CB4-9F0B-11D0-BEC7-00805F7C4268}')
    _idlflags_ = ['oleautomation']
class IObject(IRow):
    _case_insensitive_ = True
    u'Provides access to the class the row belongs to.'
    _iid_ = GUID('{1AFCDB34-AC09-11D2-8A1E-006097AFF44E}')
    _idlflags_ = ['oleautomation']
IEnumObject._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next object.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IObject)), 'Object' )),
    COMMETHOD([helpstring(u'Resets enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumObject implementation
##class IEnumObject_Impl(object):
##    def Reset(self):
##        u'Resets enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next object.'
##        #return Object
##

class IWorkspaceReplicas(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return objects containing information about replicas.'
    _iid_ = GUID('{D7463E40-9508-4B36-8728-29524D897FFF}')
    _idlflags_ = ['oleautomation']
class IWorkspaceReplicas2(IWorkspaceReplicas):
    _case_insensitive_ = True
    u'Provides access to members that return objects containing information about replicas.'
    _iid_ = GUID('{21841681-BC98-4C79-AFF1-B13CCD06F107}')
    _idlflags_ = ['oleautomation']
class IEnumReplica(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through replica objects.'
    _iid_ = GUID('{13CA9C95-BEE7-4C14-947C-F37F26A62D9C}')
    _idlflags_ = ['oleautomation']
class IReplica(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that get information about a replica.'
    _iid_ = GUID('{C475452C-72F3-4277-9FB7-FD8099665CEC}')
    _idlflags_ = ['oleautomation']
IWorkspaceReplicas._methods_ = [
    COMMETHOD(['propget', helpstring(u'Replicas contained by or refernced by this workspace.')], HRESULT, 'Replicas',
              ( ['retval', 'out'], POINTER(POINTER(IEnumReplica)), 'enumReplica' )),
    COMMETHOD(['propget', helpstring(u'The replica or reference to a replica with the specified name.')], HRESULT, 'ReplicaByName',
              ( ['in'], BSTR, 'ReplicaName' ),
              ( ['retval', 'out'], POINTER(POINTER(IReplica)), 'Replica' )),
    COMMETHOD(['propget', helpstring(u'The replica or reference to a replica with the specified ID.')], HRESULT, 'ReplicaByID',
              ( ['in'], c_int, 'ReplicaID' ),
              ( ['retval', 'out'], POINTER(POINTER(IReplica)), 'Replica' )),
    COMMETHOD(['propget', helpstring(u'The replica or reference to a replica with the specified ID.')], HRESULT, 'ReplicaByGuid',
              ( ['in'], BSTR, 'ReplicaGuid' ),
              ( ['retval', 'out'], POINTER(POINTER(IReplica)), 'Replica' )),
    COMMETHOD([helpstring(u'Re-reads the list of replicas from the database.')], HRESULT, 'RefreshReplicas'),
]
################################################################
## code template for IWorkspaceReplicas implementation
##class IWorkspaceReplicas_Impl(object):
##    @property
##    def ReplicaByName(self, ReplicaName):
##        u'The replica or reference to a replica with the specified name.'
##        #return Replica
##
##    @property
##    def ReplicaByID(self, ReplicaID):
##        u'The replica or reference to a replica with the specified ID.'
##        #return Replica
##
##    @property
##    def ReplicaByGuid(self, ReplicaGuid):
##        u'The replica or reference to a replica with the specified ID.'
##        #return Replica
##
##    def RefreshReplicas(self):
##        u'Re-reads the list of replicas from the database.'
##        #return 
##
##    @property
##    def Replicas(self):
##        u'Replicas contained by or refernced by this workspace.'
##        #return enumReplica
##

IWorkspaceReplicas2._methods_ = [
    COMMETHOD([helpstring(u'Refresh a replica from a geodatabase.')], HRESULT, 'RefreshReplica',
              ( ['in'], BSTR, 'ReplicaGuid' )),
]
################################################################
## code template for IWorkspaceReplicas2 implementation
##class IWorkspaceReplicas2_Impl(object):
##    def RefreshReplica(self, ReplicaGuid):
##        u'Refresh a replica from a geodatabase.'
##        #return 
##

class IReplica2(IReplica):
    _case_insensitive_ = True
    u'Provides access to members that get information about a replica.'
    _iid_ = GUID('{3B29C4B9-4989-4871-8006-57DCC67F59D9}')
    _idlflags_ = ['oleautomation']
class IReplicaDescription(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members which set and return the properties of a ReplicaDescription object.'
    _iid_ = GUID('{3AFC1997-7A42-483B-9A6A-ECC00A3BA86A}')
    _idlflags_ = ['oleautomation']
class IWorkspaceName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that supply workspace name information.'
    _iid_ = GUID('{FADD975C-E36F-11D1-AA81-00C04FA33A15}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriReplicaType'
esriReplicaTypeChild = 1
esriReplicaTypeParent = 2
esriCheckOutTypeChild = 4
esriCheckOutTypeParent = 8
esriReplicaTypeAny = 15
esriReplicaType = c_int # enum
class IEnumReplicaDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return a list of replica datasets.'
    _iid_ = GUID('{8DCC9460-2F73-42F4-BC2A-50700B50FEF4}')
    _idlflags_ = ['oleautomation']
IReplica._methods_ = [
    COMMETHOD(['propget', helpstring(u'The ID of the replica.')], HRESULT, 'ReplicaID',
              ( ['retval', 'out'], POINTER(c_int), 'rID' )),
    COMMETHOD(['propget', helpstring(u'The name of the replica.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'ReplicaName' )),
    COMMETHOD(['propget', helpstring(u'The database user that owns the replica in the workspace.')], HRESULT, 'Owner',
              ( ['retval', 'out'], POINTER(BSTR), 'replicaOwner' )),
    COMMETHOD(['propget', helpstring(u'The name of the replica version.')], HRESULT, 'Version',
              ( ['retval', 'out'], POINTER(BSTR), 'ReplicaVersion' )),
    COMMETHOD(['propget', helpstring(u'The ID of the replica reference in the master geodatabase.')], HRESULT, 'ParentID',
              ( ['retval', 'out'], POINTER(c_int), 'replicaParentID' )),
    COMMETHOD(['propget', helpstring(u'The date that the data was checked out.')], HRESULT, 'ReplicaDate',
              ( ['retval', 'out'], POINTER(c_double), 'rDate' )),
    COMMETHOD(['propget', helpstring(u'The guid of the replica.')], HRESULT, 'ReplicaGuid',
              ( ['retval', 'out'], POINTER(BSTR), 'rGUID' )),
    COMMETHOD(['propget', helpstring(u'The ReplicaDescription associated with the replica.')], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(POINTER(IReplicaDescription)), 'ReplicaDescription' )),
    COMMETHOD(['propget', helpstring(u'The WorkspaceName object for the master geodatabase.')], HRESULT, 'ConnectionInfo',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspaceName)), 'replicaConnectionInfo' )),
    COMMETHOD(['propget', helpstring(u'Determines if the workspace is the replica geodatabase or the master geodatabase for the replica.')], HRESULT, 'ReplicaRole',
              ( ['retval', 'out'], POINTER(esriReplicaType), 'rRole' )),
    COMMETHOD(['propget', helpstring(u'The replica datasets for this replica.')], HRESULT, 'ReplicaDatasets',
              ( ['retval', 'out'], POINTER(POINTER(IEnumReplicaDataset)), 'enumReplicaDataset' )),
]
################################################################
## code template for IReplica implementation
##class IReplica_Impl(object):
##    @property
##    def ReplicaGuid(self):
##        u'The guid of the replica.'
##        #return rGUID
##
##    @property
##    def ReplicaDatasets(self):
##        u'The replica datasets for this replica.'
##        #return enumReplicaDataset
##
##    @property
##    def ConnectionInfo(self):
##        u'The WorkspaceName object for the master geodatabase.'
##        #return replicaConnectionInfo
##
##    @property
##    def ReplicaDate(self):
##        u'The date that the data was checked out.'
##        #return rDate
##
##    @property
##    def Name(self):
##        u'The name of the replica.'
##        #return ReplicaName
##
##    @property
##    def ReplicaRole(self):
##        u'Determines if the workspace is the replica geodatabase or the master geodatabase for the replica.'
##        #return rRole
##
##    @property
##    def ReplicaID(self):
##        u'The ID of the replica.'
##        #return rID
##
##    @property
##    def Version(self):
##        u'The name of the replica version.'
##        #return ReplicaVersion
##
##    @property
##    def ParentID(self):
##        u'The ID of the replica reference in the master geodatabase.'
##        #return replicaParentID
##
##    @property
##    def Owner(self):
##        u'The database user that owns the replica in the workspace.'
##        #return replicaOwner
##
##    @property
##    def Description(self):
##        u'The ReplicaDescription associated with the replica.'
##        #return ReplicaDescription
##

class IGPReplica(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that get information about a replica.'
    _iid_ = GUID('{A64E67F0-91D2-4B3F-8553-BC9F641CBC37}')
    _idlflags_ = ['oleautomation']
class IWorkspace(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that have information about the workspace.'
    _iid_ = GUID('{D4803EE1-79F4-11D0-97FC-0080C7F79481}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriReplicaAccessType'
esriReplicaAccessNone = 0
esriReplicaChildReadOnly = 1
esriReplicaParentReadOnly = 2
esriReplicaBothReadWrite = 3
esriReplicaParentOrChildReadOnly = 4
esriReplicaAccessType = c_int # enum

# values for enumeration 'esriReplicaReconcilePolicyType'
esriReplicaDetectConflicts = 1
esriReplicaResolveConflictsInFavorOfImportedChanges = 2
esriReplicaResolveConflictsInFavorOfDatabaseChanges = 3
esriReplicaResolveConflictsNone = 4
esriReplicaReconcilePolicyType = c_int # enum

# values for enumeration 'esriReplicaState'
esriReplicaStateSendingData = 1
esriReplicaStateWaitingForData = 2
esriReplicaStateSendingAcknowledgment = 4
esriReplicaState = c_int # enum
IReplica2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The generation number for a replica.')], HRESULT, 'MyGenerationNumber',
              ( ['retval', 'out'], POINTER(c_int), 'myGen' )),
    COMMETHOD(['propget', helpstring(u"The generation number for a replica's sibling.")], HRESULT, 'SibGenerationNumber',
              ( ['retval', 'out'], POINTER(c_int), 'sibGen' )),
    COMMETHOD(['propget', helpstring(u'The generation number that the sibling thinks is my generation number.')], HRESULT, 'SibMyGenNumber',
              ( ['retval', 'out'], POINTER(c_int), 'sibMyGen' )),
    COMMETHOD(['propget', helpstring(u'Replica log associated with this replica.')], HRESULT, 'Log',
              ( ['retval', 'out'], POINTER(POINTER(IEnumReplicaLog)), 'enumReplicaLog' )),
    COMMETHOD(['propget', helpstring(u'The replica datasets for the replica.')], HRESULT, 'AllReplicaDatasets',
              ( ['retval', 'out'], POINTER(POINTER(IEnumReplicaDataset)), 'enumReplicaDataset' )),
    COMMETHOD([helpstring(u'Initializes a replica from a gpreplica.')], HRESULT, 'Init2',
              ( ['in'], POINTER(IGPReplica), 'GPReplica' ),
              ( ['in'], POINTER(IWorkspace), 'TargetWorkspace' )),
    COMMETHOD(['propget', helpstring(u'Replica access type.')], HRESULT, 'AccessType',
              ( ['retval', 'out'], POINTER(esriReplicaAccessType), 'replicaAccessType' )),
    COMMETHOD(['propget', helpstring(u'Replica reconcile policy.')], HRESULT, 'ReconcilePolicyType',
              ( ['retval', 'out'], POINTER(esriReplicaReconcilePolicyType), 'replicaReconcilePolicy' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the replica sync has conflicts.')], HRESULT, 'HasConflicts',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasConflicts' )),
    COMMETHOD(['propget', helpstring(u'The replica version that recieves the changes.')], HRESULT, 'ReplicaReceivingVersion',
              ( ['retval', 'out'], POINTER(BSTR), 'ReplicaReceivingVersion' )),
    COMMETHOD(['propget', helpstring(u'The replica state.')], HRESULT, 'ReplicaState',
              ( ['retval', 'out'], POINTER(esriReplicaState), 'ReplicaState' )),
    COMMETHOD(['propget', helpstring(u'The sib connection string for a replica.')], HRESULT, 'SibConnectionString',
              ( ['retval', 'out'], POINTER(BSTR), 'ConnectionString' )),
]
################################################################
## code template for IReplica2 implementation
##class IReplica2_Impl(object):
##    @property
##    def SibGenerationNumber(self):
##        u"The generation number for a replica's sibling."
##        #return sibGen
##
##    @property
##    def HasConflicts(self):
##        u'Indicates if the replica sync has conflicts.'
##        #return HasConflicts
##
##    @property
##    def Log(self):
##        u'Replica log associated with this replica.'
##        #return enumReplicaLog
##
##    @property
##    def ReconcilePolicyType(self):
##        u'Replica reconcile policy.'
##        #return replicaReconcilePolicy
##
##    @property
##    def SibMyGenNumber(self):
##        u'The generation number that the sibling thinks is my generation number.'
##        #return sibMyGen
##
##    @property
##    def AccessType(self):
##        u'Replica access type.'
##        #return replicaAccessType
##
##    @property
##    def AllReplicaDatasets(self):
##        u'The replica datasets for the replica.'
##        #return enumReplicaDataset
##
##    def Init2(self, GPReplica, TargetWorkspace):
##        u'Initializes a replica from a gpreplica.'
##        #return 
##
##    @property
##    def ReplicaState(self):
##        u'The replica state.'
##        #return ReplicaState
##
##    @property
##    def SibConnectionString(self):
##        u'The sib connection string for a replica.'
##        #return ConnectionString
##
##    @property
##    def ReplicaReceivingVersion(self):
##        u'The replica version that recieves the changes.'
##        #return ReplicaReceivingVersion
##
##    @property
##    def MyGenerationNumber(self):
##        u'The generation number for a replica.'
##        #return myGen
##

IPersistStreamInit._methods_ = [
    COMMETHOD([], HRESULT, 'IsDirty'),
    COMMETHOD([], HRESULT, 'Load',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStream), 'pStm' )),
    COMMETHOD([], HRESULT, 'Save',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStream), 'pStm' ),
              ( ['in'], c_int, 'fClearDirty' )),
    COMMETHOD([], HRESULT, 'GetSizeMax',
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2._ULARGE_INTEGER), 'pCbSize' )),
    COMMETHOD([], HRESULT, 'InitNew'),
]
################################################################
## code template for IPersistStreamInit implementation
##class IPersistStreamInit_Impl(object):
##    def Load(self, pStm):
##        '-no docstring-'
##        #return 
##
##    def GetSizeMax(self):
##        '-no docstring-'
##        #return pCbSize
##
##    def InitNew(self):
##        '-no docstring-'
##        #return 
##
##    def Save(self, pStm, fClearDirty):
##        '-no docstring-'
##        #return 
##
##    def IsDirty(self):
##        '-no docstring-'
##        #return 
##

class RelQueryTableSelectionSet(CoClass):
    u'Esri RelQueryTable Selection object.'
    _reg_clsid_ = GUID('{6FC04EAF-F7B8-432F-B87C-C9D9B17E79BF}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ISelectionSet(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage a set of selected table rows or features.'
    _iid_ = GUID('{F7AD47D1-D55E-11D1-8882-0000F877762D}')
    _idlflags_ = ['oleautomation']
class ISelectionSet2(ISelectionSet):
    _case_insensitive_ = True
    u'Provides access to members that manage a set of selected table rows or features.'
    _iid_ = GUID('{098AF83F-8390-11D4-9FD1-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
class IRelQueryTableSelectionSet(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage RelQueryTable selection.'
    _iid_ = GUID('{90D0F0B9-5B96-4FBC-948C-D6C04B57910F}')
    _idlflags_ = ['oleautomation']
RelQueryTableSelectionSet._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ISelectionSet, ISelectionSet2, IRelQueryTableSelectionSet]

class IGeoDBDataTransfer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that transfer data to/from GeoDatabases.'
    _iid_ = GUID('{9B6B1AD3-E0E7-11D3-8118-00C04F686238}')
    _idlflags_ = ['oleautomation']
class IGeoDBDataTransfer2(IGeoDBDataTransfer):
    _case_insensitive_ = True
    u'Provides access to members that transfer data to/from GeoDatabases.'
    _iid_ = GUID('{69EBDA67-D1FC-4F5A-829F-3E73098CD6D7}')
    _idlflags_ = ['oleautomation']
class IEnumNameMapping(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate and find specified name mappings.'
    _iid_ = GUID('{36A4D970-F5D5-11D3-8120-00C04F686238}')
    _idlflags_ = ['oleautomation']
IGeoDBDataTransfer._methods_ = [
    COMMETHOD([helpstring(u'Generate a list of objects to transfer.')], HRESULT, 'GenerateNameMapping',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IEnumName), 'from' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'toName' ),
              ( ['out'], POINTER(POINTER(IEnumNameMapping)), 'to' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'conflicts' )),
    COMMETHOD([helpstring(u'Transfers Data from one Workspace to another.')], HRESULT, 'Transfer',
              ( ['in'], POINTER(IEnumNameMapping), 'from' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'toName' )),
    COMMETHOD([helpstring(u'Returns the number of objects to be transfered (by the Simple Data Converter).')], HRESULT, 'NumberObjectsToTransfer',
              ( ['in'], POINTER(IEnumNameMapping), 'from' ),
              ( ['retval', 'out'], POINTER(c_int), 'nObjects' )),
]
################################################################
## code template for IGeoDBDataTransfer implementation
##class IGeoDBDataTransfer_Impl(object):
##    def Transfer(self, from, toName):
##        u'Transfers Data from one Workspace to another.'
##        #return 
##
##    def NumberObjectsToTransfer(self, from):
##        u'Returns the number of objects to be transfered (by the Simple Data Converter).'
##        #return nObjects
##
##    def GenerateNameMapping(self, from, toName):
##        u'Generate a list of objects to transfer.'
##        #return to, conflicts
##

IGeoDBDataTransfer2._methods_ = [
    COMMETHOD([helpstring(u'Deletes objects that were transfered.')], HRESULT, 'Delete',
              ( ['in'], POINTER(IEnumNameMapping), 'from' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'toName' )),
]
################################################################
## code template for IGeoDBDataTransfer2 implementation
##class IGeoDBDataTransfer2_Impl(object):
##    def Delete(self, from, toName):
##        u'Deletes objects that were transfered.'
##        #return 
##

class IExtractionUtilities(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members which set and return the properties of a ReplicaDescription object.'
    _iid_ = GUID('{22669F77-D848-4586-8720-4F079E796D91}')
    _idlflags_ = ['oleautomation']
IExtractionUtilities._methods_ = [
    COMMETHOD([helpstring(u'Defines the datasets to replica or extract and the output geodatabase.')], HRESULT, 'ToEnumNameMapping',
              ( ['retval', 'out'], POINTER(POINTER(IEnumNameMapping)), 'EnumNameMapping' )),
]
################################################################
## code template for IExtractionUtilities implementation
##class IExtractionUtilities_Impl(object):
##    def ToEnumNameMapping(self):
##        u'Defines the datasets to replica or extract and the output geodatabase.'
##        #return EnumNameMapping
##

class IOleDBConnectionInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to default connection information for a OleDB database.'
    _iid_ = GUID('{1AE253D9-675E-48EB-958F-68554CBF26D3}')
    _idlflags_ = ['oleautomation']
IOleDBConnectionInfo._methods_ = [
    COMMETHOD([helpstring(u'Set OleDB connection property parameters.')], HRESULT, 'SetParameters',
              ( ['in'], BSTR, 'ConnectionString' ),
              ( ['in'], BSTR, 'password' )),
    COMMETHOD([helpstring(u'Clears OleDB connection property parameters.')], HRESULT, 'ClearParameters',
              ( ['in'], BSTR, 'ConnectionString' )),
]
################################################################
## code template for IOleDBConnectionInfo implementation
##class IOleDBConnectionInfo_Impl(object):
##    def SetParameters(self, ConnectionString, password):
##        u'Set OleDB connection property parameters.'
##        #return 
##
##    def ClearParameters(self, ConnectionString):
##        u'Clears OleDB connection property parameters.'
##        #return 
##

class IFeatureDataConverter(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that are used to convert from a Personal Geodatabase/Geodatabase dataset to another.'
    _iid_ = GUID('{4ED85A73-7054-11D2-AAFE-00C04FA33C20}')
    _idlflags_ = ['oleautomation']
class IFeatureDatasetName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that hand out enumerated subset names in the feature dataset.'
    _iid_ = GUID('{89E7591A-C287-11D1-AA77-00C04FA33A15}')
    _idlflags_ = ['oleautomation']
class IGeometryDef(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about the geometry definition.'
    _iid_ = GUID('{439A0D50-3915-11D1-9CA7-0000F8780619}')
    _idlflags_ = ['oleautomation']
class IFeatureClassName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about the feature class.'
    _iid_ = GUID('{3C5BBE8F-C9C3-11D1-AA7C-00C04FA33A15}')
    _idlflags_ = ['oleautomation']
class IQueryFilter(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that filter data based on attribute values and or relationships.'
    _iid_ = GUID('{FDFEBD93-ED75-11D0-9A95-080009EC734B}')
    _idlflags_ = ['oleautomation']
class IFields(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about the fields.'
    _iid_ = GUID('{6B2072E3-23F7-11D1-89D8-006097AFF44E}')
    _idlflags_ = ['oleautomation']
class IEnumInvalidObject(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through invalid features.'
    _iid_ = GUID('{BAC25C0B-4F39-11D3-9FF8-00C04F6BDF0E}')
    _idlflags_ = ['oleautomation']
class IDatasetName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that supply dataset name information.'
    _iid_ = GUID('{89E75917-C287-11D1-AA77-00C04FA33A15}')
    _idlflags_ = ['oleautomation']
IFeatureDataConverter._methods_ = [
    COMMETHOD([helpstring(u'Converts a featureDataset to Personal Geodatabase/Geodatabase featuredataset.')], HRESULT, 'ConvertFeatureDataset',
              ( ['in'], POINTER(IFeatureDatasetName), 'inputFDatasetName' ),
              ( ['in'], POINTER(IFeatureDatasetName), 'outputFDatasetName' ),
              ( ['in'], POINTER(IGeometryDef), 'OutputGeometryDef' ),
              ( ['in'], BSTR, 'configKey' ),
              ( ['in'], c_int, 'FlushInterval' ),
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'parentHWND' )),
    COMMETHOD([helpstring(u'Converts a featureClass to a Personal Geodatabase/Geodatabase featureClass.')], HRESULT, 'ConvertFeatureClass',
              ( ['in'], POINTER(IFeatureClassName), 'InputDatasetName' ),
              ( ['in'], POINTER(IQueryFilter), 'InputQueryFilter' ),
              ( ['in'], POINTER(IFeatureDatasetName), 'outputFDatasetName' ),
              ( ['in'], POINTER(IFeatureClassName), 'outputFClassName' ),
              ( ['in'], POINTER(IGeometryDef), 'OutputGeometryDef' ),
              ( ['in'], POINTER(IFields), 'OutputFields' ),
              ( ['in'], BSTR, 'configKey' ),
              ( ['in'], c_int, 'FlushInterval' ),
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'parentHWND' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumInvalidObject)), 'EnumInvalidObject' )),
    COMMETHOD([helpstring(u'Converts a table to an Personal Geodatabase/Geodatabase table.')], HRESULT, 'ConvertTable',
              ( ['in'], POINTER(IDatasetName), 'InputDatasetName' ),
              ( ['in'], POINTER(IQueryFilter), 'InputQueryFilter' ),
              ( ['in'], POINTER(IDatasetName), 'OutputDatasetName' ),
              ( ['in'], POINTER(IFields), 'OutputFields' ),
              ( ['in'], BSTR, 'configKey' ),
              ( ['in'], c_int, 'FlushInterval' ),
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'parentHWND' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumInvalidObject)), 'EnumInvalidObject' )),
]
################################################################
## code template for IFeatureDataConverter implementation
##class IFeatureDataConverter_Impl(object):
##    def ConvertFeatureClass(self, InputDatasetName, InputQueryFilter, outputFDatasetName, outputFClassName, OutputGeometryDef, OutputFields, configKey, FlushInterval, parentHWND):
##        u'Converts a featureClass to a Personal Geodatabase/Geodatabase featureClass.'
##        #return EnumInvalidObject
##
##    def ConvertFeatureDataset(self, inputFDatasetName, outputFDatasetName, OutputGeometryDef, configKey, FlushInterval, parentHWND):
##        u'Converts a featureDataset to Personal Geodatabase/Geodatabase featuredataset.'
##        #return 
##
##    def ConvertTable(self, InputDatasetName, InputQueryFilter, OutputDatasetName, OutputFields, configKey, FlushInterval, parentHWND):
##        u'Converts a table to an Personal Geodatabase/Geodatabase table.'
##        #return EnumInvalidObject
##

class DEMapServerType(CoClass):
    u'MapServer Object Data Element object type.'
    _reg_clsid_ = GUID('{0AC3C41D-FEF8-4DE7-A3A3-7E0E5FDDBF76}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDEMapServerType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the MapServer Data Element Type.'
    _iid_ = GUID('{9904715E-E833-45BE-9259-21E2278EAB13}')
    _idlflags_ = ['oleautomation']
DEMapServerType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEMapServerType, IDEServerObjectType, IGxFilterInfo, IDataElementType, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class IReplicaDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return the properties of a replica dataset.'
    _iid_ = GUID('{4E087148-2C4F-452F-BFF0-88C67D3EFB15}')
    _idlflags_ = ['oleautomation']
IEnumReplicaDataset._methods_ = [
    COMMETHOD([helpstring(u'Returns a dataset that is part of a replica.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IReplicaDataset)), 'ReplicaDataset' )),
    COMMETHOD([helpstring(u'Resets a list of replica datasets.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumReplicaDataset implementation
##class IEnumReplicaDataset_Impl(object):
##    def Reset(self):
##        u'Resets a list of replica datasets.'
##        #return 
##
##    def Next(self):
##        u'Returns a dataset that is part of a replica.'
##        #return ReplicaDataset
##

class INetElementDescription(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that get information about the element described by this NetElementDescription object.'
    _iid_ = GUID('{B1EB90E0-0CFA-11D1-9CD7-00805F74D243}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriElementType'
esriETNone = 0
esriETJunction = 1
esriETEdge = 2
esriETTurn = 3
esriElementType = c_int # enum
INetElementDescription._methods_ = [
    COMMETHOD(['propget', helpstring(u'User class ID for the element described by this NetElementDescription object.')], HRESULT, 'UserClassID',
              ( ['retval', 'out'], POINTER(c_int), 'elementclassUserID' )),
    COMMETHOD(['propget', helpstring(u'User ID for the element described by this NetElementDescription object.')], HRESULT, 'UserID',
              ( ['retval', 'out'], POINTER(c_int), 'UserID' )),
    COMMETHOD(['propget', helpstring(u'User sub ID for the element described by this NetElementDescription object.')], HRESULT, 'UserSubID',
              ( ['retval', 'out'], POINTER(c_int), 'UserSubID' )),
    COMMETHOD(['propget', helpstring(u'Type of network element described by this NetElementDescription object.')], HRESULT, 'ElementType',
              ( ['retval', 'out'], POINTER(esriElementType), 'ElementType' )),
]
################################################################
## code template for INetElementDescription implementation
##class INetElementDescription_Impl(object):
##    @property
##    def ElementType(self):
##        u'Type of network element described by this NetElementDescription object.'
##        #return ElementType
##
##    @property
##    def UserClassID(self):
##        u'User class ID for the element described by this NetElementDescription object.'
##        #return elementclassUserID
##
##    @property
##    def UserID(self):
##        u'User ID for the element described by this NetElementDescription object.'
##        #return UserID
##
##    @property
##    def UserSubID(self):
##        u'User sub ID for the element described by this NetElementDescription object.'
##        #return UserSubID
##

class IWorkspaceName2(IWorkspaceName):
    _case_insensitive_ = True
    u'Provides access to members that supply workspace name information.'
    _iid_ = GUID('{05FC30E9-3007-11D4-8140-00C04F686238}')
    _idlflags_ = ['oleautomation']
class IWorkspaceFactory(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that create and open workspaces and supply workspace factory information.'
    _iid_ = GUID('{F173FC16-D63A-11D1-AA81-00C04FA33A15}')
    _idlflags_ = ['oleautomation']
IWorkspaceName._methods_ = [
    COMMETHOD(['propget', helpstring(u'The path name of the WorkspaceName.')], HRESULT, 'PathName',
              ( ['retval', 'out'], POINTER(BSTR), 'PathName' )),
    COMMETHOD(['propput', helpstring(u'The path name of the WorkspaceName.')], HRESULT, 'PathName',
              ( ['in'], BSTR, 'PathName' )),
    COMMETHOD(['propget', helpstring(u"The ProgID of the WorkspaceName's workspace factory.")], HRESULT, 'WorkspaceFactoryProgID',
              ( ['retval', 'out'], POINTER(BSTR), 'progID' )),
    COMMETHOD(['propput', helpstring(u"The ProgID of the WorkspaceName's workspace factory.")], HRESULT, 'WorkspaceFactoryProgID',
              ( ['in'], BSTR, 'progID' )),
    COMMETHOD(['propget', helpstring(u'The browse name of the WorkspaceName.')], HRESULT, 'BrowseName',
              ( ['retval', 'out'], POINTER(BSTR), 'BrowseName' )),
    COMMETHOD(['propput', helpstring(u'The browse name of the WorkspaceName.')], HRESULT, 'BrowseName',
              ( ['in'], BSTR, 'BrowseName' )),
    COMMETHOD(['propget', helpstring(u'The workspace factory of the WorkspaceName.')], HRESULT, 'WorkspaceFactory',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspaceFactory)), 'Factory' )),
    COMMETHOD(['propput', helpstring(u'The connection properties of the WorkspaceName.')], HRESULT, 'ConnectionProperties',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'ConnectionProperties' )),
    COMMETHOD(['propget', helpstring(u'The connection properties of the WorkspaceName.')], HRESULT, 'ConnectionProperties',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'ConnectionProperties' )),
    COMMETHOD(['propget', helpstring(u'The type of the associated workspace.')], HRESULT, 'Type',
              ( ['retval', 'out'], POINTER(esriWorkspaceType), 'Type' )),
    COMMETHOD(['propget', helpstring(u'The category of the WorkspaceName.')], HRESULT, 'Category',
              ( ['retval', 'out'], POINTER(BSTR), 'Category' )),
]
################################################################
## code template for IWorkspaceName implementation
##class IWorkspaceName_Impl(object):
##    @property
##    def Category(self):
##        u'The category of the WorkspaceName.'
##        #return Category
##
##    def _get(self):
##        u'The browse name of the WorkspaceName.'
##        #return BrowseName
##    def _set(self, BrowseName):
##        u'The browse name of the WorkspaceName.'
##    BrowseName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The path name of the WorkspaceName.'
##        #return PathName
##    def _set(self, PathName):
##        u'The path name of the WorkspaceName.'
##    PathName = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def WorkspaceFactory(self):
##        u'The workspace factory of the WorkspaceName.'
##        #return Factory
##
##    def _get(self):
##        u'The connection properties of the WorkspaceName.'
##        #return ConnectionProperties
##    def _set(self, ConnectionProperties):
##        u'The connection properties of the WorkspaceName.'
##    ConnectionProperties = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def Type(self):
##        u'The type of the associated workspace.'
##        #return Type
##
##    def _get(self):
##        u"The ProgID of the WorkspaceName's workspace factory."
##        #return progID
##    def _set(self, progID):
##        u"The ProgID of the WorkspaceName's workspace factory."
##    WorkspaceFactoryProgID = property(_get, _set, doc = _set.__doc__)
##

IWorkspaceName2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The connection properties of the WorkspaceName.')], HRESULT, 'ConnectionString',
              ( ['retval', 'out'], POINTER(BSTR), 'connectionSting' )),
    COMMETHOD(['propput', helpstring(u'The connection properties of the WorkspaceName.')], HRESULT, 'ConnectionString',
              ( ['in'], BSTR, 'connectionSting' )),
]
################################################################
## code template for IWorkspaceName2 implementation
##class IWorkspaceName2_Impl(object):
##    def _get(self):
##        u'The connection properties of the WorkspaceName.'
##        #return connectionSting
##    def _set(self, connectionSting):
##        u'The connection properties of the WorkspaceName.'
##    ConnectionString = property(_get, _set, doc = _set.__doc__)
##

class IPlugInCursorHelper(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that help the Plug-In cursor.'
    _iid_ = GUID('{B91A4256-1D0A-46DD-B8A1-A237DEDD539F}')
    _idlflags_ = ['oleautomation']
IPlugInCursorHelper._methods_ = [
    COMMETHOD([helpstring(u'Gets the next row in the record set.')], HRESULT, 'NextRecord'),
    COMMETHOD([helpstring(u'Returns True if there are no more records in the record set.')], HRESULT, 'IsFinished',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'finished' )),
    COMMETHOD([helpstring(u'Gets the values for the non-geometry fields in the current record.')], HRESULT, 'QueryValues',
              ( ['in'], POINTER(IRowBuffer), 'Row' ),
              ( ['retval', 'out'], POINTER(c_int), 'OID' )),
    COMMETHOD([helpstring(u'Gets the geometry of the current record.')], HRESULT, 'QueryShape',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pGeometry' )),
]
################################################################
## code template for IPlugInCursorHelper implementation
##class IPlugInCursorHelper_Impl(object):
##    def IsFinished(self):
##        u'Returns True if there are no more records in the record set.'
##        #return finished
##
##    def QueryShape(self, pGeometry):
##        u'Gets the geometry of the current record.'
##        #return 
##
##    def NextRecord(self):
##        u'Gets the next row in the record set.'
##        #return 
##
##    def QueryValues(self, Row):
##        u'Gets the values for the non-geometry fields in the current record.'
##        #return OID
##

class IWorkspaceFactoryStatus(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage workspace status information.'
    _iid_ = GUID('{9B90C0B4-6848-4A17-A0A4-708EE05193D6}')
    _idlflags_ = ['oleautomation']
class IEnumWorkspaceStatus(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate workspace status information.'
    _iid_ = GUID('{C2608ADB-10A1-4D0C-ABA6-5975F6D9C1DF}')
    _idlflags_ = ['oleautomation']
class IWorkspaceStatus(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Describes the status of a workspace.'
    _iid_ = GUID('{BBE342C6-2618-4540-95B5-D6A82F618DFA}')
    _idlflags_ = ['oleautomation']
IWorkspaceFactoryStatus._methods_ = [
    COMMETHOD(['propget', helpstring(u'Retrieve the workspace status information for all currently opened workspaces.')], HRESULT, 'WorkspaceStatus',
              ( ['retval', 'out'], POINTER(POINTER(IEnumWorkspaceStatus)), 'ewstatus' )),
    COMMETHOD([helpstring(u'Checks if the status of an esriWCSDown workspace has changed.')], HRESULT, 'PingWorkspaceStatus',
              ( ['in'], POINTER(IWorkspace), 'Workspace' ),
              ( ['retval', 'out'], POINTER(POINTER(IWorkspaceStatus)), 'wstatus' )),
    COMMETHOD([helpstring(u'Makes an attempt to open a new instance of a workspace that is esriWCSDown but has since become esriWCSAvailable.')], HRESULT, 'OpenAvailableWorkspace',
              ( ['in'], POINTER(IWorkspaceStatus), 'wstatus' ),
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'Workspace' )),
]
################################################################
## code template for IWorkspaceFactoryStatus implementation
##class IWorkspaceFactoryStatus_Impl(object):
##    @property
##    def WorkspaceStatus(self):
##        u'Retrieve the workspace status information for all currently opened workspaces.'
##        #return ewstatus
##
##    def OpenAvailableWorkspace(self, wstatus):
##        u'Makes an attempt to open a new instance of a workspace that is esriWCSDown but has since become esriWCSAvailable.'
##        #return Workspace
##
##    def PingWorkspaceStatus(self, Workspace):
##        u'Checks if the status of an esriWCSDown workspace has changed.'
##        #return wstatus
##


# values for enumeration 'esriWorkspaceConnectionStatus'
esriWCSUp = 0
esriWCSDown = 1
esriWCSAvailable = 2
esriWorkspaceConnectionStatus = c_int # enum

# values for enumeration 'esriEditSearchOption'
esriEditSearchBoth = 1
esriEditSearchBasicOnly = 2
esriEditSearchDeltaOnly = 3
esriEditSearchNewDeltaOnly = 4
esriEditSearchDeletedBasicOnly = 5
esriEditSearchOption = c_int # enum

# values for enumeration 'esriJoinType'
esriLeftOuterJoin = 0
esriLeftInnerJoin = 1
esriJoinType = c_int # enum
class IPlugInLicense(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for managing a licensed plug-in.'
    _iid_ = GUID('{A08CF453-1ACC-440D-9DAE-5A110A0A94D2}')
    _idlflags_ = ['oleautomation']
IPlugInLicense._methods_ = [
    COMMETHOD([helpstring(u'Checks if the license for the extension is enabled.  Fails if not enabled.')], HRESULT, 'CheckExtensionLicense'),
    COMMETHOD([helpstring(u'Increases the count of things needing the license.')], HRESULT, 'AddLicenseRef'),
    COMMETHOD([helpstring(u'Decreases the count of things needing the license.')], HRESULT, 'ReleaseLicenseRef'),
]
################################################################
## code template for IPlugInLicense implementation
##class IPlugInLicense_Impl(object):
##    def CheckExtensionLicense(self):
##        u'Checks if the license for the extension is enabled.  Fails if not enabled.'
##        #return 
##
##    def ReleaseLicenseRef(self):
##        u'Decreases the count of things needing the license.'
##        #return 
##
##    def AddLicenseRef(self):
##        u'Increases the count of things needing the license.'
##        #return 
##

class tagFieldValue(Structure):
    pass
FieldValue = tagFieldValue

# values for enumeration 'esriRelClassCodeType'
esriRelClassCodeTypeInteger = 0
esriRelClassCodeTypeString = 1
esriRelClassCodeType = c_int # enum
class INetworkQuery(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that query the elements of the network dataset.'
    _iid_ = GUID('{73BED6FC-FDA9-45B0-A82D-1B42D52A26D0}')
    _idlflags_ = ['oleautomation']
class INetworkQuery2(INetworkQuery):
    _case_insensitive_ = True
    u'Provides access to members that query the elements of the network dataset.'
    _iid_ = GUID('{F5C55877-9FBE-47DC-92CD-B49037605B9F}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriNetworkElementType'
esriNETJunction = 1
esriNETEdge = 2
esriNETTurn = 3
esriNetworkElementType = c_int # enum
class INetworkForwardStar(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that query information about adjacent elements in the network dataset.'
    _iid_ = GUID('{FDE593A2-8E96-40C8-8AB2-6DA6D60AF9B9}')
    _idlflags_ = ['oleautomation']
class INetworkForwardStarAdjacencies(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the adjacent network elements returned by the NetworkForwardStar object.'
    _iid_ = GUID('{F7B90A86-48DB-46FE-AF94-869E19B9FE75}')
    _idlflags_ = ['oleautomation']
class INetworkElement(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IDispatch):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties common to all network elements.'
    _iid_ = GUID('{ED843586-99B4-4E36-9684-5BEC34938906}')
    _idlflags_ = ['dual', 'oleautomation']

# values for enumeration 'esriNetworkEdgeDirection'
esriNEDNone = 0
esriNEDAlongDigitized = 1
esriNEDAgainstDigitized = 2
esriNetworkEdgeDirection = c_int # enum
class INetworkEdge(INetworkElement):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of this network edge element.'
    _iid_ = GUID('{EADCD556-0857-41D9-9714-03B0DBB16DFB}')
    _idlflags_ = ['dual', 'oleautomation']
class INetworkJunction(INetworkElement):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of this network junction element.'
    _iid_ = GUID('{E3D2D64E-C620-4262-888A-DC724A82F62D}')
    _idlflags_ = ['dual', 'oleautomation']
class INetworkTurn(INetworkElement):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of this network turn.'
    _iid_ = GUID('{E284790C-E7B0-40C5-8EA8-146323BEDEFA}')
    _idlflags_ = ['dual', 'oleautomation']
class IEnumNetworkElement(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a container for accessing network dataset network elements.'
    _iid_ = GUID('{CAE89BA8-0B3B-439F-89F3-430C3FAB0182}')
    _idlflags_ = ['oleautomation']
INetworkQuery._methods_ = [
    COMMETHOD(['propget', helpstring(u'Highest element ID in the network dataset for the given element type.')], HRESULT, 'MaxEID',
              ( ['in'], esriNetworkElementType, 'ElementType' ),
              ( ['retval', 'out'], POINTER(c_int), 'MaxEID' )),
    COMMETHOD(['propget', helpstring(u'Maximum number of edge elements connected to any single junction element.')], HRESULT, 'MaxValence',
              ( ['retval', 'out'], POINTER(c_int), 'MaxValence' )),
    COMMETHOD(['propget', helpstring(u'Number of network elements of the given type in the network dataset.')], HRESULT, 'ElementCount',
              ( ['in'], esriNetworkElementType, 'ElementType' ),
              ( ['retval', 'out'], POINTER(c_int), 'ElementCount' )),
    COMMETHOD(['propget', helpstring(u'Number of turn elements in the network dataset having more than two edge elements participating.')], HRESULT, 'ComplexTurnCount',
              ( ['retval', 'out'], POINTER(c_int), 'ComplexTurnCount' )),
    COMMETHOD([helpstring(u'Creates a NetworkForwardStar object for traversing the network dataset.')], HRESULT, 'CreateForwardStar',
              ( ['retval', 'out'], POINTER(POINTER(INetworkForwardStar)), 'ForwardStar' )),
    COMMETHOD([helpstring(u'Creates a NetworkForwardStarAdjacencies container object for forward star queries.')], HRESULT, 'CreateForwardStarAdjacencies',
              ( ['retval', 'out'], POINTER(POINTER(INetworkForwardStarAdjacencies)), 'forwardStarAdjacencies' )),
    COMMETHOD([helpstring(u'Creates an uninitialized network element of the specified type for use in network dataset queries.')], HRESULT, 'CreateNetworkElement',
              ( ['in'], esriNetworkElementType, 'ElementType' ),
              ( ['retval', 'out'], POINTER(POINTER(INetworkElement)), 'Element' )),
    COMMETHOD([helpstring(u'Performs a network edge element query by element ID and edge direction and populates the given edge element object.')], HRESULT, 'QueryEdge',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], esriNetworkEdgeDirection, 'Direction' ),
              ( ['in'], POINTER(INetworkEdge), 'Edge' )),
    COMMETHOD([helpstring(u'Performs a network junction element query by element ID and populates the given junction element object.')], HRESULT, 'QueryJunction',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], POINTER(INetworkJunction), 'Junction' )),
    COMMETHOD([helpstring(u'Performs a network turn element query by element ID and populates the given turn element object.')], HRESULT, 'QueryTurn',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], POINTER(INetworkTurn), 'Turn' )),
    COMMETHOD(['propget', helpstring(u'Elements in the network dataset corresponding to the given source object.')], HRESULT, 'ElementsByOID',
              ( ['in'], c_int, 'SourceID' ),
              ( ['in'], c_int, 'OID' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumNetworkElement)), 'Elements' )),
    COMMETHOD(['propget', helpstring(u'Edge elements in the network dataset with a from and to position that includes the given position for the given source object.')], HRESULT, 'EdgesByPosition',
              ( ['in'], c_int, 'SourceID' ),
              ( ['in'], c_int, 'OID' ),
              ( ['in'], c_double, 'Position' ),
              ( ['in'], VARIANT_BOOL, 'includeRelatedSDCHyperEdges' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumNetworkElement)), 'Edges' )),
    COMMETHOD(['propget', helpstring(u'Edge elements in the network dataset with a from and to position included in the given range for the given source object.')], HRESULT, 'EdgesBySegment',
              ( ['in'], c_int, 'SourceID' ),
              ( ['in'], c_int, 'OID' ),
              ( ['in'], c_double, 'fromPosition' ),
              ( ['in'], c_double, 'toPosition' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumNetworkElement)), 'Edges' )),
    COMMETHOD(['propget', helpstring(u'Enumeration of all elements in the network dataset of the given type.')], HRESULT, 'Elements',
              ( ['in'], esriNetworkElementType, 'ElementType' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumNetworkElement)), 'Elements' )),
    COMMETHOD(['propget', helpstring(u'Elements in the network dataset corresponding to the given source objects.')], HRESULT, 'ElementsByOIDs',
              ( ['in'], c_int, 'SourceID' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'oids' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumNetworkElement)), 'Elements' )),
    COMMETHOD(['propget', helpstring(u'Enumeration of all elements in the network dataset corresponding to the given source.')], HRESULT, 'ElementsForSource',
              ( ['in'], c_int, 'SourceID' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumNetworkElement)), 'Elements' )),
    COMMETHOD([helpstring(u'Empties the contents of the index used for finding network elements by source.')], HRESULT, 'ClearIDCache'),
    COMMETHOD([helpstring(u'Initializes the index used for quickly finding network elements for the given source ID.')], HRESULT, 'PopulateIDCache',
              ( ['in'], c_int, 'SourceID' )),
]
################################################################
## code template for INetworkQuery implementation
##class INetworkQuery_Impl(object):
##    def QueryTurn(self, EID, Turn):
##        u'Performs a network turn element query by element ID and populates the given turn element object.'
##        #return 
##
##    def CreateNetworkElement(self, ElementType):
##        u'Creates an uninitialized network element of the specified type for use in network dataset queries.'
##        #return Element
##
##    @property
##    def Elements(self, ElementType):
##        u'Enumeration of all elements in the network dataset of the given type.'
##        #return Elements
##
##    @property
##    def MaxValence(self):
##        u'Maximum number of edge elements connected to any single junction element.'
##        #return MaxValence
##
##    def PopulateIDCache(self, SourceID):
##        u'Initializes the index used for quickly finding network elements for the given source ID.'
##        #return 
##
##    @property
##    def ComplexTurnCount(self):
##        u'Number of turn elements in the network dataset having more than two edge elements participating.'
##        #return ComplexTurnCount
##
##    @property
##    def EdgesByPosition(self, SourceID, OID, Position, includeRelatedSDCHyperEdges):
##        u'Edge elements in the network dataset with a from and to position that includes the given position for the given source object.'
##        #return Edges
##
##    @property
##    def ElementsForSource(self, SourceID):
##        u'Enumeration of all elements in the network dataset corresponding to the given source.'
##        #return Elements
##
##    @property
##    def MaxEID(self, ElementType):
##        u'Highest element ID in the network dataset for the given element type.'
##        #return MaxEID
##
##    @property
##    def EdgesBySegment(self, SourceID, OID, fromPosition, toPosition):
##        u'Edge elements in the network dataset with a from and to position included in the given range for the given source object.'
##        #return Edges
##
##    def QueryJunction(self, EID, Junction):
##        u'Performs a network junction element query by element ID and populates the given junction element object.'
##        #return 
##
##    @property
##    def ElementsByOIDs(self, SourceID, oids):
##        u'Elements in the network dataset corresponding to the given source objects.'
##        #return Elements
##
##    @property
##    def ElementCount(self, ElementType):
##        u'Number of network elements of the given type in the network dataset.'
##        #return ElementCount
##
##    @property
##    def ElementsByOID(self, SourceID, OID):
##        u'Elements in the network dataset corresponding to the given source object.'
##        #return Elements
##
##    def ClearIDCache(self):
##        u'Empties the contents of the index used for finding network elements by source.'
##        #return 
##
##    def QueryEdge(self, EID, Direction, Edge):
##        u'Performs a network edge element query by element ID and edge direction and populates the given edge element object.'
##        #return 
##
##    def CreateForwardStar(self):
##        u'Creates a NetworkForwardStar object for traversing the network dataset.'
##        #return ForwardStar
##
##    def CreateForwardStarAdjacencies(self):
##        u'Creates a NetworkForwardStarAdjacencies container object for forward star queries.'
##        #return forwardStarAdjacencies
##

INetworkQuery2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The time zone ID for the given network element.')], HRESULT, 'TimeZoneID',
              ( ['in'], POINTER(INetworkElement), 'networkElement' ),
              ( ['retval', 'out'], POINTER(c_int), 'TimeZoneID' )),
    COMMETHOD([helpstring(u'Converts local time for the given time zone to UTC time.')], HRESULT, 'ConvertLocalTimeToUTCTime',
              ( ['in'], c_int, 'localTimeZoneID' ),
              ( ['in'], c_double, 'localTime' ),
              ( ['retval', 'out'], POINTER(c_double), 'utcTime' )),
    COMMETHOD([helpstring(u'Converts UTC time to local time for the given time zone.')], HRESULT, 'ConvertUTCTimeToLocalTime',
              ( ['in'], c_int, 'localTimeZoneID' ),
              ( ['in'], c_double, 'utcTime' ),
              ( ['retval', 'out'], POINTER(c_double), 'localTime' )),
]
################################################################
## code template for INetworkQuery2 implementation
##class INetworkQuery2_Impl(object):
##    @property
##    def TimeZoneID(self, networkElement):
##        u'The time zone ID for the given network element.'
##        #return TimeZoneID
##
##    def ConvertUTCTimeToLocalTime(self, localTimeZoneID, utcTime):
##        u'Converts UTC time to local time for the given time zone.'
##        #return localTime
##
##    def ConvertLocalTimeToUTCTime(self, localTimeZoneID, localTime):
##        u'Converts local time for the given time zone to UTC time.'
##        #return utcTime
##

tagFieldValue._fields_ = [
    ('m_value', VARIANT),
    ('m_length', c_ulong),
    ('m_status', c_ulong),
]
assert sizeof(tagFieldValue) == 24, sizeof(tagFieldValue)
assert alignment(tagFieldValue) == 8, alignment(tagFieldValue)

# values for enumeration 'esriTableComponents'
esriBusinessTable = 1
esriFeatureTable = 2
esriAddsTable = 4
esriDeletesTable = 8
esriRasterTable = 16
esriArchive = 32
esriTableComponents = c_int # enum
IEnumWorkspaceStatus._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next workspace status in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspaceStatus)), 'wstatus' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumWorkspaceStatus implementation
##class IEnumWorkspaceStatus_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next workspace status in the enumeration sequence.'
##        #return wstatus
##

class IRelClassEnumRowPairs(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate object row pairs.'
    _iid_ = GUID('{A53A808E-13C4-11D3-A0DE-0000F8775BF9}')
    _idlflags_ = ['oleautomation']
IRelClassEnumRowPairs._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next pair of rows in the enumeration sequence.')], HRESULT, 'Next',
              ( ['out'], POINTER(POINTER(IRow)), 'SourceRow' ),
              ( ['out'], POINTER(POINTER(IRow)), 'targetRow' )),
    COMMETHOD([helpstring(u'Resets enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IRelClassEnumRowPairs implementation
##class IRelClassEnumRowPairs_Impl(object):
##    def Reset(self):
##        u'Resets enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next pair of rows in the enumeration sequence.'
##        #return SourceRow, targetRow
##


# values for enumeration 'esriRelClassKey'
esriRelClassKeyUndefined = 0
esriRelClassKeyClassID = 1
esriRelClassKeyClassCode = 2
esriRelClassKey = c_int # enum

# values for enumeration 'esriTopoDirection'
esriTDTo = 0
esriTDFrom = 1
esriTopoDirection = c_int # enum

# values for enumeration 'esriTopoSide'
esriTSLeft = 0
esriTSRight = 1
esriTopoSide = c_int # enum

# values for enumeration 'esriRelKeyType'
esriRelKeyTypeSingle = 0
esriRelKeyTypeDual = 1
esriRelKeyType = c_int # enum
class IHistoricalWorkspace(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{39C92BB1-28E4-4333-8FBC-4E32FB50AE63}')
    _idlflags_ = ['oleautomation']
class IEnumHistoricalMarker(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{42925C57-BF17-4870-B0A9-3AE76A50DE6D}')
    _idlflags_ = ['oleautomation']
class IHistoricalMarker(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{95AAC432-F6C5-4407-B983-14525AFF4170}')
    _idlflags_ = ['oleautomation']
class IHistoricalVersion(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{151D2CF7-E20B-407D-9E03-98BD449AA4C5}')
    _idlflags_ = ['oleautomation']
IHistoricalWorkspace._methods_ = [
    COMMETHOD(['propget', helpstring(u'The marker name which represents the last save or post of the default transactional version.')], HRESULT, 'DefaultMarkerName',
              ( ['retval', 'out'], POINTER(BSTR), 'DefaultMarkerName' )),
    COMMETHOD(['propget', helpstring(u'An enumerator of all historical markers managed by this workspace.')], HRESULT, 'HistoricalMarkers',
              ( ['retval', 'out'], POINTER(POINTER(IEnumHistoricalMarker)), 'markerEnum' )),
    COMMETHOD([helpstring(u'Add a historical marker to this workspace.')], HRESULT, 'AddHistoricalMarker',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], VARIANT, 'tstamp' ),
              ( ['retval', 'out'], POINTER(POINTER(IHistoricalMarker)), 'marker' )),
    COMMETHOD([helpstring(u'Remove a historical marker from this workspace.')], HRESULT, 'RemoveHistoricalMarker',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD([helpstring(u'Open a historical version by specifying a timestamp.')], HRESULT, 'FindHistoricalVersionByTimeStamp',
              ( ['in'], VARIANT, 'tstamp' ),
              ( ['retval', 'out'], POINTER(POINTER(IHistoricalVersion)), 'historicalVersion' )),
    COMMETHOD([helpstring(u'Open a historical version by specifying a historical marker name.')], HRESULT, 'FindHistoricalVersionByName',
              ( ['in'], BSTR, 'historicalMarkerName' ),
              ( ['retval', 'out'], POINTER(POINTER(IHistoricalVersion)), 'historicalVersion' )),
]
################################################################
## code template for IHistoricalWorkspace implementation
##class IHistoricalWorkspace_Impl(object):
##    @property
##    def DefaultMarkerName(self):
##        u'The marker name which represents the last save or post of the default transactional version.'
##        #return DefaultMarkerName
##
##    def FindHistoricalVersionByName(self, historicalMarkerName):
##        u'Open a historical version by specifying a historical marker name.'
##        #return historicalVersion
##
##    def FindHistoricalVersionByTimeStamp(self, tstamp):
##        u'Open a historical version by specifying a timestamp.'
##        #return historicalVersion
##
##    def AddHistoricalMarker(self, Name, tstamp):
##        u'Add a historical marker to this workspace.'
##        #return marker
##
##    def RemoveHistoricalMarker(self, Name):
##        u'Remove a historical marker from this workspace.'
##        #return 
##
##    @property
##    def HistoricalMarkers(self):
##        u'An enumerator of all historical markers managed by this workspace.'
##        #return markerEnum
##

class IWorkspaceEditControl(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to method that controls if insert and update cursors on simple classes can bypass store events'
    _iid_ = GUID('{17240108-A1C0-4F02-BB9A-35D970ABEE15}')
    _idlflags_ = ['oleautomation']
IWorkspaceEditControl._methods_ = [
    COMMETHOD([helpstring(u'Indicates that insert and update cursors on simple classes cannot bypass store events')], HRESULT, 'SetStoreEventsRequired'),
]
################################################################
## code template for IWorkspaceEditControl implementation
##class IWorkspaceEditControl_Impl(object):
##    def SetStoreEventsRequired(self):
##        u'Indicates that insert and update cursors on simple classes cannot bypass store events'
##        #return 
##

class IEdgeFeatureSource(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of a network dataset source whose edge elements are derived from line geometry.'
    _iid_ = GUID('{CC16E6DB-051A-4CCB-ADAF-0CA823ECD00B}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriNetworkEdgeConnectivityPolicy'
esriNECPAnyVertex = 0
esriNECPEndVertex = 1
esriNetworkEdgeConnectivityPolicy = c_int # enum
IEdgeFeatureSource._methods_ = [
    COMMETHOD(['propget', helpstring(u'Policy determining how all edge elements in this source connect to each other.')], HRESULT, 'ClassConnectivityPolicy',
              ( ['retval', 'out'], POINTER(esriNetworkEdgeConnectivityPolicy), 'policy' )),
    COMMETHOD(['propput', helpstring(u'Policy determining how all edge elements in this source connect to each other.')], HRESULT, 'ClassConnectivityPolicy',
              ( ['in'], esriNetworkEdgeConnectivityPolicy, 'policy' )),
    COMMETHOD(['propget', helpstring(u'Connectivity group in which this edge feature source participates.')], HRESULT, 'ClassConnectivityGroup',
              ( ['retval', 'out'], POINTER(c_int), 'group' )),
    COMMETHOD(['propput', helpstring(u'Connectivity group in which this edge feature source participates.')], HRESULT, 'ClassConnectivityGroup',
              ( ['in'], c_int, 'group' )),
    COMMETHOD(['propget', helpstring(u'Policy determining how the edge elements in the specified subtype of this source connect to each other.')], HRESULT, 'SubtypeConnectivityPolicy',
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['retval', 'out'], POINTER(esriNetworkEdgeConnectivityPolicy), 'policy' )),
    COMMETHOD(['propput', helpstring(u'Policy determining how the edge elements in the specified subtype of this source connect to each other.')], HRESULT, 'SubtypeConnectivityPolicy',
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['in'], esriNetworkEdgeConnectivityPolicy, 'policy' )),
    COMMETHOD(['propget', helpstring(u'Connectivity group in which the specified subtype of this edge feature source participates.')], HRESULT, 'SubtypeConnectivityGroup',
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['retval', 'out'], POINTER(c_int), 'group' )),
    COMMETHOD(['propput', helpstring(u'Connectivity group in which the specified subtype of this edge feature source participates.')], HRESULT, 'SubtypeConnectivityGroup',
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['in'], c_int, 'group' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this edge feature source determines connectivity groups and policies by subtypes.')], HRESULT, 'UsesSubtypes',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'bySubtype' )),
    COMMETHOD(['propput', helpstring(u'Indicates if this edge feature source determines connectivity groups and policies by subtypes.')], HRESULT, 'UsesSubtypes',
              ( ['in'], VARIANT_BOOL, 'bySubtype' )),
    COMMETHOD(['propget', helpstring(u'The field name on the feature source to be used as the from elevation field when determining connectivity at coincident end vertices.')], HRESULT, 'FromElevationFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The field name on the feature source to be used as the from elevation field when determining connectivity at coincident end vertices.')], HRESULT, 'FromElevationFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The field name on the feature source to be used as the to elevation field when determining connectivity at coincident end vertices.')], HRESULT, 'ToElevationFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The field name on the feature source to be used as the to elevation field when determining connectivity at coincident end vertices.')], HRESULT, 'ToElevationFieldName',
              ( ['in'], BSTR, 'Name' )),
]
################################################################
## code template for IEdgeFeatureSource implementation
##class IEdgeFeatureSource_Impl(object):
##    def _get(self):
##        u'The field name on the feature source to be used as the to elevation field when determining connectivity at coincident end vertices.'
##        #return Name
##    def _set(self, Name):
##        u'The field name on the feature source to be used as the to elevation field when determining connectivity at coincident end vertices.'
##    ToElevationFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Connectivity group in which this edge feature source participates.'
##        #return group
##    def _set(self, group):
##        u'Connectivity group in which this edge feature source participates.'
##    ClassConnectivityGroup = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self, SubtypeCode):
##        u'Policy determining how the edge elements in the specified subtype of this source connect to each other.'
##        #return policy
##    def _set(self, SubtypeCode, policy):
##        u'Policy determining how the edge elements in the specified subtype of this source connect to each other.'
##    SubtypeConnectivityPolicy = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if this edge feature source determines connectivity groups and policies by subtypes.'
##        #return bySubtype
##    def _set(self, bySubtype):
##        u'Indicates if this edge feature source determines connectivity groups and policies by subtypes.'
##    UsesSubtypes = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The field name on the feature source to be used as the from elevation field when determining connectivity at coincident end vertices.'
##        #return Name
##    def _set(self, Name):
##        u'The field name on the feature source to be used as the from elevation field when determining connectivity at coincident end vertices.'
##    FromElevationFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self, SubtypeCode):
##        u'Connectivity group in which the specified subtype of this edge feature source participates.'
##        #return group
##    def _set(self, SubtypeCode, group):
##        u'Connectivity group in which the specified subtype of this edge feature source participates.'
##    SubtypeConnectivityGroup = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Policy determining how all edge elements in this source connect to each other.'
##        #return policy
##    def _set(self, policy):
##        u'Policy determining how all edge elements in this source connect to each other.'
##    ClassConnectivityPolicy = property(_get, _set, doc = _set.__doc__)
##

class IScratchWorkspaceFactory(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that create or get a scratch workspace.'
    _iid_ = GUID('{06DC8E4B-951C-11D2-AE75-080009EC732A}')
    _idlflags_ = ['oleautomation']
class IScratchWorkspaceFactory2(IScratchWorkspaceFactory):
    _case_insensitive_ = True
    u'Provides access to members to get the current scratch workspace.'
    _iid_ = GUID('{CEB80992-EBC0-482B-9CD9-9974AB40D4C2}')
    _idlflags_ = ['oleautomation']
IScratchWorkspaceFactory._methods_ = [
    COMMETHOD(['propget', helpstring(u'The default scratch workspace.')], HRESULT, 'DefaultScratchWorkspace',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'Workspace' )),
    COMMETHOD([helpstring(u'Creates and returns a new scratch workspace.')], HRESULT, 'CreateNewScratchWorkspace',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'Workspace' )),
]
################################################################
## code template for IScratchWorkspaceFactory implementation
##class IScratchWorkspaceFactory_Impl(object):
##    @property
##    def DefaultScratchWorkspace(self):
##        u'The default scratch workspace.'
##        #return Workspace
##
##    def CreateNewScratchWorkspace(self):
##        u'Creates and returns a new scratch workspace.'
##        #return Workspace
##

IScratchWorkspaceFactory2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The current scratch workspace.')], HRESULT, 'CurrentScratchWorkspace',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'Workspace' )),
]
################################################################
## code template for IScratchWorkspaceFactory2 implementation
##class IScratchWorkspaceFactory2_Impl(object):
##    @property
##    def CurrentScratchWorkspace(self):
##        u'The current scratch workspace.'
##        #return Workspace
##

class GPMessage(CoClass):
    _reg_clsid_ = GUID('{FD0BB2D3-6C4E-43AF-B084-A806A6C8E66E}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGPMessage(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the properties of a Geoprocessor message.'
    _iid_ = GUID('{93D8ACCB-3A6E-4FA2-B283-197EE5D0E334}')
    _idlflags_ = ['dual', 'oleautomation']
class IGPMessage2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the properties of a Geoprocessor message.'
    _iid_ = GUID('{ED4B67F0-B72B-42F7-B033-BD62C8ED163F}')
    _idlflags_ = ['oleautomation']
GPMessage._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IDispatch, IGPMessage, IGPMessage2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize]


# values for enumeration 'esriFGDBDatafileFormat'
esriFGDBStandardDatafile = 0
esriFGDBCompressedDatafile = 1
esriFGDBDatafileFormat = c_int # enum

# values for enumeration 'esriRelKeyRole'
esriRelKeyRoleOriginPrimary = 0
esriRelKeyRoleDestinationPrimary = 1
esriRelKeyRoleOriginForeign = 2
esriRelKeyRoleDestinationForeign = 3
esriRelKeyRole = c_int # enum

# values for enumeration 'esriRowsType'
esriRowsTypeNone = 0
esriRowsTypeAll = 1
esriRowsTypeFilter = 2
esriRowsType = c_int # enum
class IWorkspaceFactoryLockControl(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Manages Geodatabase Locking'
    _iid_ = GUID('{61117908-069F-48AB-A344-7A9E4394DEDF}')
    _idlflags_ = ['oleautomation']
IWorkspaceFactoryLockControl._methods_ = [
    COMMETHOD(['propget', helpstring(u'Returns true if this factory has schema locking enabled.')], HRESULT, 'SchemaLockingEnabled',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isSchemaLockingEnabled' )),
    COMMETHOD([helpstring(u'All workspaces created and managed by the factory will have schema locking enabled.')], HRESULT, 'EnableSchemaLocking'),
    COMMETHOD([helpstring(u'All workspaces created and managed by the factory will have schema locking disabled.')], HRESULT, 'DisableSchemaLocking'),
]
################################################################
## code template for IWorkspaceFactoryLockControl implementation
##class IWorkspaceFactoryLockControl_Impl(object):
##    def EnableSchemaLocking(self):
##        u'All workspaces created and managed by the factory will have schema locking enabled.'
##        #return 
##
##    @property
##    def SchemaLockingEnabled(self):
##        u'Returns true if this factory has schema locking enabled.'
##        #return isSchemaLockingEnabled
##
##    def DisableSchemaLocking(self):
##        u'All workspaces created and managed by the factory will have schema locking disabled.'
##        #return 
##


# values for enumeration 'esriRelDirection'
esriRelDirectionForward = 0
esriRelDirectionBackward = 1
esriRelDirectionBoth = 2
esriRelDirection = c_int # enum
class IHistoricalClass(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to properties and methods of a historical class.'
    _iid_ = GUID('{09CDDFBB-D80B-4E0D-856A-D490C6E3D424}')
    _idlflags_ = ['oleautomation']
IHistoricalClass._methods_ = [
]
################################################################
## code template for IHistoricalClass implementation
##class IHistoricalClass_Impl(object):

class ITopologyWorkspace(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that access the topologies in a workspace.'
    _iid_ = GUID('{EA103F9F-8226-4D62-AFD8-A9AEAD2A3BE3}')
    _idlflags_ = ['oleautomation']
class ITopology(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control a topology.'
    _iid_ = GUID('{C08348E2-5AC1-4D88-A2D0-B675317BB6CD}')
    _idlflags_ = ['oleautomation']
ITopologyWorkspace._methods_ = [
    COMMETHOD([helpstring(u'Opens and returns the topology with the specified name.')], HRESULT, 'OpenTopology',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(ITopology)), 'Topology' )),
]
################################################################
## code template for ITopologyWorkspace implementation
##class ITopologyWorkspace_Impl(object):
##    def OpenTopology(self, Name):
##        u'Opens and returns the topology with the specified name.'
##        #return Topology
##

class IWorkspaceReplicasAdmin(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that modify information about a replica.'
    _iid_ = GUID('{72AD4BEA-A562-4C4A-A264-14FC6234B187}')
    _idlflags_ = ['oleautomation']
class IWorkspaceReplicasAdmin2(IWorkspaceReplicasAdmin):
    _case_insensitive_ = True
    u'Provides access to members that modify information about a replica.'
    _iid_ = GUID('{9AA14E6D-AA5A-4DAE-A868-D70E8FD5A0BE}')
    _idlflags_ = ['oleautomation']
class IWorkspaceReplicasAdmin3(IWorkspaceReplicasAdmin2):
    _case_insensitive_ = True
    u'Provides access to members that modify information about a replica.'
    _iid_ = GUID('{9AA25800-7148-4680-9B14-D9F8818869AA}')
    _idlflags_ = ['oleautomation']
IWorkspaceReplicasAdmin._methods_ = [
    COMMETHOD([helpstring(u'Updates replica information.')], HRESULT, 'AlterReplica',
              ( ['in'], POINTER(IReplica), 'Replica' )),
    COMMETHOD([helpstring(u'Creates new replica information.')], HRESULT, 'RegisterReplica',
              ( ['in'], POINTER(IReplica), 'Replica' ),
              ( ['retval', 'out'], POINTER(c_int), 'ReplicaID' )),
    COMMETHOD([helpstring(u'Removes replica information.')], HRESULT, 'UnregisterReplica',
              ( ['in'], POINTER(IReplica), 'Replica' ),
              ( ['in'], VARIANT_BOOL, 'removeCOVersion' )),
]
################################################################
## code template for IWorkspaceReplicasAdmin implementation
##class IWorkspaceReplicasAdmin_Impl(object):
##    def AlterReplica(self, Replica):
##        u'Updates replica information.'
##        #return 
##
##    def UnregisterReplica(self, Replica, removeCOVersion):
##        u'Removes replica information.'
##        #return 
##
##    def RegisterReplica(self, Replica):
##        u'Creates new replica information.'
##        #return ReplicaID
##


# values for enumeration 'esriDatasetType'
esriDTAny = 1
esriDTContainer = 2
esriDTGeo = 3
esriDTFeatureDataset = 4
esriDTFeatureClass = 5
esriDTPlanarGraph = 6
esriDTGeometricNetwork = 7
esriDTTopology = 8
esriDTText = 9
esriDTTable = 10
esriDTRelationshipClass = 11
esriDTRasterDataset = 12
esriDTRasterBand = 13
esriDTTin = 14
esriDTCadDrawing = 15
esriDTRasterCatalog = 16
esriDTToolbox = 17
esriDTTool = 18
esriDTNetworkDataset = 19
esriDTTerrain = 20
esriDTRepresentationClass = 21
esriDTCadastralFabric = 22
esriDTSchematicDataset = 23
esriDTLocator = 24
esriDTMap = 26
esriDTLayer = 27
esriDTStyle = 28
esriDTMosaicDataset = 29
esriDTLasDataset = 30
esriDatasetType = c_int # enum
IWorkspaceReplicasAdmin2._methods_ = [
    COMMETHOD([helpstring(u'Indicates if a replica dataset can be registed with the replica.')], HRESULT, 'CanRegisterReplicaDataset',
              ( ['in'], POINTER(IReplicaDataset), 'ReplicaDataset' ),
              ( ['in'], POINTER(IReplica), 'Replica' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanRegister' )),
    COMMETHOD([helpstring(u'Register replica dataset info with the replica.')], HRESULT, 'RegisterReplicaDataset',
              ( ['in'], POINTER(IReplicaDataset), 'RDataset' ),
              ( ['in'], esriRowsType, 'filter' ),
              ( ['in'], VARIANT_BOOL, 'UseGeometry' ),
              ( ['in'], BSTR, 'QueryDef' ),
              ( ['in'], POINTER(IFIDSet), 'pSelID' ),
              ( ['in'], POINTER(IReplica), 'pToReplica' )),
    COMMETHOD([helpstring(u'Indicates if a replica dataset can be unregisted from the replica.')], HRESULT, 'CanUnregisterReplicaDataset',
              ( ['in'], POINTER(IReplicaDataset), 'ReplicaDataset' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanUnregister' )),
    COMMETHOD([helpstring(u'Removes replica dataset info from the replica.')], HRESULT, 'UnregisterReplicaDataset',
              ( ['in'], POINTER(IReplicaDataset), 'ReplicaDataset' ),
              ( ['in'], POINTER(IReplica), 'Replica' )),
    COMMETHOD([helpstring(u'Alter replica properties with the ability to persist userID and Password.')], HRESULT, 'AlterReplica2',
              ( ['in'], POINTER(IReplica), 'Replica' ),
              ( ['in'], VARIANT_BOOL, 'PersistParentUserInfo' )),
    COMMETHOD(['propget', helpstring(u'Indicates if dataset is part of a replica.')], HRESULT, 'IsReferencedByReplica',
              ( ['in'], esriDatasetType, 'DatasetType' ),
              ( ['in'], c_int, 'DatasetID' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isReferenced' )),
]
################################################################
## code template for IWorkspaceReplicasAdmin2 implementation
##class IWorkspaceReplicasAdmin2_Impl(object):
##    def CanUnregisterReplicaDataset(self, ReplicaDataset):
##        u'Indicates if a replica dataset can be unregisted from the replica.'
##        #return CanUnregister
##
##    @property
##    def IsReferencedByReplica(self, DatasetType, DatasetID):
##        u'Indicates if dataset is part of a replica.'
##        #return isReferenced
##
##    def UnregisterReplicaDataset(self, ReplicaDataset, Replica):
##        u'Removes replica dataset info from the replica.'
##        #return 
##
##    def AlterReplica2(self, Replica, PersistParentUserInfo):
##        u'Alter replica properties with the ability to persist userID and Password.'
##        #return 
##
##    def CanRegisterReplicaDataset(self, ReplicaDataset, Replica):
##        u'Indicates if a replica dataset can be registed with the replica.'
##        #return CanRegister
##
##    def RegisterReplicaDataset(self, RDataset, filter, UseGeometry, QueryDef, pSelID, pToReplica):
##        u'Register replica dataset info with the replica.'
##        #return 
##

IWorkspaceReplicasAdmin3._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if dataset is part of a replica.')], HRESULT, 'ReplicasByDataset',
              ( ['in'], esriDatasetType, 'DatasetType' ),
              ( ['in'], c_int, 'DatasetID' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray)), 'ReplicaID' )),
]
################################################################
## code template for IWorkspaceReplicasAdmin3 implementation
##class IWorkspaceReplicasAdmin3_Impl(object):
##    @property
##    def ReplicasByDataset(self, DatasetType, DatasetID):
##        u'Indicates if dataset is part of a replica.'
##        #return ReplicaID
##

class IPlugInCreateWorkspace(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for creating Plug-In workspaces.'
    _iid_ = GUID('{697FFBD6-7D45-48C2-9810-7131183EDCAF}')
    _idlflags_ = ['oleautomation']
IPlugInCreateWorkspace._methods_ = [
    COMMETHOD([helpstring(u'Gets a string uniquely identifing the workspace described by the input parameters.')], HRESULT, 'MakeWorkspaceString',
              ( ['in'], BSTR, 'parentDirectory' ),
              ( ['in'], BSTR, 'file' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'ConnectionProperties' ),
              ( ['retval', 'out'], POINTER(BSTR), 'workspaceString' )),
    COMMETHOD([helpstring(u'Creates a new Plug-In workspace.')], HRESULT, 'CreateWorkspace',
              ( ['in'], BSTR, 'workspaceString' )),
]
################################################################
## code template for IPlugInCreateWorkspace implementation
##class IPlugInCreateWorkspace_Impl(object):
##    def MakeWorkspaceString(self, parentDirectory, file, ConnectionProperties):
##        u'Gets a string uniquely identifing the workspace described by the input parameters.'
##        #return workspaceString
##
##    def CreateWorkspace(self, workspaceString):
##        u'Creates a new Plug-In workspace.'
##        #return 
##

class IPlugInWorkspaceHelper2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that help the Plug-In workspace.'
    _iid_ = GUID('{D4CE2DB3-E5D8-4ABA-B11E-39D47646339D}')
    _idlflags_ = ['oleautomation']
IPlugInWorkspaceHelper2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if datasets in this workspace allow indexes to built.')], HRESULT, 'CanAddIndex',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanAddIndex' )),
    COMMETHOD(['propget', helpstring(u'Indicates if datasets in this workspace allow indexes to be deleted.')], HRESULT, 'CanDeleteIndex',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanDeleteIndex' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this workspace is read-only.')], HRESULT, 'IsReadOnly',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsReadOnly' )),
]
################################################################
## code template for IPlugInWorkspaceHelper2 implementation
##class IPlugInWorkspaceHelper2_Impl(object):
##    @property
##    def IsReadOnly(self):
##        u'Indicates if this workspace is read-only.'
##        #return IsReadOnly
##
##    @property
##    def CanAddIndex(self):
##        u'Indicates if datasets in this workspace allow indexes to built.'
##        #return CanAddIndex
##
##    @property
##    def CanDeleteIndex(self):
##        u'Indicates if datasets in this workspace allow indexes to be deleted.'
##        #return CanDeleteIndex
##

class WorkspaceFactory(CoClass):
    u'WorkspaceFactory Object.'
    _reg_clsid_ = GUID('{FBF5715D-A05D-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IWorkspaceFactory2(IWorkspaceFactory):
    _case_insensitive_ = True
    u'Provides access to members that create and open workspaces and supply workspace factory information.'
    _iid_ = GUID('{D29CD15F-3014-11D4-8141-00C04F686238}')
    _idlflags_ = ['oleautomation']
WorkspaceFactory._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IWorkspaceFactory, IWorkspaceFactory2]

class IWorkspaceEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control Workspace Editing.'
    _iid_ = GUID('{995D5C92-15C6-11D2-89ED-006097AFF44E}')
    _idlflags_ = ['oleautomation']
class IWorkspaceEdit2(IWorkspaceEdit):
    _case_insensitive_ = True
    u'Provides access to members that control Workspace Editing.'
    _iid_ = GUID('{199A1F9D-435A-4118-9B3F-4E0B8F984AA0}')
    _idlflags_ = ['oleautomation']
IWorkspaceEdit._methods_ = [
    COMMETHOD([helpstring(u'Starts editing the workspace.')], HRESULT, 'StartEditing',
              ( [], VARIANT_BOOL, 'withUndoRedo' )),
    COMMETHOD([helpstring(u'Stops editing the workspace.')], HRESULT, 'StopEditing',
              ( ['in'], VARIANT_BOOL, 'saveEdits' )),
    COMMETHOD([helpstring(u'True if the workspace is being edited.')], HRESULT, 'IsBeingEdited',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsBeingEdited' )),
    COMMETHOD([helpstring(u'Begins an edit operation.')], HRESULT, 'StartEditOperation'),
    COMMETHOD([helpstring(u'Ends an edit operation.')], HRESULT, 'StopEditOperation'),
    COMMETHOD([helpstring(u'Aborts an edit operation.')], HRESULT, 'AbortEditOperation'),
    COMMETHOD([helpstring(u'True if there are any completed edit operations that can be undone.')], HRESULT, 'HasUndos',
              ( ['in', 'out'], POINTER(VARIANT_BOOL), 'HasUndos' )),
    COMMETHOD([helpstring(u'Causes an Undo to be performed on the last edit operation.')], HRESULT, 'UndoEditOperation'),
    COMMETHOD([helpstring(u'True if there are any completed undos that can be redone.')], HRESULT, 'HasRedos',
              ( ['in', 'out'], POINTER(VARIANT_BOOL), 'HasRedos' )),
    COMMETHOD([helpstring(u'Causes a Redo to be performed on the last undo.')], HRESULT, 'RedoEditOperation'),
    COMMETHOD([helpstring(u'Enables Undo and Redo of edit operations.')], HRESULT, 'EnableUndoRedo'),
    COMMETHOD([helpstring(u'Disables Undo and Redo of edit operations.')], HRESULT, 'DisableUndoRedo'),
    COMMETHOD([helpstring(u'True if there are any completed edit operations that need to be saved .')], HRESULT, 'HasEdits',
              ( ['in', 'out'], POINTER(VARIANT_BOOL), 'HasEdits' )),
]
################################################################
## code template for IWorkspaceEdit implementation
##class IWorkspaceEdit_Impl(object):
##    def HasRedos(self):
##        u'True if there are any completed undos that can be redone.'
##        #return HasRedos
##
##    def RedoEditOperation(self):
##        u'Causes a Redo to be performed on the last undo.'
##        #return 
##
##    def HasEdits(self):
##        u'True if there are any completed edit operations that need to be saved .'
##        #return HasEdits
##
##    def StartEditOperation(self):
##        u'Begins an edit operation.'
##        #return 
##
##    def StartEditing(self, withUndoRedo):
##        u'Starts editing the workspace.'
##        #return 
##
##    def StopEditing(self, saveEdits):
##        u'Stops editing the workspace.'
##        #return 
##
##    def AbortEditOperation(self):
##        u'Aborts an edit operation.'
##        #return 
##
##    def StopEditOperation(self):
##        u'Ends an edit operation.'
##        #return 
##
##    def EnableUndoRedo(self):
##        u'Enables Undo and Redo of edit operations.'
##        #return 
##
##    def DisableUndoRedo(self):
##        u'Disables Undo and Redo of edit operations.'
##        #return 
##
##    def IsBeingEdited(self):
##        u'True if the workspace is being edited.'
##        #return IsBeingEdited
##
##    def UndoEditOperation(self):
##        u'Causes an Undo to be performed on the last edit operation.'
##        #return 
##
##    def HasUndos(self):
##        u'True if there are any completed edit operations that can be undone.'
##        #return HasUndos
##


# values for enumeration 'esriEditDataChangesType'
esriEditDataChangesWithinSession = 0
esriEditDataChangesWithinOperation = 1
esriEditDataChangesType = c_int # enum
class IDataChangesEx(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information on data changes.'
    _iid_ = GUID('{5B0C36B9-2891-4653-8757-97117924FE7A}')
    _idlflags_ = ['oleautomation']
IWorkspaceEdit2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Is the workspace currently in an edit operation?')], HRESULT, 'IsInEditOperation',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'inEditOp' )),
    COMMETHOD(['propget', helpstring(u'gets changes during edit session')], HRESULT, 'EditDataChanges',
              ( ['in'], esriEditDataChangesType, 'editChangeType' ),
              ( ['retval', 'out'], POINTER(POINTER(IDataChangesEx)), 'EditDataChanges' )),
]
################################################################
## code template for IWorkspaceEdit2 implementation
##class IWorkspaceEdit2_Impl(object):
##    @property
##    def EditDataChanges(self, editChangeType):
##        u'gets changes during edit session'
##        #return EditDataChanges
##
##    @property
##    def IsInEditOperation(self):
##        u'Is the workspace currently in an edit operation?'
##        #return inEditOp
##

class IWorkspaceFactorySchemaCache(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Manages Geodatabase workspace schema caches.'
    _iid_ = GUID('{968AB1EA-7C1F-4AA1-9055-CA98CB622278}')
    _idlflags_ = ['oleautomation']
IWorkspaceFactorySchemaCache._methods_ = [
    COMMETHOD([helpstring(u'All new workspaces handed out by the factory will have schema caching enabled.')], HRESULT, 'EnableSchemaCaching'),
    COMMETHOD([helpstring(u'All new workspaces handed out by the factory will not have schema caching enabled.')], HRESULT, 'DisableSchemaCaching'),
    COMMETHOD([helpstring(u'Enable the schema cache for a specific workspace.')], HRESULT, 'EnableSchemaCache',
              ( ['in'], POINTER(IWorkspace), 'Workspace' )),
    COMMETHOD([helpstring(u'Enable the schema caches of all open workspaces.')], HRESULT, 'EnableAllSchemaCaches'),
    COMMETHOD([helpstring(u'Disable the schema cache for a specific workspace.')], HRESULT, 'DisableSchemaCache',
              ( ['in'], POINTER(IWorkspace), 'Workspace' )),
    COMMETHOD([helpstring(u'Disable the schema caches of all open workspaces.')], HRESULT, 'DisableAllSchemaCaches'),
    COMMETHOD([helpstring(u'Checks a specific schema cache for staleness.')], HRESULT, 'IsSchemaCacheStale',
              ( ['in'], POINTER(IWorkspace), 'Workspace' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isStale' )),
    COMMETHOD([helpstring(u'Checks all current schema caches for staleness.')], HRESULT, 'IsAnySchemaCacheStale',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isStale' )),
    COMMETHOD([helpstring(u'Refreshes the schema cache for a specific workspace.')], HRESULT, 'RefreshSchemaCache',
              ( ['in'], POINTER(IWorkspace), 'Workspace' )),
    COMMETHOD([helpstring(u'Refreshes all current schema caches.')], HRESULT, 'RefreshAllSchemaCaches'),
]
################################################################
## code template for IWorkspaceFactorySchemaCache implementation
##class IWorkspaceFactorySchemaCache_Impl(object):
##    def RefreshSchemaCache(self, Workspace):
##        u'Refreshes the schema cache for a specific workspace.'
##        #return 
##
##    def IsAnySchemaCacheStale(self):
##        u'Checks all current schema caches for staleness.'
##        #return isStale
##
##    def EnableSchemaCaching(self):
##        u'All new workspaces handed out by the factory will have schema caching enabled.'
##        #return 
##
##    def DisableSchemaCaching(self):
##        u'All new workspaces handed out by the factory will not have schema caching enabled.'
##        #return 
##
##    def IsSchemaCacheStale(self, Workspace):
##        u'Checks a specific schema cache for staleness.'
##        #return isStale
##
##    def EnableAllSchemaCaches(self):
##        u'Enable the schema caches of all open workspaces.'
##        #return 
##
##    def DisableAllSchemaCaches(self):
##        u'Disable the schema caches of all open workspaces.'
##        #return 
##
##    def DisableSchemaCache(self, Workspace):
##        u'Disable the schema cache for a specific workspace.'
##        #return 
##
##    def RefreshAllSchemaCaches(self):
##        u'Refreshes all current schema caches.'
##        #return 
##
##    def EnableSchemaCache(self, Workspace):
##        u'Enable the schema cache for a specific workspace.'
##        #return 
##

class INetworkCollection(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that create and maintain information about geometric networks.'
    _iid_ = GUID('{A933F752-5ED3-11D2-AA8A-00C04FA37B82}')
    _idlflags_ = ['oleautomation']
class IGraph(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage graphs.'
    _iid_ = GUID('{436A48BC-56F6-11D1-AE55-0000F80372B4}')
    _idlflags_ = ['oleautomation']
class IGeometricNetwork(IGraph):
    _case_insensitive_ = True
    u'Provides access to members that manage properties and elements of a geometric network.'
    _iid_ = GUID('{DBFF01C2-5579-11D1-AE55-0000F80372B4}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriNetworkType'
esriNTStreetNetwork = 0
esriNTUtilityNetwork = 1
esriNetworkType = c_int # enum
INetworkCollection._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of GeometricNetworks in this FeatureDataset.')], HRESULT, 'GeometricNetworkCount',
              ( ['retval', 'out'], POINTER(c_int), 'numNetworks' )),
    COMMETHOD(['propget', helpstring(u'The GeometricNetwork associated with the specified index value.')], HRESULT, 'GeometricNetwork',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IGeometricNetwork)), 'Network' )),
    COMMETHOD(['propget', helpstring(u'The GeometricNetwork with the specified Name.')], HRESULT, 'GeometricNetworkByName',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IGeometricNetwork)), 'Network' )),
    COMMETHOD([helpstring(u'Creates a new GeometricNetwork in this FeatureDataset.')], HRESULT, 'CreateGeometricNetwork',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], esriNetworkType, 'NetworkType' ),
              ( ['in'], VARIANT_BOOL, 'buildNormalizedTables' ),
              ( ['retval', 'out'], POINTER(POINTER(IGeometricNetwork)), 'Network' )),
]
################################################################
## code template for INetworkCollection implementation
##class INetworkCollection_Impl(object):
##    def CreateGeometricNetwork(self, Name, NetworkType, buildNormalizedTables):
##        u'Creates a new GeometricNetwork in this FeatureDataset.'
##        #return Network
##
##    @property
##    def GeometricNetwork(self, Index):
##        u'The GeometricNetwork associated with the specified index value.'
##        #return Network
##
##    @property
##    def GeometricNetworkCount(self):
##        u'The number of GeometricNetworks in this FeatureDataset.'
##        #return numNetworks
##
##    @property
##    def GeometricNetworkByName(self, Name):
##        u'The GeometricNetwork with the specified Name.'
##        #return Network
##

class XMLIndexTag(CoClass):
    u'XML Index Tag Object.'
    _reg_clsid_ = GUID('{C83EC191-D234-4353-9522-722329D2BCBF}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IXMLIndexTag(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Describes the properties used to index a tag in an XML document.'
    _iid_ = GUID('{8EDDBD6F-4EC7-488B-8E28-FE253E7E3965}')
    _idlflags_ = ['oleautomation']
XMLIndexTag._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IXMLIndexTag, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe]

class ISetDefaultConnectionInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to default connection information for a remote database (ArcSDE).'
    _iid_ = GUID('{094A1C7D-90AE-11D3-80EF-00C04F686238}')
    _idlflags_ = ['oleautomation']
class ISetDefaultConnectionInfo2(ISetDefaultConnectionInfo):
    _case_insensitive_ = True
    u'Provides access to default connection information for a remote database (ArcSDE).'
    _iid_ = GUID('{518570D2-EF66-4B3B-B0BB-FCAC077814DF}')
    _idlflags_ = ['oleautomation']
ISetDefaultConnectionInfo._methods_ = [
    COMMETHOD([helpstring(u'Sets ArcSDE connection property parameters.')], HRESULT, 'SetParameters',
              ( ['in'], BSTR, 'server' ),
              ( ['in'], BSTR, 'instance' ),
              ( ['in'], BSTR, 'user' ),
              ( ['in'], BSTR, 'password' ),
              ( ['in'], BSTR, 'versName' )),
]
################################################################
## code template for ISetDefaultConnectionInfo implementation
##class ISetDefaultConnectionInfo_Impl(object):
##    def SetParameters(self, server, instance, user, password, versName):
##        u'Sets ArcSDE connection property parameters.'
##        #return 
##

ISetDefaultConnectionInfo2._methods_ = [
    COMMETHOD([helpstring(u'Clears ArcSDE connection property parameters.')], HRESULT, 'ClearParameters',
              ( ['in'], BSTR, 'server' ),
              ( ['in'], BSTR, 'instance' )),
]
################################################################
## code template for ISetDefaultConnectionInfo2 implementation
##class ISetDefaultConnectionInfo2_Impl(object):
##    def ClearParameters(self, server, instance):
##        u'Clears ArcSDE connection property parameters.'
##        #return 
##

class ICoverageAnnotationFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to coverage annotation blob.'
    _iid_ = GUID('{74793943-D70E-11D2-9F30-00C04F79927C}')
    _idlflags_ = ['oleautomation']
ICoverageAnnotationFeature._methods_ = [
    COMMETHOD(['propget', helpstring(u'The annotation blob for the feature.')], HRESULT, 'AnnotationBlob',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IMemoryBlobStream)), 'annotation' )),
    COMMETHOD(['propputref', helpstring(u'The annotation blob for the feature.')], HRESULT, 'AnnotationBlob',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IMemoryBlobStream), 'annotation' )),
]
################################################################
## code template for ICoverageAnnotationFeature implementation
##class ICoverageAnnotationFeature_Impl(object):
##    def AnnotationBlob(self, annotation):
##        u'The annotation blob for the feature.'
##        #return 
##

class IWorkspaceProgressTracker(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a cancel tracker which allows progress.'
    _iid_ = GUID('{4E3A0D23-6213-4B78-9A2F-B9286D34E3D3}')
    _idlflags_ = ['oleautomation']
IWorkspaceProgressTracker._methods_ = [
    COMMETHOD(['propget', helpstring(u'Cancel tracker that is associated with the workspace.')], HRESULT, 'CancelTracker',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITrackCancel)), 'CancelTracker' )),
    COMMETHOD(['propputref', helpstring(u'Cancel tracker that is associated with the workspace.')], HRESULT, 'CancelTracker',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITrackCancel), 'CancelTracker' )),
]
################################################################
## code template for IWorkspaceProgressTracker implementation
##class IWorkspaceProgressTracker_Impl(object):
##    def CancelTracker(self, CancelTracker):
##        u'Cancel tracker that is associated with the workspace.'
##        #return 
##

class IPlugInGxIntegration(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for customizing the ArcCatalog integration for the data source.'
    _iid_ = GUID('{575849AD-6B49-4C34-B9E7-F9CB63CEF3CB}')
    _idlflags_ = ['oleautomation']
IPlugInGxIntegration._methods_ = [
    COMMETHOD(['propget', helpstring(u'The small image for the specific dataset type (and geometry type if the dataset is a feature class).')], HRESULT, 'SmallImage',
              ( ['in'], esriDatasetType, 'dsType' ),
              ( ['in'], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType, 'GeometryType' ),
              ( ['retval', 'out'], POINTER(c_int), 'hSmallImage' )),
    COMMETHOD(['propget', helpstring(u'The large image for the dataset type (and geometry type if the dataset is a feature class).')], HRESULT, 'LargeImage',
              ( ['in'], esriDatasetType, 'dsType' ),
              ( ['in'], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType, 'GeometryType' ),
              ( ['retval', 'out'], POINTER(c_int), 'hLargeImage' )),
    COMMETHOD(['propget', helpstring(u'The CLSID for the context menu for the dataset type.')], HRESULT, 'ContextMenu',
              ( ['in'], esriDatasetType, 'dsType' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'ClassID' )),
    COMMETHOD(['propget', helpstring(u'The CLSID for the property page component category for the dataset type.')], HRESULT, 'PropertyPageCategory',
              ( ['in'], esriDatasetType, 'dsType' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'cateoryID' )),
]
################################################################
## code template for IPlugInGxIntegration implementation
##class IPlugInGxIntegration_Impl(object):
##    @property
##    def PropertyPageCategory(self, dsType):
##        u'The CLSID for the property page component category for the dataset type.'
##        #return cateoryID
##
##    @property
##    def LargeImage(self, dsType, GeometryType):
##        u'The large image for the dataset type (and geometry type if the dataset is a feature class).'
##        #return hLargeImage
##
##    @property
##    def SmallImage(self, dsType, GeometryType):
##        u'The small image for the specific dataset type (and geometry type if the dataset is a feature class).'
##        #return hSmallImage
##
##    @property
##    def ContextMenu(self, dsType):
##        u'The CLSID for the context menu for the dataset type.'
##        #return ClassID
##

class IForwardStarGEN(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that query information about adjacent elements in the logical network.'
    _iid_ = GUID('{7EBFC159-E0DA-4D21-9C3B-5D81F2E6AD9F}')
    _idlflags_ = ['oleautomation']
class INetwork(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that give general information about the network and its elements.'
    _iid_ = GUID('{19F99C80-A089-11D0-9CC9-00805F74D243}')
    _idlflags_ = ['oleautomation']
IForwardStarGEN._methods_ = [
    COMMETHOD(['propget', helpstring(u'Underlying network of this forward star cursor.')], HRESULT, 'Network',
              ( ['retval', 'out'], POINTER(POINTER(INetwork)), 'Network' )),
    COMMETHOD([helpstring(u'Finds the edge elements that are adjacent to the given junction element and returns the count.')], HRESULT, 'FindAdjacent',
              ( ['in'], c_int, 'fromEdgeEID' ),
              ( ['in'], c_int, 'AtJunctionEID' ),
              ( ['out'], POINTER(c_int), 'adjacentEdgesCount' )),
    COMMETHOD([helpstring(u"Returns the opposite junction of the index'th adjacent edge found with FindAdjacent, and the weight value for this junction.")], HRESULT, 'QueryAdjacentJunction',
              ( ['in'], c_int, 'Index' ),
              ( ['out'], POINTER(c_int), 'adjacentJunctionEID' ),
              ( ['out'], POINTER(VARIANT), 'adjacentJunctionWeightValue' )),
    COMMETHOD([helpstring(u"Returns index'th adjacent edge found with FindAdjacent, its orientation, and its weight value.")], HRESULT, 'QueryAdjacentEdge',
              ( ['in'], c_int, 'Index' ),
              ( ['out'], POINTER(c_int), 'adjacentEdgeEID' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'reverseOrientation' ),
              ( ['out'], POINTER(VARIANT), 'adjacentEdgeWeightValue' )),
    COMMETHOD([helpstring(u"Returns the turn through which the index'th adjacent edge found with FindAdjacent passes, and the weight value of the turn.")], HRESULT, 'QueryAtTurn',
              ( ['in'], c_int, 'Index' ),
              ( ['out'], POINTER(c_int), 'adjacentTurnEID' ),
              ( ['out'], POINTER(VARIANT), 'adjacentTurnWeightValue' )),
    COMMETHOD([helpstring(u'Returns the opposite junctions of the adjacent edges found with FindAdjacent into the specified user-defined array.')], HRESULT, 'QueryAdjacentJunctions',
              ( ['in', 'out'], POINTER(_midlSAFEARRAY(c_int)), 'adjacentJunctionEIDs' ),
              ( ['in', 'out'], POINTER(_midlSAFEARRAY(VARIANT)), 'adjacentJunctionsWeightValue' )),
    COMMETHOD([helpstring(u'Returns the adjacent edges found with FindAdjacent into the specified user-defined array.')], HRESULT, 'QueryAdjacentEdges',
              ( ['in', 'out'], POINTER(_midlSAFEARRAY(c_int)), 'adjacentEdgeEIDs' ),
              ( ['in', 'out'], POINTER(_midlSAFEARRAY(VARIANT_BOOL)), 'reverseOrientation' ),
              ( ['in', 'out'], POINTER(_midlSAFEARRAY(VARIANT)), 'adjacentEdgesWeightValue' )),
]
################################################################
## code template for IForwardStarGEN implementation
##class IForwardStarGEN_Impl(object):
##    def QueryAtTurn(self, Index):
##        u"Returns the turn through which the index'th adjacent edge found with FindAdjacent passes, and the weight value of the turn."
##        #return adjacentTurnEID, adjacentTurnWeightValue
##
##    def QueryAdjacentJunctions(self):
##        u'Returns the opposite junctions of the adjacent edges found with FindAdjacent into the specified user-defined array.'
##        #return adjacentJunctionEIDs, adjacentJunctionsWeightValue
##
##    @property
##    def Network(self):
##        u'Underlying network of this forward star cursor.'
##        #return Network
##
##    def FindAdjacent(self, fromEdgeEID, AtJunctionEID):
##        u'Finds the edge elements that are adjacent to the given junction element and returns the count.'
##        #return adjacentEdgesCount
##
##    def QueryAdjacentEdge(self, Index):
##        u"Returns index'th adjacent edge found with FindAdjacent, its orientation, and its weight value."
##        #return adjacentEdgeEID, reverseOrientation, adjacentEdgeWeightValue
##
##    def QueryAdjacentEdges(self):
##        u'Returns the adjacent edges found with FindAdjacent into the specified user-defined array.'
##        #return adjacentEdgeEIDs, reverseOrientation, adjacentEdgesWeightValue
##
##    def QueryAdjacentJunction(self, Index):
##        u"Returns the opposite junction of the index'th adjacent edge found with FindAdjacent, and the weight value for this junction."
##        #return adjacentJunctionEID, adjacentJunctionWeightValue
##

class IRelationshipClassContainer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that create, add and hand out relationship classes.'
    _iid_ = GUID('{C6C98E41-EE39-11D2-8A5A-000000000000}')
    _idlflags_ = ['oleautomation']
class IEnumRelationshipClass(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate relationship classes.'
    _iid_ = GUID('{22B00697-8895-11D2-8A0D-006097AFF44E}')
    _idlflags_ = ['oleautomation']
class IClass(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about and manage the class.'
    _iid_ = GUID('{1AFCDB32-AC09-11D2-8A1E-006097AFF44E}')
    _idlflags_ = ['oleautomation']
class IObjectClass(IClass):
    _case_insensitive_ = True
    u'Provides access to members that return information about an object class.'
    _iid_ = GUID('{1AFCDB31-AC09-11D2-8A1E-006097AFF44E}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriRelCardinality'
esriRelCardinalityOneToOne = 1
esriRelCardinalityOneToMany = 2
esriRelCardinalityManyToMany = 3
esriRelCardinality = c_int # enum

# values for enumeration 'esriRelNotification'
esriRelNotificationNone = 1
esriRelNotificationForward = 2
esriRelNotificationBackward = 3
esriRelNotificationBoth = 4
esriRelNotification = c_int # enum
IRelationshipClassContainer._methods_ = [
    COMMETHOD(['propget', helpstring(u'An enumerator over the RelationshipClasses in this container.')], HRESULT, 'RelationshipClasses',
              ( ['retval', 'out'], POINTER(POINTER(IEnumRelationshipClass)), 'relClasses' )),
    COMMETHOD([helpstring(u'Creates a new relationship class in this container.')], HRESULT, 'CreateRelationshipClass',
              ( ['in'], BSTR, 'relClassName' ),
              ( ['in'], POINTER(IObjectClass), 'OriginClass' ),
              ( ['in'], POINTER(IObjectClass), 'DestinationClass' ),
              ( ['in'], BSTR, 'ForwardLabel' ),
              ( ['in'], BSTR, 'BackwardLabel' ),
              ( ['in'], esriRelCardinality, 'Cardinality' ),
              ( ['in'], esriRelNotification, 'Notification' ),
              ( ['in'], VARIANT_BOOL, 'IsComposite' ),
              ( ['in'], VARIANT_BOOL, 'IsAttributed' ),
              ( ['in'], POINTER(IFields), 'relAttrFields' ),
              ( ['in'], BSTR, 'OriginPrimaryKey' ),
              ( ['in'], BSTR, 'destPrimaryKey' ),
              ( ['in'], BSTR, 'OriginForeignKey' ),
              ( ['in'], BSTR, 'destForeignKey' ),
              ( ['retval', 'out'], POINTER(POINTER(IRelationshipClass)), 'RelationshipClass' )),
    COMMETHOD([helpstring(u'Transfers ownership of a relationship class to this container.')], HRESULT, 'AddRelationshipClass',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' )),
]
################################################################
## code template for IRelationshipClassContainer implementation
##class IRelationshipClassContainer_Impl(object):
##    @property
##    def RelationshipClasses(self):
##        u'An enumerator over the RelationshipClasses in this container.'
##        #return relClasses
##
##    def AddRelationshipClass(self, RelationshipClass):
##        u'Transfers ownership of a relationship class to this container.'
##        #return 
##
##    def CreateRelationshipClass(self, relClassName, OriginClass, DestinationClass, ForwardLabel, BackwardLabel, Cardinality, Notification, IsComposite, IsAttributed, relAttrFields, OriginPrimaryKey, destPrimaryKey, OriginForeignKey, destForeignKey):
##        u'Creates a new relationship class in this container.'
##        #return RelationshipClass
##

class TrafficData(CoClass):
    u'A container for members in traffic data.'
    _reg_clsid_ = GUID('{E7A1CD66-C6EF-440B-91CA-D6B8DB9C01F9}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ITrafficData(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members in traffic data.'
    _iid_ = GUID('{EB382BCD-C05E-45E7-A625-3C0B55525775}')
    _idlflags_ = ['oleautomation']
class ITrafficData2(ITrafficData):
    _case_insensitive_ = True
    u'Provides access to members in traffic data.'
    _iid_ = GUID('{0F7E13A0-8F82-44C6-9C94-F3D8BDFB32F3}')
    _idlflags_ = ['oleautomation']
class IHistoricalTrafficData(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members in historical traffic data.'
    _iid_ = GUID('{074C64B3-0D8B-471D-A16E-606C70DDC84A}')
    _idlflags_ = ['oleautomation']
class IHistoricalTrafficData2(IHistoricalTrafficData):
    _case_insensitive_ = True
    u'Provides access to members in historical traffic data.'
    _iid_ = GUID('{213F0913-EC31-420C-8826-CE8353C28D08}')
    _idlflags_ = ['oleautomation']
class IDynamicTrafficData(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members in dynamic traffic data.'
    _iid_ = GUID('{C8696877-C08F-4FEC-AC30-50C9AAD43FBB}')
    _idlflags_ = ['oleautomation']
TrafficData._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITrafficData, ITrafficData2, IHistoricalTrafficData, IHistoricalTrafficData2, IDynamicTrafficData]

class NetworkEdgeTrafficEvaluator(CoClass):
    u'A container for members in time dependent travel time evaluator.'
    _reg_clsid_ = GUID('{848AA108-2899-4830-9405-4B02AD3CD312}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class INetworkEvaluator(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of an attribute evaluator in a network dataset.'
    _iid_ = GUID('{0FCB88F9-8B17-4ED8-99C7-C876F5DA8B7E}')
    _idlflags_ = ['oleautomation']
class INetworkEvaluator2(INetworkEvaluator):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of an attribute evaluator in a network dataset.'
    _iid_ = GUID('{8498DE86-9E39-4F92-9301-D1E9862B1DBD}')
    _idlflags_ = ['oleautomation']
class INetworkEvaluatorSetup(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that set up a network evaluator for use within a network dataset.'
    _iid_ = GUID('{BD8ECCEF-092D-43DD-80DC-04684BA60D60}')
    _idlflags_ = ['oleautomation']
class IHistoricalTravelTimeEvaluator(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members in historical travel time evaluator.'
    _iid_ = GUID('{B65E3A4A-63B3-4A9B-974E-C17A99013376}')
    _idlflags_ = ['oleautomation']
class ITimeAwareEvaluator(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members in travel dependent evaluator.'
    _iid_ = GUID('{E55445D9-FF42-4A88-8B5C-132A2B9216F4}')
    _idlflags_ = ['oleautomation']
NetworkEdgeTrafficEvaluator._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPDescribe, INetworkEvaluator, INetworkEvaluator2, INetworkEvaluatorSetup, IHistoricalTravelTimeEvaluator, ITimeAwareEvaluator]

class TrafficDataManager(CoClass):
    u'A class for creating/managing dynamic traffic files for dynamic traffic feeds.'
    _reg_clsid_ = GUID('{95EEE584-D873-491A-8248-49A4ED60E35D}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ITrafficDataManager(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides editing capabilities for creating or deleting dynamic traffic files.'
    _iid_ = GUID('{DD1AE245-B211-4502-89D4-B880BB10701D}')
    _idlflags_ = ['oleautomation']
TrafficDataManager._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITrafficDataManager]

class TinNodeArray(CoClass):
    u'The Esri TinNodeArray component.'
    _reg_clsid_ = GUID('{A9BC13F2-3E88-4B68-826D-1866D07FC9A2}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ITinNodeArray(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control simple arrays of TIN nodes.'
    _iid_ = GUID('{C0E04940-B08C-11D2-9F6A-00C04F8ECE27}')
    _idlflags_ = ['oleautomation']
TinNodeArray._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITinNodeArray]

class TrafficFeedGPService(CoClass):
    u'A container for members in traffic feed data.'
    _reg_clsid_ = GUID('{C8A68870-3769-4271-B480-E95E806B72DF}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ITrafficFeedLocation(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to an indicator interface for network dataset traffic feed objects.'
    _iid_ = GUID('{C7A107A7-08A7-4866-AEAD-608943358EB7}')
    _idlflags_ = ['oleautomation']
class ITrafficFeedGPService(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a GP service for retrieving traffic feed data.'
    _iid_ = GUID('{92C16E94-9F87-4362-8391-E6711D13EE36}')
    _idlflags_ = ['oleautomation']
TrafficFeedGPService._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITrafficFeedLocation, ITrafficFeedGPService]

class ITinElement(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members to control TIN elements.'
    _iid_ = GUID('{3E541320-1132-11D2-92F7-444553540000}')
    _idlflags_ = ['oleautomation']
class ITinTriangle(ITinElement):
    _case_insensitive_ = True
    u'Provides access to members that control TIN triangles.'
    _iid_ = GUID('{3E541323-1132-11D2-92F7-444553540000}')
    _idlflags_ = []
class ITin(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control TINs.'
    _iid_ = GUID('{73B80FBB-FF33-11D1-A549-0000F8774F0F}')
    _idlflags_ = ['oleautomation']
ITinElement._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the specified element is uninitialized.')], HRESULT, 'IsEmpty',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsEmpty' )),
    COMMETHOD(['propget', helpstring(u'The TIN object referenced by the element.')], HRESULT, 'TheTin',
              ( ['retval', 'out'], POINTER(POINTER(ITin)), 'ppTin' )),
    COMMETHOD(['propget', helpstring(u"The element's index number.")], HRESULT, 'Index',
              ( ['retval', 'out'], POINTER(c_int), 'pIndex' )),
    COMMETHOD(['propget', helpstring(u'The tag value of the specified element.')], HRESULT, 'TagValue',
              ( ['retval', 'out'], POINTER(c_int), 'pValue' )),
    COMMETHOD([helpstring(u'Uninitializes the element.')], HRESULT, 'SetEmpty'),
    COMMETHOD([helpstring(u'Initializes a new TIN element.')], HRESULT, 'Init',
              ( ['in'], POINTER(ITin), 'pTin' ),
              ( ['in'], c_int, 'Index' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the specified element is within the interpolation zone of the TIN.')], HRESULT, 'IsInsideDataArea',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsInside' )),
    COMMETHOD(['restricted', helpstring(u'Indicates whether the element contains z-less vertex.'), 'propget'], HRESULT, 'HasVoidZ',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbHasVoidZ' )),
    COMMETHOD(['restricted', helpstring(u'Indicates whether the element is inside the specified envelope.'), 'propget'], HRESULT, 'IsInsideExtent',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'pExtent' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsInside' )),
]
################################################################
## code template for ITinElement implementation
##class ITinElement_Impl(object):
##    @property
##    def HasVoidZ(self):
##        u'Indicates whether the element contains z-less vertex.'
##        #return pbHasVoidZ
##
##    @property
##    def Index(self):
##        u"The element's index number."
##        #return pIndex
##
##    @property
##    def IsInsideExtent(self, pExtent):
##        u'Indicates whether the element is inside the specified envelope.'
##        #return pbIsInside
##
##    def Init(self, pTin, Index):
##        u'Initializes a new TIN element.'
##        #return 
##
##    @property
##    def TagValue(self):
##        u'The tag value of the specified element.'
##        #return pValue
##
##    @property
##    def TheTin(self):
##        u'The TIN object referenced by the element.'
##        #return ppTin
##
##    @property
##    def IsInsideDataArea(self):
##        u'Indicates if the specified element is within the interpolation zone of the TIN.'
##        #return pbIsInside
##
##    @property
##    def IsEmpty(self):
##        u'Indicates if the specified element is uninitialized.'
##        #return pbIsEmpty
##
##    def SetEmpty(self):
##        u'Uninitializes the element.'
##        #return 
##

class ITinNode(ITinElement):
    _case_insensitive_ = True
    u'Provides access to members that control TIN nodes.'
    _iid_ = GUID('{3E541321-1132-11D2-92F7-444553540000}')
    _idlflags_ = []
class ITinEdge(ITinElement):
    _case_insensitive_ = True
    u'Provides access to members that control TIN edges.'
    _iid_ = GUID('{3E541322-1132-11D2-92F7-444553540000}')
    _idlflags_ = []
ITinTriangle._methods_ = [
    COMMETHOD(['propget', helpstring(u'The triangle node specified by the index.')], HRESULT, 'Node',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinNode)), 'ppNode' )),
    COMMETHOD(['propget', helpstring(u'The triangle edge specified by the index.')], HRESULT, 'Edge',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinEdge)), 'ppEdge' )),
    COMMETHOD(['propget', helpstring(u'The projected area of the specified TIN triangle.')], HRESULT, 'Area',
              ( ['retval', 'out'], POINTER(c_double), 'pArea' )),
    COMMETHOD(['propget', helpstring(u'The projected perimeter of the specified TIN triangle.')], HRESULT, 'Perimeter',
              ( ['retval', 'out'], POINTER(c_double), 'pPerimeter' )),
    COMMETHOD(['propget', helpstring(u'The area of the specified triangle as measured on the TIN surface.')], HRESULT, 'Area3D',
              ( ['retval', 'out'], POINTER(c_double), 'pArea' )),
    COMMETHOD(['propget', helpstring(u'The perimeter of the specified triangle as measured on the TIN surface.')], HRESULT, 'Perimeter3D',
              ( ['retval', 'out'], POINTER(c_double), 'pPerimeter' )),
    COMMETHOD(['restricted', helpstring(u'The vector normal to the specified triangle.'), 'propget'], HRESULT, 'Normal',
              ( ['retval', 'out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pNormal' )),
    COMMETHOD(['restricted', helpstring(u'The vector normal to the specified triangle, adjusted to a magnitude of one.'), 'propget'], HRESULT, 'UnitNormal',
              ( ['retval', 'out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pNormal' )),
    COMMETHOD([helpstring(u'The vector normal to the specified triangle.')], HRESULT, 'QueryNormal',
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IVector3D), 'pNormal' )),
    COMMETHOD(['hidden', helpstring(u'The slope of the specified triangle in radians.'), 'propget'], HRESULT, 'SlopeRadians',
              ( ['retval', 'out'], POINTER(c_double), 'pSlope' )),
    COMMETHOD(['propget', helpstring(u'The slope of the specified triangle in degrees.')], HRESULT, 'SlopeDegrees',
              ( ['retval', 'out'], POINTER(c_double), 'pSlope' )),
    COMMETHOD(['propget', helpstring(u'The slope of the specified triangle in percent.')], HRESULT, 'SlopePercent',
              ( ['retval', 'out'], POINTER(c_double), 'pSlope' )),
    COMMETHOD(['hidden', helpstring(u'The aspect of the specified triangle in radians.'), 'propget'], HRESULT, 'AspectRadians',
              ( ['retval', 'out'], POINTER(c_double), 'pAspect' )),
    COMMETHOD(['propget', helpstring(u'The aspect of the specified triangle in degrees.')], HRESULT, 'AspectDegrees',
              ( ['retval', 'out'], POINTER(c_double), 'pAspect' )),
    COMMETHOD(['hidden', helpstring(u'The brightness value of the specified triangle.'), 'propget'], HRESULT, 'Intensity',
              ( ['retval', 'out'], POINTER(c_double), 'pIntensity' )),
    COMMETHOD([helpstring(u'The vertices of the specified triangle as point features.')], HRESULT, 'QueryVertices',
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPi' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPj' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPk' )),
    COMMETHOD([helpstring(u'Sets the specified triangle as a ring.')], HRESULT, 'QueryAsRing',
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IRing), 'pRing' )),
    COMMETHOD([helpstring(u'The centroid of the specified triangle as determined by averaging the coordinates of its vertices.')], HRESULT, 'QueryCentroid',
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pCentroid' )),
    COMMETHOD([helpstring(u'The circle circumscribing the specified triangle about its vertices.')], HRESULT, 'QueryCircumCircle',
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pCenter' ),
              ( ['out'], POINTER(c_double), 'pRadius' )),
    COMMETHOD([helpstring(u'The polygon based on the specified triangle and input bounds.')], HRESULT, 'QueryElevationBand',
              ( ['in'], c_double, 'zLowerBound' ),
              ( ['in'], c_double, 'zUpperBound' ),
              ( ['out'], POINTER(c_int), 'pCount' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pRegion' )),
    COMMETHOD([helpstring(u'The array of triangles adjacent to the specified triangle.')], HRESULT, 'QueryAdjacentTriangles',
              ( [], POINTER(ITinTriangle), 'pTi' ),
              ( [], POINTER(ITinTriangle), 'pTj' ),
              ( [], POINTER(ITinTriangle), 'pTk' )),
    COMMETHOD([helpstring(u'An array of index numbers belonging to triangles adjacent to the specified triangle.')], HRESULT, 'QueryAdjacentTriangleIndices',
              ( ['out'], POINTER(c_int), 'pTi' ),
              ( ['out'], POINTER(c_int), 'pTj' ),
              ( ['out'], POINTER(c_int), 'pTk' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'IsSameTriangle',
              ( ['in'], POINTER(ITinTriangle), 'pTriangle' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsTheSame' )),
]
################################################################
## code template for ITinTriangle implementation
##class ITinTriangle_Impl(object):
##    @property
##    def SlopePercent(self):
##        u'The slope of the specified triangle in percent.'
##        #return pSlope
##
##    @property
##    def Area(self):
##        u'The projected area of the specified TIN triangle.'
##        #return pArea
##
##    @property
##    def Area3D(self):
##        u'The area of the specified triangle as measured on the TIN surface.'
##        #return pArea
##
##    @property
##    def Perimeter3D(self):
##        u'The perimeter of the specified triangle as measured on the TIN surface.'
##        #return pPerimeter
##
##    @property
##    def Node(self, Index):
##        u'The triangle node specified by the index.'
##        #return ppNode
##
##    @property
##    def Normal(self):
##        u'The vector normal to the specified triangle.'
##        #return pNormal
##
##    @property
##    def SlopeDegrees(self):
##        u'The slope of the specified triangle in degrees.'
##        #return pSlope
##
##    @property
##    def UnitNormal(self):
##        u'The vector normal to the specified triangle, adjusted to a magnitude of one.'
##        #return pNormal
##
##    def QueryCircumCircle(self, pCenter):
##        u'The circle circumscribing the specified triangle about its vertices.'
##        #return pRadius
##
##    def QueryElevationBand(self, zLowerBound, zUpperBound):
##        u'The polygon based on the specified triangle and input bounds.'
##        #return pCount, pRegion
##
##    def QueryVertices(self):
##        u'The vertices of the specified triangle as point features.'
##        #return pPi, pPj, pPk
##
##    @property
##    def Perimeter(self):
##        u'The projected perimeter of the specified TIN triangle.'
##        #return pPerimeter
##
##    @property
##    def SlopeRadians(self):
##        u'The slope of the specified triangle in radians.'
##        #return pSlope
##
##    def QueryCentroid(self, pCentroid):
##        u'The centroid of the specified triangle as determined by averaging the coordinates of its vertices.'
##        #return 
##
##    @property
##    def Edge(self, Index):
##        u'The triangle edge specified by the index.'
##        #return ppEdge
##
##    @property
##    def AspectRadians(self):
##        u'The aspect of the specified triangle in radians.'
##        #return pAspect
##
##    def QueryAdjacentTriangles(self, pTi, pTj, pTk):
##        u'The array of triangles adjacent to the specified triangle.'
##        #return 
##
##    def QueryAsRing(self, pRing):
##        u'Sets the specified triangle as a ring.'
##        #return 
##
##    def IsSameTriangle(self, pTriangle):
##        u'Restricted.'
##        #return pbIsTheSame
##
##    def QueryAdjacentTriangleIndices(self):
##        u'An array of index numbers belonging to triangles adjacent to the specified triangle.'
##        #return pTi, pTj, pTk
##
##    @property
##    def AspectDegrees(self):
##        u'The aspect of the specified triangle in degrees.'
##        #return pAspect
##
##    @property
##    def Intensity(self):
##        u'The brightness value of the specified triangle.'
##        #return pIntensity
##
##    def QueryNormal(self, pNormal):
##        u'The vector normal to the specified triangle.'
##        #return 
##

class TrafficFeedDirectory(CoClass):
    u'A container for members in traffic feed data.'
    _reg_clsid_ = GUID('{2C4B45D8-7288-4BD9-9F7E-4167DECE6D34}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ITrafficFeedDirectory(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a folder directory for retrieving traffic feed data.'
    _iid_ = GUID('{30365C0D-2B90-4F76-BF61-CBFC038AA4BF}')
    _idlflags_ = ['oleautomation']
TrafficFeedDirectory._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITrafficFeedLocation, ITrafficFeedDirectory]

class IRepresentationRules(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that supply information about the representation rules of a feature class representation.'
    _iid_ = GUID('{84E3B47A-B26D-41F3-8D1B-F4D9E300D454}')
    _idlflags_ = ['oleautomation']
IRepresentationRules._methods_ = [
    COMMETHOD(['propget', helpstring(u'Name of a representation rule indicated by its ID.')], HRESULT, 'Name',
              ( ['in'], c_int, 'ID' ),
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'Name of a representation rule indicated by its ID.')], HRESULT, 'Name',
              ( ['in'], c_int, 'ID' ),
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'Index of a representation rule indicated by its ID.')], HRESULT, 'Index',
              ( ['in'], c_int, 'ID' ),
              ( ['retval', 'out'], POINTER(c_int), 'Index' )),
    COMMETHOD(['propput', helpstring(u'Index of a representation rule indicated by its ID.')], HRESULT, 'Index',
              ( ['in'], c_int, 'ID' ),
              ( ['in'], c_int, 'Index' )),
    COMMETHOD([helpstring(u'Resets the representation rule enumeration to the beginning.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Returns the next representation rule in the enumeration.')], HRESULT, 'Next',
              ( ['out'], POINTER(c_int), 'ID' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IRepresentationRule)), 'repRule' )),
    COMMETHOD(['propget', helpstring(u'The representation rule indicated by its ID.')], HRESULT, 'Rule',
              ( ['in'], c_int, 'ID' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IRepresentationRule)), 'repRule' )),
    COMMETHOD(['propput', helpstring(u'The representation rule indicated by its ID.')], HRESULT, 'Rule',
              ( ['in'], c_int, 'ID' ),
              ( ['in'], POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IRepresentationRule), 'repRule' )),
    COMMETHOD([helpstring(u'Adds a new representation rule to the collection.')], HRESULT, 'Add',
              ( ['in'], POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IRepresentationRule), 'repRule' ),
              ( ['retval', 'out'], POINTER(c_int), 'ID' )),
    COMMETHOD([helpstring(u'Removes the representation rule identified by its ID.')], HRESULT, 'Remove',
              ( ['in'], c_int, 'ID' )),
    COMMETHOD([helpstring(u'Removes all the representation rules from the collection.')], HRESULT, 'RemoveAll'),
    COMMETHOD([helpstring(u'Checks whether the given representation rule exists in the collection.')], HRESULT, 'Exists',
              ( ['in'], c_int, 'ID' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Exists' )),
]
################################################################
## code template for IRepresentationRules implementation
##class IRepresentationRules_Impl(object):
##    def Reset(self):
##        u'Resets the representation rule enumeration to the beginning.'
##        #return 
##
##    def _get(self, ID):
##        u'Index of a representation rule indicated by its ID.'
##        #return Index
##    def _set(self, ID, Index):
##        u'Index of a representation rule indicated by its ID.'
##    Index = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self, ID):
##        u'Name of a representation rule indicated by its ID.'
##        #return Name
##    def _set(self, ID, Name):
##        u'Name of a representation rule indicated by its ID.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def Exists(self, ID):
##        u'Checks whether the given representation rule exists in the collection.'
##        #return Exists
##
##    def _get(self, ID):
##        u'The representation rule indicated by its ID.'
##        #return repRule
##    def _set(self, ID, repRule):
##        u'The representation rule indicated by its ID.'
##    Rule = property(_get, _set, doc = _set.__doc__)
##
##    def Next(self):
##        u'Returns the next representation rule in the enumeration.'
##        #return ID, repRule
##
##    def RemoveAll(self):
##        u'Removes all the representation rules from the collection.'
##        #return 
##
##    def Add(self, repRule):
##        u'Adds a new representation rule to the collection.'
##        #return ID
##
##    def Remove(self, ID):
##        u'Removes the representation rule identified by its ID.'
##        #return 
##

class ITopologyName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the topology name.'
    _iid_ = GUID('{505B6FDD-9E6E-42F9-B705-53355B2F1DEF}')
    _idlflags_ = ['oleautomation']
ITopologyName._methods_ = [
    COMMETHOD(['propget', helpstring(u'Dirty areas name object.')], HRESULT, 'DirtyAreasName',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'Name' )),
    COMMETHOD(['propget', helpstring(u'Name of class holding errors for the specified geometry type.')], HRESULT, 'TopologyErrorName',
              ( ['in'], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType, 'GeometryType' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'Name' )),
    COMMETHOD(['propget', helpstring(u'Name of feature dataset containing the topology.')], HRESULT, 'FeatureDatasetName',
              ( ['retval', 'out'], POINTER(POINTER(IDatasetName)), 'Name' )),
    COMMETHOD(['propputref', helpstring(u'Name of feature dataset containing the topology.')], HRESULT, 'FeatureDatasetName',
              ( ['in'], POINTER(IDatasetName), 'Name' )),
]
################################################################
## code template for ITopologyName implementation
##class ITopologyName_Impl(object):
##    @property
##    def DirtyAreasName(self):
##        u'Dirty areas name object.'
##        #return Name
##
##    def FeatureDatasetName(self, Name):
##        u'Name of feature dataset containing the topology.'
##        #return 
##
##    @property
##    def TopologyErrorName(self, GeometryType):
##        u'Name of class holding errors for the specified geometry type.'
##        #return Name
##

class Representation(CoClass):
    u'A Feature Representation object.'
    _reg_clsid_ = GUID('{3FA48A52-2F4E-4762-9258-2D16943F8D36}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IRepresentation(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return and set properties of a representation.'
    _iid_ = GUID('{2DA11044-D45B-44AD-B982-D9B09C59928A}')
    _idlflags_ = ['oleautomation']
class IOverride(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage property overrides of a representation.'
    _iid_ = GUID('{60F814EF-730E-42A2-B043-BF28097A16D6}')
    _idlflags_ = ['oleautomation']
Representation._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRepresentation, IOverride, comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IGraphicsOutline, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]


# values for enumeration 'esriGPMessageType'
esriGPMessageTypeInformative = 0
esriGPMessageTypeProcessDefinition = 1
esriGPMessageTypeProcessStart = 2
esriGPMessageTypeProcessStop = 3
esriGPMessageTypeWarning = 50
esriGPMessageTypeError = 100
esriGPMessageTypeEmpty = 101
esriGPMessageTypeGDBError = 102
esriGPMessageTypeAbort = 200
esriGPMessageType = c_int # enum

# values for enumeration 'esriRepresentationError'
REP_E_INVALID_REP_RULE_ID = -2147218687
REP_E_REP_RULE_NAME_ALREADY_EXISTS = -2147218686
REP_E_REP_CLASS_NOT_FOUND = -2147218685
REP_E_REP_IS_FREE_GRAPHICS = -2147218684
REP_E_REP_USES_REP_RULE = -2147218683
REP_E_CANT_ACQUIRE_SCHEMA_LOCK = -2147218682
REP_E_OBJECT_IS_DELETED = -2147218681
REP_E_NO_REP_RULES = -2147218680
REP_E_WORKSPACE_DOESNT_SUPPORT_REP_EXTENSION = -2147218679
REP_E_FEATURE_TYPE_NOT_SUPPORTED = -2147218678
REP_E_GEODATABASE_DOESNT_SUPPORT_REPRESENTATIONS = -2147218677
REP_E_NO_REP_SYSTEM_TABLES = -2147218676
REP_E_REP_CLASS_NAME_ALREADY_EXISTS = -2147218675
REP_E_FIELD_NAME_ALREADY_EXISTS = -2147218674
REP_E_NAME_HAS_INVALID_CHARACTERS = -2147218673
REP_E_MUST_BE_THE_OWNER = -2147218672
REP_E_INVALID_LICENSE = -2147218671
REP_E_COMPRESSED_FEATURE_CLASS = -2147218670
esriRepresentationError = c_int # enum
class IClassEx(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about and manage the class.'
    _iid_ = GUID('{310E1637-77D5-4847-9361-F98EEF1E5BAC}')
    _idlflags_ = ['oleautomation']
IClassEx._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the class has an global object identity field.')], HRESULT, 'HasGlobalID',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasGlobalID' )),
    COMMETHOD(['propget', helpstring(u'The name of the field corresponding to the global object identity.')], HRESULT, 'GlobalIDFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
]
################################################################
## code template for IClassEx implementation
##class IClassEx_Impl(object):
##    @property
##    def HasGlobalID(self):
##        u'Indicates if the class has an global object identity field.'
##        #return HasGlobalID
##
##    @property
##    def GlobalIDFieldName(self):
##        u'The name of the field corresponding to the global object identity.'
##        #return Name
##

class IEditorTrackingInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'EditorTrackingInfo value object'
    _iid_ = GUID('{35BCA9A4-D278-4D33-9486-C64DF1B8E480}')
    _idlflags_ = ['oleautomation']
IEditorTrackingInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u"Creation date field's name")], HRESULT, 'CreationDateFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'Creator Field')], HRESULT, 'CreatorFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'Edit date field Name')], HRESULT, 'EditDateFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'Editor Field Name')], HRESULT, 'EditorFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'Time reference for creation and edit dates.')], HRESULT, 'TimeReference',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITimeReference)), 'TimeReference' )),
    COMMETHOD(['propget', helpstring(u'If true, creation and edit dates are in UTC.')], HRESULT, 'IsTimeInUTC',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsTimeInUTC' )),
    COMMETHOD(['propget', helpstring(u'Username qualifier to be used with the username in creator and editor fields.')], HRESULT, 'Realm',
              ( ['retval', 'out'], POINTER(BSTR), 'Realm' )),
]
################################################################
## code template for IEditorTrackingInfo implementation
##class IEditorTrackingInfo_Impl(object):
##    @property
##    def Realm(self):
##        u'Username qualifier to be used with the username in creator and editor fields.'
##        #return Realm
##
##    @property
##    def EditorFieldName(self):
##        u'Editor Field Name'
##        #return FieldName
##
##    @property
##    def IsTimeInUTC(self):
##        u'If true, creation and edit dates are in UTC.'
##        #return IsTimeInUTC
##
##    @property
##    def EditDateFieldName(self):
##        u'Edit date field Name'
##        #return FieldName
##
##    @property
##    def CreatorFieldName(self):
##        u'Creator Field'
##        #return FieldName
##
##    @property
##    def CreationDateFieldName(self):
##        u"Creation date field's name"
##        #return FieldName
##
##    @property
##    def TimeReference(self):
##        u'Time reference for creation and edit dates.'
##        #return TimeReference
##


# values for enumeration 'esriReplicaRole'
esriReplicaRoleChild = 0
esriReplicaRoleParent = 1
esriReplicaRole = c_int # enum
class IGPReplicaDescription(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members which set and return the properties of a GPReplicaDescription object.'
    _iid_ = GUID('{E4C1358F-56CF-4C9B-99CD-1BF58D45F1BB}')
    _idlflags_ = ['oleautomation']
IGPReplica._methods_ = [
    COMMETHOD([helpstring(u'Initializes the class using an IReplica object.')], HRESULT, 'Init',
              ( ['in'], POINTER(IReplica), 'Replica' )),
    COMMETHOD(['propput', helpstring(u'Name of the replica.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'ReplicaName' )),
    COMMETHOD(['propget', helpstring(u'Name of the replica.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'ReplicaName' )),
    COMMETHOD(['propput', helpstring(u'The ID of the replica.')], HRESULT, 'ID',
              ( ['in'], c_int, 'ReplicaID' )),
    COMMETHOD(['propget', helpstring(u'The ID of the replica.')], HRESULT, 'ID',
              ( ['retval', 'out'], POINTER(c_int), 'ReplicaID' )),
    COMMETHOD(['propput', helpstring(u'The guid of the replica.')], HRESULT, 'GUID',
              ( ['in'], BSTR, 'GUID' )),
    COMMETHOD(['propget', helpstring(u'The guid of the replica.')], HRESULT, 'GUID',
              ( ['retval', 'out'], POINTER(BSTR), 'GUID' )),
    COMMETHOD(['propput', helpstring(u'The replica role.')], HRESULT, 'Role',
              ( ['in'], esriReplicaRole, 'ReplicaRole' )),
    COMMETHOD(['propget', helpstring(u'The replica role.')], HRESULT, 'Role',
              ( ['retval', 'out'], POINTER(esriReplicaRole), 'ReplicaRole' )),
    COMMETHOD(['propput', helpstring(u'Replica access type.')], HRESULT, 'AccessType',
              ( ['in'], esriReplicaAccessType, 'AccessType' )),
    COMMETHOD(['propget', helpstring(u'Replica access type.')], HRESULT, 'AccessType',
              ( ['retval', 'out'], POINTER(esriReplicaAccessType), 'AccessType' )),
    COMMETHOD(['propput', helpstring(u'The date the replica was created.')], HRESULT, 'CreationDate',
              ( ['in'], VARIANT, 'ReplicaRole' )),
    COMMETHOD(['propget', helpstring(u'The date the replica was created.')], HRESULT, 'CreationDate',
              ( ['retval', 'out'], POINTER(VARIANT), 'ReplicaRole' )),
    COMMETHOD(['propput', helpstring(u'The name of the replica version.')], HRESULT, 'ReplicaVersion',
              ( ['in'], BSTR, 'ReplicaVersion' )),
    COMMETHOD(['propget', helpstring(u'The name of the replica version.')], HRESULT, 'ReplicaVersion',
              ( ['retval', 'out'], POINTER(BSTR), 'ReplicaVersion' )),
    COMMETHOD(['propput', helpstring(u'The generation number for the replica.')], HRESULT, 'MyGenerationNumber',
              ( ['in'], c_int, 'pMyGenerationNumber' )),
    COMMETHOD(['propget', helpstring(u'The generation number for the replica.')], HRESULT, 'MyGenerationNumber',
              ( ['retval', 'out'], POINTER(c_int), 'pMyGenerationNumber' )),
    COMMETHOD(['propput', helpstring(u'The generation number of the relative replica.')], HRESULT, 'SibGenerationNumber',
              ( ['in'], c_int, 'pSibGenerationNumber' )),
    COMMETHOD(['propget', helpstring(u'The generation number of the relative replica.')], HRESULT, 'SibGenerationNumber',
              ( ['retval', 'out'], POINTER(c_int), 'pSibGenerationNumber' )),
    COMMETHOD(['propput', helpstring(u'The last generation number that has been acknowledged by the relative replica.')], HRESULT, 'SibMyGenerationNumber',
              ( ['in'], c_int, 'pSibMyGenerationNumber' )),
    COMMETHOD(['propget', helpstring(u'The last generation number that has been acknowledged by the relative replica.')], HRESULT, 'SibMyGenerationNumber',
              ( ['retval', 'out'], POINTER(c_int), 'pSibMyGenerationNumber' )),
    COMMETHOD(['propput', helpstring(u'The replica state.')], HRESULT, 'ReplicaState',
              ( ['in'], esriReplicaState, 'ReplicaState' )),
    COMMETHOD(['propget', helpstring(u'The replica state.')], HRESULT, 'ReplicaState',
              ( ['retval', 'out'], POINTER(esriReplicaState), 'ReplicaState' )),
    COMMETHOD(['propput', helpstring(u'The connection string of the relative replica.')], HRESULT, 'SibConnectionString',
              ( ['in'], BSTR, 'SibConnectionString' )),
    COMMETHOD(['propget', helpstring(u'The connection string of the relative replica.')], HRESULT, 'SibConnectionString',
              ( ['retval', 'out'], POINTER(BSTR), 'SibConnectionString' )),
    COMMETHOD(['propputref', helpstring(u'The replica description for the replica.')], HRESULT, 'ReplicaDescription',
              ( ['in'], POINTER(IGPReplicaDescription), 'ReplicaDescription' )),
    COMMETHOD(['propget', helpstring(u'The replica description for the replica.')], HRESULT, 'ReplicaDescription',
              ( ['retval', 'out'], POINTER(POINTER(IGPReplicaDescription)), 'ReplicaDescription' )),
    COMMETHOD(['propput', helpstring(u'The replica reconcile policy.')], HRESULT, 'ReconcilePolicy',
              ( ['in'], esriReplicaReconcilePolicyType, 'policy' )),
    COMMETHOD(['propget', helpstring(u'The replica reconcile policy.')], HRESULT, 'ReconcilePolicy',
              ( ['retval', 'out'], POINTER(esriReplicaReconcilePolicyType), 'policy' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the replica is in conflict.')], HRESULT, 'HasConflicts',
              ( ['in'], VARIANT_BOOL, 'HasConflicts' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the replica is in conflict.')], HRESULT, 'HasConflicts',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasConflicts' )),
]
################################################################
## code template for IGPReplica implementation
##class IGPReplica_Impl(object):
##    def _get(self):
##        u'The generation number of the relative replica.'
##        #return pSibGenerationNumber
##    def _set(self, pSibGenerationNumber):
##        u'The generation number of the relative replica.'
##    SibGenerationNumber = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def ReplicaDescription(self, ReplicaDescription):
##        u'The replica description for the replica.'
##        #return 
##
##    def _get(self):
##        u'The date the replica was created.'
##        #return ReplicaRole
##    def _set(self, ReplicaRole):
##        u'The date the replica was created.'
##    CreationDate = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Name of the replica.'
##        #return ReplicaName
##    def _set(self, ReplicaName):
##        u'Name of the replica.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Replica access type.'
##        #return AccessType
##    def _set(self, AccessType):
##        u'Replica access type.'
##    AccessType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the replica version.'
##        #return ReplicaVersion
##    def _set(self, ReplicaVersion):
##        u'The name of the replica version.'
##    ReplicaVersion = property(_get, _set, doc = _set.__doc__)
##
##    def Init(self, Replica):
##        u'Initializes the class using an IReplica object.'
##        #return 
##
##    def _get(self):
##        u'The replica role.'
##        #return ReplicaRole
##    def _set(self, ReplicaRole):
##        u'The replica role.'
##    Role = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The generation number for the replica.'
##        #return pMyGenerationNumber
##    def _set(self, pMyGenerationNumber):
##        u'The generation number for the replica.'
##    MyGenerationNumber = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the replica is in conflict.'
##        #return HasConflicts
##    def _set(self, HasConflicts):
##        u'Indicates if the replica is in conflict.'
##    HasConflicts = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The replica state.'
##        #return ReplicaState
##    def _set(self, ReplicaState):
##        u'The replica state.'
##    ReplicaState = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The connection string of the relative replica.'
##        #return SibConnectionString
##    def _set(self, SibConnectionString):
##        u'The connection string of the relative replica.'
##    SibConnectionString = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The guid of the replica.'
##        #return GUID
##    def _set(self, GUID):
##        u'The guid of the replica.'
##    GUID = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The last generation number that has been acknowledged by the relative replica.'
##        #return pSibMyGenerationNumber
##    def _set(self, pSibMyGenerationNumber):
##        u'The last generation number that has been acknowledged by the relative replica.'
##    SibMyGenerationNumber = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The ID of the replica.'
##        #return ReplicaID
##    def _set(self, ReplicaID):
##        u'The ID of the replica.'
##    ID = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The replica reconcile policy.'
##        #return policy
##    def _set(self, policy):
##        u'The replica reconcile policy.'
##    ReconcilePolicy = property(_get, _set, doc = _set.__doc__)
##

class IResultPortion(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that allow a client to get information about the result portion.'
    _iid_ = GUID('{49F53871-3067-4027-8598-7371A241767C}')
    _idlflags_ = ['oleautomation']
IResultPortion._methods_ = [
    COMMETHOD(['propget', helpstring(u'The information about the result portion.')], HRESULT, 'ResultPortionInfo',
              ( ['retval', 'out'], POINTER(POINTER(IResultPortionInfo)), 'ResultPortionInfo' )),
    COMMETHOD(['propputref', helpstring(u'The information about the result portion.')], HRESULT, 'ResultPortionInfo',
              ( ['in'], POINTER(IResultPortionInfo), 'ResultPortionInfo' )),
]
################################################################
## code template for IResultPortion implementation
##class IResultPortion_Impl(object):
##    def ResultPortionInfo(self, ResultPortionInfo):
##        u'The information about the result portion.'
##        #return 
##

class INetworkForwardStarSetup(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the configuration for this NetworkForwardStar object.'
    _iid_ = GUID('{D68A2A0C-F2B9-47AF-8AE6-811513349546}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriNetworkForwardStarBacktrack'
esriNFSBNoBacktrack = 0
esriNFSBAllowBacktrack = 1
esriNFSBAtDeadEndsOnly = 2
esriNFSBAtDeadEndsAndIntersections = 3
esriNetworkForwardStarBacktrack = c_int # enum
class INetworkDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that query the schema of the network dataset.'
    _iid_ = GUID('{5299F003-FCA2-453D-AB8E-28B9AC6648B5}')
    _idlflags_ = ['oleautomation']
class INetworkAttribute(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of an attribute in a network dataset.'
    _iid_ = GUID('{AE92A9B6-9C80-41B1-B84D-765F18B43625}')
    _idlflags_ = ['oleautomation']
INetworkForwardStarSetup._methods_ = [
    COMMETHOD(['propget', helpstring(u'Policy on when to return the from-edge in the NetworkForwardStarAdjacencies object.')], HRESULT, 'Backtrack',
              ( ['retval', 'out'], POINTER(esriNetworkForwardStarBacktrack), 'Backtrack' )),
    COMMETHOD(['propput', helpstring(u'Policy on when to return the from-edge in the NetworkForwardStarAdjacencies object.')], HRESULT, 'Backtrack',
              ( ['in'], esriNetworkForwardStarBacktrack, 'Backtrack' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the NetworkForwardStar object is used to model forward traversal through the network dataset.')], HRESULT, 'IsForwardTraversal',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsForwardTraversal' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the NetworkForwardStar object is used to model forward traversal through the network dataset.')], HRESULT, 'IsForwardTraversal',
              ( ['in'], VARIANT_BOOL, 'IsForwardTraversal' )),
    COMMETHOD(['propget', helpstring(u'Network dataset on which the NetworkForwardStar object is querying.')], HRESULT, 'NetworkDataset',
              ( ['retval', 'out'], POINTER(POINTER(INetworkDataset)), 'Network' )),
    COMMETHOD([helpstring(u'AddCachedAttribute has been deprecated and should not be called.')], HRESULT, 'AddCachedAttribute',
              ( ['in'], POINTER(INetworkAttribute), 'Attribute' )),
    COMMETHOD([helpstring(u'RemoveAllCachedAttributes has been deprecated and should not be called.')], HRESULT, 'RemoveAllCachedAttributes'),
    COMMETHOD([helpstring(u'Adds a restriction network attribute to the NetworkForwardStar object to filter elements returned.')], HRESULT, 'AddRestriction',
              ( ['in'], POINTER(INetworkAttribute), 'Attribute' )),
    COMMETHOD(['propget', helpstring(u'Restriction network attribute by index applied to the NetworkForwardStar object.')], HRESULT, 'Restriction',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(INetworkAttribute)), 'Attribute' )),
    COMMETHOD(['propget', helpstring(u'Number of restriction network attributes applied to the NetworkForwardStar object.')], HRESULT, 'RestrictionCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD([helpstring(u'Removes the given restriction network attribute by index from the NetworkForwardStar object.')], HRESULT, 'RemoveRestriction',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD(['propputref', helpstring(u'Network attribute containing the hierarchy values for each network element.')], HRESULT, 'HierarchyAttribute',
              ( ['in'], POINTER(INetworkAttribute), 'Attribute' )),
    COMMETHOD(['propget', helpstring(u'Network attribute containing the hierarchy values for each network element.')], HRESULT, 'HierarchyAttribute',
              ( ['retval', 'out'], POINTER(POINTER(INetworkAttribute)), 'Attribute' )),
    COMMETHOD(['propput', helpstring(u'Maximum hierarchy attribute value permitted to be returned in the NetworkForwardStarAdjacencies object.')], HRESULT, 'MaxHierarchyValue',
              ( ['in'], c_int, 'MaxValue' )),
    COMMETHOD(['propget', helpstring(u'Maximum hierarchy attribute value permitted to be returned in the NetworkForwardStarAdjacencies object.')], HRESULT, 'MaxHierarchyValue',
              ( ['retval', 'out'], POINTER(c_int), 'MaxValue' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the given network element is travserable by the NetworkForwardStar object.')], HRESULT, 'Traversable',
              ( ['in'], POINTER(INetworkElement), 'Element' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Traversable' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the given network element is travserable by the NetworkForwardStar object.')], HRESULT, 'Traversable',
              ( ['in'], POINTER(INetworkElement), 'Element' ),
              ( ['in'], VARIANT_BOOL, 'Traversable' )),
    COMMETHOD([helpstring(u'Sets the given network elements to be traversable or non-traversable.')], HRESULT, 'SetTraversable',
              ( ['in'], POINTER(IEnumNetworkElement), 'Elements' ),
              ( ['in'], VARIANT_BOOL, 'Traversable' )),
    COMMETHOD([helpstring(u'Sets all network elements of the given element type to be traversable or non-traversable.')], HRESULT, 'SetAllTraversable',
              ( ['in'], esriNetworkElementType, 'ElementType' ),
              ( ['in'], VARIANT_BOOL, 'Traversable' )),
    COMMETHOD(['propget', helpstring(u'The collection of network elements of the given type that are set to not traversable.')], HRESULT, 'NonTraversableElements',
              ( ['in'], esriNetworkElementType, 'ElementType' ),
              ( ['in'], esriNetworkEdgeDirection, 'Direction' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumNetworkElement)), 'EnumNetworkElement' )),
]
################################################################
## code template for INetworkForwardStarSetup implementation
##class INetworkForwardStarSetup_Impl(object):
##    @property
##    def Restriction(self, Index):
##        u'Restriction network attribute by index applied to the NetworkForwardStar object.'
##        #return Attribute
##
##    @property
##    def HierarchyAttribute(self, Attribute):
##        u'Network attribute containing the hierarchy values for each network element.'
##        #return 
##
##    def AddCachedAttribute(self, Attribute):
##        u'AddCachedAttribute has been deprecated and should not be called.'
##        #return 
##
##    @property
##    def NonTraversableElements(self, ElementType, Direction):
##        u'The collection of network elements of the given type that are set to not traversable.'
##        #return EnumNetworkElement
##
##    def _get(self):
##        u'Policy on when to return the from-edge in the NetworkForwardStarAdjacencies object.'
##        #return Backtrack
##    def _set(self, Backtrack):
##        u'Policy on when to return the from-edge in the NetworkForwardStarAdjacencies object.'
##    Backtrack = property(_get, _set, doc = _set.__doc__)
##
##    def SetAllTraversable(self, ElementType, Traversable):
##        u'Sets all network elements of the given element type to be traversable or non-traversable.'
##        #return 
##
##    @property
##    def RestrictionCount(self):
##        u'Number of restriction network attributes applied to the NetworkForwardStar object.'
##        #return Count
##
##    def RemoveAllCachedAttributes(self):
##        u'RemoveAllCachedAttributes has been deprecated and should not be called.'
##        #return 
##
##    def _get(self, Element):
##        u'Indicates if the given network element is travserable by the NetworkForwardStar object.'
##        #return Traversable
##    def _set(self, Element, Traversable):
##        u'Indicates if the given network element is travserable by the NetworkForwardStar object.'
##    Traversable = property(_get, _set, doc = _set.__doc__)
##
##    def AddRestriction(self, Attribute):
##        u'Adds a restriction network attribute to the NetworkForwardStar object to filter elements returned.'
##        #return 
##
##    @property
##    def NetworkDataset(self):
##        u'Network dataset on which the NetworkForwardStar object is querying.'
##        #return Network
##
##    def RemoveRestriction(self, Index):
##        u'Removes the given restriction network attribute by index from the NetworkForwardStar object.'
##        #return 
##
##    def SetTraversable(self, Elements, Traversable):
##        u'Sets the given network elements to be traversable or non-traversable.'
##        #return 
##
##    def _get(self):
##        u'Indicates if the NetworkForwardStar object is used to model forward traversal through the network dataset.'
##        #return IsForwardTraversal
##    def _set(self, IsForwardTraversal):
##        u'Indicates if the NetworkForwardStar object is used to model forward traversal through the network dataset.'
##    IsForwardTraversal = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Maximum hierarchy attribute value permitted to be returned in the NetworkForwardStarAdjacencies object.'
##        #return MaxValue
##    def _set(self, MaxValue):
##        u'Maximum hierarchy attribute value permitted to be returned in the NetworkForwardStarAdjacencies object.'
##    MaxHierarchyValue = property(_get, _set, doc = _set.__doc__)
##

class IEnumTopologyEdge(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a set of topology edges.'
    _iid_ = GUID('{9A876DB0-4A30-11D5-9FE9-00C04F6BDD7F}')
    _idlflags_ = ['oleautomation']
class ITopologyElement(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the functionality present in all topology elements. ITopologyEdge and ITopologyNode inherit from this interface.'
    _iid_ = GUID('{9A876DB1-4A30-11D5-9FE9-00C04F6BDD7F}')
    _idlflags_ = ['oleautomation']
class ITopologyEdge(ITopologyElement):
    _case_insensitive_ = True
    u'Provides access to information on a topological edge within a topology graph.'
    _iid_ = GUID('{D04B7152-4989-11D5-9FE9-00C04F6BDD7F}')
    _idlflags_ = ['oleautomation']
IEnumTopologyEdge._methods_ = [
    COMMETHOD([helpstring(u'Resets the enumerator.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Returns the next topology edge.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(ITopologyEdge)), 'nextEdge' )),
    COMMETHOD(['propget', helpstring(u'The number of topology edges in the enumerator.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'EdgeCount' )),
]
################################################################
## code template for IEnumTopologyEdge implementation
##class IEnumTopologyEdge_Impl(object):
##    def Reset(self):
##        u'Resets the enumerator.'
##        #return 
##
##    @property
##    def Count(self):
##        u'The number of topology edges in the enumerator.'
##        #return EdgeCount
##
##    def Next(self):
##        u'Returns the next topology edge.'
##        #return nextEdge
##

class RepresentationClass(CoClass):
    u'A Feature Class Representation object.'
    _reg_clsid_ = GUID('{5FB4A66D-D466-4CA0-B219-A4155413D589}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IRepresentationClass(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the behavior and properties of a feature class representation.'
    _iid_ = GUID('{B4480153-CA17-4C52-A39A-0F0D12D2364A}')
    _idlflags_ = ['oleautomation']
class IDatasetComponent(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the common functionality found on all dataset components.'
    _iid_ = GUID('{5F636F00-4B3C-46EB-A684-C2D746357061}')
    _idlflags_ = ['oleautomation']
RepresentationClass._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRepresentationClass, IDataset, IDatasetComponent, ISchemaLock, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class IFeatureClass(IObjectClass):
    _case_insensitive_ = True
    u'Provides access to members that control the behavior and properties of a feature class.'
    _iid_ = GUID('{D4803EE6-79F4-11D0-97FC-0080C7F79481}')
    _idlflags_ = ['oleautomation']
class IFeature(IObject):
    _case_insensitive_ = True
    u'Provides access to members that return and set properties of a feature.'
    _iid_ = GUID('{D4803EE9-79F4-11D0-97FC-0080C7F79481}')
    _idlflags_ = ['oleautomation']
IRepresentationClass._methods_ = [
    COMMETHOD(['propget', helpstring(u'Field index of the override field.')], HRESULT, 'OverrideFieldIndex',
              ( ['retval', 'out'], POINTER(c_int), 'idx' )),
    COMMETHOD(['propget', helpstring(u'Field index of the Rule ID field.')], HRESULT, 'RuleIDFieldIndex',
              ( ['retval', 'out'], POINTER(c_int), 'idx' )),
    COMMETHOD(['propget', helpstring(u'Feature class associated with this representation class.')], HRESULT, 'FeatureClass',
              ( ['retval', 'out'], POINTER(POINTER(IFeatureClass)), 'FeatureClass' )),
    COMMETHOD(['propget', helpstring(u'ID of the representation class.')], HRESULT, 'ID',
              ( ['retval', 'out'], POINTER(c_int), 'ID' )),
    COMMETHOD([helpstring(u'Returns the representation of a given feature.')], HRESULT, 'GetRepresentation',
              ( ['in'], POINTER(IFeature), 'Feature' ),
              ( ['in'], POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IMapContext), 'MapContext' ),
              ( ['retval', 'out'], POINTER(POINTER(IRepresentation)), 'rep' )),
    COMMETHOD(['propget', helpstring(u'RepresentationRules Property.')], HRESULT, 'RepresentationRules',
              ( ['retval', 'out'], POINTER(POINTER(IRepresentationRules)), 'repRules' )),
    COMMETHOD(['propputref', helpstring(u'RepresentationRules Property.')], HRESULT, 'RepresentationRules',
              ( ['in'], POINTER(IRepresentationRules), 'repRules' )),
    COMMETHOD(['propget', helpstring(u'General attributes defined at the representation class level.')], HRESULT, 'GraphicAttributes',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IGraphicAttributes)), 'Attributes' )),
    COMMETHOD(['propputref', helpstring(u'General attributes defined at the representation class level.')], HRESULT, 'GraphicAttributes',
              ( ['in'], POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IGraphicAttributes), 'Attributes' )),
    COMMETHOD(['propget', helpstring(u'Indicates if a shape override is required for feature representations.')], HRESULT, 'RequireShapeOverride',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'RequireShapeOverride' )),
    COMMETHOD(['propput', helpstring(u'Indicates if a shape override is required for feature representations.')], HRESULT, 'RequireShapeOverride',
              ( ['in'], VARIANT_BOOL, 'RequireShapeOverride' )),
    COMMETHOD([helpstring(u'Adds the fields used by overrides to the query filter.')], HRESULT, 'PrepareFilter',
              ( ['in'], POINTER(IQueryFilter), 'filter' )),
]
################################################################
## code template for IRepresentationClass implementation
##class IRepresentationClass_Impl(object):
##    def GraphicAttributes(self, Attributes):
##        u'General attributes defined at the representation class level.'
##        #return 
##
##    @property
##    def ID(self):
##        u'ID of the representation class.'
##        #return ID
##
##    @property
##    def RuleIDFieldIndex(self):
##        u'Field index of the Rule ID field.'
##        #return idx
##
##    def PrepareFilter(self, filter):
##        u'Adds the fields used by overrides to the query filter.'
##        #return 
##
##    def RepresentationRules(self, repRules):
##        u'RepresentationRules Property.'
##        #return 
##
##    def _get(self):
##        u'Indicates if a shape override is required for feature representations.'
##        #return RequireShapeOverride
##    def _set(self, RequireShapeOverride):
##        u'Indicates if a shape override is required for feature representations.'
##    RequireShapeOverride = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def FeatureClass(self):
##        u'Feature class associated with this representation class.'
##        #return FeatureClass
##
##    @property
##    def OverrideFieldIndex(self):
##        u'Field index of the override field.'
##        #return idx
##
##    def GetRepresentation(self, Feature, MapContext):
##        u'Returns the representation of a given feature.'
##        #return rep
##

class IPlugInWorkspaceFactoryHelper(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that help the Plug-In workspace factory.'
    _iid_ = GUID('{A5E6E3FC-3A5C-42E4-B058-273F3BC57734}')
    _idlflags_ = ['oleautomation']
class IPlugInWorkspaceHelper(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that help the Plug-In workspace.'
    _iid_ = GUID('{897BDA47-2BF9-420F-886F-E0F49E2D570F}')
    _idlflags_ = ['oleautomation']
IPlugInWorkspaceFactoryHelper._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the data source.')], HRESULT, 'DataSourceName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'A desription of a detaset of the type specified.')], HRESULT, 'DatasetDescription',
              ( ['in'], esriDatasetType, 'DatasetType' ),
              ( ['retval', 'out'], POINTER(BSTR), 'dsDesc' )),
    COMMETHOD(['propget', helpstring(u'A singular or plural description of the type of workspace the workspace factory opens.')], HRESULT, 'WorkspaceDescription',
              ( ['in'], VARIANT_BOOL, 'plural' ),
              ( ['retval', 'out'], POINTER(BSTR), 'wksDesc' )),
    COMMETHOD(['propget', helpstring(u'The class ID which is registered in the WorkspaceFactory category.')], HRESULT, 'WorkspaceFactoryTypeID',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'wksFactID' )),
    COMMETHOD(['propget', helpstring(u'The type of workspace the workspace factory opens.')], HRESULT, 'WorkspaceType',
              ( ['retval', 'out'], POINTER(esriWorkspaceType), 'wksType' )),
    COMMETHOD(['propget', helpstring(u'Indicates whether datasets of this type can process SQL queries.')], HRESULT, 'CanSupportSQL',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanSupportSQL' )),
    COMMETHOD([helpstring(u'Tests if the workspace string represents a valid workspace.')], HRESULT, 'IsWorkspace',
              ( ['in'], BSTR, 'wksString' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isWks' )),
    COMMETHOD([helpstring(u'Indicates if parentDirectory contains a valid workspace, or is a valid file-system workspace.')], HRESULT, 'ContainsWorkspace',
              ( ['in'], BSTR, 'parentDirectory' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IFileNames), 'fileNames' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'ContainsWorkspace' )),
    COMMETHOD([helpstring(u'If parentDirectory is or contains a valid workspace, gets a string uniquely identifying that workspace.')], HRESULT, 'GetWorkspaceString',
              ( ['in'], BSTR, 'parentDirectory' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IFileNames), 'fileNames' ),
              ( ['retval', 'out'], POINTER(BSTR), 'wksString' )),
    COMMETHOD([helpstring(u'Opens a workspace helper for the workspace identified by the workspace string.')], HRESULT, 'OpenWorkspace',
              ( ['in'], BSTR, 'wksString' ),
              ( ['retval', 'out'], POINTER(POINTER(IPlugInWorkspaceHelper)), 'wksHelper' )),
]
################################################################
## code template for IPlugInWorkspaceFactoryHelper implementation
##class IPlugInWorkspaceFactoryHelper_Impl(object):
##    @property
##    def DataSourceName(self):
##        u'The name of the data source.'
##        #return Name
##
##    @property
##    def WorkspaceType(self):
##        u'The type of workspace the workspace factory opens.'
##        #return wksType
##
##    @property
##    def WorkspaceFactoryTypeID(self):
##        u'The class ID which is registered in the WorkspaceFactory category.'
##        #return wksFactID
##
##    @property
##    def DatasetDescription(self, DatasetType):
##        u'A desription of a detaset of the type specified.'
##        #return dsDesc
##
##    @property
##    def CanSupportSQL(self):
##        u'Indicates whether datasets of this type can process SQL queries.'
##        #return CanSupportSQL
##
##    def ContainsWorkspace(self, parentDirectory, fileNames):
##        u'Indicates if parentDirectory contains a valid workspace, or is a valid file-system workspace.'
##        #return ContainsWorkspace
##
##    def IsWorkspace(self, wksString):
##        u'Tests if the workspace string represents a valid workspace.'
##        #return isWks
##
##    def OpenWorkspace(self, wksString):
##        u'Opens a workspace helper for the workspace identified by the workspace string.'
##        #return wksHelper
##
##    def GetWorkspaceString(self, parentDirectory, fileNames):
##        u'If parentDirectory is or contains a valid workspace, gets a string uniquely identifying that workspace.'
##        #return wksString
##
##    @property
##    def WorkspaceDescription(self, plural):
##        u'A singular or plural description of the type of workspace the workspace factory opens.'
##        #return wksDesc
##

class IPlugInFileOperations(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for copying, deleting and renaming the dataset helper.'
    _iid_ = GUID('{CAB44598-68F6-490E-9F32-6D5FD06D22D2}')
    _idlflags_ = ['oleautomation']
IPlugInFileOperations._methods_ = [
    COMMETHOD([helpstring(u'True if this dataset can be copied.')], HRESULT, 'CanCopy',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanCopy' )),
    COMMETHOD([helpstring(u'Copies this dataset to a new dataset with the specified name.')], HRESULT, 'Copy',
              ( ['in'], BSTR, 'copyName' ),
              ( ['in'], POINTER(IWorkspace), 'copyWorkspace' )),
    COMMETHOD([helpstring(u'True if this dataset can be deleted.')], HRESULT, 'CanDelete',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanDelete' )),
    COMMETHOD([helpstring(u'Deletes this dataset.')], HRESULT, 'Delete'),
    COMMETHOD([helpstring(u'True if this dataset can be renamed.')], HRESULT, 'CanRename',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanRename' )),
    COMMETHOD([helpstring(u'Renames this dataset.')], HRESULT, 'Rename',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(BSTR), 'newName' )),
]
################################################################
## code template for IPlugInFileOperations implementation
##class IPlugInFileOperations_Impl(object):
##    def Rename(self, Name):
##        u'Renames this dataset.'
##        #return newName
##
##    def CanCopy(self):
##        u'True if this dataset can be copied.'
##        #return CanCopy
##
##    def CanDelete(self):
##        u'True if this dataset can be deleted.'
##        #return CanDelete
##
##    def Copy(self, copyName, copyWorkspace):
##        u'Copies this dataset to a new dataset with the specified name.'
##        #return 
##
##    def CanRename(self):
##        u'True if this dataset can be renamed.'
##        #return CanRename
##
##    def Delete(self):
##        u'Deletes this dataset.'
##        #return 
##

class ILocalDatabaseCompact(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for compacting a file or personal geodatabase.'
    _iid_ = GUID('{516C0A6D-8021-11D3-80EB-00C04F686238}')
    _idlflags_ = ['oleautomation']
ILocalDatabaseCompact._methods_ = [
    COMMETHOD([helpstring(u'Compacts the database.')], HRESULT, 'Compact',
              ( ['in'], POINTER(IWorkspaceName), 'Name' )),
]
################################################################
## code template for ILocalDatabaseCompact implementation
##class ILocalDatabaseCompact_Impl(object):
##    def Compact(self, Name):
##        u'Compacts the database.'
##        #return 
##

IGPMessage._methods_ = [
    COMMETHOD([dispid(1610678272), helpstring(u'The geoprocessing message type.'), 'propput'], HRESULT, 'Type',
              ( ['in'], esriGPMessageType, 'Type' )),
    COMMETHOD([dispid(1610678272), helpstring(u'The geoprocessing message type.'), 'propget'], HRESULT, 'Type',
              ( ['retval', 'out'], POINTER(esriGPMessageType), 'Type' )),
    COMMETHOD([dispid(1610678274), helpstring(u'The error code for the geoprocessing message.'), 'propput'], HRESULT, 'ErrorCode',
              ( ['in'], c_int, 'ErrorCode' )),
    COMMETHOD([dispid(1610678274), helpstring(u'The error code for the geoprocessing message.'), 'propget'], HRESULT, 'ErrorCode',
              ( ['retval', 'out'], POINTER(c_int), 'ErrorCode' )),
    COMMETHOD([dispid(1610678276), helpstring(u'The description of the geoprocessing message.'), 'propput'], HRESULT, 'Description',
              ( ['in'], BSTR, 'Message' )),
    COMMETHOD([dispid(1610678276), helpstring(u'The description of the geoprocessing message.'), 'propget'], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'Message' )),
    COMMETHOD([dispid(1610678278), helpstring(u'Indicates if the message is informative.')], HRESULT, 'IsInformational',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsInformational' )),
    COMMETHOD([dispid(1610678279), helpstring(u'Indicates if the message is a warning.')], HRESULT, 'IsWarning',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsWarning' )),
    COMMETHOD([dispid(1610678280), helpstring(u'Indicates if the message is an error.')], HRESULT, 'IsError',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsError' )),
    COMMETHOD([dispid(1610678281), helpstring(u'Indicates if the message is an abort.')], HRESULT, 'IsAbort',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsAbort' )),
]
################################################################
## code template for IGPMessage implementation
##class IGPMessage_Impl(object):
##    def _get(self):
##        u'The description of the geoprocessing message.'
##        #return Message
##    def _set(self, Message):
##        u'The description of the geoprocessing message.'
##    Description = property(_get, _set, doc = _set.__doc__)
##
##    def IsInformational(self):
##        u'Indicates if the message is informative.'
##        #return IsInformational
##
##    def _get(self):
##        u'The error code for the geoprocessing message.'
##        #return ErrorCode
##    def _set(self, ErrorCode):
##        u'The error code for the geoprocessing message.'
##    ErrorCode = property(_get, _set, doc = _set.__doc__)
##
##    def IsWarning(self):
##        u'Indicates if the message is a warning.'
##        #return IsWarning
##
##    def IsAbort(self):
##        u'Indicates if the message is an abort.'
##        #return IsAbort
##
##    def _get(self):
##        u'The geoprocessing message type.'
##        #return Type
##    def _set(self, Type):
##        u'The geoprocessing message type.'
##    Type = property(_get, _set, doc = _set.__doc__)
##
##    def IsError(self):
##        u'Indicates if the message is an error.'
##        #return IsError
##

IRepresentation._methods_ = [
    COMMETHOD(['propget', helpstring(u'The representation class to which this representation belongs.')], HRESULT, 'RepresentationClass',
              ( ['retval', 'out'], POINTER(POINTER(IRepresentationClass)), 'repClass' )),
    COMMETHOD(['propget', helpstring(u'The feature associated with this representation.')], HRESULT, 'Feature',
              ( ['retval', 'out'], POINTER(POINTER(IFeature)), 'Feature' )),
    COMMETHOD(['propget', helpstring(u'Map context in which the representation is defined.')], HRESULT, 'MapContext',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IMapContext)), 'MapContext' )),
    COMMETHOD(['propget', helpstring(u'Rule ID.')], HRESULT, 'RuleID',
              ( ['retval', 'out'], POINTER(c_int), 'ID' )),
    COMMETHOD(['propput', helpstring(u'Rule ID.')], HRESULT, 'RuleID',
              ( ['in'], c_int, 'ID' )),
    COMMETHOD(['propget', helpstring(u'Representation geometry.')], HRESULT, 'Shape',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Shape' )),
    COMMETHOD(['propget', helpstring(u'Representation geometry. This geometry can be a copy of the shape if the shape override option is active.')], HRESULT, 'ShapeEdit',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Shape' )),
    COMMETHOD(['propget', helpstring(u'Copy of the representation geometry.')], HRESULT, 'ShapeCopy',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Shape' )),
    COMMETHOD(['propputref', helpstring(u'Representation geometry.')], HRESULT, 'Shape',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'Shape' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the shape is overriden.')], HRESULT, 'HasShapeOverride',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasShapeOverride' )),
    COMMETHOD([helpstring(u'Removes the shape override.')], HRESULT, 'RemoveShapeOverride'),
    COMMETHOD(['propget', helpstring(u'The Graphics object that describes the free representation.')], HRESULT, 'Graphics',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IRepresentationGraphics)), 'Graphics' )),
    COMMETHOD(['propput', helpstring(u'The Graphics object that describes the free representation.')], HRESULT, 'Graphics',
              ( ['in'], POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IRepresentationGraphics), 'Graphics' )),
    COMMETHOD([helpstring(u'Updates the feature fields with the information contained in the representation.')], HRESULT, 'UpdateFeature'),
    COMMETHOD(['propget', helpstring(u'The value of a representation property.')], HRESULT, 'Value',
              ( ['in'], POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IGraphicAttributes), 'attrs' ),
              ( ['in'], c_int, 'idx' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'val' )),
    COMMETHOD(['propput', helpstring(u'The value of a representation property.')], HRESULT, 'Value',
              ( ['in'], POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IGraphicAttributes), 'attrs' ),
              ( ['in'], c_int, 'idx' ),
              ( ['in'], VARIANT, 'val' )),
]
################################################################
## code template for IRepresentation implementation
##class IRepresentation_Impl(object):
##    @property
##    def ShapeCopy(self):
##        u'Copy of the representation geometry.'
##        #return Shape
##
##    @property
##    def RepresentationClass(self):
##        u'The representation class to which this representation belongs.'
##        #return repClass
##
##    def _get(self):
##        u'Rule ID.'
##        #return ID
##    def _set(self, ID):
##        u'Rule ID.'
##    RuleID = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def HasShapeOverride(self):
##        u'Indicates if the shape is overriden.'
##        #return HasShapeOverride
##
##    def Shape(self, Shape):
##        u'Representation geometry.'
##        #return 
##
##    def _get(self, attrs, idx):
##        u'The value of a representation property.'
##        #return val
##    def _set(self, attrs, idx, val):
##        u'The value of a representation property.'
##    Value = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def Feature(self):
##        u'The feature associated with this representation.'
##        #return Feature
##
##    @property
##    def MapContext(self):
##        u'Map context in which the representation is defined.'
##        #return MapContext
##
##    @property
##    def ShapeEdit(self):
##        u'Representation geometry. This geometry can be a copy of the shape if the shape override option is active.'
##        #return Shape
##
##    def RemoveShapeOverride(self):
##        u'Removes the shape override.'
##        #return 
##
##    def _get(self):
##        u'The Graphics object that describes the free representation.'
##        #return Graphics
##    def _set(self, Graphics):
##        u'The Graphics object that describes the free representation.'
##    Graphics = property(_get, _set, doc = _set.__doc__)
##
##    def UpdateFeature(self):
##        u'Updates the feature fields with the information contained in the representation.'
##        #return 
##

class IPlugInDatasetLoad(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{CD9A0A6A-E0C7-4627-AAD7-D891A5FBD93A}')
    _idlflags_ = ['oleautomation']
class IPlugInDatasetLoader(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{389D83EA-A560-4668-BF5A-D7D8F77AD0F3}')
    _idlflags_ = ['oleautomation']
IPlugInDatasetLoad._methods_ = [
    COMMETHOD([], HRESULT, 'GetLoader',
              ( ['in'], c_int, 'ClassIndex' ),
              ( [], POINTER(POINTER(IPlugInDatasetLoader)), 'loader' )),
]
################################################################
## code template for IPlugInDatasetLoad implementation
##class IPlugInDatasetLoad_Impl(object):
##    def GetLoader(self, ClassIndex, loader):
##        '-no docstring-'
##        #return 
##

class WorkspaceExtension(CoClass):
    u'Workspace Extension Object.'
    _reg_clsid_ = GUID('{FBF5715C-A05D-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IWorkspaceExtension(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that supply workspace extension information.'
    _iid_ = GUID('{DA10C1C2-09A3-11D4-9FAA-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
class IWorkspaceExtensionControl(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage the life of a workspace extension.'
    _iid_ = GUID('{DA10C1C0-09A3-11D4-9FAA-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
WorkspaceExtension._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IWorkspaceExtension, IWorkspaceExtensionControl]


# values for enumeration 'esriDatasetFileStatTimeMode'
esriDatasetFileStatTimeLastAccess = 0
esriDatasetFileStatTimeCreation = 1
esriDatasetFileStatTimeLastModification = 2
esriDatasetFileStatTimeMode = c_int # enum
class IWorkspace2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that have information about the workspace.'
    _iid_ = GUID('{4B21005E-01DF-4945-9038-ADCBD17A0F2E}')
    _idlflags_ = ['oleautomation']
IWorkspace2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if a dataset with the given name exists within the workspace.')], HRESULT, 'NameExists',
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Exists' )),
]
################################################################
## code template for IWorkspace2 implementation
##class IWorkspace2_Impl(object):
##    @property
##    def NameExists(self, Type, Name):
##        u'Indicates if a dataset with the given name exists within the workspace.'
##        #return Exists
##

class IFeatureChanges(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to members that provide information about changes in the feature's shape."
    _iid_ = GUID('{022F7463-69FA-11D3-9FD0-00C04F6BDD84}')
    _idlflags_ = ['oleautomation']
IFeatureChanges._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the shape has changed.')], HRESULT, 'ShapeChanged',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'changed' )),
    COMMETHOD(['propget', helpstring(u'The original shape for the feature.')], HRESULT, 'OriginalShape',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Shape' )),
]
################################################################
## code template for IFeatureChanges implementation
##class IFeatureChanges_Impl(object):
##    @property
##    def ShapeChanged(self):
##        u'Indicates if the shape has changed.'
##        #return changed
##
##    @property
##    def OriginalShape(self):
##        u'The original shape for the feature.'
##        #return Shape
##


# values for enumeration 'esriTinTrianglePropertyType'
esriTinDegreeSlope = 0
esriTinPercentageSlope = 1
esriTinDegreeAspect = 2
esriTinArea = 3
esriTinSurfaceArea = 4
esriTinPerimeter = 5
esriTinSurfacePerimeter = 6
esriTinTrianglePropertyType = c_int # enum

# values for enumeration 'esriSQLClauses'
esriSQL_DISTINCT = 1
esriSQL_ALL = 2
esriSQL_AS = 4
esriSQL_ORDER_BY = 8
esriSQL_GROUP_BY = 16
esriSQLClauses = c_int # enum

# values for enumeration 'esriConfigurationKeywordType'
esriConfigurationKeywordGeneral = 1
esriConfigurationKeywordNetwork = 2
esriConfigurationKeywordTopology = 3
esriConfigurationKeywordNetworkDataset = 4
esriConfigurationKeywordTerrain = 5
esriConfigurationKeywordMosaic = 6
esriConfigurationKeywordType = c_int # enum

# values for enumeration 'esriSQLInfo'
esriSQL_CurrentDateRequiresParentheses = 0
esriSQL_PositionRequiresCommas = 1
esriSQL_SubstringRequiresCommas = 2
esriSQL_CorrelationNameAllowsASKeyword = 3
esriSQLInfo = c_int # enum

# values for enumeration 'esriSQLOperator'
esriSQL_StringConcatenate = 1
esriSQLOperator = c_int # enum

# values for enumeration 'esriDatasetFileStatAccessMode'
esriDatasetFileStatAccessUnknown = 0
esriDatasetFileStatAccessWrite = 2
esriDatasetFileStatAccessReadOnly = 4
esriDatasetFileStatAccessReadWrite = 6
esriDatasetFileStatAccessMode = c_int # enum

# values for enumeration 'esriWorkspacePropertyType'
esriWorkspacePropCanExecuteSQL = 0
esriWorkspacePropCanEdit = 1
esriWorkspacePropIsReadonly = 2
esriWorkspacePropSupportsQualifiedNames = 3
esriWorkspacePropSupportsMetadata = 4
esriWorkspacePropCanAnalyze = 5
esriWorkspacePropCanGetConfigurationKeywords = 6
esriWorkspacePropIsGeoDatabase = 7
esriWorkspacePropMaxWhereClauseLength = 8
esriWorkspacePropHasPrivateEditSession = 9
esriWorkspacePropSupportsHighPrecisionStorage = 10
esriWorkspacePropSupportsExtensionDatasets = 11
esriWorkspacePropLastCompressDate = 12
esriWorkspacePropLastCompressStatus = 13
esriWorkspacePropSupportsArchiving = 14
esriWorkspacePropSupportsMoveEditsToBase = 15
esriWorkspacePropertyType = c_int # enum

# values for enumeration 'esriSQLDatetimeType'
esriSQL_Date = 1
esriSQL_Time = 2
esriSQL_Timestamp = 3
esriSQLDatetimeType = c_int # enum
class IEnumTopologyParent(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the set of parents of a topology element.'
    _iid_ = GUID('{EFE9D2A4-1FB2-47F9-8AF9-4831FAD2DB2D}')
    _idlflags_ = ['oleautomation']
ITopologyElement._methods_ = [
    COMMETHOD(['propget', helpstring(u'The geometry of the topology element.')], HRESULT, 'Geometry',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Geometry' )),
    COMMETHOD(['propget', helpstring(u"Indicates if this element is part of its containing topology graph's selected set.")], HRESULT, 'IsSelected',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'selected' )),
    COMMETHOD([helpstring(u"Copies the element's geometry into the specified geometry.")], HRESULT, 'QueryGeometry',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'Geometry' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this element has been deleted from its containing topology graph.')], HRESULT, 'IsDeleted',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'deleted' )),
    COMMETHOD(['propget', helpstring(u'The set of parents (features) of this topology element.')], HRESULT, 'Parents',
              ( ['retval', 'out'], POINTER(POINTER(IEnumTopologyParent)), 'enumParents' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the topology element has been visited.')], HRESULT, 'Visited',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isVisited' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the topology element has been visited.')], HRESULT, 'Visited',
              ( [], VARIANT_BOOL, 'isVisited' )),
]
################################################################
## code template for ITopologyElement implementation
##class ITopologyElement_Impl(object):
##    def QueryGeometry(self, Geometry):
##        u"Copies the element's geometry into the specified geometry."
##        #return 
##
##    @property
##    def Geometry(self):
##        u'The geometry of the topology element.'
##        #return Geometry
##
##    @property
##    def IsSelected(self):
##        u"Indicates if this element is part of its containing topology graph's selected set."
##        #return selected
##
##    @property
##    def Parents(self):
##        u'The set of parents (features) of this topology element.'
##        #return enumParents
##
##    def _get(self):
##        u'Indicates if the topology element has been visited.'
##        #return isVisited
##    def _set(self, isVisited):
##        u'Indicates if the topology element has been visited.'
##    Visited = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def IsDeleted(self):
##        u'Indicates if this element has been deleted from its containing topology graph.'
##        #return deleted
##

class ITopologyNode(ITopologyElement):
    _case_insensitive_ = True
    u'Provides access to information on a topological node within a topology graph.'
    _iid_ = GUID('{D04B7154-4989-11D5-9FE9-00C04F6BDD7F}')
    _idlflags_ = ['oleautomation']
ITopologyEdge._methods_ = [
    COMMETHOD(['propget', helpstring(u'A reference to the topology node at the from point of this edge.')], HRESULT, 'FromNode',
              ( ['retval', 'out'], POINTER(POINTER(ITopologyNode)), 'FromNode' )),
    COMMETHOD(['propget', helpstring(u'A reference to the topology node at the to point of this edge.')], HRESULT, 'ToNode',
              ( ['retval', 'out'], POINTER(POINTER(ITopologyNode)), 'ToNode' )),
    COMMETHOD(['propget', helpstring(u'The set of parents (polygon features) that cover this edge. If boundedByEdge is true, then only polygons lying to the left of the edge will be returned.')], HRESULT, 'LeftParents',
              ( [], VARIANT_BOOL, 'boundedByEdge' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumTopologyParent)), 'left' )),
    COMMETHOD(['propget', helpstring(u'The set of parents (polygon features) that cover this edge. If boundedByEdge is true, then only polygons lying to the right of the edge will be returned.')], HRESULT, 'RightParents',
              ( [], VARIANT_BOOL, 'boundedByEdge' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumTopologyParent)), 'right' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the left side of the edge was visited.')], HRESULT, 'LeftVisited',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isLeftVisited' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the left side of the edge was visited.')], HRESULT, 'LeftVisited',
              ( [], VARIANT_BOOL, 'isLeftVisited' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the right side of the edge was visited.')], HRESULT, 'RightVisited',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isRightVisited' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the right side of the edge was visited.')], HRESULT, 'RightVisited',
              ( [], VARIANT_BOOL, 'isRightVisited' )),
]
################################################################
## code template for ITopologyEdge implementation
##class ITopologyEdge_Impl(object):
##    def _get(self):
##        u'Indicates if the left side of the edge was visited.'
##        #return isLeftVisited
##    def _set(self, isLeftVisited):
##        u'Indicates if the left side of the edge was visited.'
##    LeftVisited = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def LeftParents(self, boundedByEdge):
##        u'The set of parents (polygon features) that cover this edge. If boundedByEdge is true, then only polygons lying to the left of the edge will be returned.'
##        #return left
##
##    def _get(self):
##        u'Indicates if the right side of the edge was visited.'
##        #return isRightVisited
##    def _set(self, isRightVisited):
##        u'Indicates if the right side of the edge was visited.'
##    RightVisited = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def ToNode(self):
##        u'A reference to the topology node at the to point of this edge.'
##        #return ToNode
##
##    @property
##    def FromNode(self):
##        u'A reference to the topology node at the from point of this edge.'
##        #return FromNode
##
##    @property
##    def RightParents(self, boundedByEdge):
##        u'The set of parents (polygon features) that cover this edge. If boundedByEdge is true, then only polygons lying to the right of the edge will be returned.'
##        #return right
##

class ITinFilter(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control TIN filtering options.'
    _iid_ = GUID('{4EEE3270-FA94-11D2-AE10-000000000000}')
    _idlflags_ = ['oleautomation']
class ITinEdgeTypeFilter(ITinFilter):
    _case_insensitive_ = True
    u'Provides access to members that control TIN edge type filters.'
    _iid_ = GUID('{F9B595AE-A9A6-11D3-AB4B-0008C73FD50C}')
    _idlflags_ = ['oleautomation']
ITinFilter._methods_ = [
    COMMETHOD([helpstring(u'Indicates if the specified element meets the filter criteria.')], HRESULT, 'CanPass',
              ( ['in'], POINTER(ITinElement), 'pElement' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbCanPass' )),
    COMMETHOD(['propput', helpstring(u'Indicates whether the returned elements should be inside the data area.')], HRESULT, 'DataElementsOnly',
              ( ['in'], VARIANT_BOOL, 'pbDataElementsOnly' )),
    COMMETHOD(['propget', helpstring(u'Indicates whether the returned elements should be inside the data area.')], HRESULT, 'DataElementsOnly',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbDataElementsOnly' )),
]
################################################################
## code template for ITinFilter implementation
##class ITinFilter_Impl(object):
##    def _get(self):
##        u'Indicates whether the returned elements should be inside the data area.'
##        #return pbDataElementsOnly
##    def _set(self, pbDataElementsOnly):
##        u'Indicates whether the returned elements should be inside the data area.'
##    DataElementsOnly = property(_get, _set, doc = _set.__doc__)
##
##    def CanPass(self, pElement):
##        u'Indicates if the specified element meets the filter criteria.'
##        #return pbCanPass
##


# values for enumeration 'esriTinEdgeType'
esriTinRegularEdge = 0
esriTinSoftEdge = 1
esriTinHardEdge = 2
esriTinEdgeType = c_int # enum
ITinEdgeTypeFilter._methods_ = [
    COMMETHOD(['propput', helpstring(u'The edge type of the filter.')], HRESULT, 'Type',
              ( ['in'], esriTinEdgeType, 'pType' )),
    COMMETHOD(['propget', helpstring(u'The edge type of the filter.')], HRESULT, 'Type',
              ( ['retval', 'out'], POINTER(esriTinEdgeType), 'pType' )),
]
################################################################
## code template for ITinEdgeTypeFilter implementation
##class ITinEdgeTypeFilter_Impl(object):
##    def _get(self):
##        u'The edge type of the filter.'
##        #return pType
##    def _set(self, pType):
##        u'The edge type of the filter.'
##    Type = property(_get, _set, doc = _set.__doc__)
##


# values for enumeration 'esriWorkspacePropertyGroupType'
esriWorkspacePropertyGroup = 1
esriWorkspaceTablePropertyGroup = 2
esriWorkspacePropertyGroupType = c_int # enum
class ITinNodeSourceFilter(ITinFilter):
    _case_insensitive_ = True
    u'Provides access to members that control TIN node source filters.'
    _iid_ = GUID('{D462B2CC-B2AB-11D5-ABB9-0008C73FD50C}')
    _idlflags_ = ['oleautomation']
ITinNodeSourceFilter._methods_ = [
    COMMETHOD(['propput', helpstring(u'The criteria of the filter.')], HRESULT, 'Criteria',
              ( ['in'], c_int, 'pCriteria' )),
    COMMETHOD(['propget', helpstring(u'The criteria of the filter.')], HRESULT, 'Criteria',
              ( ['retval', 'out'], POINTER(c_int), 'pCriteria' )),
]
################################################################
## code template for ITinNodeSourceFilter implementation
##class ITinNodeSourceFilter_Impl(object):
##    def _get(self):
##        u'The criteria of the filter.'
##        #return pCriteria
##    def _set(self, pCriteria):
##        u'The criteria of the filter.'
##    Criteria = property(_get, _set, doc = _set.__doc__)
##


# values for enumeration 'esriWorkspaceTablePropertyType'
esriTablePropRowCountIsCalculated = 1
esriTablePropCanAddField = 2
esriTablePropCanDeleteField = 3
esriTablePropCanAddIndex = 4
esriTablePropCanDeleteIndex = 5
esriTablePropOIDIsRecordNumber = 6
esriTablePropMaxFieldNameLength = 7
esriTablePropBindCursor = 8
esriTablePropSupportsMultiColumnIndexes = 9
esriWorkspaceTablePropertyType = c_int # enum
ITransformGroup._methods_ = [
    COMMETHOD([helpstring(u'Add feature to group.')], HRESULT, 'Add',
              ( ['in'], c_int, 'ClassID' ),
              ( ['in'], c_int, 'OID' ),
              ( ['in'], POINTER(IFeature), 'Feature' )),
    COMMETHOD([helpstring(u'Delete feature from group.')], HRESULT, 'Delete',
              ( ['in'], c_int, 'ClassID' ),
              ( ['in'], c_int, 'OID' )),
    COMMETHOD([helpstring(u'Delete all features with ClassID.')], HRESULT, 'DeleteAllInClass',
              ( ['in'], c_int, 'ClassID' )),
    COMMETHOD([helpstring(u'The next type of feature and how many times it was found.')], HRESULT, 'Next',
              ( ['out'], POINTER(c_int), 'ClassID' ),
              ( ['out'], POINTER(c_int), 'OID' ),
              ( ['out'], POINTER(c_int), 'Count' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'The next set of features.')], HRESULT, 'NextSet',
              ( ['out'], POINTER(c_int), 'ClassID' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet)), 'featureSet' )),
]
################################################################
## code template for ITransformGroup implementation
##class ITransformGroup_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def NextSet(self):
##        u'The next set of features.'
##        #return ClassID, featureSet
##
##    def Next(self):
##        u'The next type of feature and how many times it was found.'
##        #return ClassID, OID, Count
##
##    def Add(self, ClassID, OID, Feature):
##        u'Add feature to group.'
##        #return 
##
##    def DeleteAllInClass(self, ClassID):
##        u'Delete all features with ClassID.'
##        #return 
##
##    def Delete(self, ClassID, OID):
##        u'Delete feature from group.'
##        #return 
##

class IWorkspaceDefinition(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe the definition of a workspace.'
    _iid_ = GUID('{4F1D89CE-C93A-4733-9926-7022A7576D2A}')
    _idlflags_ = ['oleautomation']
class IWorkspaceDefinition2(IWorkspaceDefinition):
    _case_insensitive_ = True
    u'Provides access to members that describe the definition of a workspace.'
    _iid_ = GUID('{FB6B7E43-30F9-4C2F-9920-D145CE9F92DB}')
    _idlflags_ = ['oleautomation']
IWorkspaceDefinition._methods_ = [
    COMMETHOD(['propget', helpstring(u'The workspace type.')], HRESULT, 'WorkspaceType',
              ( ['retval', 'out'], POINTER(esriWorkspaceType), 'WorkspaceType' )),
    COMMETHOD(['propput', helpstring(u'The workspace type.')], HRESULT, 'WorkspaceType',
              ( ['in'], esriWorkspaceType, 'WorkspaceType' )),
    COMMETHOD(['propget', helpstring(u'The workspace version.')], HRESULT, 'Version',
              ( ['retval', 'out'], POINTER(BSTR), 'workspaceVersion' )),
    COMMETHOD(['propput', helpstring(u'The workspace version.')], HRESULT, 'Version',
              ( ['in'], BSTR, 'workspaceVersion' )),
    COMMETHOD(['propget', helpstring(u'The list of Domains.')], HRESULT, 'Domains',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'Domains' )),
    COMMETHOD(['propputref', helpstring(u'The list of Domains.')], HRESULT, 'Domains',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'Domains' )),
    COMMETHOD(['propget', helpstring(u'The list of sub-elements.')], HRESULT, 'Children',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'DataElements' )),
    COMMETHOD(['propputref', helpstring(u'The list of sub-elements.')], HRESULT, 'Children',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'DataElements' )),
]
################################################################
## code template for IWorkspaceDefinition implementation
##class IWorkspaceDefinition_Impl(object):
##    def Domains(self, Domains):
##        u'The list of Domains.'
##        #return 
##
##    def _get(self):
##        u'The workspace type.'
##        #return WorkspaceType
##    def _set(self, WorkspaceType):
##        u'The workspace type.'
##    WorkspaceType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The workspace version.'
##        #return workspaceVersion
##    def _set(self, workspaceVersion):
##        u'The workspace version.'
##    Version = property(_get, _set, doc = _set.__doc__)
##
##    def Children(self, DataElements):
##        u'The list of sub-elements.'
##        #return 
##

IWorkspaceDefinition2._methods_ = [
    COMMETHOD(['propputref', helpstring(u'The replica.')], HRESULT, 'GPReplica',
              ( ['in'], POINTER(IGPReplica), 'Replica' )),
    COMMETHOD(['propget', helpstring(u'The replica.')], HRESULT, 'GPReplica',
              ( ['retval', 'out'], POINTER(POINTER(IGPReplica)), 'Replica' )),
]
################################################################
## code template for IWorkspaceDefinition2 implementation
##class IWorkspaceDefinition2_Impl(object):
##    @property
##    def GPReplica(self, Replica):
##        u'The replica.'
##        #return 
##

class ITinAdvanced(ITin):
    _case_insensitive_ = True
    u'Provides access to members that control advanced TIN functions.'
    _iid_ = GUID('{A8523EE8-7B16-11D2-9F4B-00C04F8ECE27}')
    _idlflags_ = []
ITin._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the TIN contains no data.')], HRESULT, 'IsEmpty',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsEmpty' )),
    COMMETHOD(['propget', helpstring(u'Indicates if TIN was constructed using Delaunay triangulation.')], HRESULT, 'IsDelaunay',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsEmpty' )),
    COMMETHOD([helpstring(u'Saves the TIN to disk using the specified name.')], HRESULT, 'SaveAs',
              ( ['in'], BSTR, 'newName' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pOverWrite' )),
    COMMETHOD(['propget', helpstring(u'The interpolation zone of the TIN.')], HRESULT, 'Extent',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'ppExtent' )),
    COMMETHOD(['propget', helpstring(u'The number of data nodes in the TIN.')], HRESULT, 'DataNodeCount',
              ( ['retval', 'out'], POINTER(c_int), 'pcNodes' )),
    COMMETHOD(['propget', helpstring(u'The number of TIN edges that have a data triangle on one side or the other.')], HRESULT, 'DataEdgeCount',
              ( ['retval', 'out'], POINTER(c_int), 'pcEdges' )),
    COMMETHOD(['propget', helpstring(u'The number of data triangles in the TIN.')], HRESULT, 'DataTriangleCount',
              ( ['retval', 'out'], POINTER(c_int), 'pcTriangles' )),
    COMMETHOD(['propget', helpstring(u'Multiplication factor applied to all z values in a TIN to provide unit-congruency between coordinate components.')], HRESULT, 'ZFactor',
              ( ['retval', 'out'], POINTER(c_double), 'pFactor' )),
    COMMETHOD(['propput', helpstring(u'Multiplication factor applied to all z values in a TIN to provide unit-congruency between coordinate components.')], HRESULT, 'ZFactor',
              ( ['in'], c_double, 'pFactor' )),
    COMMETHOD(['hidden', helpstring(u'Returns the version number of the TIN engine used to build the TIN.'), 'propget'], HRESULT, 'Version',
              ( ['retval', 'out'], POINTER(c_int), 'pVer' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the TIN dataset has node tag values.')], HRESULT, 'HasNodeTagValues',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbHasNodeValues' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the TIN dataset has edge tag values.')], HRESULT, 'HasEdgeTagValues',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbHasEdgeValues' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the TIN dataset has triangle tag values.')], HRESULT, 'HasTriangleTagValues',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbHasTriangleValues' )),
    COMMETHOD(['propget', helpstring(u'The collection of attribute items of the TIN.')], HRESULT, 'Fields',
              ( ['retval', 'out'], POINTER(POINTER(IFields)), 'Fields' )),
]
################################################################
## code template for ITin implementation
##class ITin_Impl(object):
##    @property
##    def IsDelaunay(self):
##        u'Indicates if TIN was constructed using Delaunay triangulation.'
##        #return pbIsEmpty
##
##    def _get(self):
##        u'Multiplication factor applied to all z values in a TIN to provide unit-congruency between coordinate components.'
##        #return pFactor
##    def _set(self, pFactor):
##        u'Multiplication factor applied to all z values in a TIN to provide unit-congruency between coordinate components.'
##    ZFactor = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def HasNodeTagValues(self):
##        u'Indicates if the TIN dataset has node tag values.'
##        #return pbHasNodeValues
##
##    def SaveAs(self, newName, pOverWrite):
##        u'Saves the TIN to disk using the specified name.'
##        #return 
##
##    @property
##    def Fields(self):
##        u'The collection of attribute items of the TIN.'
##        #return Fields
##
##    @property
##    def HasTriangleTagValues(self):
##        u'Indicates if the TIN dataset has triangle tag values.'
##        #return pbHasTriangleValues
##
##    @property
##    def HasEdgeTagValues(self):
##        u'Indicates if the TIN dataset has edge tag values.'
##        #return pbHasEdgeValues
##
##    @property
##    def DataTriangleCount(self):
##        u'The number of data triangles in the TIN.'
##        #return pcTriangles
##
##    @property
##    def Version(self):
##        u'Returns the version number of the TIN engine used to build the TIN.'
##        #return pVer
##
##    @property
##    def DataNodeCount(self):
##        u'The number of data nodes in the TIN.'
##        #return pcNodes
##
##    @property
##    def Extent(self):
##        u'The interpolation zone of the TIN.'
##        #return ppExtent
##
##    @property
##    def DataEdgeCount(self):
##        u'The number of TIN edges that have a data triangle on one side or the other.'
##        #return pcEdges
##
##    @property
##    def IsEmpty(self):
##        u'Indicates if the TIN contains no data.'
##        #return pbIsEmpty
##

class ISurface(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IFunctionalSurface):
    _case_insensitive_ = True
    u'Provides access to members that control surfaces.'
    _iid_ = GUID('{73B80FBC-FF33-11D1-A549-0000F8774F0F}')
    _idlflags_ = []
class IEnumTinNode(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control TIN node enumerators.'
    _iid_ = GUID('{6BFA889C-BF0D-11D3-AB4F-0008C73FD50C}')
    _idlflags_ = []
class IEnumTinEdge(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control TIN edge enumerators.'
    _iid_ = GUID('{6BFA889D-BF0D-11D3-AB4F-0008C73FD50C}')
    _idlflags_ = []
class IEnumTinTriangle(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control TIN triangle enumerators.'
    _iid_ = GUID('{6BFA889E-BF0D-11D3-AB4F-0008C73FD50C}')
    _idlflags_ = []
class ITinTriangleArray(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control simple arrays of TIN triangles.'
    _iid_ = GUID('{C0E04942-B08C-11D2-9F6A-00C04F8ECE27}')
    _idlflags_ = ['oleautomation']
class ITinPolyline(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control TIN polyline characteristics.'
    _iid_ = GUID('{83A9E75C-A212-11D3-AB4B-0008C73FD50C}')
    _idlflags_ = ['oleautomation']
class ITinPolygon(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control TIN polygon characteristics.'
    _iid_ = GUID('{ADDDA5CA-A214-11D3-AB4B-0008C73FD50C}')
    _idlflags_ = ['oleautomation']
class ITinDynamicFilter(ITinFilter):
    _case_insensitive_ = True
    u'Provides access to members that control TIN dynamic filtering options.'
    _iid_ = GUID('{0122C788-FD32-11D3-A0D6-00C04F8ECE27}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriTinElementType'
esriTinNode = 0
esriTinEdge = 1
esriTinTriangle = 2
esriTinElementType = c_int # enum
ITinAdvanced._methods_ = [
    COMMETHOD(['propget', helpstring(u'The process cancellation on TIN methods.')], HRESULT, 'TrackCancel',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITrackCancel)), 'ppTrackCancle' )),
    COMMETHOD(['propputref', helpstring(u'The process cancellation on TIN methods.')], HRESULT, 'TrackCancel',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITrackCancel), 'ppTrackCancle' )),
    COMMETHOD(['propget', helpstring(u'Indicates if a process has been cancelled.')], HRESULT, 'ProcessCancelled',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbCancelled' )),
    COMMETHOD(['propput', helpstring(u'Indicates if a process has been cancelled.')], HRESULT, 'ProcessCancelled',
              ( ['in'], VARIANT_BOOL, 'pbCancelled' )),
    COMMETHOD(['propget', helpstring(u'The ISurface interface (convenient tool for chaining in VB).')], HRESULT, 'Surface',
              ( ['retval', 'out'], POINTER(POINTER(ISurface)), 'ppSurface' )),
    COMMETHOD([helpstring(u'Uninitializes the TIN.')], HRESULT, 'SetEmpty'),
    COMMETHOD([helpstring(u'Opens the specified TIN.')], HRESULT, 'Init',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propput', helpstring(u'The user-defined flag for the TIN.')], HRESULT, 'Flag',
              ( ['in'], c_int, 'pFlag' )),
    COMMETHOD(['propget', helpstring(u'The user-defined flag for the TIN.')], HRESULT, 'Flag',
              ( ['retval', 'out'], POINTER(c_int), 'pFlag' )),
    COMMETHOD(['propget', helpstring(u'The full 2D-extent of the TIN including NODATA nodes.')], HRESULT, 'FullExtent',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'ppExtent' )),
    COMMETHOD(['hidden', helpstring(u'The full extent of the TIN based on the super nodes.'), 'propget'], HRESULT, 'SuperNodeExtent',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'ppExtent' )),
    COMMETHOD([helpstring(u"Indicates if the passed value is equal to the TIN's void value.")], HRESULT, 'IsVoidZ',
              ( ['in'], c_double, 'Value' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsVoid' )),
    COMMETHOD([helpstring(u'Makes a node enumerator based on the extent of the envelope.')], HRESULT, 'MakeNodeEnumerator',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'pAreaOfInterest' ),
              ( ['in'], c_int, 'Criteria' ),
              ( ['in'], POINTER(ITinFilter), 'pFilter' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumTinNode)), 'ppEnumerator' )),
    COMMETHOD([helpstring(u'Makes an edge enumerator based on the extent of the envelope.')], HRESULT, 'MakeEdgeEnumerator',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'pAreaOfInterest' ),
              ( ['in'], c_int, 'Criteria' ),
              ( ['in'], POINTER(ITinFilter), 'pFilter' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumTinEdge)), 'ppEnumerator' )),
    COMMETHOD([helpstring(u'Makes a triangle enumerator based on the extent of the envelope.')], HRESULT, 'MakeTriangleEnumerator',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'pAreaOfInterest' ),
              ( ['in'], c_int, 'Criteria' ),
              ( ['in'], POINTER(ITinFilter), 'pFilter' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumTinTriangle)), 'ppEnumerator' )),
    COMMETHOD(['propget', helpstring(u'The total number of nodes in the TIN.')], HRESULT, 'NodeCount',
              ( ['retval', 'out'], POINTER(c_int), 'pcNodes' )),
    COMMETHOD([helpstring(u'The node referenced by the specified index.')], HRESULT, 'GetNode',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinNode)), 'ppNode' )),
    COMMETHOD([helpstring(u'Queries the node equal to that specified by the index.')], HRESULT, 'QueryNode',
              ( ['in'], c_int, 'Index' ),
              ( [], POINTER(ITinNode), 'pNode' )),
    COMMETHOD([helpstring(u'Queries the point equal to that specified by the index.')], HRESULT, 'QueryNodeAsPoint',
              ( ['in'], c_int, 'Index' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' )),
    COMMETHOD([helpstring(u'Queries the point equal to that specified by the index.')], HRESULT, 'QueryNodeAsWKSPointZ',
              ( ['in'], c_int, 'Index' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPoint' )),
    COMMETHOD([helpstring(u'The z value of the node referenced by the index.')], HRESULT, 'GetNodeZ',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(c_double), 'pZ' )),
    COMMETHOD([helpstring(u'The tag value of the node referenced by the index.')], HRESULT, 'GetNodeTagValue',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(c_int), 'pValue' )),
    COMMETHOD(['propget', helpstring(u'The total number of edges in the TIN.')], HRESULT, 'EdgeCount',
              ( ['retval', 'out'], POINTER(c_int), 'pcEdges' )),
    COMMETHOD([helpstring(u'The edge referenced by the index.')], HRESULT, 'GetEdge',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinEdge)), 'ppEdge' )),
    COMMETHOD([helpstring(u'The edge equal to that referenced by the index.')], HRESULT, 'QueryEdge',
              ( ['in'], c_int, 'Index' ),
              ( [], POINTER(ITinEdge), 'pEdge' )),
    COMMETHOD([helpstring(u'The line equal to the edge referenced by the index.')], HRESULT, 'QueryEdgeAsLine',
              ( ['in'], c_int, 'Index' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ILine), 'pLine' )),
    COMMETHOD([helpstring(u'The points equal to the end points of the edge referenced by the index.')], HRESULT, 'QueryEdgeAsWKSPointZs',
              ( ['in'], c_int, 'Index' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pFrom' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pTo' )),
    COMMETHOD([helpstring(u'The tag value of the edge referenced by the index.')], HRESULT, 'GetEdgeTagValue',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(c_int), 'pValue' )),
    COMMETHOD([helpstring(u"Gets the specified edge's type.")], HRESULT, 'GetEdgeType',
              ( ['in'], c_int, 'edgeIndex' ),
              ( ['out'], POINTER(esriTinEdgeType), 'pType' )),
    COMMETHOD(['propget', helpstring(u'The total number of triangles in the TIN.')], HRESULT, 'TriangleCount',
              ( ['retval', 'out'], POINTER(c_int), 'pcTriangles' )),
    COMMETHOD([helpstring(u'The triangle referenced by the index.')], HRESULT, 'GetTriangle',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinTriangle)), 'ppTriangle' )),
    COMMETHOD([helpstring(u'The triangle equal to that referenced by the index.')], HRESULT, 'QueryTriangle',
              ( ['in'], c_int, 'Index' ),
              ( [], POINTER(ITinTriangle), 'pTriangle' )),
    COMMETHOD([helpstring(u'The ring equal to the triangle referenced by the index.')], HRESULT, 'QueryTriangleAsRing',
              ( ['in'], c_int, 'Index' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IRing), 'pRing' )),
    COMMETHOD([helpstring(u'Queries the points equal to the nodes of the triangle referenced by the index.')], HRESULT, 'QueryTriangleAsWKSPointZs',
              ( ['in'], c_int, 'Index' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPi' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPj' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPk' )),
    COMMETHOD([helpstring(u'The tag value of the triangle referenced by the index.')], HRESULT, 'GetTriangleTagValue',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(c_int), 'pValue' )),
    COMMETHOD([helpstring(u'Finds and returns the nearest node to the query point.')], HRESULT, 'QueryNearestNode',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( [], POINTER(ITinNode), 'pNode' ),
              ( [], POINTER(c_double), 'pDistance' )),
    COMMETHOD([helpstring(u'Finds and returns the nearest edge to the query point.')], HRESULT, 'QueryNearestEdge',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( [], POINTER(ITinEdge), 'pEdge' ),
              ( [], POINTER(c_double), 'pDistance' )),
    COMMETHOD([helpstring(u'The triangle at the specified location.')], HRESULT, 'FindTriangle',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinTriangle)), 'ppTriangle' )),
    COMMETHOD([helpstring(u'Returns the immediate surrounding nodes to the query point.')], HRESULT, 'FindNaturalNeighbors',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinNodeArray)), 'ppNodes' )),
    COMMETHOD([helpstring(u'Returns all triangles whose circumscribed circle contains the query point.')], HRESULT, 'FindTriangleNeighborhood',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinTriangleArray)), 'ppTriangles' )),
    COMMETHOD([helpstring(u'Returns a polyline definition based on triangle edges that meet the same filter criteria.')], HRESULT, 'ExtractPolyline',
              ( ['in'], POINTER(ITinEdge), 'pSeed' ),
              ( ['in'], POINTER(ITinFilter), 'pFilter' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinPolyline)), 'ppPolyline' )),
    COMMETHOD([helpstring(u'Returns a polygon definition based on all contiguous triangles having the same filter criteria.')], HRESULT, 'ExtractPolygon',
              ( ['in'], POINTER(ITinElement), 'pSeed' ),
              ( ['in'], POINTER(ITinFilter), 'pFilter' ),
              ( ['in'], VARIANT_BOOL, 'bStopAtEnforcedEdge' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinPolygon)), 'ppPolygon' )),
    COMMETHOD([helpstring(u'Returns one triangle representing each polygon defined by the filter criteria of the TIN.')], HRESULT, 'GetTriangleSeeds',
              ( ['in'], POINTER(ITinDynamicFilter), 'pFilter' ),
              ( ['in'], VARIANT_BOOL, 'bStopAtEnforcedEdge' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumTinTriangle)), 'ppTriangles' )),
    COMMETHOD([helpstring(u'Converts similar triangles to a polygon feature class.')], HRESULT, 'ConvertToPolygons',
              ( [], POINTER(IFeatureClass), 'pFeatureClass' ),
              ( ['in'], POINTER(ITinDynamicFilter), 'pFilter' ),
              ( ['in'], VARIANT_BOOL, 'bStopAtEnforcedEdge' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pFieldName' )),
    COMMETHOD([helpstring(u'Returns a polygon representing the data area of the TIN.')], HRESULT, 'GetDataArea',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon)), 'ppArea' )),
    COMMETHOD(['propget', helpstring(u'The number of unique tag values for the specified element type.')], HRESULT, 'UniqueTagValueCount',
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['retval', 'out'], POINTER(c_int), 'pCount' )),
    COMMETHOD([helpstring(u'Returns unique tag values for the specified element type.')], HRESULT, 'GetUniqueTagValues',
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray)), 'ppValues' )),
    COMMETHOD([helpstring(u'Returns a new, previously unused tag value for the element.')], HRESULT, 'GenerateUniqueTagValue',
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['retval', 'out'], POINTER(c_int), 'pValue' )),
]
################################################################
## code template for ITinAdvanced implementation
##class ITinAdvanced_Impl(object):
##    def FindTriangle(self, pPoint):
##        u'The triangle at the specified location.'
##        #return ppTriangle
##
##    @property
##    def EdgeCount(self):
##        u'The total number of edges in the TIN.'
##        #return pcEdges
##
##    def GetDataArea(self):
##        u'Returns a polygon representing the data area of the TIN.'
##        #return ppArea
##
##    def ExtractPolyline(self, pSeed, pFilter):
##        u'Returns a polyline definition based on triangle edges that meet the same filter criteria.'
##        #return ppPolyline
##
##    def QueryTriangle(self, Index, pTriangle):
##        u'The triangle equal to that referenced by the index.'
##        #return 
##
##    def GetTriangleTagValue(self, Index):
##        u'The tag value of the triangle referenced by the index.'
##        #return pValue
##
##    def QueryNodeAsPoint(self, Index, pPoint):
##        u'Queries the point equal to that specified by the index.'
##        #return 
##
##    def ConvertToPolygons(self, pFeatureClass, pFilter, bStopAtEnforcedEdge, pFieldName):
##        u'Converts similar triangles to a polygon feature class.'
##        #return 
##
##    def QueryNode(self, Index, pNode):
##        u'Queries the node equal to that specified by the index.'
##        #return 
##
##    def GetNodeZ(self, Index):
##        u'The z value of the node referenced by the index.'
##        #return pZ
##
##    def QueryNodeAsWKSPointZ(self, Index):
##        u'Queries the point equal to that specified by the index.'
##        #return pPoint
##
##    def QueryNearestNode(self, pPoint, pNode, pDistance):
##        u'Finds and returns the nearest node to the query point.'
##        #return 
##
##    def GetNode(self, Index):
##        u'The node referenced by the specified index.'
##        #return ppNode
##
##    def TrackCancel(self, ppTrackCancle):
##        u'The process cancellation on TIN methods.'
##        #return 
##
##    def GetEdgeType(self, edgeIndex):
##        u"Gets the specified edge's type."
##        #return pType
##
##    def MakeTriangleEnumerator(self, pAreaOfInterest, Criteria, pFilter):
##        u'Makes a triangle enumerator based on the extent of the envelope.'
##        #return ppEnumerator
##
##    def GetEdgeTagValue(self, Index):
##        u'The tag value of the edge referenced by the index.'
##        #return pValue
##
##    def GetNodeTagValue(self, Index):
##        u'The tag value of the node referenced by the index.'
##        #return pValue
##
##    def GetTriangleSeeds(self, pFilter, bStopAtEnforcedEdge):
##        u'Returns one triangle representing each polygon defined by the filter criteria of the TIN.'
##        #return ppTriangles
##
##    def QueryNearestEdge(self, pPoint, pEdge, pDistance):
##        u'Finds and returns the nearest edge to the query point.'
##        #return 
##
##    def _get(self):
##        u'The user-defined flag for the TIN.'
##        #return pFlag
##    def _set(self, pFlag):
##        u'The user-defined flag for the TIN.'
##    Flag = property(_get, _set, doc = _set.__doc__)
##
##    def SetEmpty(self):
##        u'Uninitializes the TIN.'
##        #return 
##
##    def ExtractPolygon(self, pSeed, pFilter, bStopAtEnforcedEdge):
##        u'Returns a polygon definition based on all contiguous triangles having the same filter criteria.'
##        #return ppPolygon
##
##    @property
##    def SuperNodeExtent(self):
##        u'The full extent of the TIN based on the super nodes.'
##        #return ppExtent
##
##    def GetUniqueTagValues(self, Type):
##        u'Returns unique tag values for the specified element type.'
##        #return ppValues
##
##    def QueryTriangleAsWKSPointZs(self, Index):
##        u'Queries the points equal to the nodes of the triangle referenced by the index.'
##        #return pPi, pPj, pPk
##
##    @property
##    def TriangleCount(self):
##        u'The total number of triangles in the TIN.'
##        #return pcTriangles
##
##    def QueryEdgeAsLine(self, Index, pLine):
##        u'The line equal to the edge referenced by the index.'
##        #return 
##
##    def _get(self):
##        u'Indicates if a process has been cancelled.'
##        #return pbCancelled
##    def _set(self, pbCancelled):
##        u'Indicates if a process has been cancelled.'
##    ProcessCancelled = property(_get, _set, doc = _set.__doc__)
##
##    def GetEdge(self, Index):
##        u'The edge referenced by the index.'
##        #return ppEdge
##
##    def GenerateUniqueTagValue(self, Type):
##        u'Returns a new, previously unused tag value for the element.'
##        #return pValue
##
##    def MakeEdgeEnumerator(self, pAreaOfInterest, Criteria, pFilter):
##        u'Makes an edge enumerator based on the extent of the envelope.'
##        #return ppEnumerator
##
##    def FindTriangleNeighborhood(self, pPoint):
##        u'Returns all triangles whose circumscribed circle contains the query point.'
##        #return ppTriangles
##
##    @property
##    def UniqueTagValueCount(self, Type):
##        u'The number of unique tag values for the specified element type.'
##        #return pCount
##
##    def FindNaturalNeighbors(self, pPoint):
##        u'Returns the immediate surrounding nodes to the query point.'
##        #return ppNodes
##
##    def QueryEdge(self, Index, pEdge):
##        u'The edge equal to that referenced by the index.'
##        #return 
##
##    def Init(self, Name):
##        u'Opens the specified TIN.'
##        #return 
##
##    @property
##    def Surface(self):
##        u'The ISurface interface (convenient tool for chaining in VB).'
##        #return ppSurface
##
##    def QueryTriangleAsRing(self, Index, pRing):
##        u'The ring equal to the triangle referenced by the index.'
##        #return 
##
##    def GetTriangle(self, Index):
##        u'The triangle referenced by the index.'
##        #return ppTriangle
##
##    @property
##    def NodeCount(self):
##        u'The total number of nodes in the TIN.'
##        #return pcNodes
##
##    @property
##    def FullExtent(self):
##        u'The full 2D-extent of the TIN including NODATA nodes.'
##        #return ppExtent
##
##    def MakeNodeEnumerator(self, pAreaOfInterest, Criteria, pFilter):
##        u'Makes a node enumerator based on the extent of the envelope.'
##        #return ppEnumerator
##
##    def QueryEdgeAsWKSPointZs(self, Index):
##        u'The points equal to the end points of the edge referenced by the index.'
##        #return pFrom, pTo
##
##    def IsVoidZ(self, Value):
##        u"Indicates if the passed value is equal to the TIN's void value."
##        #return pbIsVoid
##


# values for enumeration 'esriGeodatabaseServerClassType'
esriServerClassUnknown = 0
esriServerClassPersonal = 1
esriServerClassWorkgroup = 2
esriServerClassEnterprise = 3
esriGeodatabaseServerClassType = c_int # enum

# values for enumeration 'esriNetworkFeatureAncillaryRole'
esriNFARNone = 0
esriNFARSource = 1
esriNFARSink = 2
esriNetworkFeatureAncillaryRole = c_int # enum
class IRecordSet(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the rows or features in a recordset.'
    _iid_ = GUID('{4510A65B-ACD1-4046-B8B0-10F9D0DA673F}')
    _idlflags_ = ['oleautomation']
class ICursor(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that hand out enumerated rows, field collections and allows for the updating, deleting and inserting of rows.'
    _iid_ = GUID('{D4803EE7-79F4-11D0-97FC-0080C7F79481}')
    _idlflags_ = ['oleautomation']
class ITable(IClass):
    _case_insensitive_ = True
    u'Provides access to members that return information about and manage tables.'
    _iid_ = GUID('{FCB01CB5-9F0B-11D0-BEC7-00805F7C4268}')
    _idlflags_ = ['oleautomation']
IRecordSet._methods_ = [
    COMMETHOD(['propget', helpstring(u'The fields of the recordset.')], HRESULT, 'Fields',
              ( ['retval', 'out'], POINTER(POINTER(IFields)), 'FieldSet' )),
    COMMETHOD(['propget', helpstring(u'A cursor over the rows or features in the recordset.')], HRESULT, 'Cursor',
              ( ['in'], VARIANT_BOOL, 'Recycling' ),
              ( ['retval', 'out'], POINTER(POINTER(ICursor)), 'Cursor' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the recordset is a feature collection.')], HRESULT, 'IsFeatureCollection',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsFeatureCollection' )),
    COMMETHOD(['propget', helpstring(u'The source table or feature class for the recordset.')], HRESULT, 'Table',
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'Table' )),
]
################################################################
## code template for IRecordSet implementation
##class IRecordSet_Impl(object):
##    @property
##    def Cursor(self, Recycling):
##        u'A cursor over the rows or features in the recordset.'
##        #return Cursor
##
##    @property
##    def Fields(self):
##        u'The fields of the recordset.'
##        #return FieldSet
##
##    @property
##    def Table(self):
##        u'The source table or feature class for the recordset.'
##        #return Table
##
##    @property
##    def IsFeatureCollection(self):
##        u'Indicates if the recordset is a feature collection.'
##        #return IsFeatureCollection
##

class ITinEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control TIN editing.'
    _iid_ = GUID('{6615635A-BFAB-11D2-9F6D-00C04F8ECE27}')
    _idlflags_ = []

# values for enumeration 'esriTinSurfaceType'
esriTinContour = 0
esriTinHardLine = 1
esriTinHardClip = 2
esriTinHardErase = 3
esriTinHardReplace = 4
esriTinHardValueFill = 5
esriTinZLessHardLine = 6
esriTinZLessHardClip = 7
esriTinZLessHardErase = 8
esriTinSoftLine = 9
esriTinSoftClip = 10
esriTinSoftErase = 11
esriTinSoftReplace = 12
esriTinSoftValueFill = 13
esriTinZLessSoftLine = 14
esriTinZLessContour = 15
esriTinZLessSoftClip = 16
esriTinZLessSoftErase = 17
esriTinMassPoint = 18
esriTinSurfaceType = c_int # enum
class IField(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about the field.'
    _iid_ = GUID('{FCB01CB3-9F0B-11D0-BEC7-00805F7C4268}')
    _idlflags_ = ['oleautomation']
class IFeatureCursor(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that hand out enumerated features, field collections and allows for the updating, deleting and inserting of features.'
    _iid_ = GUID('{D4803EF8-79F4-11D0-97FC-0080C7F79481}')
    _idlflags_ = ['oleautomation']
ITinEdit._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the TIN can be edited.')], HRESULT, 'IsEditable',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsEditable' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the TIN is in edit mode.')], HRESULT, 'IsInEditMode',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsInEditMode' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the TIN is dirty.')], HRESULT, 'IsDirty',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsDirty' )),
    COMMETHOD([helpstring(u'Initiates edit mode.')], HRESULT, 'StartEditing',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsSuccessful' )),
    COMMETHOD([helpstring(u'Terminates edit mode, optionally saving changes to disk.')], HRESULT, 'StopEditing',
              ( ['in'], VARIANT_BOOL, 'bSaveEdits' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsSuccessful' )),
    COMMETHOD([helpstring(u'Initializes a new TIN using the passed extent to define the data area.')], HRESULT, 'InitNew',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'pExtent' )),
    COMMETHOD([helpstring(u'Saves edits to disk.')], HRESULT, 'Save'),
    COMMETHOD([helpstring(u'Saves the TIN to disk using the specified name.')], HRESULT, 'SaveAs',
              ( ['in'], BSTR, 'newName' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pOverWrite' )),
    COMMETHOD([helpstring(u'Adds a well known structure point to the TIN.')], HRESULT, 'AddWKSPointZ',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPoint' ),
              ( ['in'], c_int, 'vlue' ),
              ( ['retval', 'out'], POINTER(c_int), 'pNodeIndex' )),
    COMMETHOD([helpstring(u'Adds a 3D point to the TIN.')], HRESULT, 'AddPointZ',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( ['in'], c_int, 'TagValue' ),
              ( ['retval', 'out'], POINTER(c_int), 'pNodeIndex' )),
    COMMETHOD([helpstring(u'Adds a 3D shape to the TIN.')], HRESULT, 'AddShapeZ',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pShape' ),
              ( ['in'], esriTinSurfaceType, 'Type' ),
              ( ['in'], c_int, 'TagValue' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pbUseShapeZ' )),
    COMMETHOD([helpstring(u'Adds a 2D shape to the TIN.')], HRESULT, 'AddShape',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pShape' ),
              ( ['in'], esriTinSurfaceType, 'Type' ),
              ( ['in'], c_int, 'TagValue' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pZ' )),
    COMMETHOD([helpstring(u'Adds features from a feature class to the TIN.')], HRESULT, 'AddFromFeatureClass',
              ( ['in'], POINTER(IFeatureClass), 'pFeatureClass' ),
              ( ['in'], POINTER(IQueryFilter), 'pFilter' ),
              ( ['in'], POINTER(IField), 'pHeightField' ),
              ( ['in'], POINTER(IField), 'pTagValueField' ),
              ( ['in'], esriTinSurfaceType, 'Type' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pbUseShapeZ' )),
    COMMETHOD([helpstring(u'Adds features from a feature cursor to the TIN.')], HRESULT, 'AddFromFeatureCursor',
              ( ['in'], POINTER(IFeatureCursor), 'pCursor' ),
              ( ['in'], POINTER(IField), 'pHeightField' ),
              ( ['in'], POINTER(IField), 'pTagValueField' ),
              ( ['in'], esriTinSurfaceType, 'Type' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pbUseShapeZ' )),
    COMMETHOD([helpstring(u'Adds pixels from a pixel block to the TIN.')], HRESULT, 'AddFromPixelBlock',
              ( ['in'], c_double, 'xOrigin' ),
              ( ['in'], c_double, 'yOrigin' ),
              ( ['in'], c_double, 'xPixelSize' ),
              ( ['in'], c_double, 'yPixelSize' ),
              ( ['in'], VARIANT, 'valueForNoData' ),
              ( ['in'], VARIANT, 'block' ),
              ( ['in'], c_double, 'ZTolerance' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pMaxPoints' ),
              ( ['out', 'optional'], POINTER(VARIANT), 'pbToleranceAchieved' )),
    COMMETHOD([helpstring(u'Deletes a specified node from the TIN.')], HRESULT, 'DeleteNode',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD([helpstring(u'Deletes specified nodes from the TIN.')], HRESULT, 'DeleteSelectedNodes'),
    COMMETHOD([helpstring(u'Deletes all nodes from outside the TIN interpolation zone.')], HRESULT, 'DeleteNodesOutsideDataArea'),
    COMMETHOD([helpstring(u'Sets the type of the triangle edge referenced by the TIN.')], HRESULT, 'SetEdgeType',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], esriTinEdgeType, 'Type' )),
    COMMETHOD([helpstring(u'Sets the z value of a TIN node referenced by the index.')], HRESULT, 'SetNodeZ',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], c_double, 'Z' )),
    COMMETHOD([helpstring(u'Sets the tag value of a TIN node referenced by the index.')], HRESULT, 'SetNodeTagValue',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], c_int, 'Value' )),
    COMMETHOD([helpstring(u'Sets the tag value of the triangle edge referenced by the index.')], HRESULT, 'SetEdgeTagValue',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], c_int, 'Value' )),
    COMMETHOD([helpstring(u'Sets the face tag value of the triangle referenced by the index.')], HRESULT, 'SetTriangleTagValue',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], c_int, 'Value' )),
    COMMETHOD([helpstring(u'Propagates triangle tag value changes to all immediate triangles with the same initial value.')], HRESULT, 'PropagateTriangleTagValue',
              ( ['in'], POINTER(ITinTriangle), 'pSeed' ),
              ( ['in'], c_int, 'newTagValue' ),
              ( ['in'], VARIANT_BOOL, 'bStopAtEnforcedEdge' )),
    COMMETHOD([helpstring(u'Sets all triangles within the TIN interpolation zone.')], HRESULT, 'SetTrianglesInsideDataArea'),
    COMMETHOD([helpstring(u'Sets a triangle within the TIN interpolation zone.')], HRESULT, 'SetTriangleInsideDataArea',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD([helpstring(u'Sets a triangle outside of the TIN interpolation zone.')], HRESULT, 'SetTriangleOutsideDataArea',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD([helpstring(u'Deletes all node tag values in the TIN.')], HRESULT, 'DeleteNodeTagValues'),
    COMMETHOD([helpstring(u'Deletes all edge tag values in the TIN.')], HRESULT, 'DeleteEdgeTagValues'),
    COMMETHOD([helpstring(u'Deletes all triangle face tag values in the TIN.')], HRESULT, 'DeleteTriangleTagValues'),
    COMMETHOD([helpstring(u"Updates TIN's extents, data area, and data elements count.")], HRESULT, 'Refresh'),
    COMMETHOD([helpstring(u'Set a copy of the specified spatial reference to the TIN.')], HRESULT, 'SetSpatialReference',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'pSpatialReference' )),
]
################################################################
## code template for ITinEdit implementation
##class ITinEdit_Impl(object):
##    @property
##    def IsInEditMode(self):
##        u'Indicates if the TIN is in edit mode.'
##        #return pbIsInEditMode
##
##    def SetEdgeType(self, Index, Type):
##        u'Sets the type of the triangle edge referenced by the TIN.'
##        #return 
##
##    def AddFromPixelBlock(self, xOrigin, yOrigin, xPixelSize, yPixelSize, valueForNoData, block, ZTolerance, pMaxPoints):
##        u'Adds pixels from a pixel block to the TIN.'
##        #return pbToleranceAchieved
##
##    def SetTriangleOutsideDataArea(self, Index):
##        u'Sets a triangle outside of the TIN interpolation zone.'
##        #return 
##
##    def SetSpatialReference(self, pSpatialReference):
##        u'Set a copy of the specified spatial reference to the TIN.'
##        #return 
##
##    def SetTriangleInsideDataArea(self, Index):
##        u'Sets a triangle within the TIN interpolation zone.'
##        #return 
##
##    def SetTrianglesInsideDataArea(self):
##        u'Sets all triangles within the TIN interpolation zone.'
##        #return 
##
##    def AddFromFeatureClass(self, pFeatureClass, pFilter, pHeightField, pTagValueField, Type, pbUseShapeZ):
##        u'Adds features from a feature class to the TIN.'
##        #return 
##
##    def Save(self):
##        u'Saves edits to disk.'
##        #return 
##
##    def DeleteNodesOutsideDataArea(self):
##        u'Deletes all nodes from outside the TIN interpolation zone.'
##        #return 
##
##    def SetNodeZ(self, Index, Z):
##        u'Sets the z value of a TIN node referenced by the index.'
##        #return 
##
##    def SetTriangleTagValue(self, Index, Value):
##        u'Sets the face tag value of the triangle referenced by the index.'
##        #return 
##
##    def DeleteSelectedNodes(self):
##        u'Deletes specified nodes from the TIN.'
##        #return 
##
##    def AddPointZ(self, pPoint, TagValue):
##        u'Adds a 3D point to the TIN.'
##        #return pNodeIndex
##
##    def PropagateTriangleTagValue(self, pSeed, newTagValue, bStopAtEnforcedEdge):
##        u'Propagates triangle tag value changes to all immediate triangles with the same initial value.'
##        #return 
##
##    def AddShape(self, pShape, Type, TagValue, pZ):
##        u'Adds a 2D shape to the TIN.'
##        #return 
##
##    def AddWKSPointZ(self, pPoint, vlue):
##        u'Adds a well known structure point to the TIN.'
##        #return pNodeIndex
##
##    def Refresh(self):
##        u"Updates TIN's extents, data area, and data elements count."
##        #return 
##
##    def AddShapeZ(self, pShape, Type, TagValue, pbUseShapeZ):
##        u'Adds a 3D shape to the TIN.'
##        #return 
##
##    def SetNodeTagValue(self, Index, Value):
##        u'Sets the tag value of a TIN node referenced by the index.'
##        #return 
##
##    def DeleteTriangleTagValues(self):
##        u'Deletes all triangle face tag values in the TIN.'
##        #return 
##
##    def DeleteEdgeTagValues(self):
##        u'Deletes all edge tag values in the TIN.'
##        #return 
##
##    @property
##    def IsDirty(self):
##        u'Indicates if the TIN is dirty.'
##        #return pbIsDirty
##
##    def AddFromFeatureCursor(self, pCursor, pHeightField, pTagValueField, Type, pbUseShapeZ):
##        u'Adds features from a feature cursor to the TIN.'
##        #return 
##
##    def SaveAs(self, newName, pOverWrite):
##        u'Saves the TIN to disk using the specified name.'
##        #return 
##
##    def DeleteNode(self, Index):
##        u'Deletes a specified node from the TIN.'
##        #return 
##
##    @property
##    def IsEditable(self):
##        u'Indicates if the TIN can be edited.'
##        #return pbIsEditable
##
##    def StartEditing(self):
##        u'Initiates edit mode.'
##        #return pbIsSuccessful
##
##    def StopEditing(self, bSaveEdits):
##        u'Terminates edit mode, optionally saving changes to disk.'
##        #return pbIsSuccessful
##
##    def InitNew(self, pExtent):
##        u'Initializes a new TIN using the passed extent to define the data area.'
##        #return 
##
##    def DeleteNodeTagValues(self):
##        u'Deletes all node tag values in the TIN.'
##        #return 
##
##    def SetEdgeTagValue(self, Index, Value):
##        u'Sets the tag value of the triangle edge referenced by the index.'
##        #return 
##


# values for enumeration 'esriRasterStorage'
esriRasterStorageBinary = 0
esriRasterStorageLOB = 1
esriRasterStorageST = 2
esriRasterStorageSDO = 3
esriRasterStorage = c_int # enum
class FGDCSynchronizationHelper(CoClass):
    u'FGDC Synchronization Helper.'
    _reg_clsid_ = GUID('{7002C8B6-1D00-11D3-A63B-0008C7D3AE50}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ISynchronizationHelper(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to helper functions for metadata synchronization.'
    _iid_ = GUID('{7002C8B5-1D00-11D3-A63B-0008C7D3AE50}')
    _idlflags_ = ['oleautomation']
FGDCSynchronizationHelper._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ISynchronizationHelper]

class IWorkspaceDomains(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about domains and allows you to add or delete domains.'
    _iid_ = GUID('{D80957F0-8883-11D2-AABB-00C04FA37B82}')
    _idlflags_ = ['oleautomation']
class IEnumDomain(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through domains.'
    _iid_ = GUID('{8917197E-8884-11D2-AABB-00C04FA37B82}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriFieldType'
esriFieldTypeSmallInteger = 0
esriFieldTypeInteger = 1
esriFieldTypeSingle = 2
esriFieldTypeDouble = 3
esriFieldTypeString = 4
esriFieldTypeDate = 5
esriFieldTypeOID = 6
esriFieldTypeGeometry = 7
esriFieldTypeBlob = 8
esriFieldTypeRaster = 9
esriFieldTypeGUID = 10
esriFieldTypeGlobalID = 11
esriFieldTypeXML = 12
esriFieldType = c_int # enum
IWorkspaceDomains._methods_ = [
    COMMETHOD([helpstring(u'Adds the given domain to the workspace.')], HRESULT, 'AddDomain',
              ( ['in'], POINTER(IDomain), 'Domain' ),
              ( ['retval', 'out'], POINTER(c_int), 'DomainID' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the user can delete the domain.')], HRESULT, 'CanDeleteDomain',
              ( ['in'], BSTR, 'DomainName' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'deletable' )),
    COMMETHOD([helpstring(u'Deletes the given domain from the workspace.')], HRESULT, 'DeleteDomain',
              ( ['in'], BSTR, 'DomainName' )),
    COMMETHOD(['propget', helpstring(u'All the domains in the workspace.')], HRESULT, 'Domains',
              ( ['retval', 'out'], POINTER(POINTER(IEnumDomain)), 'Domains' )),
    COMMETHOD(['propget', helpstring(u'The domain with the given name from the workspace.')], HRESULT, 'DomainByName',
              ( ['in'], BSTR, 'DomainName' ),
              ( ['retval', 'out'], POINTER(POINTER(IDomain)), 'Domain' )),
    COMMETHOD(['propget', helpstring(u'The domain with the given name from the workspace.')], HRESULT, 'DomainsByFieldType',
              ( ['in'], esriFieldType, 'Type' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumDomain)), 'Domains' )),
]
################################################################
## code template for IWorkspaceDomains implementation
##class IWorkspaceDomains_Impl(object):
##    def AddDomain(self, Domain):
##        u'Adds the given domain to the workspace.'
##        #return DomainID
##
##    @property
##    def DomainByName(self, DomainName):
##        u'The domain with the given name from the workspace.'
##        #return Domain
##
##    @property
##    def Domains(self):
##        u'All the domains in the workspace.'
##        #return Domains
##
##    def DeleteDomain(self, DomainName):
##        u'Deletes the given domain from the workspace.'
##        #return 
##
##    @property
##    def CanDeleteDomain(self, DomainName):
##        u'Indicates if the user can delete the domain.'
##        #return deletable
##
##    @property
##    def DomainsByFieldType(self, Type):
##        u'The domain with the given name from the workspace.'
##        #return Domains
##


# values for enumeration 'esriGeometryStorage'
esriGeometryStorageBinary = 0
esriGeometryStorageLOB = 1
esriGeometryStorageWKB = 2
esriGeometryStorageST = 3
esriGeometryStorageSDO = 4
esriGeometryStoragePostGIS = 5
esriGeometryStorageMSSQLGeometry = 6
esriGeometryStorageMSSQLGeography = 7
esriGeometryStorage = c_int # enum
class IFeatureWorkspaceManage(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to dataset deletion and renaming, table and index analysis, field validation and version and object class registration .'
    _iid_ = GUID('{FF866B9F-6F94-11D3-80E5-00C04F686238}')
    _idlflags_ = ['oleautomation']
IFeatureWorkspaceManage._methods_ = [
    COMMETHOD([helpstring(u"Deletes an object by it's name.")], HRESULT, 'DeleteByName',
              ( ['in'], POINTER(IDatasetName), 'aName' )),
    COMMETHOD([helpstring(u'Checks if an object is registered as versioned.')], HRESULT, 'IsRegisteredAsVersioned',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'aName' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isRegistered' )),
    COMMETHOD([helpstring(u'Checks if an object is registered as an object class.')], HRESULT, 'IsRegisteredAsObjectClass',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isRegistered' )),
    COMMETHOD([helpstring(u'Checks if an object can be deleted.')], HRESULT, 'CanDelete',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'aName' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanDelete' )),
    COMMETHOD([helpstring(u'Checks if an object can be renamed.')], HRESULT, 'CanRename',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'aName' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanRename' )),
    COMMETHOD([helpstring(u'Analyze the table to generate DBMS statistics.')], HRESULT, 'AnalyzeTable',
              ( ['in'], BSTR, 'TableName' ),
              ( ['in'], c_int, 'tableComponents' )),
    COMMETHOD([helpstring(u'Analyze the index to generate DBMS statistics.')], HRESULT, 'AnalyzeIndex',
              ( ['in'], BSTR, 'TableName' ),
              ( ['in'], BSTR, 'Index' )),
    COMMETHOD([helpstring(u'Validate a field, performing type conversion if necessary.')], HRESULT, 'ValidateField',
              ( ['in'], POINTER(IField), 'inField' ),
              ( ['retval', 'out'], POINTER(POINTER(IField)), 'outField' )),
]
################################################################
## code template for IFeatureWorkspaceManage implementation
##class IFeatureWorkspaceManage_Impl(object):
##    def IsRegisteredAsVersioned(self, aName):
##        u'Checks if an object is registered as versioned.'
##        #return isRegistered
##
##    def ValidateField(self, inField):
##        u'Validate a field, performing type conversion if necessary.'
##        #return outField
##
##    def AnalyzeTable(self, TableName, tableComponents):
##        u'Analyze the table to generate DBMS statistics.'
##        #return 
##
##    def CanDelete(self, aName):
##        u'Checks if an object can be deleted.'
##        #return CanDelete
##
##    def AnalyzeIndex(self, TableName, Index):
##        u'Analyze the index to generate DBMS statistics.'
##        #return 
##
##    def IsRegisteredAsObjectClass(self, Name):
##        u'Checks if an object is registered as an object class.'
##        #return isRegistered
##
##    def DeleteByName(self, aName):
##        u"Deletes an object by it's name."
##        #return 
##
##    def CanRename(self, aName):
##        u'Checks if an object can be renamed.'
##        #return CanRename
##


# values for enumeration 'esriPlaneReferenceType'
esriPlaneReferenceAbove = 0
esriPlaneReferenceBelow = 1
esriPlaneReferenceType = c_int # enum

# values for enumeration 'esriSurfaceConversionType'
esriDegreeSlope = 0
esriPercentageSlope = 1
esriDegreeAspect = 2
esriSurfaceConversionType = c_int # enum

# values for enumeration 'esriRasterizationType'
esriDegreeSlopeAsRaster = 0
esriPercentageSlopeAsRaster = 1
esriDegreeAspectAsRaster = 2
esriElevationAsRaster = 3
esriHillShadeAsRaster = 4
esriRasterizationType = c_int # enum
ISurface._methods_ = [
    COMMETHOD(['propget', helpstring(u'Multiplication factor applied to all z values to provide unit-congruency between coordinate components.')], HRESULT, 'ZFactor',
              ( ['retval', 'out'], POINTER(c_double), 'pFactor' )),
    COMMETHOD(['propput', helpstring(u'Multiplication factor applied to all z values to provide unit-congruency between coordinate components.')], HRESULT, 'ZFactor',
              ( ['in'], c_double, 'pFactor' )),
    COMMETHOD([helpstring(u'Returns the projected area of the surface above or below an input z value.')], HRESULT, 'GetProjectedArea',
              ( ['in'], c_double, 'referenceHeight' ),
              ( ['in'], esriPlaneReferenceType, 'Type' ),
              ( ['retval', 'out'], POINTER(c_double), 'pArea' )),
    COMMETHOD([helpstring(u'Returns the area measured on its surface above or below an input z value.')], HRESULT, 'GetSurfaceArea',
              ( ['in'], c_double, 'referenceHeight' ),
              ( ['in'], esriPlaneReferenceType, 'Type' ),
              ( ['retval', 'out'], POINTER(c_double), 'pArea' )),
    COMMETHOD([helpstring(u'Returns the volume above or below an input z value.')], HRESULT, 'GetVolume',
              ( ['in'], c_double, 'reference' ),
              ( ['in'], esriPlaneReferenceType, 'Type' ),
              ( ['retval', 'out'], POINTER(c_double), 'pVolume' )),
    COMMETHOD([helpstring(u'Returns the vector normal to the specified triangle.')], HRESULT, 'QueryNormal',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pLocation' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IVector3D), 'pNormal' )),
    COMMETHOD(['restricted', helpstring(u'Returns the normal vector to the specified location.')], HRESULT, 'GetNormal',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pLocation' ),
              ( ['retval', 'out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pNormal' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'FindNormal',
              ( ['in'], c_double, 'X' ),
              ( ['in'], c_double, 'Y' ),
              ( ['retval', 'out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pNormal' )),
    COMMETHOD([helpstring(u'Returns the z value of the specified location.')], HRESULT, 'GetElevation',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( ['retval', 'out'], POINTER(c_double), 'pElevation' )),
    COMMETHOD([helpstring(u'Returns the slope at the specified location in degrees.')], HRESULT, 'GetSlopeDegrees',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( ['retval', 'out'], POINTER(c_double), 'pSlope' )),
    COMMETHOD([helpstring(u'Returns the slope at the specified location in radians.')], HRESULT, 'GetSlopeRadians',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( ['retval', 'out'], POINTER(c_double), 'pSlope' )),
    COMMETHOD([helpstring(u'Returns the slope at the specified location in percent.')], HRESULT, 'GetSlopePercent',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( ['retval', 'out'], POINTER(c_double), 'pSlope' )),
    COMMETHOD([helpstring(u'Returns the aspect at the specified location in degrees.')], HRESULT, 'GetAspectDegrees',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( ['retval', 'out'], POINTER(c_double), 'pAspect' )),
    COMMETHOD([helpstring(u'Returns the aspect at the specified location in radians.')], HRESULT, 'GetAspectRadians',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( ['retval', 'out'], POINTER(c_double), 'pAspect' )),
    COMMETHOD([helpstring(u"Returns TRUE if the passed value is equal to the surface's void value.")], HRESULT, 'IsVoidZ',
              ( ['in'], c_double, 'Value' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsVoid' )),
    COMMETHOD([helpstring(u'Interpolates z values for a defined geometric shape.')], HRESULT, 'InterpolateShape',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pShape' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'ppOutShape' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pStepSize' )),
    COMMETHOD([helpstring(u'Interpolates z values for a defined geometric shape at its vertices only.')], HRESULT, 'InterpolateShapeVertices',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pShape' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'ppOutShape' )),
    COMMETHOD([helpstring(u'Returns a polyline with z values interpolated from the surface.')], HRESULT, 'GetProfile',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pShape' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'ppProfile' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pStepSize' )),
    COMMETHOD(['restricted', helpstring(u'Indicates if earth curvature can be applied.'), 'propget'], HRESULT, 'CanDoCurvature',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbCanDo' )),
    COMMETHOD([helpstring(u'Computes the visibility of a line-of-sight from the observer to the target.')], HRESULT, 'GetLineOfSight',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pObserver' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pTarget' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint)), 'ppObstruction' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolyline)), 'ppVisibleLines' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolyline)), 'ppInvisibleLines' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'pbIsVisible' ),
              ( ['in'], VARIANT_BOOL, 'bApplyCurvature' ),
              ( ['in'], VARIANT_BOOL, 'bApplyRefraction' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pRefractionFactor' )),
    COMMETHOD([helpstring(u'Returns the length of an input polyline measured on the surface.')], HRESULT, 'QuerySurfaceLength',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pShape' ),
              ( ['out'], POINTER(c_double), 'pLength' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pStepSize' )),
    COMMETHOD([helpstring(u'Returns the intersection of the query ray and the surface.')], HRESULT, 'Locate',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IRay), 'pRay' ),
              ( ['in'], c_int, 'hint' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint)), 'ppLocation' )),
    COMMETHOD([helpstring(u'Returns the distances of intersections of the query ray and the surface.')], HRESULT, 'LocateAll',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IRay), 'pRay' ),
              ( ['in'], c_int, 'hint' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDoubleArray)), 'ppDistances' )),
    COMMETHOD([helpstring(u'Returns a countour passing through the queried point.')], HRESULT, 'GetContour',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolyline)), 'ppContour' ),
              ( ['out'], POINTER(c_double), 'pElevation' )),
    COMMETHOD([helpstring(u'Output a list of contours corresponding to the specified eleveation values.')], HRESULT, 'ContourList',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDoubleArray), 'pBreaks' ),
              ( [], POINTER(IFeatureClass), 'pFeatureClass' ),
              ( ['in'], BSTR, 'FieldName' ),
              ( ['in'], c_int, 'digitsAfterDecimalPoint' )),
    COMMETHOD([helpstring(u'Output contours based on the specified root value and interval.')], HRESULT, 'Contour',
              ( ['in'], c_double, 'referenceContourHeight' ),
              ( ['in'], c_double, 'interval' ),
              ( [], POINTER(IFeatureClass), 'pFeatureClass' ),
              ( ['in'], BSTR, 'FieldName' ),
              ( ['in'], c_int, 'digitsAfterDecimalPoint' )),
    COMMETHOD([helpstring(u'Converts the surface to a polygon feature class representing slope or aspect.')], HRESULT, 'AsPolygons',
              ( [], POINTER(IFeatureClass), 'pFeatureClass' ),
              ( ['in'], esriSurfaceConversionType, 'Type' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDoubleArray), 'pClassBreaks' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'pClassCodes' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'FieldName' )),
    COMMETHOD([helpstring(u'Returns the steepest path downhill from the specified point.')], HRESULT, 'GetSteepestPath',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolyline)), 'ppPath' )),
    COMMETHOD([helpstring(u'Derives slope, aspect, hillshade, or elevation from the input surface and writes the result to the provided PixelBlock.')], HRESULT, 'QueryPixelBlock',
              ( ['in'], c_double, 'xOrigin' ),
              ( ['in'], c_double, 'yOrigin' ),
              ( ['in'], c_double, 'xPixelSize' ),
              ( ['in'], c_double, 'yPixelSize' ),
              ( ['in'], esriRasterizationType, 'Type' ),
              ( ['in'], VARIANT, 'valueForNoData' ),
              ( ['in'], VARIANT, 'block' )),
]
################################################################
## code template for ISurface implementation
##class ISurface_Impl(object):
##    def GetProfile(self, pShape, pStepSize):
##        u'Returns a polyline with z values interpolated from the surface.'
##        #return ppProfile
##
##    def GetNormal(self, pLocation):
##        u'Returns the normal vector to the specified location.'
##        #return pNormal
##
##    def GetSlopePercent(self, pPoint):
##        u'Returns the slope at the specified location in percent.'
##        #return pSlope
##
##    def GetSlopeDegrees(self, pPoint):
##        u'Returns the slope at the specified location in degrees.'
##        #return pSlope
##
##    def Locate(self, pRay, hint):
##        u'Returns the intersection of the query ray and the surface.'
##        #return ppLocation
##
##    def GetVolume(self, reference, Type):
##        u'Returns the volume above or below an input z value.'
##        #return pVolume
##
##    def ContourList(self, pBreaks, pFeatureClass, FieldName, digitsAfterDecimalPoint):
##        u'Output a list of contours corresponding to the specified eleveation values.'
##        #return 
##
##    def QueryPixelBlock(self, xOrigin, yOrigin, xPixelSize, yPixelSize, Type, valueForNoData, block):
##        u'Derives slope, aspect, hillshade, or elevation from the input surface and writes the result to the provided PixelBlock.'
##        #return 
##
##    def _get(self):
##        u'Multiplication factor applied to all z values to provide unit-congruency between coordinate components.'
##        #return pFactor
##    def _set(self, pFactor):
##        u'Multiplication factor applied to all z values to provide unit-congruency between coordinate components.'
##    ZFactor = property(_get, _set, doc = _set.__doc__)
##
##    def QuerySurfaceLength(self, pShape, pStepSize):
##        u'Returns the length of an input polyline measured on the surface.'
##        #return pLength
##
##    def InterpolateShape(self, pShape, pStepSize):
##        u'Interpolates z values for a defined geometric shape.'
##        #return ppOutShape
##
##    def LocateAll(self, pRay, hint):
##        u'Returns the distances of intersections of the query ray and the surface.'
##        #return ppDistances
##
##    @property
##    def CanDoCurvature(self):
##        u'Indicates if earth curvature can be applied.'
##        #return pbCanDo
##
##    def GetSteepestPath(self, pPoint):
##        u'Returns the steepest path downhill from the specified point.'
##        #return ppPath
##
##    def InterpolateShapeVertices(self, pShape):
##        u'Interpolates z values for a defined geometric shape at its vertices only.'
##        #return ppOutShape
##
##    def GetAspectDegrees(self, pPoint):
##        u'Returns the aspect at the specified location in degrees.'
##        #return pAspect
##
##    def AsPolygons(self, pFeatureClass, Type, pClassBreaks, pClassCodes, FieldName):
##        u'Converts the surface to a polygon feature class representing slope or aspect.'
##        #return 
##
##    def FindNormal(self, X, Y):
##        u'Restricted.'
##        #return pNormal
##
##    def GetSlopeRadians(self, pPoint):
##        u'Returns the slope at the specified location in radians.'
##        #return pSlope
##
##    def GetProjectedArea(self, referenceHeight, Type):
##        u'Returns the projected area of the surface above or below an input z value.'
##        #return pArea
##
##    def GetElevation(self, pPoint):
##        u'Returns the z value of the specified location.'
##        #return pElevation
##
##    def GetSurfaceArea(self, referenceHeight, Type):
##        u'Returns the area measured on its surface above or below an input z value.'
##        #return pArea
##
##    def GetContour(self, pPoint):
##        u'Returns a countour passing through the queried point.'
##        #return ppContour, pElevation
##
##    def GetAspectRadians(self, pPoint):
##        u'Returns the aspect at the specified location in radians.'
##        #return pAspect
##
##    def GetLineOfSight(self, pObserver, pTarget, bApplyCurvature, bApplyRefraction, pRefractionFactor):
##        u'Computes the visibility of a line-of-sight from the observer to the target.'
##        #return ppObstruction, ppVisibleLines, ppInvisibleLines, pbIsVisible
##
##    def QueryNormal(self, pLocation, pNormal):
##        u'Returns the vector normal to the specified triangle.'
##        #return 
##
##    def Contour(self, referenceContourHeight, interval, pFeatureClass, FieldName, digitsAfterDecimalPoint):
##        u'Output contours based on the specified root value and interval.'
##        #return 
##
##    def IsVoidZ(self, Value):
##        u"Returns TRUE if the passed value is equal to the surface's void value."
##        #return pbIsVoid
##


# values for enumeration 'esriGeoDatabaseServerMessageCode'
esriGeoDatabaseServerMessageCode_ErrorMessage = 102000
esriGeoDatabaseServerMessageCode_WarningMessage = 102001
esriGeoDatabaseServerMessageCode_InfoMessage = 102002
esriGeoDatabaseServerMessageCode_DebugMessage = 102003
esriGeoDatabaseServerMessageCode = c_int # enum

# values for enumeration 'esriTransformType'
esriTTMove = 1
esriTTStretch = 2
esriTTRotate = 3
esriTTProgrammatic = 4
esriTransformType = c_int # enum
class IFeatureClassStorage(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe the storage characteristics of a feature class.'
    _iid_ = GUID('{380423DF-2032-4FD0-A4ED-05A76A3C17B8}')
    _idlflags_ = ['oleautomation']
class IFeatureClassStorage2(IFeatureClassStorage):
    _case_insensitive_ = True
    u'Provides access to members that describe the storage characteristics of a feature class.'
    _iid_ = GUID('{8D6276DB-496E-46D9-A6E4-65144514C309}')
    _idlflags_ = ['oleautomation']
IFeatureClassStorage._methods_ = [
    COMMETHOD(['propget', helpstring(u'Retrieves the geometry field storage.')], HRESULT, 'GeometryStorage',
              ( ['retval', 'out'], POINTER(esriGeometryStorage), 'GeometryStorage' )),
]
################################################################
## code template for IFeatureClassStorage implementation
##class IFeatureClassStorage_Impl(object):
##    @property
##    def GeometryStorage(self):
##        u'Retrieves the geometry field storage.'
##        #return GeometryStorage
##

IFeatureClassStorage2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Retrieves the raster field storage.')], HRESULT, 'RasterStorage',
              ( ['retval', 'out'], POINTER(esriRasterStorage), 'RasterStorage' )),
]
################################################################
## code template for IFeatureClassStorage2 implementation
##class IFeatureClassStorage2_Impl(object):
##    @property
##    def RasterStorage(self):
##        u'Retrieves the raster field storage.'
##        #return RasterStorage
##

class FIDSet(CoClass):
    u'Esri FID Set object.'
    _reg_clsid_ = GUID('{D79BDAF0-CAA8-11D2-B2BE-0000F878229E}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
FIDSet._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IFIDSet, IFIDSet2, IFIDSetOperator, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class QueryFilter(CoClass):
    u'Esri Query Filter object.'
    _reg_clsid_ = GUID('{FDFEBD95-ED75-11D0-9A95-080009EC734B}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IQueryFilter2(IQueryFilter):
    _case_insensitive_ = True
    u'Provides access to members that return and modify the output spatial resolution.'
    _iid_ = GUID('{E5B21410-17A6-11D4-9F4B-00C04F79927C}')
    _idlflags_ = ['oleautomation']
class IQueryFilterDefinition(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to query filter definition properties.'
    _iid_ = GUID('{90F3C7CA-30D5-454B-AB33-FB869991EDFE}')
    _idlflags_ = ['oleautomation']
class IQueryFilterDefinition2(IQueryFilterDefinition):
    _case_insensitive_ = True
    u'Provides access to query filter definition properties.'
    _iid_ = GUID('{45096447-06FF-4E5E-A260-9213E009AF29}')
    _idlflags_ = ['oleautomation']
QueryFilter._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IQueryFilter, IQueryFilter2, IQueryFilterDefinition, IQueryFilterDefinition2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize]

class IRecordSet2(IRecordSet):
    _case_insensitive_ = True
    u'Provides access to the rows or features in a recordset.'
    _iid_ = GUID('{2D6CB9CC-C6A0-437F-A431-9C9B7FDC4862}')
    _idlflags_ = ['oleautomation']
IRecordSet2._methods_ = [
    COMMETHOD([helpstring(u'Saves the recordset to a table of feature class in the provided workspace.')], HRESULT, 'SaveAsTable',
              ( ['in'], POINTER(IWorkspace), 'Workspace' ),
              ( ['in'], BSTR, 'TableName' ),
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'Table' )),
    COMMETHOD([helpstring(u'Detach Recordset from table and apply the subfield of QueryFilter.')], HRESULT, 'DetachTable'),
]
################################################################
## code template for IRecordSet2 implementation
##class IRecordSet2_Impl(object):
##    def DetachTable(self):
##        u'Detach Recordset from table and apply the subfield of QueryFilter.'
##        #return 
##
##    def SaveAsTable(self, Workspace, TableName):
##        u'Saves the recordset to a table of feature class in the provided workspace.'
##        #return Table
##

class IGUIDGenerator(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a GUID generator.'
    _iid_ = GUID('{2F489AA7-6566-4051-9554-8F831211C2D9}')
    _idlflags_ = ['oleautomation']
IGUIDGenerator._methods_ = [
    COMMETHOD([helpstring(u'Create a Global Unique Identifier.')], HRESULT, 'CreateGUID',
              ( ['retval', 'out'], POINTER(BSTR), 'GUID' )),
    COMMETHOD([helpstring(u'Validates the format of a Global Unique Identifier.')], HRESULT, 'ValidateGUID',
              ( ['in'], BSTR, 'GUID' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isValidFormat' )),
]
################################################################
## code template for IGUIDGenerator implementation
##class IGUIDGenerator_Impl(object):
##    def CreateGUID(self):
##        u'Create a Global Unique Identifier.'
##        #return GUID
##
##    def ValidateGUID(self, GUID):
##        u'Validates the format of a Global Unique Identifier.'
##        #return isValidFormat
##

class SQLCheck(CoClass):
    u'Esri Sql check object.'
    _reg_clsid_ = GUID('{7A236D41-AE55-462F-8D50-C1411DF68E5F}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ISQLCheck(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that check a SQL statement for invalid characters.'
    _iid_ = GUID('{78482309-3ABF-4556-925E-9A5F79CD6ED8}')
    _idlflags_ = ['oleautomation']
SQLCheck._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ISQLCheck]

class INetElements(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that convert between user IDs and network element IDs (EIDs).'
    _iid_ = GUID('{5DB91DB3-AFB4-11D0-9CCD-00805F74D243}')
    _idlflags_ = ['oleautomation']
class IEnumNetEID(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that iterate through an enumeration of network element IDs (EIDs).'
    _iid_ = GUID('{5DB91DB4-AFB4-11D0-9CCD-00805F74D243}')
    _idlflags_ = ['oleautomation']
INetElements._methods_ = [
    COMMETHOD([helpstring(u'Returns whether the specified element is part of the network.')], HRESULT, 'IsValidElement',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], esriElementType, 'ElementType' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'validState' )),
    COMMETHOD([helpstring(u'Returns the network element ID (EID).')], HRESULT, 'GetEID',
              ( ['in'], c_int, 'UserClassID' ),
              ( ['in'], c_int, 'UserID' ),
              ( ['in'], c_int, 'UserSubID' ),
              ( ['in'], esriElementType, 'ElementType' ),
              ( ['retval', 'out'], POINTER(c_int), 'EID' )),
    COMMETHOD([helpstring(u'Returns the number of network element IDs (EIDs) corresponding to the specified user class ID and user ID.')], HRESULT, 'GetEIDCount',
              ( ['in'], c_int, 'UserClassID' ),
              ( ['in'], c_int, 'UserID' ),
              ( ['in'], esriElementType, 'ElementType' ),
              ( ['retval', 'out'], POINTER(c_int), 'eIDCount' )),
    COMMETHOD([helpstring(u'Returns the network element IDs (EIDs) corresponding to the specified user classID and user ID.')], HRESULT, 'GetEIDs',
              ( ['in'], c_int, 'UserClassID' ),
              ( ['in'], c_int, 'UserID' ),
              ( ['in'], esriElementType, 'ElementType' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumNetEID)), 'EIDs' )),
    COMMETHOD([helpstring(u'Returns the user class ID, user ID, and user sub ID for the specified network element.')], HRESULT, 'QueryIDs',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], esriElementType, 'ElementType' ),
              ( ['out'], POINTER(c_int), 'UserClassID' ),
              ( ['out'], POINTER(c_int), 'UserID' ),
              ( ['out'], POINTER(c_int), 'UserSubID' )),
]
################################################################
## code template for INetElements implementation
##class INetElements_Impl(object):
##    def IsValidElement(self, EID, ElementType):
##        u'Returns whether the specified element is part of the network.'
##        #return validState
##
##    def GetEIDCount(self, UserClassID, UserID, ElementType):
##        u'Returns the number of network element IDs (EIDs) corresponding to the specified user class ID and user ID.'
##        #return eIDCount
##
##    def GetEIDs(self, UserClassID, UserID, ElementType):
##        u'Returns the network element IDs (EIDs) corresponding to the specified user classID and user ID.'
##        #return EIDs
##
##    def GetEID(self, UserClassID, UserID, UserSubID, ElementType):
##        u'Returns the network element ID (EID).'
##        #return EID
##
##    def QueryIDs(self, EID, ElementType):
##        u'Returns the user class ID, user ID, and user sub ID for the specified network element.'
##        #return UserClassID, UserID, UserSubID
##

class IEventSource(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to event source properties.'
    _iid_ = GUID('{59E43823-7F5A-11D4-9FE6-00C04F6BDF06}')
    _idlflags_ = ['oleautomation']
IEventSource._methods_ = [
]
################################################################
## code template for IEventSource implementation
##class IEventSource_Impl(object):


# values for enumeration 'esriRuleType'
esriRTAttribute = 1
esriRTEdgeConnectivity = 2
esriRTJunctionConnectivity = 3
esriRTSpatial = 4
esriRTRelationship = 5
esriRTTopology = 6
esriRuleType = c_int # enum
IRule._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name associated with the validation rule.')], HRESULT, 'Category',
              ( ['retval', 'out'], POINTER(c_int), 'groupBitmap' )),
    COMMETHOD(['propput', helpstring(u'The name associated with the validation rule.')], HRESULT, 'Category',
              ( ['in'], c_int, 'groupBitmap' )),
    COMMETHOD(['propget', helpstring(u'The helpstring associated with the validation rule.')], HRESULT, 'Helpstring',
              ( ['retval', 'out'], POINTER(BSTR), 'Helpstring' )),
    COMMETHOD(['propput', helpstring(u'The helpstring associated with the validation rule.')], HRESULT, 'Helpstring',
              ( ['in'], BSTR, 'Helpstring' )),
    COMMETHOD(['hidden', helpstring(u'The ID of the validation rule.'), 'propget'], HRESULT, 'ID',
              ( ['retval', 'out'], POINTER(c_int), 'ID' )),
    COMMETHOD(['hidden', helpstring(u'The ID of the validation rule.'), 'propput'], HRESULT, 'ID',
              ( ['in'], c_int, 'ID' )),
    COMMETHOD(['propget', helpstring(u'The type associated with the validation rule.')], HRESULT, 'Type',
              ( ['retval', 'out'], POINTER(esriRuleType), 'Type' )),
]
################################################################
## code template for IRule implementation
##class IRule_Impl(object):
##    def _get(self):
##        u'The name associated with the validation rule.'
##        #return groupBitmap
##    def _set(self, groupBitmap):
##        u'The name associated with the validation rule.'
##    Category = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The helpstring associated with the validation rule.'
##        #return Helpstring
##    def _set(self, Helpstring):
##        u'The helpstring associated with the validation rule.'
##    Helpstring = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def Type(self):
##        u'The type associated with the validation rule.'
##        #return Type
##
##    def _get(self):
##        u'The ID of the validation rule.'
##        #return ID
##    def _set(self, ID):
##        u'The ID of the validation rule.'
##    ID = property(_get, _set, doc = _set.__doc__)
##

class INetWeight(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that get information about the network weight described by this NetWeight object.'
    _iid_ = GUID('{027E7415-981B-11D1-B264-0000F878229E}')
    _idlflags_ = ['oleautomation']
class INetWeightEdit(INetWeight):
    _case_insensitive_ = True
    u'Provides access to members that set information for this NetWeight object.'
    _iid_ = GUID('{3EBBE030-557D-11D1-B254-0000F878229E}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriWeightType'
esriWTNull = 0
esriWTBitGate = 1
esriWTInteger = 2
esriWTSingle = 3
esriWTDouble = 4
esriWTBoolean = 5
esriWeightType = c_int # enum
INetWeight._methods_ = [
    COMMETHOD(['propget', helpstring(u'Name of the network weight described by this NetWeight object.')], HRESULT, 'WeightName',
              ( ['retval', 'out'], POINTER(BSTR), 'WeightName' )),
    COMMETHOD(['propget', helpstring(u'Type of network weight described by this NetWeight object.')], HRESULT, 'WeightType',
              ( ['retval', 'out'], POINTER(esriWeightType), 'WeightType' )),
    COMMETHOD(['propget', helpstring(u'Bit gate size of the network weight described by this NetWeight object.')], HRESULT, 'BitGateSize',
              ( ['retval', 'out'], POINTER(c_int), 'bigGateSize' )),
    COMMETHOD(['propget', helpstring(u'Internal ID of the network weight described by this NetWeight object.')], HRESULT, 'WeightID',
              ( ['retval', 'out'], POINTER(c_int), 'InternalID' )),
]
################################################################
## code template for INetWeight implementation
##class INetWeight_Impl(object):
##    @property
##    def WeightType(self):
##        u'Type of network weight described by this NetWeight object.'
##        #return WeightType
##
##    @property
##    def WeightName(self):
##        u'Name of the network weight described by this NetWeight object.'
##        #return WeightName
##
##    @property
##    def BitGateSize(self):
##        u'Bit gate size of the network weight described by this NetWeight object.'
##        #return bigGateSize
##
##    @property
##    def WeightID(self):
##        u'Internal ID of the network weight described by this NetWeight object.'
##        #return InternalID
##

INetWeightEdit._methods_ = [
    COMMETHOD(['propput', helpstring(u'Name of this NetWeight object.')], HRESULT, 'WeightName',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Type of network weight of this NetWeight object.')], HRESULT, 'WeightType',
              ( ['in'], esriWeightType, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Bit gate size of this NetWeight object.')], HRESULT, 'BitGateSize',
              ( ['in'], c_int, 'rhs' )),
]
################################################################
## code template for INetWeightEdit implementation
##class INetWeightEdit_Impl(object):
##    def _set(self, rhs):
##        u'Type of network weight of this NetWeight object.'
##    WeightType = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Name of this NetWeight object.'
##    WeightName = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Bit gate size of this NetWeight object.'
##    BitGateSize = property(fset = _set, doc = _set.__doc__)
##

class XMLFilterDef(CoClass):
    u'Esri XML Filter Definition object.'
    _reg_clsid_ = GUID('{47F975DB-77C0-4A8C-B8A0-8E9FE77A9795}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IXMLFilterDef(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to XML filter definition properties.'
    _iid_ = GUID('{0B308561-D65C-4256-9BF9-4363F7997F3B}')
    _idlflags_ = ['oleautomation']
class IFilterDef(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Indicator interface for filter definitions.'
    _iid_ = GUID('{8B67E76A-B7F8-4CDB-ACA2-B647581BD9EA}')
    _idlflags_ = ['oleautomation']
XMLFilterDef._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IXMLFilterDef, IFilterDef, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]


# values for enumeration 'rstResamplingTypes'
RSP_NearestNeighbor = 0
RSP_BilinearInterpolation = 1
RSP_CubicConvolution = 2
RSP_Majority = 3
RSP_BilinearInterpolationPlus = 4
RSP_BilinearGaussBlur = 5
RSP_BilinearGaussBlurPlus = 6
rstResamplingTypes = c_int # enum
class FilterDefs(CoClass):
    u'An array of filter definition objects.'
    _reg_clsid_ = GUID('{3131151A-4B5C-4526-98BE-711746B03DF8}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IFilterDefs(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to methods that control an array of filter definition objects.'
    _iid_ = GUID('{0FA04C6D-25BD-4FEE-B9E7-1146219B102D}')
    _idlflags_ = ['oleautomation']
FilterDefs._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IFilterDefs, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class GeometricNetwork(CoClass):
    u'Esri Geometric Network object.'
    _reg_clsid_ = GUID('{E30EADCA-5D47-11D1-AE5F-0000F80372B4}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDatasetEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to information about the status of datasets being edited.'
    _iid_ = GUID('{448C5D21-9746-11D1-89E2-006097AFF44E}')
    _idlflags_ = ['oleautomation']
class IGeoDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that provide information about a Geographic Dataset.'
    _iid_ = GUID('{34C20004-4D3C-11D0-92D8-00805F7C28B0}')
    _idlflags_ = ['oleautomation']
class INativeTypeInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the native type.'
    _iid_ = GUID('{906DB24A-F0AD-4CA5-871B-5466E54FAB80}')
    _idlflags_ = ['oleautomation']
class IFeatureClassContainer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return feature classes by name, ID and index.'
    _iid_ = GUID('{3B439634-CFC3-11D1-AEAD-0000F80372B4}')
    _idlflags_ = ['oleautomation']
class IGeometricNetworkErrorDetection(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage and provide geometric network error detection.'
    _iid_ = GUID('{8BF5C9A4-6D40-11D4-A0B4-00C04F6BDD84}')
    _idlflags_ = ['oleautomation']
class IGeometricNetworkConnectivity(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a member that rebuilds geometric network connectivity.'
    _iid_ = GUID('{3FC4DB86-64B4-11D4-A0AD-00C04F6BDD84}')
    _idlflags_ = ['oleautomation']
class IGeometricNetworkConnectivity2(IGeometricNetworkConnectivity):
    _case_insensitive_ = True
    u'Provides access to members that check and repair and rebuild connectivity.'
    _iid_ = GUID('{3942BF39-EFE9-4094-9089-BC41B459B384}')
    _idlflags_ = ['oleautomation']
class IGeometricNetworkReconcileProperties(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to properties that influence reconciliation.'
    _iid_ = GUID('{E775F490-DDBF-4710-965C-070BCCD1CEC4}')
    _idlflags_ = ['oleautomation']
class IMetadataEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that provide information about whether metadata can be edited.'
    _iid_ = GUID('{97FDB978-62A4-49C5-8252-B07837B33EE9}')
    _idlflags_ = ['oleautomation']
GeometricNetwork._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDataset, IDatasetEdit, IGeoDataset, INativeTypeInfo, ISchemaLock, IFeatureClassContainer, IGeometricNetwork, IGeometricNetworkErrorDetection, IGeometricNetworkConnectivity2, IGeometricNetworkReconcileProperties, IMetadata, IMetadataEdit, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

IGeoDataset._methods_ = [
    COMMETHOD(['propget', helpstring(u'The spatial reference of the GeoDataset.')], HRESULT, 'SpatialReference',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference)), 'spref' )),
    COMMETHOD(['propget', helpstring(u'The extent of the GeoDataset.')], HRESULT, 'Extent',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'Extent' )),
]
################################################################
## code template for IGeoDataset implementation
##class IGeoDataset_Impl(object):
##    @property
##    def Extent(self):
##        u'The extent of the GeoDataset.'
##        #return Extent
##
##    @property
##    def SpatialReference(self):
##        u'The spatial reference of the GeoDataset.'
##        #return spref
##


# values for enumeration 'esriRasterCompressionType'
esriRasterCompressionUnknown = -1
esriRasterCompressionUncompressed = 0
esriRasterCompressionLZ77 = 1
esriRasterCompressionJPEG = 2
esriRasterCompressionJPEG2000 = 4
esriRasterCompressionPackBits = 5
esriRasterCompressionLZW = 6
esriRasterCompressionRLE = 7
esriRasterCompressionCCITTG3 = 8
esriRasterCompressionCCITTG4 = 9
esriRasterCompressionCCITTRLE = 10
esriRasterCompressionJPEGYCbCr = 11
esriRasterCompressionType = c_int # enum
class IEnumRelationshipClassInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through the relationship classes.'
    _iid_ = GUID('{D3AD61AB-CADF-469E-8D7B-02483329A66D}')
    _idlflags_ = ['oleautomation']
IEnumRelationshipClassInfo._methods_ = [
    COMMETHOD([helpstring(u'Retreives the next relationship class in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IRelationshipClassInfo)), 'RelInfo' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumRelationshipClassInfo implementation
##class IEnumRelationshipClassInfo_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retreives the next relationship class in the enumeration sequence.'
##        #return RelInfo
##

class IRouteEventProperties(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the properties of an event table.'
    _iid_ = GUID('{35BDF2ED-3B21-11D4-9FCB-00C04F6BDF06}')
    _idlflags_ = ['oleautomation']
IRouteEventProperties._methods_ = [
    COMMETHOD(['propput', helpstring(u'The route identifier field name.')], HRESULT, 'EventRouteIDFieldName',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'The route identifier field name.')], HRESULT, 'EventRouteIDFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propput', helpstring(u'The units of the event measure(s).')], HRESULT, 'EventMeasureUnit',
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.esriUnits, 'Units' )),
    COMMETHOD(['propget', helpstring(u'The units of the event measure(s).')], HRESULT, 'EventMeasureUnit',
              ( ['retval', 'out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.esriUnits), 'Units' )),
    COMMETHOD(['propput', helpstring(u'The lateral offset field name.')], HRESULT, 'LateralOffsetFieldName',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'The lateral offset field name.')], HRESULT, 'LateralOffsetFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['hidden', helpstring(u'Is a line event.'), 'propget'], HRESULT, 'IsALineEvent',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'lineEvent' )),
    COMMETHOD(['hidden', helpstring(u'The state of the object (see if all the required field names have been set).')], HRESULT, 'GetSettingError'),
]
################################################################
## code template for IRouteEventProperties implementation
##class IRouteEventProperties_Impl(object):
##    def _get(self):
##        u'The route identifier field name.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The route identifier field name.'
##    EventRouteIDFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The units of the event measure(s).'
##        #return Units
##    def _set(self, Units):
##        u'The units of the event measure(s).'
##    EventMeasureUnit = property(_get, _set, doc = _set.__doc__)
##
##    def GetSettingError(self):
##        u'The state of the object (see if all the required field names have been set).'
##        #return 
##
##    @property
##    def IsALineEvent(self):
##        u'Is a line event.'
##        #return lineEvent
##
##    def _get(self):
##        u'The lateral offset field name.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The lateral offset field name.'
##    LateralOffsetFieldName = property(_get, _set, doc = _set.__doc__)
##

class TableSort(CoClass):
    u'Esri Table Sort object.'
    _reg_clsid_ = GUID('{2D0F935D-32F5-11D2-A06F-0000F8775BF9}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ITableSort(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return and modify information to sort a table.'
    _iid_ = GUID('{2D0F935E-32F5-11D2-A06F-0000F8775BF9}')
    _idlflags_ = ['oleautomation']
TableSort._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITableSort]

class ISystemJunctionSource(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of a network dataset source whose junction elements are generated automatically when the network is built.'
    _iid_ = GUID('{BA5FFB8B-06A4-4A95-B14D-AE71BB9A354E}')
    _idlflags_ = ['oleautomation']
ISystemJunctionSource._methods_ = [
    COMMETHOD(['propget', helpstring(u'The field name to be used as the elevation field when determining connectivity at coincident vertices.')], HRESULT, 'ElevationFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
]
################################################################
## code template for ISystemJunctionSource implementation
##class ISystemJunctionSource_Impl(object):
##    @property
##    def ElevationFieldName(self):
##        u'The field name to be used as the elevation field when determining connectivity at coincident vertices.'
##        #return Name
##

IRowBuffer._methods_ = [
    COMMETHOD(['propget', helpstring(u'The value of the field with the specified  index.')], HRESULT, 'Value',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The value of the field with the specified  index.')], HRESULT, 'Value',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], VARIANT, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The fields Collection for this row buffer.')], HRESULT, 'Fields',
              ( ['retval', 'out'], POINTER(POINTER(IFields)), 'Fields' )),
]
################################################################
## code template for IRowBuffer implementation
##class IRowBuffer_Impl(object):
##    @property
##    def Fields(self):
##        u'The fields Collection for this row buffer.'
##        #return Fields
##
##    def _get(self, Index):
##        u'The value of the field with the specified  index.'
##        #return Value
##    def _set(self, Index, Value):
##        u'The value of the field with the specified  index.'
##    Value = property(_get, _set, doc = _set.__doc__)
##

IRow._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the row has an OID.')], HRESULT, 'HasOID',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasOID' )),
    COMMETHOD(['propget', helpstring(u'The OID for the row.')], HRESULT, 'OID',
              ( ['retval', 'out'], POINTER(c_int), 'OID' )),
    COMMETHOD(['propget', helpstring(u'The Table for the row.')], HRESULT, 'Table',
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'Table' )),
    COMMETHOD([helpstring(u'Stores the row.')], HRESULT, 'Store'),
    COMMETHOD([helpstring(u'Deletes the row.')], HRESULT, 'Delete'),
]
################################################################
## code template for IRow implementation
##class IRow_Impl(object):
##    @property
##    def Table(self):
##        u'The Table for the row.'
##        #return Table
##
##    @property
##    def OID(self):
##        u'The OID for the row.'
##        #return OID
##
##    def Store(self):
##        u'Stores the row.'
##        #return 
##
##    @property
##    def HasOID(self):
##        u'Indicates if the row has an OID.'
##        #return HasOID
##
##    def Delete(self):
##        u'Deletes the row.'
##        #return 
##

IObject._methods_ = [
    COMMETHOD(['propget', helpstring(u'The Object Class for the row.')], HRESULT, 'Class',
              ( ['retval', 'out'], POINTER(POINTER(IObjectClass)), 'Table' )),
]
################################################################
## code template for IObject implementation
##class IObject_Impl(object):
##    @property
##    def Class(self):
##        u'The Object Class for the row.'
##        #return Table
##


# values for enumeration 'esriFeatureType'
esriFTSimple = 1
esriFTSimpleJunction = 7
esriFTSimpleEdge = 8
esriFTComplexJunction = 9
esriFTComplexEdge = 10
esriFTAnnotation = 11
esriFTCoverageAnnotation = 12
esriFTDimension = 13
esriFTRasterCatalogItem = 14
esriFeatureType = c_int # enum
IFeature._methods_ = [
    COMMETHOD(['propget', helpstring(u'A cloned copy of the default shape for the feature.')], HRESULT, 'ShapeCopy',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Shape' )),
    COMMETHOD(['propget', helpstring(u'A reference to the default shape for the feature.')], HRESULT, 'Shape',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Shape' )),
    COMMETHOD(['propputref', helpstring(u'A reference to the default shape for the feature.')], HRESULT, 'Shape',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'Shape' )),
    COMMETHOD(['propget', helpstring(u'The extent of the feature.')], HRESULT, 'Extent',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'Extent' )),
    COMMETHOD(['propget', helpstring(u'The type of the feature.')], HRESULT, 'FeatureType',
              ( ['retval', 'out'], POINTER(esriFeatureType), 'Type' )),
]
################################################################
## code template for IFeature implementation
##class IFeature_Impl(object):
##    @property
##    def FeatureType(self):
##        u'The type of the feature.'
##        #return Type
##
##    def Shape(self, Shape):
##        u'A reference to the default shape for the feature.'
##        #return 
##
##    @property
##    def ShapeCopy(self):
##        u'A cloned copy of the default shape for the feature.'
##        #return Shape
##
##    @property
##    def Extent(self):
##        u'The extent of the feature.'
##        #return Extent
##

class ComplexEdgeFeature(CoClass):
    u'Esri Complex edge geometric network feature object.'
    _reg_clsid_ = GUID('{A30E8A2A-C50B-11D1-AEA9-0000F80372B4}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IRowEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that occur when an object is modified, created or deleted.'
    _iid_ = GUID('{8C387320-12C6-11D2-AAD1-00C04FA37B81}')
    _idlflags_ = ['oleautomation']
class IRowSubtypes(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members to return and modify the subtype code and to initialize the default values.'
    _iid_ = GUID('{D3F18540-BF77-11D2-AAF2-00C04FA37B82}')
    _idlflags_ = ['oleautomation']
class IRowChanges(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about changed values and the original value in a row.'
    _iid_ = GUID('{022F7462-69FA-11D3-9FD0-00C04F6BDD84}')
    _idlflags_ = ['oleautomation']
class IRowCompare(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a member that compares two rows.'
    _iid_ = GUID('{7D3E2831-6C5A-11D3-8A98-000000000000}')
    _idlflags_ = ['oleautomation']
class IFeatureBuffer(IRowBuffer):
    _case_insensitive_ = True
    u'Provides access to setting and returning the default shape in the feature buffer.'
    _iid_ = GUID('{956A4E53-2482-11D1-89D8-006097AFF44E}')
    _idlflags_ = ['oleautomation']
class IFeatureEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that happen when a feature is split or merged.'
    _iid_ = GUID('{46097234-1224-11D2-AACF-00C04FA37B81}')
    _idlflags_ = ['oleautomation']
class IFeatureDraw(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control custom drawing by a feature.'
    _iid_ = GUID('{B0E8D294-3A9C-11D1-9AA1-080009EC734B}')
    _idlflags_ = ['oleautomation']
class INetworkFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that are common to all features in a GeometricNetwork.'
    _iid_ = GUID('{317E551C-55FC-11D1-AE55-0000F80372B4}')
    _idlflags_ = ['oleautomation']
class INetworkFeatureEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events for connecting and disconnecting network features.'
    _iid_ = GUID('{826B121A-14E9-11D2-AEF5-0000F80372B4}')
    _idlflags_ = ['oleautomation']
class IEdgeFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that modify and return information about an edge feature.'
    _iid_ = GUID('{84FBB0C8-EA84-11D1-AECC-0000F80372B4}')
    _idlflags_ = ['oleautomation']
class IComplexEdgeFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about a complex edge feature.'
    _iid_ = GUID('{66F783AE-EA1B-11D1-AA91-00C04FA37B81}')
    _idlflags_ = ['oleautomation']
class IComplexNetworkFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return and modify complex network features.'
    _iid_ = GUID('{6BD2B5C0-C503-11D1-AEA9-0000F80372B4}')
    _idlflags_ = ['oleautomation']
class IRowEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members implemented to customize object editing.'
    _iid_ = GUID('{192ADA11-33F1-11D3-9F6A-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
class IFeatureEdit(IRowEdit):
    _case_insensitive_ = True
    u'Provides access to members implemented to customize feature editing.'
    _iid_ = GUID('{33848E00-983B-11D1-8463-0000F875B9C6}')
    _idlflags_ = ['oleautomation']
class IFeatureEdit2(IFeatureEdit):
    _case_insensitive_ = True
    u'Provides access to members implemented to customize feature editing.'
    _iid_ = GUID('{2892CE6B-96D6-45D6-9002-7A6CC91968AD}')
    _idlflags_ = ['oleautomation']
class IFeatureSimplify(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to simplifying a feature's geometry."
    _iid_ = GUID('{10E6443F-FECB-11D3-9FA5-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
class IFeatureSimplify2(IFeatureSimplify):
    _case_insensitive_ = True
    u'Provides access to methods that extend IFeatureSimplify.'
    _iid_ = GUID('{0A9035F6-9E34-473D-BDFB-35663EA162B7}')
    _idlflags_ = ['oleautomation']
class IRelatedObjectEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that occur when related objects change, move or rotate.'
    _iid_ = GUID('{22B0069A-8895-11D2-8A0D-006097AFF44E}')
    _idlflags_ = ['oleautomation']
class IValidate(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members to validate individual features.'
    _iid_ = GUID('{80E4FF2C-475D-11D2-9932-0000F80372B4}')
    _idlflags_ = ['oleautomation']
class IFeatureProject(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to project a feature's geometry."
    _iid_ = GUID('{0AD74A92-B396-4819-AC73-BB6CCC5CA326}')
    _idlflags_ = ['oleautomation']
ComplexEdgeFeature._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRow, IRowBuffer, IRowEvents, IRowSubtypes, IRowChanges, IRowCompare, IFeature, IFeatureBuffer, IFeatureEvents, IFeatureChanges, IFeatureDraw, INetworkFeature, INetworkFeatureEvents, IEdgeFeature, IComplexEdgeFeature, IComplexNetworkFeature, IRowEdit, IFeatureEdit, IFeatureEdit2, IFeatureSimplify, IFeatureSimplify2, IRelatedObjectEvents, IValidate, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, IFeatureProject]

class IRecordArray(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{5CC3BC63-D6D3-4D98-A05B-30EEA9D23139}')
    _idlflags_ = ['oleautomation']
class IRecord(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{7FC39E06-D6F0-456D-B3F4-2AD431CC7ECF}')
    _idlflags_ = ['oleautomation']
IRecordArray._methods_ = [
    COMMETHOD(['propget', helpstring(u'The record count.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'Returns the record at the specified position.')], HRESULT, 'Element',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IRecord)), 'rec' )),
    COMMETHOD([helpstring(u'Removes the record at the specified position.')], HRESULT, 'Remove',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD([helpstring(u'Removes all records.')], HRESULT, 'RemoveAll'),
    COMMETHOD([helpstring(u'Adds a record.')], HRESULT, 'Add',
              ( ['in'], POINTER(IRecord), 'rec' )),
    COMMETHOD([helpstring(u'Adds a record at the specified position.')], HRESULT, 'Insert',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(IRecord), 'rec' )),
]
################################################################
## code template for IRecordArray implementation
##class IRecordArray_Impl(object):
##    @property
##    def Count(self):
##        u'The record count.'
##        #return Count
##
##    def Insert(self, Index, rec):
##        u'Adds a record at the specified position.'
##        #return 
##
##    def Remove(self, Index):
##        u'Removes the record at the specified position.'
##        #return 
##
##    @property
##    def Element(self, Index):
##        u'Returns the record at the specified position.'
##        #return rec
##
##    def RemoveAll(self):
##        u'Removes all records.'
##        #return 
##
##    def Add(self, rec):
##        u'Adds a record.'
##        #return 
##

class ITurnFeatureSource(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to an indicator interface for a network dataset source whose turn elements are derived from a turn feature class.'
    _iid_ = GUID('{BCA908AF-0118-41E5-A1E0-7E6EF003E2A8}')
    _idlflags_ = ['oleautomation']
ITurnFeatureSource._methods_ = [
]
################################################################
## code template for ITurnFeatureSource implementation
##class ITurnFeatureSource_Impl(object):

class ITinAdvanced2(ITinAdvanced):
    _case_insensitive_ = True
    u'Provides access to members that control advanced TIN functions.'
    _iid_ = GUID('{23FFD401-973F-11D5-8111-00C04FA0ADF8}')
    _idlflags_ = []

# values for enumeration 'esriTinNodeSourceType'
esriTinUnknown = 1
esriTinSuperNode = 2
esriTinOriginal = 4
esriTinDensified = 8
esriTinIntersection = 32
esriTinNodeSourceType = c_int # enum

# values for enumeration 'esriTinVersion'
esriTin70001 = 0
esriTin80001 = 1
esriTinVersion = c_int # enum
ITinAdvanced2._methods_ = [
    COMMETHOD([helpstring(u'Returns the source of the specified node.')], HRESULT, 'GetNodeSource',
              ( ['in'], c_int, 'nodeIndex' ),
              ( ['retval', 'out'], POINTER(esriTinNodeSourceType), 'pSource' )),
    COMMETHOD([helpstring(u'Returns the number of nodes with respect to different sources.')], HRESULT, 'GetNodeSourceCounts',
              ( ['out'], POINTER(c_int), 'pcOriginal' ),
              ( ['out'], POINTER(c_int), 'pcSuper' ),
              ( ['out'], POINTER(c_int), 'pcDensified' ),
              ( ['out'], POINTER(c_int), 'pcIntersection' ),
              ( ['out'], POINTER(c_int), 'pcUnknown' )),
    COMMETHOD([helpstring(u'Returns the degree of the specified node.')], HRESULT, 'GetNodeDegree',
              ( ['in'], c_int, 'nodeIndex' ),
              ( ['in'], VARIANT_BOOL, 'bEnforcedEdgesOnly' ),
              ( ['retval', 'out'], POINTER(c_int), 'pDegree' )),
    COMMETHOD([helpstring(u"Returns TRUE if the specified node is on domain's boundary.")], HRESULT, 'IsNodeOnDomainBoundary',
              ( ['in'], c_int, 'nodeIndex' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsOn' )),
    COMMETHOD([helpstring(u'Returns the total number of special edges in the TIN.')], HRESULT, 'GetSpecialEdgeCounts',
              ( ['out'], POINTER(c_int), 'pcHardDataEdges' ),
              ( ['out'], POINTER(c_int), 'pcSoftDataEdges' ),
              ( ['out'], POINTER(c_int), 'pcTagValueDataEdges' )),
    COMMETHOD([helpstring(u'Returns TRUE if the TIN contains the specified edge type.')], HRESULT, 'HasEdgeType',
              ( ['in'], esriTinEdgeType, 'Type' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbHasType' )),
    COMMETHOD([helpstring(u'Gets left triangle index of the specified edge.')], HRESULT, 'GetLeftTriangleIndex',
              ( ['in'], c_int, 'edgeIndex' ),
              ( ['retval', 'out'], POINTER(c_int), 'pTriangle' )),
    COMMETHOD([helpstring(u'Gets right triangle index of the specified edge.')], HRESULT, 'GetRightTriangleIndex',
              ( ['in'], c_int, 'edgeIndex' ),
              ( ['retval', 'out'], POINTER(c_int), 'pTriangle' )),
    COMMETHOD([helpstring(u'Gets begin and end nodes of the specified edge.')], HRESULT, 'QueryBeginEndNodeIndices',
              ( ['in'], c_int, 'edgeIndex' ),
              ( ['out'], POINTER(c_int), 'pBegin' ),
              ( ['out'], POINTER(c_int), 'pEnd' )),
    COMMETHOD([helpstring(u'Gets neighbor edge index.')], HRESULT, 'GetNeighborEdgeIndex',
              ( ['in'], c_int, 'edgeIndex' ),
              ( ['retval', 'out'], POINTER(c_int), 'pNeighbor' )),
    COMMETHOD([helpstring(u'Gets the three nodes of the specified triangle (clockwise).')], HRESULT, 'QueryTriangleNodeIndices',
              ( ['in'], c_int, 'triangleIndex' ),
              ( ['out'], POINTER(c_int), 'pA' ),
              ( ['out'], POINTER(c_int), 'pB' ),
              ( ['out'], POINTER(c_int), 'pC' )),
    COMMETHOD([helpstring(u'Gets the three edges of the specified triangle (clockwise).')], HRESULT, 'QueryTriangleEdgeIndices',
              ( ['in'], c_int, 'triangleIndex' ),
              ( ['out'], POINTER(c_int), 'pA' ),
              ( ['out'], POINTER(c_int), 'pB' ),
              ( ['out'], POINTER(c_int), 'pC' )),
    COMMETHOD([helpstring(u'Returns all nodes connected to the specified node.')], HRESULT, 'QueryNodeIndicesAroundNode',
              ( ['in'], c_int, 'nodeIndex' ),
              ( [], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'pNodes' )),
    COMMETHOD([helpstring(u'Returns all edges having the specified node as begin node.')], HRESULT, 'QueryEdgeIndicesAroundNode',
              ( ['in'], c_int, 'nodeIndex' ),
              ( [], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'pEdges' )),
    COMMETHOD([helpstring(u'Returns all edges connected to the specified node. If the last edge in the array has negative value, then its end node, instead of begin node, is the specified node.')], HRESULT, 'QueryAllEdgeIndicesAroundNode',
              ( ['in'], c_int, 'nodeIndex' ),
              ( [], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'pEdges' )),
    COMMETHOD([helpstring(u'Returns all triangles sharing the specified node.')], HRESULT, 'QueryTriangleIndicesAroundNode',
              ( ['in'], c_int, 'nodeIndex' ),
              ( [], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'pTriangles' )),
    COMMETHOD([helpstring(u'Returns all Natural Neighbors corresponding to the query point.')], HRESULT, 'QueryNaturalNeighborIndices',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( [], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'pNodes' )),
    COMMETHOD([helpstring(u'Returns all triangles whose circumscribed circle contains the query point.')], HRESULT, 'QueryTriangleNeighborhoodIndices',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( [], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'pTriangles' )),
    COMMETHOD([helpstring(u'Output the specified TIN element as Geometry object.')], HRESULT, 'QueryElementAsGeometry',
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['in'], c_int, 'Index' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pGeometry' )),
    COMMETHOD([helpstring(u'Returns natural neighbors and their weights corresponding to the query point.')], HRESULT, 'QueryNeighborsAndWeights',
              ( ['in'], c_double, 'X' ),
              ( ['in'], c_double, 'Y' ),
              ( [], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'pNeighbors' ),
              ( [], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDoubleArray), 'pWeights' )),
    COMMETHOD([helpstring(u'The triangle at the specified location.')], HRESULT, 'FindTriangleIndex',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( ['retval', 'out'], POINTER(c_int), 'pTriangle' )),
    COMMETHOD([helpstring(u'Returns TRUE if the triangle is inside data area.')], HRESULT, 'IsTriangleInsideDataArea',
              ( ['in'], c_int, 'triangleIndex' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsInside' )),
    COMMETHOD([helpstring(u'Returns TRUE if the edge is inside data area.')], HRESULT, 'IsEdgeInsideDataArea',
              ( ['in'], c_int, 'edgeIndex' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsInside' )),
    COMMETHOD([helpstring(u'Returns TRUE if the node is inside data area.')], HRESULT, 'IsNodeInsideDataArea',
              ( ['in'], c_int, 'nodeIndex' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsInside' )),
    COMMETHOD([helpstring(u'Returns unique tag values with counts for the specified element type.')], HRESULT, 'GetCountedUniqueTagValues',
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray)), 'ppValues' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray)), 'ppCounts' )),
    COMMETHOD([helpstring(u'Return the z-coordinate of the specified location using Natural Neighbor interpolation.')], HRESULT, 'GetNaturalNeighborZ',
              ( ['in'], c_double, 'X' ),
              ( ['in'], c_double, 'Y' ),
              ( ['retval', 'out'], POINTER(c_double), 'pZ' )),
    COMMETHOD([helpstring(u'Converts qualified edges to a polyline feature class.')], HRESULT, 'ConvertToPolylines',
              ( [], POINTER(IFeatureClass), 'pFeatureClass' ),
              ( ['in'], POINTER(ITinDynamicFilter), 'pFilter' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pFieldName' )),
    COMMETHOD([helpstring(u'Saves the TIN to disk using the specified (full path) name.')], HRESULT, 'SaveAsVersion',
              ( ['in'], BSTR, 'newName' ),
              ( ['in'], esriTinVersion, 'ver' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pOverWrite' )),
    COMMETHOD(['restricted', helpstring(u'Free memory used by the TIN.')], HRESULT, 'FreeMemory'),
]
################################################################
## code template for ITinAdvanced2 implementation
##class ITinAdvanced2_Impl(object):
##    def GetLeftTriangleIndex(self, edgeIndex):
##        u'Gets left triangle index of the specified edge.'
##        #return pTriangle
##
##    def QueryAllEdgeIndicesAroundNode(self, nodeIndex, pEdges):
##        u'Returns all edges connected to the specified node. If the last edge in the array has negative value, then its end node, instead of begin node, is the specified node.'
##        #return 
##
##    def GetNodeSource(self, nodeIndex):
##        u'Returns the source of the specified node.'
##        #return pSource
##
##    def QueryNaturalNeighborIndices(self, pPoint, pNodes):
##        u'Returns all Natural Neighbors corresponding to the query point.'
##        #return 
##
##    def ConvertToPolylines(self, pFeatureClass, pFilter, pFieldName):
##        u'Converts qualified edges to a polyline feature class.'
##        #return 
##
##    def FindTriangleIndex(self, pPoint):
##        u'The triangle at the specified location.'
##        #return pTriangle
##
##    def QueryElementAsGeometry(self, Type, Index, pGeometry):
##        u'Output the specified TIN element as Geometry object.'
##        #return 
##
##    def QueryTriangleNeighborhoodIndices(self, pPoint, pTriangles):
##        u'Returns all triangles whose circumscribed circle contains the query point.'
##        #return 
##
##    def FreeMemory(self):
##        u'Free memory used by the TIN.'
##        #return 
##
##    def GetNaturalNeighborZ(self, X, Y):
##        u'Return the z-coordinate of the specified location using Natural Neighbor interpolation.'
##        #return pZ
##
##    def IsNodeOnDomainBoundary(self, nodeIndex):
##        u"Returns TRUE if the specified node is on domain's boundary."
##        #return pbIsOn
##
##    def QueryEdgeIndicesAroundNode(self, nodeIndex, pEdges):
##        u'Returns all edges having the specified node as begin node.'
##        #return 
##
##    def QueryTriangleEdgeIndices(self, triangleIndex):
##        u'Gets the three edges of the specified triangle (clockwise).'
##        #return pA, pB, pC
##
##    def QueryNodeIndicesAroundNode(self, nodeIndex, pNodes):
##        u'Returns all nodes connected to the specified node.'
##        #return 
##
##    def GetRightTriangleIndex(self, edgeIndex):
##        u'Gets right triangle index of the specified edge.'
##        #return pTriangle
##
##    def GetSpecialEdgeCounts(self):
##        u'Returns the total number of special edges in the TIN.'
##        #return pcHardDataEdges, pcSoftDataEdges, pcTagValueDataEdges
##
##    def QueryTriangleNodeIndices(self, triangleIndex):
##        u'Gets the three nodes of the specified triangle (clockwise).'
##        #return pA, pB, pC
##
##    def QueryBeginEndNodeIndices(self, edgeIndex):
##        u'Gets begin and end nodes of the specified edge.'
##        #return pBegin, pEnd
##
##    def GetCountedUniqueTagValues(self, Type):
##        u'Returns unique tag values with counts for the specified element type.'
##        #return ppValues, ppCounts
##
##    def GetNeighborEdgeIndex(self, edgeIndex):
##        u'Gets neighbor edge index.'
##        #return pNeighbor
##
##    def GetNodeDegree(self, nodeIndex, bEnforcedEdgesOnly):
##        u'Returns the degree of the specified node.'
##        #return pDegree
##
##    def HasEdgeType(self, Type):
##        u'Returns TRUE if the TIN contains the specified edge type.'
##        #return pbHasType
##
##    def SaveAsVersion(self, newName, ver, pOverWrite):
##        u'Saves the TIN to disk using the specified (full path) name.'
##        #return 
##
##    def QueryNeighborsAndWeights(self, X, Y, pNeighbors, pWeights):
##        u'Returns natural neighbors and their weights corresponding to the query point.'
##        #return 
##
##    def GetNodeSourceCounts(self):
##        u'Returns the number of nodes with respect to different sources.'
##        #return pcOriginal, pcSuper, pcDensified, pcIntersection, pcUnknown
##
##    def QueryTriangleIndicesAroundNode(self, nodeIndex, pTriangles):
##        u'Returns all triangles sharing the specified node.'
##        #return 
##
##    def IsNodeInsideDataArea(self, nodeIndex):
##        u'Returns TRUE if the node is inside data area.'
##        #return pbIsInside
##
##    def IsEdgeInsideDataArea(self, edgeIndex):
##        u'Returns TRUE if the edge is inside data area.'
##        #return pbIsInside
##
##    def IsTriangleInsideDataArea(self, triangleIndex):
##        u'Returns TRUE if the triangle is inside data area.'
##        #return pbIsInside
##

class ComplexJunctionFeature(CoClass):
    u'Esri Complex junction geometric network feature.'
    _reg_clsid_ = GUID('{DF9D71F4-DA32-11D1-AEBA-0000F80372B4}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IJunctionFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that modify and return information about a junction feature.'
    _iid_ = GUID('{2C411BAE-EA1A-11D1-AA91-00C04FA37B81}')
    _idlflags_ = ['oleautomation']
class IComplexJunctionFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return and modify complex junction features.'
    _iid_ = GUID('{8AE6975E-EA99-11D1-AECC-0000F80372B4}')
    _idlflags_ = ['oleautomation']
class IFeatureSnap(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enable features to do custom snapping.'
    _iid_ = GUID('{BFFB1704-DBC0-11D1-AA7C-00C04FA374BD}')
    _idlflags_ = ['oleautomation']
class IFeatureConnect(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that expose connector points and connection points.'
    _iid_ = GUID('{A175835A-C4FA-11D1-AEA9-0000F80372B4}')
    _idlflags_ = ['oleautomation']
ComplexJunctionFeature._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRow, IRowBuffer, IRowEvents, IRowSubtypes, IRowChanges, IRowCompare, IFeature, IFeatureBuffer, IFeatureEvents, IFeatureDraw, IFeatureChanges, IFeatureSimplify, IFeatureSimplify2, INetworkFeature, INetworkFeatureEvents, IJunctionFeature, IComplexJunctionFeature, IComplexNetworkFeature, IRowEdit, IFeatureEdit, IFeatureEdit2, IFeatureSnap, IFeatureConnect, IRelatedObjectEvents, IValidate, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, IFeatureProject]

class INetElementDescriptionEdit(INetElementDescription):
    _case_insensitive_ = True
    u'Provides access to members that set information for this NetElementDescription object.'
    _iid_ = GUID('{027E7416-981B-11D1-B264-0000F878229E}')
    _idlflags_ = ['oleautomation']
INetElementDescriptionEdit._methods_ = [
    COMMETHOD(['propput', helpstring(u'User class ID for this NetElementDescription object.')], HRESULT, 'UserClassID',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'User ID for this NetElementDescription object.')], HRESULT, 'UserID',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'User sub ID for this NetElementDescription object.')], HRESULT, 'UserSubID',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Type of network element for this NetElementDescription object.')], HRESULT, 'ElementType',
              ( ['in'], esriElementType, 'rhs' )),
]
################################################################
## code template for INetElementDescriptionEdit implementation
##class INetElementDescriptionEdit_Impl(object):
##    def _set(self, rhs):
##        u'Type of network element for this NetElementDescription object.'
##    ElementType = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'User class ID for this NetElementDescription object.'
##    UserClassID = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'User ID for this NetElementDescription object.'
##    UserID = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'User sub ID for this NetElementDescription object.'
##    UserSubID = property(fset = _set, doc = _set.__doc__)
##

class INetworkSourceDirections(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the properties for generating driving directions for a specific network dataset source.'
    _iid_ = GUID('{DFE6C801-152D-4D0F-B3AA-54331384D777}')
    _idlflags_ = ['oleautomation']
class INetworkSourceDirections2(INetworkSourceDirections):
    _case_insensitive_ = True
    u'Provides access to the properties for generating driving directions for a specific network dataset source.'
    _iid_ = GUID('{CD84E891-2B4A-4CED-83F2-DEDD9E24E16B}')
    _idlflags_ = ['oleautomation']
class INetworkSourceDirections3(INetworkSourceDirections2):
    _case_insensitive_ = True
    u'Provides access to the properties for generating driving directions for a specific network dataset source.'
    _iid_ = GUID('{031D0936-FFDD-4259-A549-31FAB7889CA0}')
    _idlflags_ = ['oleautomation']
class IShields(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a container for refining directions with shields.'
    _iid_ = GUID('{9E82750B-BDDC-40A1-9A63-FF699FFC55E1}')
    _idlflags_ = ['oleautomation']
INetworkSourceDirections._methods_ = [
    COMMETHOD(['propget', helpstring(u'The directions shields settings for this source.')], HRESULT, 'Shields',
              ( ['retval', 'out'], POINTER(POINTER(IShields)), 'Shields' )),
    COMMETHOD(['propputref', helpstring(u'The directions shields settings for this source.')], HRESULT, 'Shields',
              ( ['in'], POINTER(IShields), 'Shields' )),
    COMMETHOD(['propget', helpstring(u'The name of the field containing the administrative area information for generating driving directions.')], HRESULT, 'AdminAreaFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the field containing the administrative area information for generating driving directions.')], HRESULT, 'AdminAreaFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The fields containing the street names used in reporting driving directions.')], HRESULT, 'StreetNameFields',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'Fields' )),
    COMMETHOD(['propputref', helpstring(u'The fields containing the street names used in reporting driving directions.')], HRESULT, 'StreetNameFields',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'Fields' )),
]
################################################################
## code template for INetworkSourceDirections implementation
##class INetworkSourceDirections_Impl(object):
##    def StreetNameFields(self, Fields):
##        u'The fields containing the street names used in reporting driving directions.'
##        #return 
##
##    def Shields(self, Shields):
##        u'The directions shields settings for this source.'
##        #return 
##
##    def _get(self):
##        u'The name of the field containing the administrative area information for generating driving directions.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the field containing the administrative area information for generating driving directions.'
##    AdminAreaFieldName = property(_get, _set, doc = _set.__doc__)
##

INetworkSourceDirections2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The collection of directions field mapping.')], HRESULT, 'FieldMappings',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'FieldMappings' )),
    COMMETHOD(['propputref', helpstring(u'The collection of directions field mapping.')], HRESULT, 'FieldMappings',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'FieldMappings' )),
]
################################################################
## code template for INetworkSourceDirections2 implementation
##class INetworkSourceDirections2_Impl(object):
##    def FieldMappings(self, FieldMappings):
##        u'The collection of directions field mapping.'
##        #return 
##

INetworkSourceDirections3._methods_ = [
    COMMETHOD(['propget', helpstring(u'The collection of DirectionsLandmarkSource items used to generate event bypass instructions.')], HRESULT, 'LandmarkEventSources',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'eventSources' )),
    COMMETHOD(['propputref', helpstring(u'The collection of DirectionsLandmarkSource items used to generate event bypass instructions.')], HRESULT, 'LandmarkEventSources',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'eventSources' )),
    COMMETHOD(['propget', helpstring(u'The collection of DirectionsLandmarkSource items used to improve maneuver guidance.')], HRESULT, 'LandmarkManeuverSources',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'maneuverSources' )),
    COMMETHOD(['propputref', helpstring(u'The collection of DirectionsLandmarkSource items used to improve maneuver guidance.')], HRESULT, 'LandmarkManeuverSources',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'maneuverSources' )),
]
################################################################
## code template for INetworkSourceDirections3 implementation
##class INetworkSourceDirections3_Impl(object):
##    def LandmarkEventSources(self, eventSources):
##        u'The collection of DirectionsLandmarkSource items used to generate event bypass instructions.'
##        #return 
##
##    def LandmarkManeuverSources(self, maneuverSources):
##        u'The collection of DirectionsLandmarkSource items used to improve maneuver guidance.'
##        #return 
##

class IRasterDef(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control raster column definition.'
    _iid_ = GUID('{CDBA994F-8F18-4ABE-8A39-502BED07265E}')
    _idlflags_ = ['oleautomation']
IRasterDef._methods_ = [
    COMMETHOD(['propput', helpstring(u'The raster column description.')], HRESULT, 'Description',
              ( ['in'], BSTR, 'descrption' )),
    COMMETHOD(['propget', helpstring(u'The raster column description.')], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'descrption' )),
    COMMETHOD(['propget', helpstring(u'The SpatialReference of the raster.')], HRESULT, 'SpatialReference',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference)), 'spref' )),
    COMMETHOD(['propputref', helpstring(u'The SpatialReference of the raster.')], HRESULT, 'SpatialReference',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'spref' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the Raster column value is to be managed by GeoDatabase.')], HRESULT, 'IsManaged',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsManaged' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the Raster column value is to be managed by GeoDatabase.')], HRESULT, 'IsManaged',
              ( ['in'], VARIANT_BOOL, 'IsManaged' )),
    COMMETHOD(['propget', helpstring(u'Indicates whether the definition is for RasterDataset.')], HRESULT, 'IsRasterDataset',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsRasterDataset' )),
    COMMETHOD(['propput', helpstring(u'Indicates whether the definition is for RasterDataset.')], HRESULT, 'IsRasterDataset',
              ( ['in'], VARIANT_BOOL, 'IsRasterDataset' )),
]
################################################################
## code template for IRasterDef implementation
##class IRasterDef_Impl(object):
##    def _get(self):
##        u'Indicates if the Raster column value is to be managed by GeoDatabase.'
##        #return IsManaged
##    def _set(self, IsManaged):
##        u'Indicates if the Raster column value is to be managed by GeoDatabase.'
##    IsManaged = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The raster column description.'
##        #return descrption
##    def _set(self, descrption):
##        u'The raster column description.'
##    Description = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates whether the definition is for RasterDataset.'
##        #return IsRasterDataset
##    def _set(self, IsRasterDataset):
##        u'Indicates whether the definition is for RasterDataset.'
##    IsRasterDataset = property(_get, _set, doc = _set.__doc__)
##
##    def SpatialReference(self, spref):
##        u'The SpatialReference of the raster.'
##        #return 
##

class IEnumDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through Datasets.'
    _iid_ = GUID('{2D04C044-7766-11D0-B77D-00805F7CED21}')
    _idlflags_ = ['oleautomation']
IEnumDataset._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next dataset in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IDataset)), 'item' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumDataset implementation
##class IEnumDataset_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next dataset in the enumeration sequence.'
##        #return item
##

class IPnt(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control a portable point.'
    _iid_ = GUID('{55614793-3490-11D3-A627-0008C7D3AF56}')
    _idlflags_ = ['oleautomation']
IPnt._methods_ = [
    COMMETHOD(['propget', helpstring(u'X coordinate of the point.')], HRESULT, 'X',
              ( ['retval', 'out'], POINTER(c_double), 'val' )),
    COMMETHOD(['propput', helpstring(u'X coordinate of the point.')], HRESULT, 'X',
              ( ['in'], c_double, 'val' )),
    COMMETHOD(['propget', helpstring(u'Y coordinate of the point.')], HRESULT, 'Y',
              ( ['retval', 'out'], POINTER(c_double), 'val' )),
    COMMETHOD(['propput', helpstring(u'Y coordinate of the point.')], HRESULT, 'Y',
              ( ['in'], c_double, 'val' )),
    COMMETHOD([helpstring(u'Set X and Y coordinates of the point.')], HRESULT, 'SetCoords',
              ( ['in'], c_double, 'X' ),
              ( ['in'], c_double, 'Y' )),
    COMMETHOD([helpstring(u"Reset from Esri's Point Object.")], HRESULT, 'Set2Point',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'env' )),
    COMMETHOD([helpstring(u"Set Esri's Point Object from Pnt.")], HRESULT, 'Convert2Point',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'env' )),
]
################################################################
## code template for IPnt implementation
##class IPnt_Impl(object):
##    def _get(self):
##        u'Y coordinate of the point.'
##        #return val
##    def _set(self, val):
##        u'Y coordinate of the point.'
##    Y = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'X coordinate of the point.'
##        #return val
##    def _set(self, val):
##        u'X coordinate of the point.'
##    X = property(_get, _set, doc = _set.__doc__)
##
##    def Convert2Point(self, env):
##        u"Set Esri's Point Object from Pnt."
##        #return 
##
##    def SetCoords(self, X, Y):
##        u'Set X and Y coordinates of the point.'
##        #return 
##
##    def Set2Point(self, env):
##        u"Reset from Esri's Point Object."
##        #return 
##

class IAttachmentInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe an attachment.'
    _iid_ = GUID('{74060067-8955-44DA-8653-C18F388893CE}')
    _idlflags_ = ['oleautomation']
class IAttachmentInfo2(IAttachmentInfo):
    _case_insensitive_ = True
    u'Provides access to members that describe an attachment.'
    _iid_ = GUID('{74060067-8955-44EE-8653-C18F388893C0}')
    _idlflags_ = ['oleautomation']
IAttachmentInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'ID that uniquely identifies an attachment.')], HRESULT, 'AttachmentID',
              ( ['retval', 'out'], POINTER(c_int), 'attID' )),
    COMMETHOD(['propget', helpstring(u'Descriptive name of an attachment.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'Descriptive name of an attachment.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The source ID that to which the attachment is associated to.')], HRESULT, 'ParentID',
              ( ['retval', 'out'], POINTER(c_int), 'OID' )),
    COMMETHOD(['propput', helpstring(u'The source ID that to which the attachment is associated to.')], HRESULT, 'ParentID',
              ( ['in'], c_int, 'OID' )),
    COMMETHOD(['propget', helpstring(u'Content type that indicates the type of the mime content.')], HRESULT, 'ContentType',
              ( ['retval', 'out'], POINTER(BSTR), 'ContentType' )),
    COMMETHOD(['propput', helpstring(u'Content type that indicates the type of the mime content.')], HRESULT, 'ContentType',
              ( ['in'], BSTR, 'ContentType' )),
    COMMETHOD(['propget', helpstring(u'The size of the attachment.')], HRESULT, 'Size',
              ( ['retval', 'out'], POINTER(c_int), 'Size' )),
]
################################################################
## code template for IAttachmentInfo implementation
##class IAttachmentInfo_Impl(object):
##    def _get(self):
##        u'Content type that indicates the type of the mime content.'
##        #return ContentType
##    def _set(self, ContentType):
##        u'Content type that indicates the type of the mime content.'
##    ContentType = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def Size(self):
##        u'The size of the attachment.'
##        #return Size
##
##    @property
##    def AttachmentID(self):
##        u'ID that uniquely identifies an attachment.'
##        #return attID
##
##    def _get(self):
##        u'Descriptive name of an attachment.'
##        #return Name
##    def _set(self, Name):
##        u'Descriptive name of an attachment.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The source ID that to which the attachment is associated to.'
##        #return OID
##    def _set(self, OID):
##        u'The source ID that to which the attachment is associated to.'
##    ParentID = property(_get, _set, doc = _set.__doc__)
##

IAttachmentInfo2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Is the attachment global ID based.')], HRESULT, 'IsAttachmentRelationshipGlobalIDBased',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'globalIDBased' )),
    COMMETHOD(['propget', helpstring(u'Global ID that uniquely identifies the attachment.')], HRESULT, 'GlobalID',
              ( ['retval', 'out'], POINTER(BSTR), 'GlobalID' )),
    COMMETHOD(['propput', helpstring(u'Global ID that uniquely identifies the attachment.')], HRESULT, 'GlobalID',
              ( ['in'], BSTR, 'GlobalID' )),
    COMMETHOD(['propget', helpstring(u'The source global ID that to which the attachment is associated to.')], HRESULT, 'ParentGlobalID',
              ( ['retval', 'out'], POINTER(BSTR), 'GlobalID' )),
    COMMETHOD(['propput', helpstring(u'The source global ID that to which the attachment is associated to.')], HRESULT, 'ParentGlobalID',
              ( ['in'], BSTR, 'GlobalID' )),
]
################################################################
## code template for IAttachmentInfo2 implementation
##class IAttachmentInfo2_Impl(object):
##    def _get(self):
##        u'The source global ID that to which the attachment is associated to.'
##        #return GlobalID
##    def _set(self, GlobalID):
##        u'The source global ID that to which the attachment is associated to.'
##    ParentGlobalID = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def IsAttachmentRelationshipGlobalIDBased(self):
##        u'Is the attachment global ID based.'
##        #return globalIDBased
##
##    def _get(self):
##        u'Global ID that uniquely identifies the attachment.'
##        #return GlobalID
##    def _set(self, GlobalID):
##        u'Global ID that uniquely identifies the attachment.'
##    GlobalID = property(_get, _set, doc = _set.__doc__)
##

class SimpleEdgeFeature(CoClass):
    u'Esri Geometric network simple edge feature object.'
    _reg_clsid_ = GUID('{E7031C90-55FE-11D1-AE55-0000F80372B4}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ISimpleNetworkFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Indicator interface for simple network features.'
    _iid_ = GUID('{C87BE760-DA2A-11D1-AEBA-0000F80372B4}')
    _idlflags_ = ['oleautomation']
class ISimpleEdgeFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the ID of a simple edge feature.'
    _iid_ = GUID('{4DBC418C-EA1A-11D1-AA91-00C04FA37B81}')
    _idlflags_ = ['oleautomation']
SimpleEdgeFeature._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRow, IRowBuffer, IRowEvents, IRowSubtypes, IRowChanges, IRowCompare, IFeature, IFeatureBuffer, IFeatureEvents, IFeatureChanges, IFeatureDraw, INetworkFeature, INetworkFeatureEvents, ISimpleNetworkFeature, IEdgeFeature, ISimpleEdgeFeature, IRowEdit, IFeatureEdit, IFeatureEdit2, IFeatureSimplify, IFeatureSimplify2, IValidate, IRelatedObjectEvents, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, IFeatureProject]

class Objects(CoClass):
    u'The Objects CoClass.'
    _reg_clsid_ = GUID('{6674054C-4FFC-11D1-9AA8-080009EC734B}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IObjects(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manipulate a collection of objects.'
    _iid_ = GUID('{ABAB1C4B-49A8-11D1-9AA6-080009EC734B}')
    _idlflags_ = ['oleautomation']
Objects._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IObjects]

class DEGeoDataServerType(CoClass):
    u'GeoDataServer Object Data Element object type.'
    _reg_clsid_ = GUID('{64FF9C15-FC3F-40FE-B311-765B801F08AB}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDEGeoDataServerType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the GeoDataServer Data Element Type.'
    _iid_ = GUID('{878BA0F9-A1B9-4D80-9F50-B8E5C9071B24}')
    _idlflags_ = ['oleautomation']
DEGeoDataServerType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEGeoDataServerType, IDEServerObjectType, IGxFilterInfo, IDataElementType, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class INetDiagnostics(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to logical network diagnostics methods.'
    _iid_ = GUID('{2FB1FD60-C418-4E33-9B55-0A8B12530164}')
    _idlflags_ = ['oleautomation']
INetDiagnostics._methods_ = [
    COMMETHOD(['hidden', helpstring(u'Dump the contents of the logical network to the given file.')], HRESULT, 'Dump',
              ( ['in'], BSTR, 'fileName' )),
]
################################################################
## code template for INetDiagnostics implementation
##class INetDiagnostics_Impl(object):
##    def Dump(self, fileName):
##        u'Dump the contents of the logical network to the given file.'
##        #return 
##

class IGPCodedValueDomain(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return and modify coded value domain values.'
    _iid_ = GUID('{41DC44A0-D2EB-11D5-933F-0080C71A3226}')
    _idlflags_ = ['oleautomation']
IGPCodedValueDomain._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of codes for the associated attribute.')], HRESULT, 'CodeCount',
              ( ['retval', 'out'], POINTER(c_int), 'values' )),
    COMMETHOD(['propget', helpstring(u'The code name for the specified code index.')], HRESULT, 'Name',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The value object for the specified code index.')], HRESULT, 'Value',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IGPValue)), 'Value' )),
    COMMETHOD([helpstring(u'Provides the value object for the specified code.')], HRESULT, 'FindValue',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IGPValue)), 'Value' )),
    COMMETHOD([helpstring(u'Adds a (value, name) code.')], HRESULT, 'AddCode',
              ( ['in'], POINTER(IGPValue), 'Value' ),
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD([helpstring(u'Adds a (value, name) code.')], HRESULT, 'AddStringCode',
              ( ['in'], BSTR, 'Value' ),
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD([helpstring(u'Deletes a code with the specified value.')], HRESULT, 'DeleteCode',
              ( ['in'], POINTER(IGPValue), 'Value' )),
    COMMETHOD([helpstring(u'Deletes all the codes.')], HRESULT, 'Empty'),
    COMMETHOD([helpstring(u'Populate the domain codes.')], HRESULT, 'PopulateDomain',
              ( ['in'], BSTR, 'values' ),
              ( ['in'], BSTR, 'Names' ),
              ( ['in'], POINTER(IGPDataType), 'GPDataType' )),
    COMMETHOD([helpstring(u'Provides the name for the specified value.')], HRESULT, 'FindName',
              ( ['in'], POINTER(IGPValue), 'Value' ),
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
]
################################################################
## code template for IGPCodedValueDomain implementation
##class IGPCodedValueDomain_Impl(object):
##    @property
##    def Name(self, Index):
##        u'The code name for the specified code index.'
##        #return Name
##
##    def AddCode(self, Value, Name):
##        u'Adds a (value, name) code.'
##        #return 
##
##    def DeleteCode(self, Value):
##        u'Deletes a code with the specified value.'
##        #return 
##
##    @property
##    def Value(self, Index):
##        u'The value object for the specified code index.'
##        #return Value
##
##    def FindValue(self, Name):
##        u'Provides the value object for the specified code.'
##        #return Value
##
##    def AddStringCode(self, Value, Name):
##        u'Adds a (value, name) code.'
##        #return 
##
##    @property
##    def CodeCount(self):
##        u'The number of codes for the associated attribute.'
##        #return values
##
##    def FindName(self, Value):
##        u'Provides the name for the specified value.'
##        #return Name
##
##    def PopulateDomain(self, values, Names, GPDataType):
##        u'Populate the domain codes.'
##        #return 
##
##    def Empty(self):
##        u'Deletes all the codes.'
##        #return 
##

IFeatureCursor._methods_ = [
    COMMETHOD([helpstring(u'The index of the field with the specified name.')], HRESULT, 'FindField',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(c_int), 'FieldIndex' )),
    COMMETHOD(['propget', helpstring(u'The fields Collection for this cursor.')], HRESULT, 'Fields',
              ( ['retval', 'out'], POINTER(POINTER(IFields)), 'Fields' )),
    COMMETHOD([helpstring(u'Advance the position of the cursor by one and return the Feature object at that position.')], HRESULT, 'NextFeature',
              ( ['retval', 'out'], POINTER(POINTER(IFeature)), 'Object' )),
    COMMETHOD([helpstring(u'Update the existing Feature in the database corresponding to the current position of the cursor.')], HRESULT, 'UpdateFeature',
              ( ['in'], POINTER(IFeature), 'Object' )),
    COMMETHOD([helpstring(u'Delete the existing Feature in the database corresponding to the current position of the cursor.')], HRESULT, 'DeleteFeature'),
    COMMETHOD([helpstring(u'Insert a new Feature into the database using the property values in the input buffer. The  ID  of the new Feature is returned.')], HRESULT, 'InsertFeature',
              ( ['in'], POINTER(IFeatureBuffer), 'buffer' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'ID' )),
    COMMETHOD([helpstring(u'Flush any outstanding buffered writes to the database.')], HRESULT, 'Flush'),
]
################################################################
## code template for IFeatureCursor implementation
##class IFeatureCursor_Impl(object):
##    def InsertFeature(self, buffer):
##        u'Insert a new Feature into the database using the property values in the input buffer. The  ID  of the new Feature is returned.'
##        #return ID
##
##    @property
##    def Fields(self):
##        u'The fields Collection for this cursor.'
##        #return Fields
##
##    def FindField(self, Name):
##        u'The index of the field with the specified name.'
##        #return FieldIndex
##
##    def DeleteFeature(self):
##        u'Delete the existing Feature in the database corresponding to the current position of the cursor.'
##        #return 
##
##    def Flush(self):
##        u'Flush any outstanding buffered writes to the database.'
##        #return 
##
##    def NextFeature(self):
##        u'Advance the position of the cursor by one and return the Feature object at that position.'
##        #return Object
##
##    def UpdateFeature(self, Object):
##        u'Update the existing Feature in the database corresponding to the current position of the cursor.'
##        #return 
##

class IThumbnailInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members of thumbnail info.'
    _iid_ = GUID('{553E8170-17F7-4F05-BFEF-BE392BC0A3C8}')
    _idlflags_ = ['oleautomation']
IThumbnailInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'Url of the thumbnail.')], HRESULT, 'URL',
              ( ['retval', 'out'], POINTER(BSTR), 'pUrl' )),
    COMMETHOD(['propput', helpstring(u'Url of the thumbnail.')], HRESULT, 'URL',
              ( ['in'], BSTR, 'pUrl' )),
    COMMETHOD(['propget', helpstring(u'Embedded data of the thumbnail.')], HRESULT, 'EmbeddedData',
              ( ['retval', 'out'], POINTER(_midlSAFEARRAY(c_ubyte)), 'ppData' )),
    COMMETHOD(['propput', helpstring(u'Embedded data of the thumbnail.')], HRESULT, 'EmbeddedData',
              ( ['in'], POINTER(_midlSAFEARRAY(c_ubyte)), 'ppData' )),
]
################################################################
## code template for IThumbnailInfo implementation
##class IThumbnailInfo_Impl(object):
##    def _get(self):
##        u'Url of the thumbnail.'
##        #return pUrl
##    def _set(self, pUrl):
##        u'Url of the thumbnail.'
##    URL = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Embedded data of the thumbnail.'
##        #return ppData
##    def _set(self, ppData):
##        u'Embedded data of the thumbnail.'
##    EmbeddedData = property(_get, _set, doc = _set.__doc__)
##

class TableName(CoClass):
    u'Esri Table Name object.'
    _reg_clsid_ = GUID('{06783DB1-E5EE-11D1-B0A2-0000F8780820}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ITableName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Indicator interface for table name objects.'
    _iid_ = GUID('{62EE07D6-09C4-11D4-A05E-00C04F6BDD84}')
    _idlflags_ = ['oleautomation']
class IObjectClassName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the objects class ID.'
    _iid_ = GUID('{7FC83CFA-09C4-11D4-A05E-00C04F6BDD84}')
    _idlflags_ = ['oleautomation']
class IModelInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the model name of the field.'
    _iid_ = GUID('{2D660904-1DBD-11D3-9F87-00C04F6BDD84}')
    _idlflags_ = ['oleautomation']
class ISQLPrivilege(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for granting and revoking privileges to database users.'
    _iid_ = GUID('{A867A185-C5CB-11D2-AAE2-00C04FA37849}')
    _idlflags_ = ['oleautomation']
TableName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, ITableName, IObjectClassName, IModelInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IMetadata, IMetadataEdit, INativeTypeInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, ISQLPrivilege]

class IEvaluatedNetworkAttribute(INetworkAttribute):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of an evaluated attribute in a network dataset.'
    _iid_ = GUID('{AFB92F55-F7E1-4210-B44E-E118AC2D4D99}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriNetworkAttributeDataType'
esriNADTInteger = 0
esriNADTFloat = 1
esriNADTDouble = 2
esriNADTBoolean = 3
esriNetworkAttributeDataType = c_int # enum

# values for enumeration 'esriNetworkAttributeUsageType'
esriNAUTCost = 0
esriNAUTDescriptor = 1
esriNAUTRestriction = 2
esriNAUTHierarchy = 3
esriNetworkAttributeUsageType = c_int # enum

# values for enumeration 'esriNetworkAttributeUnits'
esriNAUUnknown = 0
esriNAUInches = 1
esriNAUFeet = 3
esriNAUYards = 4
esriNAUMiles = 5
esriNAUNauticalMiles = 6
esriNAUMillimeters = 7
esriNAUCentimeters = 8
esriNAUMeters = 9
esriNAUKilometers = 10
esriNAUDecimalDegrees = 11
esriNAUDecimeters = 12
esriNAUSeconds = 20
esriNAUMinutes = 21
esriNAUHours = 22
esriNAUDays = 23
esriNAUMilesPerHour = 30
esriNAUKilometersPerHour = 31
esriNetworkAttributeUnits = c_int # enum
INetworkAttribute._methods_ = [
    COMMETHOD(['propget', helpstring(u'Name of this network attribute.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'AttributeName' )),
    COMMETHOD(['propput', helpstring(u'Name of this network attribute.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'AttributeName' )),
    COMMETHOD(['propget', helpstring(u'Unique identifier of this network attribute.')], HRESULT, 'ID',
              ( ['retval', 'out'], POINTER(c_int), 'AttributeID' )),
    COMMETHOD(['propget', helpstring(u'Type of data used in this network attribute.')], HRESULT, 'DataType',
              ( ['retval', 'out'], POINTER(esriNetworkAttributeDataType), 'DataType' )),
    COMMETHOD(['propput', helpstring(u'Type of data used in this network attribute.')], HRESULT, 'DataType',
              ( ['in'], esriNetworkAttributeDataType, 'DataType' )),
    COMMETHOD(['propget', helpstring(u'Usage type of this network attribute.')], HRESULT, 'UsageType',
              ( ['retval', 'out'], POINTER(esriNetworkAttributeUsageType), 'UsageType' )),
    COMMETHOD(['propput', helpstring(u'Usage type of this network attribute.')], HRESULT, 'UsageType',
              ( ['in'], esriNetworkAttributeUsageType, 'UsageType' )),
    COMMETHOD(['propget', helpstring(u'Units of this network attribute.')], HRESULT, 'Units',
              ( ['retval', 'out'], POINTER(esriNetworkAttributeUnits), 'Units' )),
    COMMETHOD(['propput', helpstring(u'Units of this network attribute.')], HRESULT, 'Units',
              ( ['in'], esriNetworkAttributeUnits, 'Units' )),
]
################################################################
## code template for INetworkAttribute implementation
##class INetworkAttribute_Impl(object):
##    def _get(self):
##        u'Type of data used in this network attribute.'
##        #return DataType
##    def _set(self, DataType):
##        u'Type of data used in this network attribute.'
##    DataType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Units of this network attribute.'
##        #return Units
##    def _set(self, Units):
##        u'Units of this network attribute.'
##    Units = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Usage type of this network attribute.'
##        #return UsageType
##    def _set(self, UsageType):
##        u'Usage type of this network attribute.'
##    UsageType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Name of this network attribute.'
##        #return AttributeName
##    def _set(self, AttributeName):
##        u'Name of this network attribute.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def ID(self):
##        u'Unique identifier of this network attribute.'
##        #return AttributeID
##

class INetworkSource(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of a source in a network dataset.'
    _iid_ = GUID('{10F8D75C-1D54-4F2A-8CE8-FB7D50A0DF1D}')
    _idlflags_ = ['oleautomation']
IEvaluatedNetworkAttribute._methods_ = [
    COMMETHOD(['propputref', helpstring(u"Evaluator used to derive attribute values for the given element type when an evaluator is not specified for a network element's source.")], HRESULT, 'DefaultEvaluator',
              ( ['in'], esriNetworkElementType, 'ElementType' ),
              ( ['in'], POINTER(INetworkEvaluator), 'Evaluator' )),
    COMMETHOD(['propget', helpstring(u"Evaluator used to derive attribute values for the given element type when an evaluator is not specified for a network element's source.")], HRESULT, 'DefaultEvaluator',
              ( ['in'], esriNetworkElementType, 'ElementType' ),
              ( ['retval', 'out'], POINTER(POINTER(INetworkEvaluator)), 'Evaluator' )),
    COMMETHOD(['propputref', helpstring(u'Evaluator used to derive values from the given network source for this network attribute.')], HRESULT, 'Evaluator',
              ( ['in'], POINTER(INetworkSource), 'NetworkSource' ),
              ( ['in'], esriNetworkEdgeDirection, 'Direction' ),
              ( ['in'], POINTER(INetworkEvaluator), 'Evaluator' )),
    COMMETHOD(['propget', helpstring(u'Evaluator used to derive values from the given network source for this network attribute.')], HRESULT, 'Evaluator',
              ( ['in'], POINTER(INetworkSource), 'NetworkSource' ),
              ( ['in'], esriNetworkEdgeDirection, 'Direction' ),
              ( ['retval', 'out'], POINTER(POINTER(INetworkEvaluator)), 'Evaluator' )),
]
################################################################
## code template for IEvaluatedNetworkAttribute implementation
##class IEvaluatedNetworkAttribute_Impl(object):
##    @property
##    def Evaluator(self, NetworkSource, Direction, Evaluator):
##        u'Evaluator used to derive values from the given network source for this network attribute.'
##        #return 
##
##    @property
##    def DefaultEvaluator(self, ElementType, Evaluator):
##        u"Evaluator used to derive attribute values for the given element type when an evaluator is not specified for a network element's source."
##        #return 
##

class IRasterCatalogName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about a RasterCatalog.'
    _iid_ = GUID('{D1909A6F-8EDA-4F3D-B9D2-310FD621386A}')
    _idlflags_ = ['oleautomation']
IRasterCatalogName._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the default Raster field.')], HRESULT, 'RasterFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the default Raster field.')], HRESULT, 'RasterFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this is a RasterDataset (a special one-row RasterCatalog).')], HRESULT, 'IsRasterDataset',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsRasterDataset' )),
    COMMETHOD(['propput', helpstring(u'Indicates if this is a RasterDataset (a special one-row RasterCatalog).')], HRESULT, 'IsRasterDataset',
              ( ['in'], VARIANT_BOOL, 'IsRasterDataset' )),
]
################################################################
## code template for IRasterCatalogName implementation
##class IRasterCatalogName_Impl(object):
##    def _get(self):
##        u'The name of the default Raster field.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the default Raster field.'
##    RasterFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if this is a RasterDataset (a special one-row RasterCatalog).'
##        #return IsRasterDataset
##    def _set(self, IsRasterDataset):
##        u'Indicates if this is a RasterDataset (a special one-row RasterCatalog).'
##    IsRasterDataset = property(_get, _set, doc = _set.__doc__)
##

class ObjectClassName(CoClass):
    u'Esri Object Class Name object.'
    _reg_clsid_ = GUID('{905CEC64-0B2C-11D4-A060-00C04F6BDD84}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
ObjectClassName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, ITableName, IObjectClassName, IModelInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IMetadata, IMetadataEdit, INativeTypeInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, ISQLPrivilege]

class IRouteEventSourceName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the route event source name properties.'
    _iid_ = GUID('{7F9C0D54-B8C7-11D3-9F7C-00C04F6BDF06}')
    _idlflags_ = ['oleautomation']
class IRouteLocatorName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to route locator name properties.'
    _iid_ = GUID('{D03A61A0-2070-11D4-9FC1-00C04F6BDF06}')
    _idlflags_ = ['oleautomation']
IRouteEventSourceName._methods_ = [
    COMMETHOD(['propputref', helpstring(u'The name object of the route locator.')], HRESULT, 'RouteLocatorName',
              ( ['in'], POINTER(IRouteLocatorName), 'locatorName' )),
    COMMETHOD(['propget', helpstring(u'The name object of the route locator.')], HRESULT, 'RouteLocatorName',
              ( ['retval', 'out'], POINTER(POINTER(IRouteLocatorName)), 'locatorName' )),
    COMMETHOD(['propputref', helpstring(u'The name object for the table containing route events.')], HRESULT, 'EventTableName',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'aName' )),
    COMMETHOD(['propget', helpstring(u'The name object for the table containing route events.')], HRESULT, 'EventTableName',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'aName' )),
    COMMETHOD(['propputref', helpstring(u'The route event properties.')], HRESULT, 'EventProperties',
              ( ['in'], POINTER(IRouteEventProperties), 'EventProperties' )),
    COMMETHOD(['propget', helpstring(u'The route event properties.')], HRESULT, 'EventProperties',
              ( ['retval', 'out'], POINTER(POINTER(IRouteEventProperties)), 'EventProperties' )),
]
################################################################
## code template for IRouteEventSourceName implementation
##class IRouteEventSourceName_Impl(object):
##    @property
##    def EventProperties(self, EventProperties):
##        u'The route event properties.'
##        #return 
##
##    @property
##    def RouteLocatorName(self, locatorName):
##        u'The name object of the route locator.'
##        #return 
##
##    @property
##    def EventTableName(self, aName):
##        u'The name object for the table containing route events.'
##        #return 
##

class IXYEventProperties(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to xy event properties.'
    _iid_ = GUID('{71045CA3-7902-11D4-9FE5-00C04F6BDF06}')
    _idlflags_ = ['oleautomation']
IXYEventProperties._methods_ = [
]
################################################################
## code template for IXYEventProperties implementation
##class IXYEventProperties_Impl(object):

class IDirectionsLandmarkSource(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'.'
    _iid_ = GUID('{A85044B3-A490-49B6-B37B-91210E2E9375}')
    _idlflags_ = ['oleautomation']
IDirectionsLandmarkSource._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the landmarks feature class.')], HRESULT, 'FeatureClassName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the landmarks feature class.')], HRESULT, 'FeatureClassName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The name of the landmarks feature class field which is used to access the landmark display name.')], HRESULT, 'LabelFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the landmarks feature class field which is used to access the landmark display name.')], HRESULT, 'LabelFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The name of the landmarks feature class field which is used to access the landmark Z-level value.')], HRESULT, 'LevelFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the landmarks feature class field which is used to access the landmark Z-level value.')], HRESULT, 'LevelFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The search tolerance value used to find landmarks along the route using spatial search.')], HRESULT, 'SearchTolerance',
              ( ['retval', 'out'], POINTER(c_double), 'tolerance' )),
    COMMETHOD(['propput', helpstring(u'The search tolerance value used to find landmarks along the route using spatial search.')], HRESULT, 'SearchTolerance',
              ( ['in'], c_double, 'tolerance' )),
    COMMETHOD(['propget', helpstring(u'The search tolerance value unit type.')], HRESULT, 'SearchToleranceUnits',
              ( ['retval', 'out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.esriUnits), 'Units' )),
    COMMETHOD(['propput', helpstring(u'The search tolerance value unit type.')], HRESULT, 'SearchToleranceUnits',
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.esriUnits, 'Units' )),
    COMMETHOD(['propget', helpstring(u'Indicates if spatial search should be used to locate landmarks along the route.')], HRESULT, 'UseSpatialSearch',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'useSearch' )),
    COMMETHOD(['propput', helpstring(u'Indicates if spatial search should be used to locate landmarks along the route.')], HRESULT, 'UseSpatialSearch',
              ( ['in'], VARIANT_BOOL, 'useSearch' )),
]
################################################################
## code template for IDirectionsLandmarkSource implementation
##class IDirectionsLandmarkSource_Impl(object):
##    def _get(self):
##        u'The name of the landmarks feature class field which is used to access the landmark display name.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the landmarks feature class field which is used to access the landmark display name.'
##    LabelFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if spatial search should be used to locate landmarks along the route.'
##        #return useSearch
##    def _set(self, useSearch):
##        u'Indicates if spatial search should be used to locate landmarks along the route.'
##    UseSpatialSearch = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The search tolerance value unit type.'
##        #return Units
##    def _set(self, Units):
##        u'The search tolerance value unit type.'
##    SearchToleranceUnits = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the landmarks feature class field which is used to access the landmark Z-level value.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the landmarks feature class field which is used to access the landmark Z-level value.'
##    LevelFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The search tolerance value used to find landmarks along the route using spatial search.'
##        #return tolerance
##    def _set(self, tolerance):
##        u'The search tolerance value used to find landmarks along the route using spatial search.'
##    SearchTolerance = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the landmarks feature class.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the landmarks feature class.'
##    FeatureClassName = property(_get, _set, doc = _set.__doc__)
##

class IDocumentationInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members of documentation info.'
    _iid_ = GUID('{0FFC5219-9896-48A1-A79F-B5697790C987}')
    _idlflags_ = ['oleautomation']
IDocumentationInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'Url of the documentation.')], HRESULT, 'URL',
              ( ['retval', 'out'], POINTER(BSTR), 'pUrl' )),
    COMMETHOD(['propput', helpstring(u'Url of the documentation.')], HRESULT, 'URL',
              ( ['in'], BSTR, 'pUrl' )),
    COMMETHOD(['propget', helpstring(u'Embedded data of the documentation.')], HRESULT, 'EmbeddedData',
              ( ['retval', 'out'], POINTER(_midlSAFEARRAY(c_ubyte)), 'ppData' )),
    COMMETHOD(['propput', helpstring(u'Embedded data of the documentation.')], HRESULT, 'EmbeddedData',
              ( ['in'], POINTER(_midlSAFEARRAY(c_ubyte)), 'ppData' )),
]
################################################################
## code template for IDocumentationInfo implementation
##class IDocumentationInfo_Impl(object):
##    def _get(self):
##        u'Url of the documentation.'
##        #return pUrl
##    def _set(self, pUrl):
##        u'Url of the documentation.'
##    URL = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Embedded data of the documentation.'
##        #return ppData
##    def _set(self, ppData):
##        u'Embedded data of the documentation.'
##    EmbeddedData = property(_get, _set, doc = _set.__doc__)
##

class ITopologyProtectNames(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{45196DB7-5FA4-4596-9D2E-7557BBEEDA92}')
    _idlflags_ = ['hidden']
ITopologyProtectNames._methods_ = [
    COMMETHOD([], HRESULT, 'Topology'),
    COMMETHOD([], HRESULT, 'Errors'),
    COMMETHOD([], HRESULT, 'Rules'),
    COMMETHOD([], HRESULT, 'TopologyName'),
    COMMETHOD([], HRESULT, 'TopologyID'),
    COMMETHOD([], HRESULT, 'ErrorFeature'),
    COMMETHOD([], HRESULT, 'ErrorClass'),
    COMMETHOD([], HRESULT, 'Exceptions'),
    COMMETHOD([], HRESULT, 'SelectionChanged'),
    COMMETHOD([], HRESULT, 'EventNotificationOnValidate'),
    COMMETHOD([], HRESULT, 'ObjectClass'),
    COMMETHOD([], HRESULT, 'XYRank'),
    COMMETHOD([], HRESULT, 'ZRank'),
    COMMETHOD([], HRESULT, 'RuleID'),
    COMMETHOD([], HRESULT, 'RuleGUID'),
    COMMETHOD([], HRESULT, 'TrustedArea'),
    COMMETHOD([], HRESULT, 'Classes'),
]
################################################################
## code template for ITopologyProtectNames implementation
##class ITopologyProtectNames_Impl(object):
##    def Classes(self):
##        '-no docstring-'
##        #return 
##
##    def Errors(self):
##        '-no docstring-'
##        #return 
##
##    def ErrorFeature(self):
##        '-no docstring-'
##        #return 
##
##    def RuleID(self):
##        '-no docstring-'
##        #return 
##
##    def Rules(self):
##        '-no docstring-'
##        #return 
##
##    def TrustedArea(self):
##        '-no docstring-'
##        #return 
##
##    def TopologyID(self):
##        '-no docstring-'
##        #return 
##
##    def TopologyName(self):
##        '-no docstring-'
##        #return 
##
##    def EventNotificationOnValidate(self):
##        '-no docstring-'
##        #return 
##
##    def ErrorClass(self):
##        '-no docstring-'
##        #return 
##
##    def ObjectClass(self):
##        '-no docstring-'
##        #return 
##
##    def SelectionChanged(self):
##        '-no docstring-'
##        #return 
##
##    def Exceptions(self):
##        '-no docstring-'
##        #return 
##
##    def XYRank(self):
##        '-no docstring-'
##        #return 
##
##    def RuleGUID(self):
##        '-no docstring-'
##        #return 
##
##    def ZRank(self):
##        '-no docstring-'
##        #return 
##
##    def Topology(self):
##        '-no docstring-'
##        #return 
##

class FeatureDatasetName(CoClass):
    u'Esri Feature Dataset Name object.'
    _reg_clsid_ = GUID('{198846CF-CA42-11D1-AA7C-00C04FA33A15}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IFeatureDatasetName2(IFeatureDatasetName):
    _case_insensitive_ = True
    u'Provides access to members that hand out enumerated subset names in the feature dataset.'
    _iid_ = GUID('{2D661A88-8067-4579-B569-5531DB29799A}')
    _idlflags_ = ['oleautomation']
class IDatasetContainerName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that hand out enumerated subset names in the dataset container.'
    _iid_ = GUID('{721DB11A-1001-44DC-9670-8577E824AFF2}')
    _idlflags_ = ['oleautomation']
FeatureDatasetName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, IFeatureDatasetName, IFeatureDatasetName2, IDatasetContainerName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IMetadata, IMetadataEdit, INativeTypeInfo, ISQLPrivilege]

class TinNodeSourceFilter(CoClass):
    u'The Esri TinNodeSourceFilter component.'
    _reg_clsid_ = GUID('{124F6D4A-B2A3-11D5-ABB9-0008C73FD50C}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinNodeSourceFilter._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITinFilter, ITinNodeSourceFilter, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

IFeatureBuffer._methods_ = [
    COMMETHOD(['propget', helpstring(u'The default shape in the feature buffer.')], HRESULT, 'Shape',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Shape' )),
    COMMETHOD(['propputref', helpstring(u'The default shape in the feature buffer.')], HRESULT, 'Shape',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'Shape' )),
]
################################################################
## code template for IFeatureBuffer implementation
##class IFeatureBuffer_Impl(object):
##    def Shape(self, Shape):
##        u'The default shape in the feature buffer.'
##        #return 
##

class IItemInfos(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the ItemInfos Interface.'
    _iid_ = GUID('{2D9150AE-DDED-4D71-B672-26757CD882AF}')
    _idlflags_ = ['oleautomation']
class IItemInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members of item info.'
    _iid_ = GUID('{506A8D89-C3AF-4C4B-8F03-8F83B36B5329}')
    _idlflags_ = ['oleautomation']
IItemInfos._methods_ = [
    COMMETHOD(['propget', helpstring(u'The ItemInfo count.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The ItemInfo at the specified position.')], HRESULT, 'Element',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IItemInfo)), 'ii' )),
    COMMETHOD([helpstring(u'Removes the ItemInfo at the specified position.')], HRESULT, 'Remove',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD([helpstring(u'Removes all ItemInfos.')], HRESULT, 'RemoveAll'),
    COMMETHOD([helpstring(u'Adds an ItemInfo to the array.')], HRESULT, 'Add',
              ( ['in'], POINTER(IItemInfo), 'ii' )),
    COMMETHOD([helpstring(u'Adds a ItemInfo at the specified position.')], HRESULT, 'Insert',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(IItemInfo), 'ii' )),
]
################################################################
## code template for IItemInfos implementation
##class IItemInfos_Impl(object):
##    @property
##    def Count(self):
##        u'The ItemInfo count.'
##        #return Count
##
##    def Insert(self, Index, ii):
##        u'Adds a ItemInfo at the specified position.'
##        #return 
##
##    def Remove(self, Index):
##        u'Removes the ItemInfo at the specified position.'
##        #return 
##
##    @property
##    def Element(self, Index):
##        u'The ItemInfo at the specified position.'
##        #return ii
##
##    def RemoveAll(self):
##        u'Removes all ItemInfos.'
##        #return 
##
##    def Add(self, ii):
##        u'Adds an ItemInfo to the array.'
##        #return 
##

IDataset._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the Dataset.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The associated name object.')], HRESULT, 'FullName',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The browse name of the dataset.')], HRESULT, 'BrowseName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The browse name of the dataset.')], HRESULT, 'BrowseName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The type of the Dataset.')], HRESULT, 'Type',
              ( ['retval', 'out'], POINTER(esriDatasetType), 'Type' )),
    COMMETHOD(['propget', helpstring(u'The category of the dataset.')], HRESULT, 'Category',
              ( ['retval', 'out'], POINTER(BSTR), 'Category' )),
    COMMETHOD(['propget', helpstring(u'Datasets contained within this dataset.')], HRESULT, 'Subsets',
              ( ['retval', 'out'], POINTER(POINTER(IEnumDataset)), 'Datasets' )),
    COMMETHOD(['propget', helpstring(u'The workspace containing this dataset.')], HRESULT, 'Workspace',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'database' )),
    COMMETHOD(['propget', helpstring(u'The set of properties for the dataset.')], HRESULT, 'PropertySet',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'props' )),
    COMMETHOD([helpstring(u'True if this dataset can be copied.')], HRESULT, 'CanCopy',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanCopy' )),
    COMMETHOD([helpstring(u'Copies this dataset to a new dataset with the specified name.')], HRESULT, 'Copy',
              ( ['in'], BSTR, 'copyName' ),
              ( ['in'], POINTER(IWorkspace), 'copyWorkspace' ),
              ( ['retval', 'out'], POINTER(POINTER(IDataset)), 'CopyDataset' )),
    COMMETHOD([helpstring(u'True if this dataset can be deleted.')], HRESULT, 'CanDelete',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanDelete' )),
    COMMETHOD([helpstring(u'Deletes this dataset.')], HRESULT, 'Delete'),
    COMMETHOD([helpstring(u'True if this dataset can be renamed.')], HRESULT, 'CanRename',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanRename' )),
    COMMETHOD([helpstring(u'Renames this Dataset.')], HRESULT, 'Rename',
              ( ['in'], BSTR, 'Name' )),
]
################################################################
## code template for IDataset implementation
##class IDataset_Impl(object):
##    @property
##    def Category(self):
##        u'The category of the dataset.'
##        #return Category
##
##    def Rename(self, Name):
##        u'Renames this Dataset.'
##        #return 
##
##    def CanCopy(self):
##        u'True if this dataset can be copied.'
##        #return CanCopy
##
##    @property
##    def Name(self):
##        u'The name of the Dataset.'
##        #return Name
##
##    @property
##    def Subsets(self):
##        u'Datasets contained within this dataset.'
##        #return Datasets
##
##    @property
##    def PropertySet(self):
##        u'The set of properties for the dataset.'
##        #return props
##
##    def _get(self):
##        u'The browse name of the dataset.'
##        #return Name
##    def _set(self, Name):
##        u'The browse name of the dataset.'
##    BrowseName = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def Workspace(self):
##        u'The workspace containing this dataset.'
##        #return database
##
##    @property
##    def FullName(self):
##        u'The associated name object.'
##        #return Name
##
##    def Copy(self, copyName, copyWorkspace):
##        u'Copies this dataset to a new dataset with the specified name.'
##        #return CopyDataset
##
##    @property
##    def Type(self):
##        u'The type of the Dataset.'
##        #return Type
##
##    def CanRename(self):
##        u'True if this dataset can be renamed.'
##        #return CanRename
##
##    def Delete(self):
##        u'Deletes this dataset.'
##        #return 
##
##    def CanDelete(self):
##        u'True if this dataset can be deleted.'
##        #return CanDelete
##

class IRandomAccessCursor(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that support random access to  row objects in a table.'
    _iid_ = GUID('{D756D09B-9BA9-11D4-9F7C-00C04F6BDF0E}')
    _idlflags_ = ['oleautomation']
IRandomAccessCursor._methods_ = [
    COMMETHOD([helpstring(u'Get a row given its object id.')], HRESULT, 'GetRow',
              ( ['in'], c_int, 'rowID' ),
              ( ['retval', 'out'], POINTER(POINTER(IRow)), 'Row' )),
]
################################################################
## code template for IRandomAccessCursor implementation
##class IRandomAccessCursor_Impl(object):
##    def GetRow(self, rowID):
##        u'Get a row given its object id.'
##        #return Row
##

class IVersionedObject(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage a versioned object.'
    _iid_ = GUID('{4A1FB361-B863-11D1-9CE7-0000F8780619}')
    _idlflags_ = ['oleautomation']
class IVersionedObject2(IVersionedObject):
    _case_insensitive_ = True
    u'Provides access to members that manage a versioned object.'
    _iid_ = GUID('{884D388E-8918-443A-8F4A-DB5AAC5B9D5E}')
    _idlflags_ = ['oleautomation']
class IVersion(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for managing a version.'
    _iid_ = GUID('{1A945841-B381-11D1-9CE6-0000F8780619}')
    _idlflags_ = ['oleautomation']
IVersionedObject._methods_ = [
    COMMETHOD(['propget', helpstring(u"The object's current version.")], HRESULT, 'Version',
              ( ['retval', 'out'], POINTER(POINTER(IVersion)), 'Version' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the object is registered as versioned.')], HRESULT, 'IsRegisteredAsVersioned',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isRegistered' )),
    COMMETHOD([helpstring(u'Register/UnRegister the object as being versioned.')], HRESULT, 'RegisterAsVersioned',
              ( ['in'], VARIANT_BOOL, 'isVersioned' )),
]
################################################################
## code template for IVersionedObject implementation
##class IVersionedObject_Impl(object):
##    @property
##    def IsRegisteredAsVersioned(self):
##        u'Indicates if the object is registered as versioned.'
##        #return isRegistered
##
##    @property
##    def Version(self):
##        u"The object's current version."
##        #return Version
##
##    def RegisterAsVersioned(self, isVersioned):
##        u'Register/UnRegister the object as being versioned.'
##        #return 
##

IVersionedObject2._methods_ = [
    COMMETHOD(['propget', helpstring(u"Indicates if the object has edits that haven't been compressed yet.")], HRESULT, 'HasUncompressedEdits',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasUncompressedEdits' )),
]
################################################################
## code template for IVersionedObject2 implementation
##class IVersionedObject2_Impl(object):
##    @property
##    def HasUncompressedEdits(self):
##        u"Indicates if the object has edits that haven't been compressed yet."
##        #return HasUncompressedEdits
##

class DEFeatureClassType(CoClass):
    u'Feature Class Data Element object Type.'
    _reg_clsid_ = GUID('{E87C2F50-7758-4A34-BD92-D66BEB2DF03E}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDEFeatureClassType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the FeatureClass Data Element Type.'
    _iid_ = GUID('{47A096BB-F338-428A-A403-FF6E8DE9EF94}')
    _idlflags_ = ['oleautomation']
DEFeatureClassType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEFeatureClassType, IDETableType, IDEGeoDatasetType, IDEDatasetType, IGxFilterInfo, IDataElementType, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]


# values for enumeration 'esriRelationshipSplitPolicy'
esriRSPUseDefault = 1
esriRSPPreserveOnLargest = 2
esriRSPPreserveOnSmallest = 3
esriRSPPreserveOnAll = 4
esriRSPDeleteRelationship = 5
esriRSPDeleteParts = 6
esriRelationshipSplitPolicy = c_int # enum
class IDENetworkDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe network dataset data elements.'
    _iid_ = GUID('{71E4AA21-1957-4224-B505-984C189AA520}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriNetworkDatasetType'
esriNDTUnknown = 0
esriNDTGeodatabase = 1
esriNDTShapefile = 2
esriNDTSDC = 3
esriNetworkDatasetType = c_int # enum
class INetworkDirections(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the properties for setting up driving directions.'
    _iid_ = GUID('{ACDA7B59-B41F-48B8-A1CE-582FE481053F}')
    _idlflags_ = ['oleautomation']
IDENetworkDataset._methods_ = [
    COMMETHOD(['propget', helpstring(u'The type of the network dataset.')], HRESULT, 'NetworkType',
              ( ['retval', 'out'], POINTER(esriNetworkDatasetType), 'Type' )),
    COMMETHOD(['propput', helpstring(u'The type of the network dataset.')], HRESULT, 'NetworkType',
              ( ['in'], esriNetworkDatasetType, 'Type' )),
    COMMETHOD(['propget', helpstring(u'Array of network attributes in this network dataset.')], HRESULT, 'Attributes',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'Attributes' )),
    COMMETHOD(['propputref', helpstring(u'Array of network attributes in this network dataset.')], HRESULT, 'Attributes',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'Attributes' )),
    COMMETHOD(['propget', helpstring(u'The database configuration keyword for the network dataset.')], HRESULT, 'ConfigurationKeyword',
              ( ['retval', 'out'], POINTER(BSTR), 'ConfigKeyword' )),
    COMMETHOD(['propput', helpstring(u'The database configuration keyword for the network dataset.')], HRESULT, 'ConfigurationKeyword',
              ( ['in'], BSTR, 'ConfigKeyword' )),
    COMMETHOD(['propget', helpstring(u'Array of network sources in this network dataset.')], HRESULT, 'Sources',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'Sources' )),
    COMMETHOD(['propputref', helpstring(u'Array of network sources in this network dataset.')], HRESULT, 'Sources',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'Sources' )),
    COMMETHOD(['propget', helpstring(u'The driving directions settings for the network dataset.')], HRESULT, 'Directions',
              ( ['retval', 'out'], POINTER(POINTER(INetworkDirections)), 'Directions' )),
    COMMETHOD(['propputref', helpstring(u'The driving directions settings for the network dataset.')], HRESULT, 'Directions',
              ( ['in'], POINTER(INetworkDirections), 'Directions' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this network dataset supports network turn elements.')], HRESULT, 'SupportsTurns',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'SupportsTurns' )),
    COMMETHOD(['propput', helpstring(u'Indicates if this network dataset supports network turn elements.')], HRESULT, 'SupportsTurns',
              ( ['in'], VARIANT_BOOL, 'SupportsTurns' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this network dataset is buildable.')], HRESULT, 'Buildable',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'SupportsTurns' )),
    COMMETHOD(['propput', helpstring(u'Indicates if this network dataset is buildable.')], HRESULT, 'Buildable',
              ( ['in'], VARIANT_BOOL, 'SupportsTurns' )),
    COMMETHOD(['propget', helpstring(u'User specified property set of this network dataset.')], HRESULT, 'UserData',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'userProperties' )),
    COMMETHOD(['propput', helpstring(u'User specified property set of this network dataset.')], HRESULT, 'UserData',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'userProperties' )),
    COMMETHOD(['propget', helpstring(u'Property set of this network dataset.')], HRESULT, 'Properties',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'datasetProperties' )),
    COMMETHOD(['propput', helpstring(u'Property set of this network dataset.')], HRESULT, 'Properties',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'datasetProperties' )),
    COMMETHOD(['propget', helpstring(u'The network attribute that is used to optimize network building for hierarchical traversal.')], HRESULT, 'HierarchyClusterAttribute',
              ( ['retval', 'out'], POINTER(POINTER(INetworkAttribute)), 'Attribute' )),
    COMMETHOD(['propput', helpstring(u'The network attribute that is used to optimize network building for hierarchical traversal.')], HRESULT, 'HierarchyClusterAttribute',
              ( ['in'], POINTER(INetworkAttribute), 'Attribute' )),
    COMMETHOD(['propput', helpstring(u'The number of hierarchy levels in the network dataset.')], HRESULT, 'HierarchyLevelCount',
              ( ['in'], c_int, 'Count' )),
    COMMETHOD(['propget', helpstring(u'The number of hierarchy levels in the network dataset.')], HRESULT, 'HierarchyLevelCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propput', helpstring(u'The maximum value for the specified hierarchy level in the network dataset.')], HRESULT, 'MaxValueForHierarchy',
              ( ['in'], c_int, 'level' ),
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The maximum value for the specified hierarchy level in the network dataset.')], HRESULT, 'MaxValueForHierarchy',
              ( ['in'], c_int, 'level' ),
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
]
################################################################
## code template for IDENetworkDataset implementation
##class IDENetworkDataset_Impl(object):
##    def _get(self):
##        u'User specified property set of this network dataset.'
##        #return userProperties
##    def _set(self, userProperties):
##        u'User specified property set of this network dataset.'
##    UserData = property(_get, _set, doc = _set.__doc__)
##
##    def Attributes(self, Attributes):
##        u'Array of network attributes in this network dataset.'
##        #return 
##
##    def _get(self):
##        u'Indicates if this network dataset is buildable.'
##        #return SupportsTurns
##    def _set(self, SupportsTurns):
##        u'Indicates if this network dataset is buildable.'
##    Buildable = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self, level):
##        u'The maximum value for the specified hierarchy level in the network dataset.'
##        #return Value
##    def _set(self, level, Value):
##        u'The maximum value for the specified hierarchy level in the network dataset.'
##    MaxValueForHierarchy = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if this network dataset supports network turn elements.'
##        #return SupportsTurns
##    def _set(self, SupportsTurns):
##        u'Indicates if this network dataset supports network turn elements.'
##    SupportsTurns = property(_get, _set, doc = _set.__doc__)
##
##    def Sources(self, Sources):
##        u'Array of network sources in this network dataset.'
##        #return 
##
##    def _get(self):
##        u'The network attribute that is used to optimize network building for hierarchical traversal.'
##        #return Attribute
##    def _set(self, Attribute):
##        u'The network attribute that is used to optimize network building for hierarchical traversal.'
##    HierarchyClusterAttribute = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The number of hierarchy levels in the network dataset.'
##        #return Count
##    def _set(self, Count):
##        u'The number of hierarchy levels in the network dataset.'
##    HierarchyLevelCount = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The database configuration keyword for the network dataset.'
##        #return ConfigKeyword
##    def _set(self, ConfigKeyword):
##        u'The database configuration keyword for the network dataset.'
##    ConfigurationKeyword = property(_get, _set, doc = _set.__doc__)
##
##    def Directions(self, Directions):
##        u'The driving directions settings for the network dataset.'
##        #return 
##
##    def _get(self):
##        u'The type of the network dataset.'
##        #return Type
##    def _set(self, Type):
##        u'The type of the network dataset.'
##    NetworkType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Property set of this network dataset.'
##        #return datasetProperties
##    def _set(self, datasetProperties):
##        u'Property set of this network dataset.'
##    Properties = property(_get, _set, doc = _set.__doc__)
##

class DEWorkspace(CoClass):
    u'Database Data Element object.'
    _reg_clsid_ = GUID('{2127AF36-CAE1-427E-B1A8-BF0F1AD19F6E}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DEWorkspace._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEWorkspace3, IDataElement, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe]

class INetworkTurn2(INetworkTurn):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of this network turn element.'
    _iid_ = GUID('{FC74A0BD-1FA9-4669-A9FE-02833FF07547}')
    _idlflags_ = ['dual', 'oleautomation']
INetworkElement._methods_ = [
    COMMETHOD([dispid(10), helpstring(u'Element ID for this network element.'), 'propget'], HRESULT, 'EID',
              ( ['retval', 'out'], POINTER(c_int), 'EID' )),
    COMMETHOD([dispid(20), helpstring(u'Type of this network element.'), 'propget'], HRESULT, 'ElementType',
              ( ['retval', 'out'], POINTER(esriNetworkElementType), 'Type' )),
    COMMETHOD([dispid(30), helpstring(u'ID of the network dataset source from which this network element was derived.'), 'propget'], HRESULT, 'SourceID',
              ( ['retval', 'out'], POINTER(c_int), 'SourceID' )),
    COMMETHOD([dispid(40), helpstring(u'Object ID of the object corresponding to this network element.'), 'propget'], HRESULT, 'OID',
              ( ['retval', 'out'], POINTER(c_int), 'OID' )),
    COMMETHOD([dispid(50), helpstring(u'Value of this network element for the given network attribute ID.'), 'propget'], HRESULT, 'AttributeValue',
              ( ['in'], c_int, 'AttributeID' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'AttributeValue' )),
    COMMETHOD([dispid(60), helpstring(u'Value of this network element for the given network attribute name.'), 'propget'], HRESULT, 'AttributeValueByName',
              ( ['in'], BSTR, 'AttributeName' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'AttributeValue' )),
]
################################################################
## code template for INetworkElement implementation
##class INetworkElement_Impl(object):
##    @property
##    def AttributeValueByName(self, AttributeName):
##        u'Value of this network element for the given network attribute name.'
##        #return AttributeValue
##
##    @property
##    def SourceID(self):
##        u'ID of the network dataset source from which this network element was derived.'
##        #return SourceID
##
##    @property
##    def OID(self):
##        u'Object ID of the object corresponding to this network element.'
##        #return OID
##
##    @property
##    def EID(self):
##        u'Element ID for this network element.'
##        #return EID
##
##    @property
##    def ElementType(self):
##        u'Type of this network element.'
##        #return Type
##
##    @property
##    def AttributeValue(self, AttributeID):
##        u'Value of this network element for the given network attribute ID.'
##        #return AttributeValue
##


# values for enumeration 'esriNetworkTurnType'
esriNTTImplicit = 0
esriNTTExplicit = 1
esriNetworkTurnType = c_int # enum
INetworkTurn._methods_ = [
    COMMETHOD([dispid(100), helpstring(u'Type of network turn.'), 'propget'], HRESULT, 'TurnType',
              ( ['retval', 'out'], POINTER(esriNetworkTurnType), 'TurnType' )),
    COMMETHOD([dispid(110), helpstring(u'Queries the at-junction of this network turn.')], HRESULT, 'QueryAtJunction',
              ( ['in'], POINTER(INetworkJunction), 'Junction' )),
    COMMETHOD([dispid(120), helpstring(u'Angle of the turning movement described by this network turn.'), 'propget'], HRESULT, 'Angle',
              ( ['retval', 'out'], POINTER(c_double), 'Angle' )),
    COMMETHOD([dispid(130), helpstring(u'Number of network edge elements that participate in this network turn.'), 'propget'], HRESULT, 'EdgeCount',
              ( ['retval', 'out'], POINTER(c_int), 'EdgeCount' )),
    COMMETHOD([dispid(140), helpstring(u"Queries the index'th edge element of this network turn.")], HRESULT, 'QueryEdge',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(INetworkEdge), 'Edge' )),
]
################################################################
## code template for INetworkTurn implementation
##class INetworkTurn_Impl(object):
##    @property
##    def Angle(self):
##        u'Angle of the turning movement described by this network turn.'
##        #return Angle
##
##    def QueryEdge(self, Index, Edge):
##        u"Queries the index'th edge element of this network turn."
##        #return 
##
##    def QueryAtJunction(self, Junction):
##        u'Queries the at-junction of this network turn.'
##        #return 
##
##    @property
##    def TurnType(self):
##        u'Type of network turn.'
##        #return TurnType
##
##    @property
##    def EdgeCount(self):
##        u'Number of network edge elements that participate in this network turn.'
##        #return EdgeCount
##


# values for enumeration 'esriNetworkTimeUsage'
esriNTUBeforeTraversal = 1
esriNTUAfterTraversal = 2
esriNetworkTimeUsage = c_int # enum
INetworkTurn2._methods_ = [
    COMMETHOD([dispid(1610874880), helpstring(u'Value of this network element for the given network attribute ID and local time.'), 'propget'], HRESULT, 'AttributeValueAtTime',
              ( ['in'], c_int, 'AttributeID' ),
              ( ['in'], c_double, 'localTime' ),
              ( ['in'], esriNetworkTimeUsage, 'timeUsage' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'AttributeValue' )),
]
################################################################
## code template for INetworkTurn2 implementation
##class INetworkTurn2_Impl(object):
##    @property
##    def AttributeValueAtTime(self, AttributeID, localTime, timeUsage):
##        u'Value of this network element for the given network attribute ID and local time.'
##        #return AttributeValue
##

class IRasterDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control a raster dataset.'
    _iid_ = GUID('{7ACA3D01-0629-11D2-8D24-0000F8780535}')
    _idlflags_ = ['oleautomation']
class IRasterDataset2(IRasterDataset):
    _case_insensitive_ = True
    u'Provides access to members that control a raster dataset.'
    _iid_ = GUID('{76AA6A59-25B4-4F26-9079-7A634759FED9}')
    _idlflags_ = ['oleautomation']
class IRasterDataset3(IRasterDataset2):
    _case_insensitive_ = True
    u'Provides access to members that control a RasterDataset.'
    _iid_ = GUID('{2C046294-251C-43B4-8CFF-D80C24DEC088}')
    _idlflags_ = ['oleautomation']
class IRaster(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control an in-memory raster.'
    _iid_ = GUID('{AEEC7D31-1533-11D2-8D25-0000F8780535}')
    _idlflags_ = ['oleautomation']
IRasterDataset._methods_ = [
    COMMETHOD(['propget', helpstring(u'The format of this RasterRataset.')], HRESULT, 'Format',
              ( ['retval', 'out'], POINTER(BSTR), 'Format' )),
    COMMETHOD(['hidden', helpstring(u'The sensor type used for this RasterDataset.'), 'propget'], HRESULT, 'SensorType',
              ( ['retval', 'out'], POINTER(BSTR), 'SensorType' )),
    COMMETHOD(['propget', helpstring(u'The compression technique applied to this RasterDataset.')], HRESULT, 'CompressionType',
              ( ['retval', 'out'], POINTER(BSTR), 'comp' )),
    COMMETHOD([helpstring(u'Creates a raster object with the default properties for this dataset.')], HRESULT, 'CreateDefaultRaster',
              ( ['retval', 'out'], POINTER(POINTER(IRaster)), 'ras' )),
    COMMETHOD([helpstring(u'Returns true if this dataset can be copied.')], HRESULT, 'CanCopy',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanCopy' )),
    COMMETHOD([helpstring(u'Copies this dataset to a new dataset with the specified name.')], HRESULT, 'Copy',
              ( ['in'], BSTR, 'copyName' ),
              ( ['in'], POINTER(IWorkspace), 'copyWorkspace' ),
              ( ['retval', 'out'], POINTER(POINTER(IDataset)), 'CopyDataset' )),
    COMMETHOD([helpstring(u'Attaches dataset to a particular file.')], HRESULT, 'OpenFromFile',
              ( ['in'], BSTR, 'Path' )),
    COMMETHOD([helpstring(u'Calculates statistics and histograms for specified bands.')], HRESULT, 'PrecalculateStats',
              ( ['in'], VARIANT, 'index_list' )),
    COMMETHOD(['propget', helpstring(u'The full path of the RasterDataset.')], HRESULT, 'CompleteName',
              ( ['retval', 'out'], POINTER(BSTR), 'CompleteName' )),
    COMMETHOD([helpstring(u'Opens the dataset from file.')], HRESULT, 'BasicOpenFromFile',
              ( ['in'], BSTR, 'Path' )),
]
################################################################
## code template for IRasterDataset implementation
##class IRasterDataset_Impl(object):
##    @property
##    def CompleteName(self):
##        u'The full path of the RasterDataset.'
##        #return CompleteName
##
##    @property
##    def CompressionType(self):
##        u'The compression technique applied to this RasterDataset.'
##        #return comp
##
##    def CanCopy(self):
##        u'Returns true if this dataset can be copied.'
##        #return CanCopy
##
##    def PrecalculateStats(self, index_list):
##        u'Calculates statistics and histograms for specified bands.'
##        #return 
##
##    def OpenFromFile(self, Path):
##        u'Attaches dataset to a particular file.'
##        #return 
##
##    @property
##    def Format(self):
##        u'The format of this RasterRataset.'
##        #return Format
##
##    @property
##    def SensorType(self):
##        u'The sensor type used for this RasterDataset.'
##        #return SensorType
##
##    def CreateDefaultRaster(self):
##        u'Creates a raster object with the default properties for this dataset.'
##        #return ras
##
##    def Copy(self, copyName, copyWorkspace):
##        u'Copies this dataset to a new dataset with the specified name.'
##        #return CopyDataset
##
##    def BasicOpenFromFile(self, Path):
##        u'Opens the dataset from file.'
##        #return 
##

IRasterDataset2._methods_ = [
    COMMETHOD([helpstring(u'Creates an empty raster.')], HRESULT, 'CreateRaster',
              ( ['retval', 'out'], POINTER(POINTER(IRaster)), 'Raster' )),
    COMMETHOD([helpstring(u'Creates a raster containing all bands in this raster dataset.')], HRESULT, 'CreateFullRaster',
              ( ['retval', 'out'], POINTER(POINTER(IRaster)), 'Raster' )),
    COMMETHOD(['propget', helpstring(u'Indicates whether the raster dataset is empty.')], HRESULT, 'IsEmpty',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsEmpty' )),
]
################################################################
## code template for IRasterDataset2 implementation
##class IRasterDataset2_Impl(object):
##    @property
##    def IsEmpty(self):
##        u'Indicates whether the raster dataset is empty.'
##        #return IsEmpty
##
##    def CreateFullRaster(self):
##        u'Creates a raster containing all bands in this raster dataset.'
##        #return Raster
##
##    def CreateRaster(self):
##        u'Creates an empty raster.'
##        #return Raster
##

class IRasterLODInfos(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control custom Level of Details.'
    _iid_ = GUID('{2EE0F992-E4CB-429D-B663-7A12213B0CD1}')
    _idlflags_ = ['oleautomation']
class IPixelBlock(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control a PixelBlock.'
    _iid_ = GUID('{169BAFE0-40F6-11D2-9CFA-00A0249480F0}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriRasterWriteMode'
esriRasterWriteMosaic = 1
esriRasterWriteErase = 2
esriRasterWriteMode = c_int # enum
IRasterDataset3._methods_ = [
    COMMETHOD(['propget', helpstring(u'The native block width.')], HRESULT, 'BlockWidth',
              ( ['retval', 'out'], POINTER(c_int), 'Width' )),
    COMMETHOD(['propget', helpstring(u'The native block height.')], HRESULT, 'BlockHeight',
              ( ['retval', 'out'], POINTER(c_int), 'Height' )),
    COMMETHOD(['propget', helpstring(u'The maximum available pyramid level.')], HRESULT, 'MaximumPyramidLevel',
              ( ['retval', 'out'], POINTER(c_int), 'maxLevel' )),
    COMMETHOD(['propget', helpstring(u'The first available pyramid level.')], HRESULT, 'FirstPyramidLevel',
              ( ['retval', 'out'], POINTER(c_int), 'firstLevel' )),
    COMMETHOD(['propget', helpstring(u'The custom LOD infos.')], HRESULT, 'LODInfos',
              ( ['retval', 'out'], POINTER(POINTER(IRasterLODInfos)), 'LODInfos' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this RasterDataset is writable.')], HRESULT, 'CanWrite',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanWrite' )),
    COMMETHOD([helpstring(u'Reads a block of pixels starting from the top left corner.')], HRESULT, 'Read',
              ( ['in'], POINTER(IPnt), 'tlc' ),
              ( ['in'], POINTER(IRaster), 'Raster' ),
              ( ['in'], POINTER(IPixelBlock), 'PixelBlock' )),
    COMMETHOD([helpstring(u'Writes a block of pixels starting from the top left corner.')], HRESULT, 'Write',
              ( ['in'], POINTER(IPnt), 'tlc' ),
              ( ['in'], POINTER(IRaster), 'Raster' ),
              ( ['in'], esriRasterWriteMode, 'mode' ),
              ( ['in'], POINTER(IPixelBlock), 'PixelBlock' )),
    COMMETHOD([helpstring(u'Refreshes opened RasterDataset.')], HRESULT, 'Refresh'),
    COMMETHOD([helpstring(u'Reads a block of pixels at a given pyramid level.')], HRESULT, 'ReadPyramid',
              ( ['in'], POINTER(IPnt), 'tlc' ),
              ( ['in'], c_int, 'PyramidLevel' ),
              ( ['in'], POINTER(IRaster), 'Raster' ),
              ( ['in'], POINTER(IPixelBlock), 'PixelBlock' )),
]
################################################################
## code template for IRasterDataset3 implementation
##class IRasterDataset3_Impl(object):
##    @property
##    def FirstPyramidLevel(self):
##        u'The first available pyramid level.'
##        #return firstLevel
##
##    @property
##    def BlockWidth(self):
##        u'The native block width.'
##        #return Width
##
##    def Read(self, tlc, Raster, PixelBlock):
##        u'Reads a block of pixels starting from the top left corner.'
##        #return 
##
##    @property
##    def MaximumPyramidLevel(self):
##        u'The maximum available pyramid level.'
##        #return maxLevel
##
##    def Refresh(self):
##        u'Refreshes opened RasterDataset.'
##        #return 
##
##    @property
##    def LODInfos(self):
##        u'The custom LOD infos.'
##        #return LODInfos
##
##    def Write(self, tlc, Raster, mode, PixelBlock):
##        u'Writes a block of pixels starting from the top left corner.'
##        #return 
##
##    def ReadPyramid(self, tlc, PyramidLevel, Raster, PixelBlock):
##        u'Reads a block of pixels at a given pyramid level.'
##        #return 
##
##    @property
##    def CanWrite(self):
##        u'Indicates if this RasterDataset is writable.'
##        #return CanWrite
##
##    @property
##    def BlockHeight(self):
##        u'The native block height.'
##        #return Height
##

IEnumNetworkElement._methods_ = [
    COMMETHOD([helpstring(u'Forces the enumerator pointing before first network element; a subsequent next gives the first network element in the enumeration.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Moves the enumerator forward and returns the network element pointed by the enumerator using query semantics.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(INetworkElement)), 'Element' )),
]
################################################################
## code template for IEnumNetworkElement implementation
##class IEnumNetworkElement_Impl(object):
##    def Reset(self):
##        u'Forces the enumerator pointing before first network element; a subsequent next gives the first network element in the enumeration.'
##        #return 
##
##    def Next(self):
##        u'Moves the enumerator forward and returns the network element pointed by the enumerator using query semantics.'
##        #return Element
##

class IObjectClassValidation(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that validate row information.'
    _iid_ = GUID('{7AEE5F1A-A98B-11D2-AADA-00C04FA37B82}')
    _idlflags_ = ['oleautomation']
IObjectClassValidation._methods_ = [
    COMMETHOD([helpstring(u"Validates the row's specified attribute.")], HRESULT, 'ValidateField',
              ( ['in'], POINTER(IRow), 'Row' ),
              ( ['in'], BSTR, 'FieldName' ),
              ( ['retval', 'out'], POINTER(BSTR), 'errorMessage' )),
    COMMETHOD([helpstring(u'Validates the row.')], HRESULT, 'ValidateRow',
              ( ['in'], POINTER(IRow), 'Row' ),
              ( ['retval', 'out'], POINTER(BSTR), 'errorMessage' )),
]
################################################################
## code template for IObjectClassValidation implementation
##class IObjectClassValidation_Impl(object):
##    def ValidateField(self, Row, FieldName):
##        u"Validates the row's specified attribute."
##        #return errorMessage
##
##    def ValidateRow(self, Row):
##        u'Validates the row.'
##        #return errorMessage
##

INetworkForwardStar._methods_ = [
    COMMETHOD([helpstring(u'Finds all network elements that are adjacent to the given sequence of network elements.')], HRESULT, 'QueryAdjacencies',
              ( ['in'], POINTER(INetworkJunction), 'atJunction' ),
              ( ['in'], POINTER(INetworkEdge), 'fromEdge' ),
              ( ['in'], POINTER(INetworkEdge), 'lastExteriorEdge' ),
              ( ['in'], POINTER(INetworkForwardStarAdjacencies), 'adjacencies' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the given network element is filtered out from the adjacencies object.')], HRESULT, 'IsFiltered',
              ( ['in'], POINTER(INetworkElement), 'Element' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsFiltered' )),
]
################################################################
## code template for INetworkForwardStar implementation
##class INetworkForwardStar_Impl(object):
##    @property
##    def IsFiltered(self, Element):
##        u'Indicates if the given network element is filtered out from the adjacencies object.'
##        #return IsFiltered
##
##    def QueryAdjacencies(self, atJunction, fromEdge, lastExteriorEdge, adjacencies):
##        u'Finds all network elements that are adjacent to the given sequence of network elements.'
##        #return 
##

class IRandomAccessTable(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that support random access to a table.'
    _iid_ = GUID('{5735AF8F-9BAA-11D4-9F7C-00C04F6BDF0E}')
    _idlflags_ = ['oleautomation']
IRandomAccessTable._methods_ = [
    COMMETHOD([helpstring(u'Get a random access cursor on the table.')], HRESULT, 'GetRandomRows',
              ( ['in'], BSTR, 'SubFields' ),
              ( ['in'], VARIANT_BOOL, 'recycle' ),
              ( ['retval', 'out'], POINTER(POINTER(IRandomAccessCursor)), 'randomCursor' )),
]
################################################################
## code template for IRandomAccessTable implementation
##class IRandomAccessTable_Impl(object):
##    def GetRandomRows(self, SubFields, recycle):
##        u'Get a random access cursor on the table.'
##        #return randomCursor
##

class TinName(CoClass):
    u'The Esri TinName component.'
    _reg_clsid_ = GUID('{5F13F416-42BC-11D2-A569-0000F8774F0F}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IMetadata, IMetadataEdit, INativeTypeInfo]

class IXMLIndex(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'A XML Index defines the searchable tags of an XML document stored in an XML field.'
    _iid_ = GUID('{5240CEAA-366D-42ED-97FE-61DFB3C20248}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriXMLIndexType'
esriXMLIndexTypeAuto = 0
esriXMLIndexTypeAutoString = 1
esriXMLIndexTypeDefined = 2
esriXMLIndexTypeTemplate = 3
esriXMLIndexType = c_int # enum
class IXMLIndexTags(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Manages a collection of XML Index Tags.'
    _iid_ = GUID('{22715D9C-B744-453B-84E2-7CBEA383A70F}')
    _idlflags_ = ['oleautomation']
IXMLIndex._methods_ = [
    COMMETHOD(['propget', helpstring(u'The type of XML Index.')], HRESULT, 'XMLIndexType',
              ( ['retval', 'out'], POINTER(esriXMLIndexType), 'XMLIndexType' )),
    COMMETHOD(['propget', helpstring(u'The collection of included tags.')], HRESULT, 'IncludedTags',
              ( ['retval', 'out'], POINTER(POINTER(IXMLIndexTags)), 'Tags' )),
    COMMETHOD(['propget', helpstring(u'The collection of excluded tags.')], HRESULT, 'ExcludedTags',
              ( ['retval', 'out'], POINTER(POINTER(IXMLIndexTags)), 'Tags' )),
    COMMETHOD(['propget', helpstring(u'A textual description of the XML Index.')], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'indexDescription' )),
]
################################################################
## code template for IXMLIndex implementation
##class IXMLIndex_Impl(object):
##    @property
##    def XMLIndexType(self):
##        u'The type of XML Index.'
##        #return XMLIndexType
##
##    @property
##    def Description(self):
##        u'A textual description of the XML Index.'
##        #return indexDescription
##
##    @property
##    def ExcludedTags(self):
##        u'The collection of excluded tags.'
##        #return Tags
##
##    @property
##    def IncludedTags(self):
##        u'The collection of included tags.'
##        #return Tags
##

class IVersionedObject3(IVersionedObject2):
    _case_insensitive_ = True
    u'Provides access to members that manage a versioned object.'
    _iid_ = GUID('{092D0BF9-9E6C-42BE-AA79-2F8167E0FF75}')
    _idlflags_ = ['oleautomation']
IVersionedObject3._methods_ = [
    COMMETHOD([helpstring(u'Indicates if this object supports moving edits to base as a RegisterAsVersioned3 option.')], HRESULT, 'SupportsMovingEditsToBase',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanMove' )),
    COMMETHOD([helpstring(u'Register this object as versioned with the option to move edits to base.')], HRESULT, 'RegisterAsVersioned3',
              ( ['in'], VARIANT_BOOL, 'moveEditsToBase' )),
    COMMETHOD([helpstring(u'UnRegister this object as versioned with the option to compress the Default edits to base.')], HRESULT, 'UnRegisterAsVersioned3',
              ( ['in'], VARIANT_BOOL, 'compressDefault' )),
    COMMETHOD([helpstring(u'Indicates if this object is registered as versioned and is moving edits to base.')], HRESULT, 'GetVersionRegistrationInfo',
              ( ['out'], POINTER(VARIANT_BOOL), 'isRegistered' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'isMovingEditsToBase' )),
]
################################################################
## code template for IVersionedObject3 implementation
##class IVersionedObject3_Impl(object):
##    def GetVersionRegistrationInfo(self):
##        u'Indicates if this object is registered as versioned and is moving edits to base.'
##        #return isRegistered, isMovingEditsToBase
##
##    def UnRegisterAsVersioned3(self, compressDefault):
##        u'UnRegister this object as versioned with the option to compress the Default edits to base.'
##        #return 
##
##    def SupportsMovingEditsToBase(self):
##        u'Indicates if this object supports moving edits to base as a RegisterAsVersioned3 option.'
##        #return CanMove
##
##    def RegisterAsVersioned3(self, moveEditsToBase):
##        u'Register this object as versioned with the option to move edits to base.'
##        #return 
##

INetworkForwardStarAdjacencies._methods_ = [
    COMMETHOD(['propget', helpstring(u'Number of adjacent edges returned by the NetworkForwardStar object.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD([helpstring(u'Queries the junction element used as the atJunction in the NetworkForwardStar object.')], HRESULT, 'QueryAtJunction',
              ( ['in'], POINTER(INetworkJunction), 'Junction' )),
    COMMETHOD([helpstring(u'Queries the adjacent edge element at the specified index.')], HRESULT, 'QueryEdge',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(INetworkEdge), 'adjacentEdge' ),
              ( ['out'], POINTER(c_double), 'fromPosition' ),
              ( ['out'], POINTER(c_double), 'toPosition' )),
    COMMETHOD([helpstring(u'For the adjacent edge element at the specified index, queries the junction element opposite of the atJunction.')], HRESULT, 'QueryToJunction',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(INetworkJunction), 'adjacentJunction' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'IsFiltered' )),
    COMMETHOD([helpstring(u'Queries the turn element that passes through the fromEdge, the atJunction, and the adjacent edge at the specified index.')], HRESULT, 'QueryTurn',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(INetworkTurn), 'adjacentTurn' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the adjacent edge at the specified index has a turn.')], HRESULT, 'HasTurn',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasTurn' )),
    COMMETHOD(['propget', helpstring(u'Indicates if any of the adjacent edges are restricted due to a turn restriction.')], HRESULT, 'HasTurnRestriction',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasTurnRestriction' )),
]
################################################################
## code template for INetworkForwardStarAdjacencies implementation
##class INetworkForwardStarAdjacencies_Impl(object):
##    @property
##    def Count(self):
##        u'Number of adjacent edges returned by the NetworkForwardStar object.'
##        #return Count
##
##    def QueryTurn(self, Index, adjacentTurn):
##        u'Queries the turn element that passes through the fromEdge, the atJunction, and the adjacent edge at the specified index.'
##        #return 
##
##    def QueryAtJunction(self, Junction):
##        u'Queries the junction element used as the atJunction in the NetworkForwardStar object.'
##        #return 
##
##    def QueryToJunction(self, Index, adjacentJunction):
##        u'For the adjacent edge element at the specified index, queries the junction element opposite of the atJunction.'
##        #return IsFiltered
##
##    def QueryEdge(self, Index, adjacentEdge):
##        u'Queries the adjacent edge element at the specified index.'
##        #return fromPosition, toPosition
##
##    @property
##    def HasTurnRestriction(self):
##        u'Indicates if any of the adjacent edges are restricted due to a turn restriction.'
##        #return HasTurnRestriction
##
##    @property
##    def HasTurn(self, Index):
##        u'Indicates if the adjacent edge at the specified index has a turn.'
##        #return HasTurn
##

class IDEGeometricNetworkType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the Geometric Network Data Element Type.'
    _iid_ = GUID('{B4789B1D-FC20-446B-9A84-964491C6F6BA}')
    _idlflags_ = ['oleautomation']
IDEGeometricNetworkType._methods_ = [
]
################################################################
## code template for IDEGeometricNetworkType implementation
##class IDEGeometricNetworkType_Impl(object):

class IXMLIndexEdit(IXMLIndex):
    _case_insensitive_ = True
    u'A XML Index defines the searchable tags of an XML document stored in an XML field.'
    _iid_ = GUID('{537FC360-CC9B-4671-B155-07D141FE8D99}')
    _idlflags_ = ['oleautomation']
IXMLIndexEdit._methods_ = [
    COMMETHOD(['propput', helpstring(u'The type of XML Index.')], HRESULT, 'XMLIndexType',
              ( ['in'], esriXMLIndexType, 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The collection of included tags.')], HRESULT, 'IncludedTags',
              ( ['in'], POINTER(IXMLIndexTags), 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The collection of excluded tags.')], HRESULT, 'ExcludedTags',
              ( ['in'], POINTER(IXMLIndexTags), 'rhs' )),
    COMMETHOD(['propput', helpstring(u'A textual description of the XML Index.')], HRESULT, 'Description',
              ( ['in'], BSTR, 'rhs' )),
]
################################################################
## code template for IXMLIndexEdit implementation
##class IXMLIndexEdit_Impl(object):
##    def _set(self, rhs):
##        u'The type of XML Index.'
##    XMLIndexType = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'A textual description of the XML Index.'
##    Description = property(fset = _set, doc = _set.__doc__)
##
##    def ExcludedTags(self, rhs):
##        u'The collection of excluded tags.'
##        #return 
##
##    def IncludedTags(self, rhs):
##        u'The collection of included tags.'
##        #return 
##

class IInvalidObjectInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about the features that did not convert.'
    _iid_ = GUID('{49E8AE69-4F38-11D3-9FF8-00C04F6BDF0E}')
    _idlflags_ = ['oleautomation']
IEnumInvalidObject._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next invalid feature/row in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IInvalidObjectInfo)), 'invalidFeatureInfo' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumInvalidObject implementation
##class IEnumInvalidObject_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next invalid feature/row in the enumeration sequence.'
##        #return invalidFeatureInfo
##

class IArchivableObject(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{5A6D0742-CD6B-4502-9251-AF9CB7ACAD51}')
    _idlflags_ = ['oleautomation']
IArchivableObject._methods_ = [
    COMMETHOD(['propget', helpstring(u'True if this object has historical archiving enabled.')], HRESULT, 'IsArchiving',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsArchiving' )),
    COMMETHOD([helpstring(u'Enable historical archiving for this object.')], HRESULT, 'EnableArchiving',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'archiveRegistrationInfos' ),
              ( ['in'], VARIANT, 'SeedTimeStamp' ),
              ( [], VARIANT_BOOL, 'traverseRelationships' )),
    COMMETHOD([helpstring(u'Disable historical archiving for this object.')], HRESULT, 'DisableArchiving',
              ( ['in'], VARIANT_BOOL, 'deleteArchive' ),
              ( ['in'], VARIANT_BOOL, 'traverseRelationships' )),
]
################################################################
## code template for IArchivableObject implementation
##class IArchivableObject_Impl(object):
##    @property
##    def IsArchiving(self):
##        u'True if this object has historical archiving enabled.'
##        #return IsArchiving
##
##    def DisableArchiving(self, deleteArchive, traverseRelationships):
##        u'Disable historical archiving for this object.'
##        #return 
##
##    def EnableArchiving(self, archiveRegistrationInfos, SeedTimeStamp, traverseRelationships):
##        u'Enable historical archiving for this object.'
##        #return 
##

class DEFeatureClass(CoClass):
    u'Feature Class Data Element object.'
    _reg_clsid_ = GUID('{00BB7F40-3E51-4864-A66C-7F0C8EE9A842}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDEFeatureClass(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about feature class data elements.'
    _iid_ = GUID('{2C944211-D17C-45F4-89DA-AB37E95E6411}')
    _idlflags_ = ['oleautomation']
class IDEGdbFeatureClass(IDEFeatureClass):
    _case_insensitive_ = True
    u'Provides access to members that return information about geodatabase feature class data elements.'
    _iid_ = GUID('{1FFD96A0-1158-4FB1-9081-1E8F0F801761}')
    _idlflags_ = ['oleautomation']
class IDEGdbTable(IDETable):
    _case_insensitive_ = True
    u'Provides access to members that return information about geodatabase table data element.'
    _iid_ = GUID('{F35FE0CF-D9FC-4172-81F8-20CE5A553AB1}')
    _idlflags_ = ['oleautomation']
class IDEGdbTable2(IDEGdbTable):
    _case_insensitive_ = True
    u'Provides access to members that return information about geodatabase table data element.'
    _iid_ = GUID('{94BCAE52-2F1C-416D-835B-B206DA11F69B}')
    _idlflags_ = ['oleautomation']
class IDEEditorTracking(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about Editor Tracking properties in data element.'
    _iid_ = GUID('{E80995A9-FF03-43E6-A4A7-DC263E681565}')
    _idlflags_ = ['oleautomation']
DEFeatureClass._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEFeatureClass, IDETable, IDEGdbFeatureClass, IDEGdbTable2, IDEEditorTracking, IDEGeoDataset, IDEDataset2, IDataElement, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe]

class GPGeometricNetworkMembership(CoClass):
    u'The Geometric Network Membership object.'
    _reg_clsid_ = GUID('{7EE891D6-6ACD-4687-9BF4-FCE49FC47157}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGPControllerMembership(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Indicator interface for controller memberships.'
    _iid_ = GUID('{AC1BD3A5-AA1D-4B24-BB64-0554D59AF1FD}')
    _idlflags_ = ['oleautomation']
class IGPGeometricNetworkMembership(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to members that describe the properties of a feature class' geometric network membership."
    _iid_ = GUID('{D012D66D-49F4-409E-BF48-1DA710A8D414}')
    _idlflags_ = ['oleautomation']
GPGeometricNetworkMembership._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPControllerMembership, IGPGeometricNetworkMembership, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

IRowEvents._methods_ = [
    COMMETHOD([helpstring(u'An after event that is fired when a custom object is changed.')], HRESULT, 'OnChanged'),
    COMMETHOD([helpstring(u'An after event that is fired when a custom object is deleted.')], HRESULT, 'OnDelete'),
    COMMETHOD([helpstring(u'An after event that is fired when a custom object is initialized.')], HRESULT, 'OnInitialize'),
    COMMETHOD([helpstring(u'An after event that is fired when a custom object is Stored for the first time.')], HRESULT, 'OnNew'),
    COMMETHOD([helpstring(u'An after event that is fired when a custom object is validated.')], HRESULT, 'OnValidate'),
]
################################################################
## code template for IRowEvents implementation
##class IRowEvents_Impl(object):
##    def OnInitialize(self):
##        u'An after event that is fired when a custom object is initialized.'
##        #return 
##
##    def OnDelete(self):
##        u'An after event that is fired when a custom object is deleted.'
##        #return 
##
##    def OnChanged(self):
##        u'An after event that is fired when a custom object is changed.'
##        #return 
##
##    def OnNew(self):
##        u'An after event that is fired when a custom object is Stored for the first time.'
##        #return 
##
##    def OnValidate(self):
##        u'An after event that is fired when a custom object is validated.'
##        #return 
##

class IArchiveRegistrationInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'The properties used to register a dataset for archiving and for describing an already registered object.'
    _iid_ = GUID('{3112504B-A3C5-4729-AC3A-E2ABCD29E260}')
    _idlflags_ = ['oleautomation']
IArchiveRegistrationInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the dataset this registration information applies to.')], HRESULT, 'DatasetName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the dataset this registration information applies to.')], HRESULT, 'DatasetName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The name of the archive table.')], HRESULT, 'ArchiveTableName',
              ( ['retval', 'out'], POINTER(BSTR), 'ArchiveTableName' )),
    COMMETHOD(['propput', helpstring(u'The name of the archive table.')], HRESULT, 'ArchiveTableName',
              ( ['in'], BSTR, 'ArchiveTableName' )),
    COMMETHOD(['propget', helpstring(u'The name of the FROM field.')], HRESULT, 'FromFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'fromField' )),
    COMMETHOD(['propput', helpstring(u'The name of the FROM field.')], HRESULT, 'FromFieldName',
              ( ['in'], BSTR, 'fromField' )),
    COMMETHOD(['propget', helpstring(u'The name of the TO field.')], HRESULT, 'ToFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'toField' )),
    COMMETHOD(['propput', helpstring(u'The name of the TO field.')], HRESULT, 'ToFieldName',
              ( ['in'], BSTR, 'toField' )),
    COMMETHOD(['propget', helpstring(u'The name of the archive object id field.')], HRESULT, 'OIDFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'oidField' )),
    COMMETHOD(['propput', helpstring(u'The name of the archive object id field.')], HRESULT, 'OIDFieldName',
              ( ['in'], BSTR, 'oidField' )),
    COMMETHOD(['propget', helpstring(u'The initial timestamp when archiving was enabled.')], HRESULT, 'SeedTimeStamp',
              ( ['retval', 'out'], POINTER(VARIANT), 'seedStamp' )),
]
################################################################
## code template for IArchiveRegistrationInfo implementation
##class IArchiveRegistrationInfo_Impl(object):
##    def _get(self):
##        u'The name of the dataset this registration information applies to.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the dataset this registration information applies to.'
##    DatasetName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the archive table.'
##        #return ArchiveTableName
##    def _set(self, ArchiveTableName):
##        u'The name of the archive table.'
##    ArchiveTableName = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def SeedTimeStamp(self):
##        u'The initial timestamp when archiving was enabled.'
##        #return seedStamp
##
##    def _get(self):
##        u'The name of the FROM field.'
##        #return fromField
##    def _set(self, fromField):
##        u'The name of the FROM field.'
##    FromFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the TO field.'
##        #return toField
##    def _set(self, toField):
##        u'The name of the TO field.'
##    ToFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the archive object id field.'
##        #return oidField
##    def _set(self, oidField):
##        u'The name of the archive object id field.'
##    OIDFieldName = property(_get, _set, doc = _set.__doc__)
##


# values for enumeration 'esriNetworkDatasetState'
esriNDSUnbuilt = 0
esriNDSBuilt = 1
esriNDSEmpty = 2
esriNetworkDatasetState = c_int # enum
INetworkDataset._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if this network dataset is buildable.')], HRESULT, 'Buildable',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Buildable' )),
    COMMETHOD(['propget', helpstring(u'The type of the network dataset.')], HRESULT, 'NetworkType',
              ( ['retval', 'out'], POINTER(esriNetworkDatasetType), 'Type' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this network dataset supports network turn elements.')], HRESULT, 'SupportsTurns',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'SupportsTurns' )),
    COMMETHOD(['propget', helpstring(u'Network dataset attribute corresponding to the specified ID.')], HRESULT, 'AttributeByID',
              ( ['in'], c_int, 'ID' ),
              ( ['retval', 'out'], POINTER(POINTER(INetworkAttribute)), 'Attribute' )),
    COMMETHOD(['propget', helpstring(u'Network dataset attribute corresponding to the specified name.')], HRESULT, 'AttributeByName',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(INetworkAttribute)), 'Attribute' )),
    COMMETHOD(['propget', helpstring(u'Number of attributes in the network dataset.')], HRESULT, 'AttributeCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'Network dataset attribute by index.')], HRESULT, 'Attribute',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(INetworkAttribute)), 'Attribute' )),
    COMMETHOD(['propget', helpstring(u'Network dataset source corresponding to the specified ID.')], HRESULT, 'SourceByID',
              ( ['in'], c_int, 'ID' ),
              ( ['retval', 'out'], POINTER(POINTER(INetworkSource)), 'Source' )),
    COMMETHOD(['propget', helpstring(u'Network dataset source corresponding to the specified name.')], HRESULT, 'SourceByName',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(INetworkSource)), 'Source' )),
    COMMETHOD(['propget', helpstring(u'Number of sources in the network dataset.')], HRESULT, 'SourceCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'Network dataset source by index.')], HRESULT, 'Source',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(INetworkSource)), 'Source' )),
    COMMETHOD(['propget', helpstring(u'Indicates whether the network dataset is built or not.')], HRESULT, 'State',
              ( ['retval', 'out'], POINTER(esriNetworkDatasetState), 'State' )),
]
################################################################
## code template for INetworkDataset implementation
##class INetworkDataset_Impl(object):
##    @property
##    def AttributeByName(self, Name):
##        u'Network dataset attribute corresponding to the specified name.'
##        #return Attribute
##
##    @property
##    def SourceCount(self):
##        u'Number of sources in the network dataset.'
##        #return Count
##
##    @property
##    def Source(self, Index):
##        u'Network dataset source by index.'
##        #return Source
##
##    @property
##    def Attribute(self, Index):
##        u'Network dataset attribute by index.'
##        #return Attribute
##
##    @property
##    def AttributeCount(self):
##        u'Number of attributes in the network dataset.'
##        #return Count
##
##    @property
##    def SupportsTurns(self):
##        u'Indicates if this network dataset supports network turn elements.'
##        #return SupportsTurns
##
##    @property
##    def Buildable(self):
##        u'Indicates if this network dataset is buildable.'
##        #return Buildable
##
##    @property
##    def State(self):
##        u'Indicates whether the network dataset is built or not.'
##        #return State
##
##    @property
##    def AttributeByID(self, ID):
##        u'Network dataset attribute corresponding to the specified ID.'
##        #return Attribute
##
##    @property
##    def SourceByID(self, ID):
##        u'Network dataset source corresponding to the specified ID.'
##        #return Source
##
##    @property
##    def NetworkType(self):
##        u'The type of the network dataset.'
##        #return Type
##
##    @property
##    def SourceByName(self, Name):
##        u'Network dataset source corresponding to the specified name.'
##        #return Source
##

class RasterValue(CoClass):
    u'The Raster Value Class.'
    _reg_clsid_ = GUID('{93D0B191-6BF1-418F-AB89-6F290278C245}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IRasterValue(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control raster value.'
    _iid_ = GUID('{6B2D0243-7100-4E3F-AA02-5EC12DAF6980}')
    _idlflags_ = ['oleautomation']
class IRasterValue2(IRasterValue):
    _case_insensitive_ = True
    u'Provides access to additional members that control a raster value.'
    _iid_ = GUID('{4F128505-C63B-474B-9167-A92C8A90536A}')
    _idlflags_ = ['oleautomation']
RasterValue._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRasterValue, IRasterValue2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

class WorkspaceProperty(CoClass):
    u'Workspace Property object.'
    _reg_clsid_ = GUID('{2A07E8D8-309F-47F1-B9AE-C546ADD83A83}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IWorkspaceProperty(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the Workspace property object.'
    _iid_ = GUID('{7771B899-02CD-46D1-AAE1-5392B662C8D0}')
    _idlflags_ = ['oleautomation']
WorkspaceProperty._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IWorkspaceProperty]


# values for enumeration 'esriNetworkErrorType'
esriNETAll = 0
esriNETConnectivity = 1
esriNETAssociatedElements = 2
esriNETMissingAllElements = 3
esriNETMissingAnyElements = 4
esriNETDuplicateElements = 5
esriNETAssociatedWithInvalidElements = 6
esriNETAssociatedFeatures = 7
esriNETAssociatedWithMissingFeatures = 8
esriNETGeometry = 9
esriNETEmptyGeometry = 10
esriNETMultipartGeometry = 11
esriNETIdenticalStartStopVertex = 12
esriNETZeroLengthGeometry = 13
esriNETAssociatedWithSameFromToJunction = 14
esriNETMismatchedZValue = 15
esriNETStandaloneJunction = 16
esriNETEdgeTooSmall = 17
esriNETInvalidSubtypeValue = 18
esriNetworkErrorType = c_int # enum
class DERelationshipClass(CoClass):
    u'Relationship Class Data Element object.'
    _reg_clsid_ = GUID('{D41F5487-6B16-42FD-AB61-63A55B519B71}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDERelationshipClassEx(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe relationship class data elements.'
    _iid_ = GUID('{DA5F6014-AFE5-4F1B-9E9C-BA117CD4E594}')
    _idlflags_ = ['oleautomation']
class IDERelationshipClassEx2(IDERelationshipClassEx):
    _case_insensitive_ = True
    u'Provides access to members that describe relationship class data elements.'
    _iid_ = GUID('{AED8F280-FE0E-4B19-9C2A-1A227CD72EEC}')
    _idlflags_ = ['oleautomation']
DERelationshipClass._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDERelationshipClassEx2, IDETable, IDEGdbTable2, IDataElement, IDEDataset2, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe]

class IRasterDatasetEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control raster dataset level editing operations.'
    _iid_ = GUID('{BA86A917-98EC-4994-B692-760ABEDCC306}')
    _idlflags_ = ['oleautomation']
class IRasterDatasetEdit2(IRasterDatasetEdit):
    _case_insensitive_ = True
    u'Provides access to members that control editing of a RasterDataset.'
    _iid_ = GUID('{24217915-7F69-4317-B0E0-908400E578C4}')
    _idlflags_ = ['oleautomation']
class IRasterColormap(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control a raster colormap.'
    _iid_ = GUID('{7E7E6105-FA34-11D1-8D22-0000F8780535}')
    _idlflags_ = ['oleautomation']
IRasterDatasetEdit._methods_ = [
    COMMETHOD([helpstring(u'Mosaics a Raster into this RasterDataset.')], HRESULT, 'Mosaic',
              ( ['in'], POINTER(IRaster), 'Raster' ),
              ( ['in'], c_double, 'tolerance' )),
    COMMETHOD([helpstring(u'Mosaics a Raster into this RasterDataset at a given starting band index.')], HRESULT, 'MosaicBands',
              ( ['in'], POINTER(IRaster), 'Raster' ),
              ( ['in'], c_int, 'start' ),
              ( ['in'], c_double, 'tolerance' )),
    COMMETHOD([helpstring(u'Erases a rectanglar area of this RasterDataset.')], HRESULT, 'Erase',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'Extent' )),
    COMMETHOD([helpstring(u'Calculates statistics and histograms from a given pyramid level.')], HRESULT, 'ComputeStats',
              ( ['in'], c_int, 'PyramidLevel' )),
    COMMETHOD([helpstring(u'Deletes statistics and histograms.')], HRESULT, 'DeleteStats'),
    COMMETHOD([helpstring(u'Alters colormap.')], HRESULT, 'AlterColormap',
              ( ['in'], POINTER(IRasterColormap), 'Colormap' )),
    COMMETHOD([helpstring(u'Deletes colormap.')], HRESULT, 'DeleteColormap'),
    COMMETHOD([helpstring(u'Appends a new raster band.')], HRESULT, 'AppendNewBand'),
]
################################################################
## code template for IRasterDatasetEdit implementation
##class IRasterDatasetEdit_Impl(object):
##    def DeleteColormap(self):
##        u'Deletes colormap.'
##        #return 
##
##    def AlterColormap(self, Colormap):
##        u'Alters colormap.'
##        #return 
##
##    def AppendNewBand(self):
##        u'Appends a new raster band.'
##        #return 
##
##    def MosaicBands(self, Raster, start, tolerance):
##        u'Mosaics a Raster into this RasterDataset at a given starting band index.'
##        #return 
##
##    def Erase(self, Extent):
##        u'Erases a rectanglar area of this RasterDataset.'
##        #return 
##
##    def ComputeStats(self, PyramidLevel):
##        u'Calculates statistics and histograms from a given pyramid level.'
##        #return 
##
##    def DeleteStats(self):
##        u'Deletes statistics and histograms.'
##        #return 
##
##    def Mosaic(self, Raster, tolerance):
##        u'Mosaics a Raster into this RasterDataset.'
##        #return 
##

IRasterDatasetEdit2._methods_ = [
    COMMETHOD([helpstring(u'Alters the raster attribute table.')], HRESULT, 'AlterAttributeTable',
              ( ['in'], POINTER(ITable), 'newTable' )),
    COMMETHOD([helpstring(u'Deletes the raster attribute table.')], HRESULT, 'DeleteAttributeTable'),
    COMMETHOD(['propget', helpstring(u'Indicates if the raster attribute table can be altered.')], HRESULT, 'CanAlterAttributeTable',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'canAlter' )),
    COMMETHOD([helpstring(u'Builds the raster attribute table.')], HRESULT, 'BuildAttributeTable'),
]
################################################################
## code template for IRasterDatasetEdit2 implementation
##class IRasterDatasetEdit2_Impl(object):
##    @property
##    def CanAlterAttributeTable(self):
##        u'Indicates if the raster attribute table can be altered.'
##        #return canAlter
##
##    def BuildAttributeTable(self):
##        u'Builds the raster attribute table.'
##        #return 
##
##    def DeleteAttributeTable(self):
##        u'Deletes the raster attribute table.'
##        #return 
##
##    def AlterAttributeTable(self, newTable):
##        u'Alters the raster attribute table.'
##        #return 
##

class IRasterDatasetEdit3(IRasterDatasetEdit2):
    _case_insensitive_ = True
    u'Provides access to members that control editing of a RasterDataset.'
    _iid_ = GUID('{8E68E3DA-30D6-492B-B12E-CA2669A106EF}')
    _idlflags_ = ['oleautomation']
IRasterDatasetEdit3._methods_ = [
    COMMETHOD([helpstring(u'Computes statistics and histogram for a skip factor and a list of Ignore vlaues.')], HRESULT, 'ComputeStatisticsHistogram',
              ( ['in'], c_int, 'skipx' ),
              ( ['in'], c_int, 'skipy' ),
              ( ['in'], VARIANT, 'ignoreValues' ),
              ( ['in'], VARIANT_BOOL, 'requireHistogram' )),
]
################################################################
## code template for IRasterDatasetEdit3 implementation
##class IRasterDatasetEdit3_Impl(object):
##    def ComputeStatisticsHistogram(self, skipx, skipy, ignoreValues, requireHistogram):
##        u'Computes statistics and histogram for a skip factor and a list of Ignore vlaues.'
##        #return 
##

class IXMLIndexUtil(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'XML Index Utilities.'
    _iid_ = GUID('{15B08BC9-9C06-47A2-830F-D4FFF1270131}')
    _idlflags_ = ['oleautomation']
IXMLIndexUtil._methods_ = [
    COMMETHOD([helpstring(u'Loads the collection of tags from an XML document.')], HRESULT, 'LoadTags',
              ( ['in'], BSTR, 'xml' ),
              ( ['in'], POINTER(IXMLIndexTags), 'Tags' )),
    COMMETHOD([], HRESULT, 'SynchronizeTextIndex',
              ( ['in'], BSTR, 'ClassName' ),
              ( ['in'], BSTR, 'xmlFieldName' )),
]
################################################################
## code template for IXMLIndexUtil implementation
##class IXMLIndexUtil_Impl(object):
##    def SynchronizeTextIndex(self, ClassName, xmlFieldName):
##        '-no docstring-'
##        #return 
##
##    def LoadTags(self, xml, Tags):
##        u'Loads the collection of tags from an XML document.'
##        #return 
##

class IFileDataLock(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to file data sources data lock functionality.'
    _iid_ = GUID('{ADF6D66D-A47A-11D4-9F87-00C04F6BDF0E}')
    _idlflags_ = ['oleautomation']
IFileDataLock._methods_ = [
    COMMETHOD([helpstring(u'Acquire a file data lock.')], HRESULT, 'AcquireFileLock',
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.esriLockMgrType, 'LockType' )),
    COMMETHOD([helpstring(u'Release a file data lock.')], HRESULT, 'ReleaseFileLock'),
    COMMETHOD([helpstring(u'Change the file data lock type.')], HRESULT, 'ChangeFileLock',
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.esriLockMgrType, 'LockType' )),
    COMMETHOD([helpstring(u'Get the lock type.')], HRESULT, 'GetLockType',
              ( ['retval', 'out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.esriLockMgrType), 'LockType' )),
]
################################################################
## code template for IFileDataLock implementation
##class IFileDataLock_Impl(object):
##    def AcquireFileLock(self, LockType):
##        u'Acquire a file data lock.'
##        #return 
##
##    def GetLockType(self):
##        u'Get the lock type.'
##        #return LockType
##
##    def ReleaseFileLock(self):
##        u'Release a file data lock.'
##        #return 
##
##    def ChangeFileLock(self, LockType):
##        u'Change the file data lock type.'
##        #return 
##

class IRasterDef2(IRasterDef):
    _case_insensitive_ = True
    u'Provides access to members that control raster column definition.'
    _iid_ = GUID('{16C76984-E0E8-4112-80C9-E052C9B9C9D2}')
    _idlflags_ = ['oleautomation']
class IRasterDef3(IRasterDef2):
    _case_insensitive_ = True
    u'Provides access to members that control raster column definition.'
    _iid_ = GUID('{E7841A16-32CF-4E95-8530-0D778D3D25B2}')
    _idlflags_ = ['oleautomation']
IRasterDef2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the Raster column value stores function dataset.')], HRESULT, 'IsFunction',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pIsFunction' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the Raster column value stores function dataset.')], HRESULT, 'IsFunction',
              ( ['in'], VARIANT_BOOL, 'pIsFunction' )),
]
################################################################
## code template for IRasterDef2 implementation
##class IRasterDef2_Impl(object):
##    def _get(self):
##        u'Indicates if the Raster column value stores function dataset.'
##        #return pIsFunction
##    def _set(self, pIsFunction):
##        u'Indicates if the Raster column value stores function dataset.'
##    IsFunction = property(_get, _set, doc = _set.__doc__)
##

IRasterDef3._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the raster is stored as inline dataset.')], HRESULT, 'IsInline',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pIsInline' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the raster is stored as inline dataset.')], HRESULT, 'IsInline',
              ( ['in'], VARIANT_BOOL, 'pIsInline' )),
]
################################################################
## code template for IRasterDef3 implementation
##class IRasterDef3_Impl(object):
##    def _get(self):
##        u'Indicates if the raster is stored as inline dataset.'
##        #return pIsInline
##    def _set(self, pIsInline):
##        u'Indicates if the raster is stored as inline dataset.'
##    IsInline = property(_get, _set, doc = _set.__doc__)
##

class GPDataTypeName(CoClass):
    _reg_clsid_ = GUID('{960CB02A-8CAF-442B-ACF7-6B6256FC19F9}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGPName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to properties of a Geoprocessing Name.'
    _iid_ = GUID('{17A47938-E1ED-4D82-A1D1-D274465FCBC4}')
    _idlflags_ = ['oleautomation']
class IGPDataTypeName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to Data Type Name.'
    _iid_ = GUID('{DF228952-8E0A-408E-9873-CE8341EF7D57}')
    _idlflags_ = ['oleautomation']
GPDataTypeName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IGPName, IGPDataTypeName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

class IRasterStorageDef(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control raster storage properties.'
    _iid_ = GUID('{30B9828A-85A6-4228-A7A4-7AFB8A9842CC}')
    _idlflags_ = ['oleautomation']
class IRasterStorageDef2(IRasterStorageDef):
    _case_insensitive_ = True
    u'Provides access to members that control raster storage properties.'
    _iid_ = GUID('{5AA61692-EB96-4DCD-9FB9-310869D5620D}')
    _idlflags_ = ['oleautomation']
IRasterStorageDef._methods_ = [
    COMMETHOD(['propput', helpstring(u'The raster storage tile width.')], HRESULT, 'TileWidth',
              ( ['in'], c_int, 'Width' )),
    COMMETHOD(['propget', helpstring(u'The raster storage tile width.')], HRESULT, 'TileWidth',
              ( ['retval', 'out'], POINTER(c_int), 'Width' )),
    COMMETHOD(['propput', helpstring(u'The raster storage tile height.')], HRESULT, 'TileHeight',
              ( ['in'], c_int, 'Height' )),
    COMMETHOD(['propget', helpstring(u'The raster storage tile height.')], HRESULT, 'TileHeight',
              ( ['retval', 'out'], POINTER(c_int), 'Height' )),
    COMMETHOD(['propput', helpstring(u'The method used for pyramid resampling.')], HRESULT, 'PyramidResampleType',
              ( ['in'], rstResamplingTypes, 'method' )),
    COMMETHOD(['propget', helpstring(u'The method used for pyramid resampling.')], HRESULT, 'PyramidResampleType',
              ( ['retval', 'out'], POINTER(rstResamplingTypes), 'method' )),
    COMMETHOD(['propput', helpstring(u'The number of pyramid levels.')], HRESULT, 'PyramidLevel',
              ( ['in'], c_int, 'level' )),
    COMMETHOD(['propget', helpstring(u'The number of pyramid levels.')], HRESULT, 'PyramidLevel',
              ( ['retval', 'out'], POINTER(c_int), 'level' )),
    COMMETHOD(['propput', helpstring(u'The compression type to be applied on the raster being stored.')], HRESULT, 'CompressionType',
              ( ['in'], esriRasterCompressionType, 'Type' )),
    COMMETHOD(['propget', helpstring(u'The compression type to be applied on the raster being stored.')], HRESULT, 'CompressionType',
              ( ['retval', 'out'], POINTER(esriRasterCompressionType), 'Type' )),
    COMMETHOD(['propput', helpstring(u'The compression quality (in case of JPEG compression) to be applied to the raster being stored.')], HRESULT, 'CompressionQuality',
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The compression quality (in case of JPEG compression) to be applied to the raster being stored.')], HRESULT, 'CompressionQuality',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propputref', helpstring(u'The origin of the raster to be stored.')], HRESULT, 'Origin',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'Origin' )),
    COMMETHOD(['propget', helpstring(u'The origin of the raster to be stored.')], HRESULT, 'Origin',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint)), 'Origin' )),
    COMMETHOD(['propputref', helpstring(u'The cell size of the raster to be stored.')], HRESULT, 'CellSize',
              ( ['in'], POINTER(IPnt), 'CellSize' )),
    COMMETHOD(['propget', helpstring(u'The cell size of the raster to be stored.')], HRESULT, 'CellSize',
              ( ['retval', 'out'], POINTER(POINTER(IPnt)), 'CellSize' )),
]
################################################################
## code template for IRasterStorageDef implementation
##class IRasterStorageDef_Impl(object):
##    @property
##    def Origin(self, Origin):
##        u'The origin of the raster to be stored.'
##        #return 
##
##    def _get(self):
##        u'The compression type to be applied on the raster being stored.'
##        #return Type
##    def _set(self, Type):
##        u'The compression type to be applied on the raster being stored.'
##    CompressionType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The raster storage tile height.'
##        #return Height
##    def _set(self, Height):
##        u'The raster storage tile height.'
##    TileHeight = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The raster storage tile width.'
##        #return Width
##    def _set(self, Width):
##        u'The raster storage tile width.'
##    TileWidth = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The number of pyramid levels.'
##        #return level
##    def _set(self, level):
##        u'The number of pyramid levels.'
##    PyramidLevel = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The compression quality (in case of JPEG compression) to be applied to the raster being stored.'
##        #return Value
##    def _set(self, Value):
##        u'The compression quality (in case of JPEG compression) to be applied to the raster being stored.'
##    CompressionQuality = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def CellSize(self, CellSize):
##        u'The cell size of the raster to be stored.'
##        #return 
##
##    def _get(self):
##        u'The method used for pyramid resampling.'
##        #return method
##    def _set(self, method):
##        u'The method used for pyramid resampling.'
##    PyramidResampleType = property(_get, _set, doc = _set.__doc__)
##

IRasterStorageDef2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if output raster dataset should be tiled if applicable.')], HRESULT, 'Tiled',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Tiled' )),
    COMMETHOD(['propput', helpstring(u'Indicates if output raster dataset should be tiled if applicable.')], HRESULT, 'Tiled',
              ( ['in'], VARIANT_BOOL, 'Tiled' )),
]
################################################################
## code template for IRasterStorageDef2 implementation
##class IRasterStorageDef2_Impl(object):
##    def _get(self):
##        u'Indicates if output raster dataset should be tiled if applicable.'
##        #return Tiled
##    def _set(self, Tiled):
##        u'Indicates if output raster dataset should be tiled if applicable.'
##    Tiled = property(_get, _set, doc = _set.__doc__)
##

IRowChanges._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates whether the value of the field at the specified index has changed since the last call to Store on the Row object.')], HRESULT, 'ValueChanged',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'changed' )),
    COMMETHOD(['propget', helpstring(u'The value of the field at the specified index immediately after the last call to Store on the Row object.')], HRESULT, 'OriginalValue',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
]
################################################################
## code template for IRowChanges implementation
##class IRowChanges_Impl(object):
##    @property
##    def ValueChanged(self, Index):
##        u'Indicates whether the value of the field at the specified index has changed since the last call to Store on the Row object.'
##        #return changed
##
##    @property
##    def OriginalValue(self, Index):
##        u'The value of the field at the specified index immediately after the last call to Store on the Row object.'
##        #return Value
##

INetworkDirections._methods_ = [
    COMMETHOD(['propget', helpstring(u'The default length units that will be used for reporting distances in driving directions.')], HRESULT, 'DefaultOutputLengthUnits',
              ( ['retval', 'out'], POINTER(esriNetworkAttributeUnits), 'Units' )),
    COMMETHOD(['propput', helpstring(u'The default length units that will be used for reporting distances in driving directions.')], HRESULT, 'DefaultOutputLengthUnits',
              ( ['in'], esriNetworkAttributeUnits, 'Units' )),
    COMMETHOD(['propget', helpstring(u'The name of the network attribute to be used for reporting travel distances.')], HRESULT, 'LengthAttributeName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the network attribute to be used for reporting travel distances.')], HRESULT, 'LengthAttributeName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The name of the network attribute to be used for reporting travel time.')], HRESULT, 'TimeAttributeName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the network attribute to be used for reporting travel time.')], HRESULT, 'TimeAttributeName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The name of the network attribute to be used for road classification.')], HRESULT, 'RoadClassAttributeName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the network attribute to be used for road classification.')], HRESULT, 'RoadClassAttributeName',
              ( ['in'], BSTR, 'Name' )),
]
################################################################
## code template for INetworkDirections implementation
##class INetworkDirections_Impl(object):
##    def _get(self):
##        u'The name of the network attribute to be used for reporting travel time.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the network attribute to be used for reporting travel time.'
##    TimeAttributeName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The default length units that will be used for reporting distances in driving directions.'
##        #return Units
##    def _set(self, Units):
##        u'The default length units that will be used for reporting distances in driving directions.'
##    DefaultOutputLengthUnits = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the network attribute to be used for reporting travel distances.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the network attribute to be used for reporting travel distances.'
##    LengthAttributeName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the network attribute to be used for road classification.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the network attribute to be used for road classification.'
##    RoadClassAttributeName = property(_get, _set, doc = _set.__doc__)
##

IFeatureEvents._methods_ = [
    COMMETHOD([helpstring(u'Initialize the shape.')], HRESULT, 'InitShape'),
    COMMETHOD([helpstring(u'An after event that is fired when a Feature is split, on the deleted input Feature.')], HRESULT, 'OnSplit'),
    COMMETHOD([helpstring(u'An after event that is fired when Features have been merged, on each deleted input Feature.')], HRESULT, 'OnMerge'),
]
################################################################
## code template for IFeatureEvents implementation
##class IFeatureEvents_Impl(object):
##    def OnSplit(self):
##        u'An after event that is fired when a Feature is split, on the deleted input Feature.'
##        #return 
##
##    def InitShape(self):
##        u'Initialize the shape.'
##        #return 
##
##    def OnMerge(self):
##        u'An after event that is fired when Features have been merged, on each deleted input Feature.'
##        #return 
##

class WorkspaceEditEvents(CoClass):
    u'WorkspaceEditEvents Class.'
    _reg_clsid_ = GUID('{849FC785-8D9E-11D4-9FD8-00C04F6BDF0C}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IWorkspaceEditEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that occur to a workspace in the context of editing it.'
    _iid_ = GUID('{0B437962-89F9-11D4-8B5F-000000000000}')
    _idlflags_ = ['oleautomation']
WorkspaceEditEvents._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown]
WorkspaceEditEvents._outgoing_interfaces_ = [IWorkspaceEditEvents]

class IRasterStorageDef3(IRasterStorageDef2):
    _case_insensitive_ = True
    u'Provides access to members that control raster storage properties.'
    _iid_ = GUID('{27CEA6D0-6D18-4ED4-AE3A-0861AD0CAF4B}')
    _idlflags_ = ['oleautomation']
IRasterStorageDef3._methods_ = [
    COMMETHOD(['propget', helpstring(u'A list of format specific creation options (<Name>=<Value>,... ).')], HRESULT, 'CreationOptions',
              ( ['retval', 'out'], POINTER(BSTR), 'pOptions' )),
    COMMETHOD(['propput', helpstring(u'A list of format specific creation options (<Name>=<Value>,... ).')], HRESULT, 'CreationOptions',
              ( ['in'], BSTR, 'pOptions' )),
]
################################################################
## code template for IRasterStorageDef3 implementation
##class IRasterStorageDef3_Impl(object):
##    def _get(self):
##        u'A list of format specific creation options (<Name>=<Value>,... ).'
##        #return pOptions
##    def _set(self, pOptions):
##        u'A list of format specific creation options (<Name>=<Value>,... ).'
##    CreationOptions = property(_get, _set, doc = _set.__doc__)
##

class Workspace(CoClass):
    u'Workspace Object.'
    _reg_clsid_ = GUID('{FBF5715B-A05D-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDatasetContainer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to adding datasets to the dataset container.'
    _iid_ = GUID('{BD770969-EFB7-11D3-9FA2-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
class IFeatureWorkspace(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that create and open various types of datasets and other workspace level objects.'
    _iid_ = GUID('{D9CAB491-3F69-11D1-B095-0000F8780820}')
    _idlflags_ = ['oleautomation']
class IFeatureWorkspaceSchemaEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to altering the instance CLSID and the class extension CLSID.'
    _iid_ = GUID('{74996427-6627-11D3-80D3-00C04F686238}')
    _idlflags_ = ['oleautomation']
class IGeodatabaseRelease(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that provide information about the release version of a geodatabase.'
    _iid_ = GUID('{FE8F2FEC-85AE-11D4-A0CA-00C04F6BDD84}')
    _idlflags_ = ['oleautomation']
class ITransactions(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control Transaction management.'
    _iid_ = GUID('{F05D9BC1-D03C-11D1-887F-0000F877762D}')
    _idlflags_ = ['oleautomation']
class ITransactionsOptions(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control Transaction options.'
    _iid_ = GUID('{6E45153F-DF82-11D1-AA82-00C04FA37585}')
    _idlflags_ = ['oleautomation']
class IWorkspaceDomains2(IWorkspaceDomains):
    _case_insensitive_ = True
    u'Provides access to members that allow you to alter a domain.'
    _iid_ = GUID('{56A5E6D4-01C6-11D4-A057-00C04F6BDD84}')
    _idlflags_ = ['oleautomation']
class IWorkspaceDomains3(IWorkspaceDomains2):
    _case_insensitive_ = True
    u'Provides access to members that allow you to alter a domain.'
    _iid_ = GUID('{7FD9B83C-76C0-4998-B9D3-AFE9600B5D36}')
    _idlflags_ = ['oleautomation']
class ISpatialCacheManager(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the Spatial Cache Management.'
    _iid_ = GUID('{E2E4622F-55B4-11D3-9F77-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
class ISpatialCacheManager2(ISpatialCacheManager):
    _case_insensitive_ = True
    u'Provides access to members that control the Spatial Cache Management.'
    _iid_ = GUID('{9078F181-BB75-11D4-9FEB-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
class IFeatureWorkspaceAnno(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to creating an annotation class as well as managing a symbol collection.'
    _iid_ = GUID('{14EB5331-CA80-11D2-8A2F-006097AFF44E}')
    _idlflags_ = ['oleautomation']
class IDatabaseCompact(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for compacting a file or personal geodatabase.'
    _iid_ = GUID('{660214D1-7C1B-11D3-80EA-00C04F686238}')
    _idlflags_ = ['oleautomation']
class ISQLSyntax(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that supply information about SQL functionality.'
    _iid_ = GUID('{18E2854E-EDC8-11D2-AAEF-00C04FA37849}')
    _idlflags_ = ['oleautomation']
class IWorkspaceConfiguration(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to configuration keywords.'
    _iid_ = GUID('{9E8F5C35-7888-4DF9-862C-9DD74EFF9062}')
    _idlflags_ = ['oleautomation']
class IWorkspaceSpatialReferenceInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to spatial reference information for the workspace.'
    _iid_ = GUID('{89890719-42D8-11D4-8145-00C04F686238}')
    _idlflags_ = ['oleautomation']
class IWorkspaceExtensionManager(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage a workspace extension.'
    _iid_ = GUID('{B2119283-0CD1-11D4-9FAC-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
class IDatabaseConnectionInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to members that provide information about the Workspace's connected database."
    _iid_ = GUID('{2808CAD6-E0FA-4478-BE5B-0E645A2BC7ED}')
    _idlflags_ = ['oleautomation']
class IRasterWorkspaceEx(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that create and open raster catalogs and datasets.'
    _iid_ = GUID('{C8778A65-0E27-4CB5-9A50-A7471B398EA7}')
    _idlflags_ = ['oleautomation']
class IWorkspaceEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that may be fired by a Workspace.'
    _iid_ = GUID('{DA10C1C4-09A3-11D4-9FAA-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
class IWorkspaceEvents2(IWorkspaceEvents):
    _case_insensitive_ = True
    u'Provides access to events that may be fired by a Workspace.'
    _iid_ = GUID('{AA21C2D4-12A3-D1D4-901A-80305F60DFCA}')
    _idlflags_ = ['oleautomation']
class IWorkspaceReplicaDatasets(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return a list of replica datasets.'
    _iid_ = GUID('{95F9E91D-885B-4F0E-9873-D66F5409EE41}')
    _idlflags_ = ['oleautomation']
Workspace._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IWorkspace, IWorkspace2, IDataset, IDatasetContainer, IWorkspaceEdit, IWorkspaceEditControl, IFeatureWorkspace, IFeatureWorkspaceManage, IFeatureWorkspaceSchemaEdit, IGeodatabaseRelease, ITransactions, ITransactionsOptions, IWorkspaceDomains, IWorkspaceDomains2, IWorkspaceDomains3, ISpatialCacheManager, ISpatialCacheManager2, IFeatureWorkspaceAnno, IDatabaseCompact, ISQLSyntax, IWorkspaceConfiguration, IWorkspaceSpatialReferenceInfo, IWorkspaceExtensionManager, IDatabaseConnectionInfo, IRasterWorkspaceEx, IWorkspaceReplicas, IWorkspaceReplicasAdmin, IWorkspaceReplicasAdmin2, IWorkspaceReplicasAdmin3, IWorkspaceReplicaDatasets, ITopologyWorkspace]
Workspace._outgoing_interfaces_ = [IWorkspaceEvents, IWorkspaceEvents2]

class GPMessages(CoClass):
    _reg_clsid_ = GUID('{6D59957C-EAD2-491B-963C-2C41FEB79C2F}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGPMessages(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to Geoprocessor messages.'
    _iid_ = GUID('{0696AA9D-C26B-4A3E-89B7-3763EA11F16C}')
    _idlflags_ = ['oleautomation']
GPMessages._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IDispatch, IGPMessage, IGPMessages, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize]

class IRasterCatalogItem(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control a raster catalog item.'
    _iid_ = GUID('{6E0577D2-8FE5-44D6-B18C-222687A19025}')
    _idlflags_ = ['oleautomation']
IRasterCatalogItem._methods_ = [
    COMMETHOD(['propget', helpstring(u'The raster dataset of the raster catalog feature.')], HRESULT, 'RasterDataset',
              ( ['retval', 'out'], POINTER(POINTER(IRasterDataset)), 'Dataset' )),
    COMMETHOD(['propputref', helpstring(u'The raster dataset of the raster catalog feature.')], HRESULT, 'RasterDataset',
              ( ['in'], POINTER(IRasterDataset), 'Dataset' )),
]
################################################################
## code template for IRasterCatalogItem implementation
##class IRasterCatalogItem_Impl(object):
##    def RasterDataset(self, Dataset):
##        u'The raster dataset of the raster catalog feature.'
##        #return 
##

IDatabaseCompact._methods_ = [
    COMMETHOD([helpstring(u'Compacts the database.')], HRESULT, 'Compact'),
    COMMETHOD([helpstring(u'True if this dataset can be compacted.')], HRESULT, 'CanCompact',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanCompact' )),
]
################################################################
## code template for IDatabaseCompact implementation
##class IDatabaseCompact_Impl(object):
##    def Compact(self):
##        u'Compacts the database.'
##        #return 
##
##    def CanCompact(self):
##        u'True if this dataset can be compacted.'
##        #return CanCompact
##

class IRasterWorkspace2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control an improved raster workspace.'
    _iid_ = GUID('{9FD9A370-1D1B-11D4-ABDA-0008C73FCA1C}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'rstPixelType'
PT_UNKNOWN = -1
PT_U1 = 0
PT_U2 = 1
PT_U4 = 2
PT_UCHAR = 3
PT_CHAR = 4
PT_USHORT = 5
PT_SHORT = 6
PT_ULONG = 7
PT_LONG = 8
PT_FLOAT = 9
PT_DOUBLE = 10
PT_COMPLEX = 11
PT_DCOMPLEX = 12
PT_CSHORT = 13
PT_CLONG = 14
rstPixelType = c_int # enum
IRasterWorkspace2._methods_ = [
    COMMETHOD([helpstring(u'Opens a RasterDataset in the workspace given its name.')], HRESULT, 'OpenRasterDataset',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IRasterDataset)), 'RasterDataset' )),
    COMMETHOD([helpstring(u'Creates a RasterDataset in the workspace given its name.')], HRESULT, 'CreateRasterDataset',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], BSTR, 'Format' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'Origin' ),
              ( ['in'], c_int, 'columnCount' ),
              ( ['in'], c_int, 'RowCount' ),
              ( ['in'], c_double, 'cellSizeX' ),
              ( ['in'], c_double, 'cellSizeY' ),
              ( ['in'], c_int, 'numBands' ),
              ( ['in'], rstPixelType, 'PixelType' ),
              ( ['in', 'optional'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference', 0 ),
              ( ['in', 'optional'], VARIANT_BOOL, 'Permanent', True ),
              ( ['retval', 'out', 'optional'], POINTER(POINTER(IRasterDataset)), 'RasterDataset' )),
    COMMETHOD([helpstring(u'Indicates if the file path specified is a raster workspace.')], HRESULT, 'IsWorkspace',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsWorkspace' )),
    COMMETHOD([helpstring(u'Indicates if this dataset can be copied.')], HRESULT, 'CanCopy',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanCopy' )),
    COMMETHOD([helpstring(u'Copies this workspace to a new workspace with the specified name.')], HRESULT, 'Copy',
              ( ['in'], BSTR, 'copyName' ),
              ( ['in'], POINTER(IWorkspace), 'copyWorkspace' ),
              ( ['retval', 'out'], POINTER(POINTER(IDataset)), 'CopyDataset' )),
]
################################################################
## code template for IRasterWorkspace2 implementation
##class IRasterWorkspace2_Impl(object):
##    def OpenRasterDataset(self, Name):
##        u'Opens a RasterDataset in the workspace given its name.'
##        #return RasterDataset
##
##    def CanCopy(self):
##        u'Indicates if this dataset can be copied.'
##        #return CanCopy
##
##    def Copy(self, copyName, copyWorkspace):
##        u'Copies this workspace to a new workspace with the specified name.'
##        #return CopyDataset
##
##    def IsWorkspace(self, Name):
##        u'Indicates if the file path specified is a raster workspace.'
##        #return IsWorkspace
##
##    def CreateRasterDataset(self, Name, Format, Origin, columnCount, RowCount, cellSizeX, cellSizeY, numBands, PixelType, SpatialReference, Permanent):
##        u'Creates a RasterDataset in the workspace given its name.'
##        #return RasterDataset
##

IRowCompare._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the rows (which may be from two different versions) are the same (oid + values).')], HRESULT, 'IsEqual',
              ( ['in'], POINTER(IRow), 'otherRow' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsEqual' )),
]
################################################################
## code template for IRowCompare implementation
##class IRowCompare_Impl(object):
##    @property
##    def IsEqual(self, otherRow):
##        u'Indicates if the rows (which may be from two different versions) are the same (oid + values).'
##        #return IsEqual
##

IDatasetContainer._methods_ = [
    COMMETHOD([helpstring(u'Adds a dataset to the dataset collection.')], HRESULT, 'AddDataset',
              ( ['in'], POINTER(IDataset), 'datasetToAdd' )),
]
################################################################
## code template for IDatasetContainer implementation
##class IDatasetContainer_Impl(object):
##    def AddDataset(self, datasetToAdd):
##        u'Adds a dataset to the dataset collection.'
##        #return 
##

class IFeatureDataset(IDataset):
    _case_insensitive_ = True
    u'Provides access to create a new feature class in a feature dataset.'
    _iid_ = GUID('{D4803EE3-79F4-11D0-97FC-0080C7F79481}')
    _idlflags_ = ['oleautomation']
class IQueryDef(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control attribute based queries.'
    _iid_ = GUID('{97103D51-3A9E-11D1-8816-0000F877762D}')
    _idlflags_ = ['oleautomation']
IFeatureWorkspace._methods_ = [
    COMMETHOD([helpstring(u'Opens an existing table.')], HRESULT, 'OpenTable',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'Table' )),
    COMMETHOD([helpstring(u'Creates a new table.')], HRESULT, 'CreateTable',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IFields), 'Fields' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'CLSID' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'EXTCLSID' ),
              ( ['in'], BSTR, 'ConfigKeyword' ),
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'Table' )),
    COMMETHOD([helpstring(u'Opens an existing feature class.')], HRESULT, 'OpenFeatureClass',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureClass)), 'FeatureClass' )),
    COMMETHOD([helpstring(u'Creates a new standalone feature class under the workspace.')], HRESULT, 'CreateFeatureClass',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IFields), 'Fields' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'CLSID' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'EXTCLSID' ),
              ( ['in'], esriFeatureType, 'FeatureType' ),
              ( ['in'], BSTR, 'ShapeFieldName' ),
              ( ['in'], BSTR, 'ConfigKeyword' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureClass)), 'oclass' )),
    COMMETHOD([helpstring(u'Opens an existing feature dataset.')], HRESULT, 'OpenFeatureDataset',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureDataset)), 'Dataset' )),
    COMMETHOD([helpstring(u'Creates a new feature dataset.')], HRESULT, 'CreateFeatureDataset',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureDataset)), 'Dataset' )),
    COMMETHOD([helpstring(u'Create a query definition object.')], HRESULT, 'CreateQueryDef',
              ( ['retval', 'out'], POINTER(POINTER(IQueryDef)), 'QueryDef' )),
    COMMETHOD([helpstring(u'Opens a feature dataset containing a single feature class defined by the specified Query.')], HRESULT, 'OpenFeatureQuery',
              ( ['in'], BSTR, 'QueryName' ),
              ( ['in'], POINTER(IQueryDef), 'QueryDef' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureDataset)), 'FeatureDataset' )),
    COMMETHOD([helpstring(u'Opens an existing relationship class.')], HRESULT, 'OpenRelationshipClass',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IRelationshipClass)), 'RelationshipClass' )),
    COMMETHOD([helpstring(u'Creates a new relationship class.')], HRESULT, 'CreateRelationshipClass',
              ( ['in'], BSTR, 'relClassName' ),
              ( ['in'], POINTER(IObjectClass), 'OriginClass' ),
              ( ['in'], POINTER(IObjectClass), 'DestinationClass' ),
              ( ['in'], BSTR, 'ForwardLabel' ),
              ( ['in'], BSTR, 'BackwardLabel' ),
              ( ['in'], esriRelCardinality, 'Cardinality' ),
              ( ['in'], esriRelNotification, 'Notification' ),
              ( ['in'], VARIANT_BOOL, 'IsComposite' ),
              ( ['in'], VARIANT_BOOL, 'IsAttributed' ),
              ( ['in'], POINTER(IFields), 'relAttrFields' ),
              ( ['in'], BSTR, 'OriginPrimaryKey' ),
              ( ['in'], BSTR, 'destPrimaryKey' ),
              ( ['in'], BSTR, 'OriginForeignKey' ),
              ( ['in'], BSTR, 'destForeignKey' ),
              ( ['retval', 'out'], POINTER(POINTER(IRelationshipClass)), 'RelationshipClass' )),
    COMMETHOD([helpstring(u'The table of a relationship join query.')], HRESULT, 'OpenRelationshipQuery',
              ( ['in'], POINTER(IRelationshipClass), 'relClass' ),
              ( ['in'], VARIANT_BOOL, 'joinForward' ),
              ( ['in'], POINTER(IQueryFilter), 'SrcQueryFilter' ),
              ( ['in'], POINTER(ISelectionSet), 'SrcSelectionSet' ),
              ( ['in'], BSTR, 'TargetColumns' ),
              ( ['in'], VARIANT_BOOL, 'DoNotPushJoinToDB' ),
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'Table' )),
]
################################################################
## code template for IFeatureWorkspace implementation
##class IFeatureWorkspace_Impl(object):
##    def CreateFeatureDataset(self, Name, SpatialReference):
##        u'Creates a new feature dataset.'
##        #return Dataset
##
##    def CreateQueryDef(self):
##        u'Create a query definition object.'
##        #return QueryDef
##
##    def OpenRelationshipClass(self, Name):
##        u'Opens an existing relationship class.'
##        #return RelationshipClass
##
##    def OpenRelationshipQuery(self, relClass, joinForward, SrcQueryFilter, SrcSelectionSet, TargetColumns, DoNotPushJoinToDB):
##        u'The table of a relationship join query.'
##        #return Table
##
##    def OpenFeatureClass(self, Name):
##        u'Opens an existing feature class.'
##        #return FeatureClass
##
##    def CreateTable(self, Name, Fields, CLSID, EXTCLSID, ConfigKeyword):
##        u'Creates a new table.'
##        #return Table
##
##    def CreateFeatureClass(self, Name, Fields, CLSID, EXTCLSID, FeatureType, ShapeFieldName, ConfigKeyword):
##        u'Creates a new standalone feature class under the workspace.'
##        #return oclass
##
##    def OpenFeatureDataset(self, Name):
##        u'Opens an existing feature dataset.'
##        #return Dataset
##
##    def CreateRelationshipClass(self, relClassName, OriginClass, DestinationClass, ForwardLabel, BackwardLabel, Cardinality, Notification, IsComposite, IsAttributed, relAttrFields, OriginPrimaryKey, destPrimaryKey, OriginForeignKey, destForeignKey):
##        u'Creates a new relationship class.'
##        #return RelationshipClass
##
##    def OpenTable(self, Name):
##        u'Opens an existing table.'
##        #return Table
##
##    def OpenFeatureQuery(self, QueryName, QueryDef):
##        u'Opens a feature dataset containing a single feature class defined by the specified Query.'
##        #return FeatureDataset
##

class INativeType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that supply native type information about a dataset.'
    _iid_ = GUID('{BDC57556-F689-4149-A526-B49DEA3F443F}')
    _idlflags_ = ['oleautomation']
INativeType._methods_ = [
    COMMETHOD(['propget', helpstring(u'The unique ID of the type.')], HRESULT, 'TypeID',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'TypeID' )),
    COMMETHOD(['propget', helpstring(u'The description of the type.')], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'Description' )),
]
################################################################
## code template for INativeType implementation
##class INativeType_Impl(object):
##    @property
##    def TypeID(self):
##        u'The unique ID of the type.'
##        #return TypeID
##
##    @property
##    def Description(self):
##        u'The description of the type.'
##        #return Description
##

class IEnumSpatialReferenceInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members to enumerate spatial references.'
    _iid_ = GUID('{5F345E5F-4251-11D4-8145-00C04F686238}')
    _idlflags_ = ['oleautomation']
IWorkspaceSpatialReferenceInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'The defined Spatial References in the Workspace.')], HRESULT, 'SpatialReferenceInfo',
              ( ['retval', 'out'], POINTER(POINTER(IEnumSpatialReferenceInfo)), 'spatialReferences' )),
]
################################################################
## code template for IWorkspaceSpatialReferenceInfo implementation
##class IWorkspaceSpatialReferenceInfo_Impl(object):
##    @property
##    def SpatialReferenceInfo(self):
##        u'The defined Spatial References in the Workspace.'
##        #return spatialReferences
##

class ConfigurationKeyword(CoClass):
    u'ConfigurationKeyword Object.'
    _reg_clsid_ = GUID('{FBF57161-A05D-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IConfigurationKeyword(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members to supply information about configuration keywords.'
    _iid_ = GUID('{2BE5DA4C-7A75-4CC9-AA73-C0320B89846F}')
    _idlflags_ = ['oleautomation']
ConfigurationKeyword._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IConfigurationKeyword]

IEnumNetEID._methods_ = [
    COMMETHOD(['propget', helpstring(u'Network from which these elements came.')], HRESULT, 'Network',
              ( ['retval', 'out'], POINTER(POINTER(INetwork)), 'Network' )),
    COMMETHOD(['propget', helpstring(u'Number of network elements in this enumeration.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'Type of network elements in this enumeration.')], HRESULT, 'ElementType',
              ( ['retval', 'out'], POINTER(esriElementType), 'ElementType' )),
    COMMETHOD([helpstring(u'Forces the enumerator pointing before first network element; a subsequent next gives the first network element in the enumeration.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Moves the enumerator forward and returns the network element pointed by the enumerator.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(c_int), 'EID' )),
    COMMETHOD([helpstring(u'Forces the enumerator pointing at the last element in the enumeration and returns the last element.')], HRESULT, 'Last',
              ( ['retval', 'out'], POINTER(c_int), 'EID' )),
    COMMETHOD([helpstring(u'Returns the network element pointed by the enumerator and moves the enumerator backward.')], HRESULT, 'Prev',
              ( ['retval', 'out'], POINTER(c_int), 'EID' )),
]
################################################################
## code template for IEnumNetEID implementation
##class IEnumNetEID_Impl(object):
##    @property
##    def Count(self):
##        u'Number of network elements in this enumeration.'
##        #return Count
##
##    def Reset(self):
##        u'Forces the enumerator pointing before first network element; a subsequent next gives the first network element in the enumeration.'
##        #return 
##
##    def Prev(self):
##        u'Returns the network element pointed by the enumerator and moves the enumerator backward.'
##        #return EID
##
##    def Last(self):
##        u'Forces the enumerator pointing at the last element in the enumeration and returns the last element.'
##        #return EID
##
##    @property
##    def Network(self):
##        u'Network from which these elements came.'
##        #return Network
##
##    def Next(self):
##        u'Moves the enumerator forward and returns the network element pointed by the enumerator.'
##        #return EID
##
##    @property
##    def ElementType(self):
##        u'Type of network elements in this enumeration.'
##        #return ElementType
##

class ConfigurationParameter(CoClass):
    u'ConfigurationParameter Object.'
    _reg_clsid_ = GUID('{FBF57162-A05D-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IConfigurationParameter(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members to supply information about configuration paramters.'
    _iid_ = GUID('{32BD0A83-25E5-4F24-B81B-5EBEA2DFE35A}')
    _idlflags_ = ['oleautomation']
ConfigurationParameter._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IConfigurationParameter]

class VersionedWorkspace(CoClass):
    u'VersionedWorkspace Object.'
    _reg_clsid_ = GUID('{23A7329A-AB83-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IVersionedWorkspace(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage versions.'
    _iid_ = GUID('{1B256191-B380-11D1-9CE6-0000F8780619}')
    _idlflags_ = ['oleautomation']
class IVersionedWorkspace2(IVersionedWorkspace):
    _case_insensitive_ = True
    u'Provides access to members that manage versions.'
    _iid_ = GUID('{9D039F1B-8B1E-494D-81B1-C6B6AE7C167A}')
    _idlflags_ = ['oleautomation']
class IVersionedWorkspace3(IVersionedWorkspace2):
    _case_insensitive_ = True
    u'Provides access to members that manage versions.'
    _iid_ = GUID('{5E1F7E4F-213E-4F46-A1CA-294C997C1823}')
    _idlflags_ = ['oleautomation']
class IVersion2(IVersion):
    _case_insensitive_ = True
    u'Provides access to members for managing a version.'
    _iid_ = GUID('{E21436A7-87CA-4E97-9F47-D096C8871BAE}')
    _idlflags_ = ['oleautomation']
class IVersionEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about versions and posting of versions.'
    _iid_ = GUID('{2393B65D-74D4-11D2-AAD9-00C04FA37585}')
    _idlflags_ = ['oleautomation']
class IVersionEdit2(IVersionEdit):
    _case_insensitive_ = True
    u'Provides access to members that return information about versions and posting of versions.'
    _iid_ = GUID('{650B3674-3AEA-44D5-8441-794CF3C36A27}')
    _idlflags_ = ['oleautomation']
class IVersionEdit3(IVersionEdit2):
    _case_insensitive_ = True
    u'Provides access to members that return information about versions and posting of versions.'
    _iid_ = GUID('{69D4C025-1A2C-4CCA-B901-20EB2093AB6B}')
    _idlflags_ = ['oleautomation']
class IWorkspaceProperties(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the workspace properties.'
    _iid_ = GUID('{0F1B2257-E2D8-4046-B749-7FF1B058A943}')
    _idlflags_ = ['oleautomation']
VersionedWorkspace._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IVersionedWorkspace, IVersionedWorkspace2, IVersionedWorkspace3, IVersion, IVersion2, IVersionEdit, IVersionEdit2, IVersionEdit3, IWorkspace, IFeatureWorkspace, IDataset, IDatasetContainer, IWorkspaceEdit, IFeatureWorkspaceManage, IFeatureWorkspaceSchemaEdit, IGeodatabaseRelease, ITransactions, ITransactionsOptions, IWorkspaceDomains, IWorkspaceDomains2, IWorkspaceDomains3, ISpatialCacheManager, ISpatialCacheManager2, IFeatureWorkspaceAnno, IDatabaseCompact, ISQLSyntax, IWorkspaceProperties, IWorkspaceConfiguration, IWorkspaceExtensionManager, IWorkspaceSpatialReferenceInfo, IDatabaseConnectionInfo]
VersionedWorkspace._outgoing_interfaces_ = [IWorkspaceEvents]

class IGPVersionInfos(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the VersionInfos Interface.'
    _iid_ = GUID('{96CD2DFF-41C3-4D2C-9619-0A96E21AE341}')
    _idlflags_ = ['oleautomation']
class IGPVersionInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that supply version information.'
    _iid_ = GUID('{E349FCDE-57E2-4FAB-9094-7675D1ADD79D}')
    _idlflags_ = ['oleautomation']
IGPVersionInfos._methods_ = [
    COMMETHOD(['propget', helpstring(u'The version info count.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The version info at the specified position.')], HRESULT, 'Element',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IGPVersionInfo)), 'VersionInfo' )),
    COMMETHOD([helpstring(u'Removes the version info at the specified position.')], HRESULT, 'Remove',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD([helpstring(u'Removes all version infos.')], HRESULT, 'RemoveAll'),
    COMMETHOD([helpstring(u'Adds a version info.')], HRESULT, 'Add',
              ( ['in'], POINTER(IGPVersionInfo), 'VersionInfo' )),
    COMMETHOD([helpstring(u'Adds a version info at the specified position.')], HRESULT, 'Insert',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(IGPVersionInfo), 'VersionInfo' )),
]
################################################################
## code template for IGPVersionInfos implementation
##class IGPVersionInfos_Impl(object):
##    @property
##    def Count(self):
##        u'The version info count.'
##        #return Count
##
##    def Insert(self, Index, VersionInfo):
##        u'Adds a version info at the specified position.'
##        #return 
##
##    def Remove(self, Index):
##        u'Removes the version info at the specified position.'
##        #return 
##
##    @property
##    def Element(self, Index):
##        u'The version info at the specified position.'
##        #return VersionInfo
##
##    def RemoveAll(self):
##        u'Removes all version infos.'
##        #return 
##
##    def Add(self, VersionInfo):
##        u'Adds a version info.'
##        #return 
##

class VersionInfo(CoClass):
    u'VersionInfo Object.'
    _reg_clsid_ = GUID('{23A7329C-AB83-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IVersionInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that supply version information.'
    _iid_ = GUID('{904C01CF-0ED9-11D3-9F3E-00C04F6BDDD9}')
    _idlflags_ = ['oleautomation']
class IVersionInfo2(IVersionInfo):
    _case_insensitive_ = True
    u'Provides access to members that supply version information.'
    _iid_ = GUID('{0D147C7B-7284-4779-8FCC-072BB6891A32}')
    _idlflags_ = ['oleautomation']
VersionInfo._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IVersionInfo, IVersionInfo2]

class IQueryDef2(IQueryDef):
    _case_insensitive_ = True
    u'Provides access to members that control attribute based queries.'
    _iid_ = GUID('{D825C680-72A9-4870-B71C-E3DA72A00EEE}')
    _idlflags_ = ['oleautomation']
IQueryDef._methods_ = [
    COMMETHOD(['propget', helpstring(u'The comma delimited list of table names for the query.')], HRESULT, 'Tables',
              ( ['retval', 'out'], POINTER(BSTR), 'Tables' )),
    COMMETHOD(['propput', helpstring(u'The comma delimited list of table names for the query.')], HRESULT, 'Tables',
              ( ['in'], BSTR, 'Tables' )),
    COMMETHOD(['propget', helpstring(u'The comma delimited list of field names for the query.')], HRESULT, 'SubFields',
              ( ['retval', 'out'], POINTER(BSTR), 'SubFields' )),
    COMMETHOD(['propput', helpstring(u'The comma delimited list of field names for the query.')], HRESULT, 'SubFields',
              ( ['in'], BSTR, 'SubFields' )),
    COMMETHOD(['propget', helpstring(u'The where clause for the query.')], HRESULT, 'WhereClause',
              ( ['retval', 'out'], POINTER(BSTR), 'WhereClause' )),
    COMMETHOD(['propput', helpstring(u'The where clause for the query.')], HRESULT, 'WhereClause',
              ( ['in'], BSTR, 'WhereClause' )),
    COMMETHOD([helpstring(u'Evaluate the query and return a cursor on the result set.')], HRESULT, 'Evaluate',
              ( ['retval', 'out'], POINTER(POINTER(ICursor)), 'Cursor' )),
]
################################################################
## code template for IQueryDef implementation
##class IQueryDef_Impl(object):
##    def _get(self):
##        u'The comma delimited list of table names for the query.'
##        #return Tables
##    def _set(self, Tables):
##        u'The comma delimited list of table names for the query.'
##    Tables = property(_get, _set, doc = _set.__doc__)
##
##    def Evaluate(self):
##        u'Evaluate the query and return a cursor on the result set.'
##        #return Cursor
##
##    def _get(self):
##        u'The comma delimited list of field names for the query.'
##        #return SubFields
##    def _set(self, SubFields):
##        u'The comma delimited list of field names for the query.'
##    SubFields = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The where clause for the query.'
##        #return WhereClause
##    def _set(self, WhereClause):
##        u'The where clause for the query.'
##    WhereClause = property(_get, _set, doc = _set.__doc__)
##

IQueryDef2._methods_ = [
    COMMETHOD(['propget', helpstring(u'A clause that will be inserted between the SELECT keyword and the SELECT COLUMN LIST.  Most commonly used for clauses like DISTINCT or ALL.')], HRESULT, 'PrefixClause',
              ( ['retval', 'out'], POINTER(BSTR), 'clause' )),
    COMMETHOD(['propput', helpstring(u'A clause that will be inserted between the SELECT keyword and the SELECT COLUMN LIST.  Most commonly used for clauses like DISTINCT or ALL.')], HRESULT, 'PrefixClause',
              ( ['in'], BSTR, 'clause' )),
    COMMETHOD(['propget', helpstring(u'A clause that will be appended to the SELECT statement, following the where clause. Most commonly used for clauses like ORDER BY.')], HRESULT, 'PostfixClause',
              ( ['retval', 'out'], POINTER(BSTR), 'clause' )),
    COMMETHOD(['propput', helpstring(u'A clause that will be appended to the SELECT statement, following the where clause. Most commonly used for clauses like ORDER BY.')], HRESULT, 'PostfixClause',
              ( ['in'], BSTR, 'clause' )),
    COMMETHOD([helpstring(u'Evaluate the query and return a cursor on the result set.')], HRESULT, 'Evaluate2',
              ( ['in'], VARIANT_BOOL, 'Recycling' ),
              ( ['retval', 'out'], POINTER(POINTER(ICursor)), 'Cursor' )),
]
################################################################
## code template for IQueryDef2 implementation
##class IQueryDef2_Impl(object):
##    def Evaluate2(self, Recycling):
##        u'Evaluate the query and return a cursor on the result set.'
##        #return Cursor
##
##    def _get(self):
##        u'A clause that will be appended to the SELECT statement, following the where clause. Most commonly used for clauses like ORDER BY.'
##        #return clause
##    def _set(self, clause):
##        u'A clause that will be appended to the SELECT statement, following the where clause. Most commonly used for clauses like ORDER BY.'
##    PostfixClause = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'A clause that will be inserted between the SELECT keyword and the SELECT COLUMN LIST.  Most commonly used for clauses like DISTINCT or ALL.'
##        #return clause
##    def _set(self, clause):
##        u'A clause that will be inserted between the SELECT keyword and the SELECT COLUMN LIST.  Most commonly used for clauses like DISTINCT or ALL.'
##    PrefixClause = property(_get, _set, doc = _set.__doc__)
##

class IEnumConflictClass(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through conflict classes.'
    _iid_ = GUID('{2BA511E1-8A2F-11D2-AAE3-00C04FA37585}')
    _idlflags_ = ['oleautomation']
IVersionEdit._methods_ = [
    COMMETHOD(['propget', helpstring(u'All objects modified by the current and reconciled versions.')], HRESULT, 'ModifiedClasses',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IEnumBSTR)), 'classNames' )),
    COMMETHOD(['propget', helpstring(u'All objects which contain conflicts between the current and reconciled versions.')], HRESULT, 'ConflictClasses',
              ( ['retval', 'out'], POINTER(POINTER(IEnumConflictClass)), 'ConflictClasses' )),
    COMMETHOD(['propget', helpstring(u'The version that the current version is reconciling against.')], HRESULT, 'ReconcileVersion',
              ( ['retval', 'out'], POINTER(POINTER(IVersion)), 'conflictVersion' )),
    COMMETHOD(['propget', helpstring(u'The version prior to any edits.')], HRESULT, 'StartEditingVersion',
              ( ['retval', 'out'], POINTER(POINTER(IVersion)), 'StartEditingVersion' )),
    COMMETHOD(['propget', helpstring(u'The version prior to reconciliation.')], HRESULT, 'PreReconcileVersion',
              ( ['retval', 'out'], POINTER(POINTER(IVersion)), 'PreReconcileVersion' )),
    COMMETHOD(['propget', helpstring(u'The common ancestor of this version and the reconcile version.')], HRESULT, 'CommonAncestorVersion',
              ( ['retval', 'out'], POINTER(POINTER(IVersion)), 'ancestorVersion' )),
    COMMETHOD([helpstring(u'Reconciles the current version with a target version.')], HRESULT, 'Reconcile',
              ( ['in'], BSTR, 'VersionName' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'foundConflicts' )),
    COMMETHOD([helpstring(u'Returns a boolean if the version can be posted to the reconcile version.')], HRESULT, 'CanPost',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanPost' )),
    COMMETHOD([helpstring(u'Posts the current version to the reconcilled version.')], HRESULT, 'Post',
              ( ['in'], BSTR, 'VersionName' )),
]
################################################################
## code template for IVersionEdit implementation
##class IVersionEdit_Impl(object):
##    @property
##    def ModifiedClasses(self):
##        u'All objects modified by the current and reconciled versions.'
##        #return classNames
##
##    @property
##    def PreReconcileVersion(self):
##        u'The version prior to reconciliation.'
##        #return PreReconcileVersion
##
##    def Reconcile(self, VersionName):
##        u'Reconciles the current version with a target version.'
##        #return foundConflicts
##
##    @property
##    def StartEditingVersion(self):
##        u'The version prior to any edits.'
##        #return StartEditingVersion
##
##    @property
##    def ReconcileVersion(self):
##        u'The version that the current version is reconciling against.'
##        #return conflictVersion
##
##    @property
##    def ConflictClasses(self):
##        u'All objects which contain conflicts between the current and reconciled versions.'
##        #return ConflictClasses
##
##    def Post(self, VersionName):
##        u'Posts the current version to the reconcilled version.'
##        #return 
##
##    def CanPost(self):
##        u'Returns a boolean if the version can be posted to the reconcile version.'
##        #return CanPost
##
##    @property
##    def CommonAncestorVersion(self):
##        u'The common ancestor of this version and the reconcile version.'
##        #return ancestorVersion
##

class IForwardStar(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that query information about adjacent elements in the logical network.'
    _iid_ = GUID('{19F99C81-A089-11D0-9CC9-00805F74D243}')
    _idlflags_ = []
IForwardStar._methods_ = [
    COMMETHOD(['propget', helpstring(u'Underlying network of this forward star cursor.')], HRESULT, 'Network',
              ( ['retval', 'out'], POINTER(POINTER(INetwork)), 'Network' )),
    COMMETHOD([helpstring(u'Finds the edge elements that are adjacent to the given junction element and returns the count.')], HRESULT, 'FindAdjacent',
              ( ['in'], c_int, 'fromEdgeEID' ),
              ( ['in'], c_int, 'AtJunctionEID' ),
              ( ['out'], POINTER(c_int), 'adjacentEdgesCount' )),
    COMMETHOD([helpstring(u"Returns the opposite junction of the index'th adjacent edge found with FindAdjacent, and the weight value for this junction.")], HRESULT, 'QueryAdjacentJunction',
              ( ['in'], c_int, 'Index' ),
              ( ['out'], POINTER(c_int), 'adjacentJunctionEID' ),
              ( ['out'], POINTER(VARIANT), 'adjacentJunctionWeightValue' )),
    COMMETHOD([helpstring(u"Returns index'th adjacent edge found with FindAdjacent, its orientation, and its weight value.")], HRESULT, 'QueryAdjacentEdge',
              ( ['in'], c_int, 'Index' ),
              ( ['out'], POINTER(c_int), 'adjacentEdgeEID' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'reverseOrientation' ),
              ( ['out'], POINTER(VARIANT), 'adjacentEdgeWeightValue' )),
    COMMETHOD([helpstring(u"Returns the turn through which the index'th adjacent edge found with FindAdjacent passes, and the weight value of the turn.")], HRESULT, 'QueryAtTurn',
              ( ['in'], c_int, 'Index' ),
              ( ['out'], POINTER(c_int), 'adjacentTurnEID' ),
              ( ['out'], POINTER(VARIANT), 'adjacentTurnWeightValue' )),
    COMMETHOD(['hidden', helpstring(u'Returns the opposite junctions of the adjacent edges found with FindAdjacent into the specified user-defined array.')], HRESULT, 'QueryAdjacentJunctions',
              ( ['in'], c_int, 'Count' ),
              ( ['out'], POINTER(c_int), 'adjacentJunctionEIDs' ),
              ( ['out'], POINTER(VARIANT), 'adjacentJunctionsWeightValue' )),
    COMMETHOD(['hidden', helpstring(u'Returns the adjacent edges found with FindAdjacent into the specified user-defined array.')], HRESULT, 'QueryAdjacentEdges',
              ( ['in'], c_int, 'Count' ),
              ( ['out'], POINTER(c_int), 'adjacentEdgeEIDs' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'reverseOrientation' ),
              ( ['out'], POINTER(VARIANT), 'adjacentEdgesWeightValue' )),
    COMMETHOD(['hidden', helpstring(u'Returns the turns through which the adjacent edges found with FindAdjacent passes into the user-defined array.')], HRESULT, 'QueryAtTurns',
              ( ['in'], c_int, 'Count' ),
              ( ['out'], POINTER(c_int), 'adjacentTurnEIDs' ),
              ( ['out'], POINTER(VARIANT), 'adjacentTurnsWeightValue' )),
]
################################################################
## code template for IForwardStar implementation
##class IForwardStar_Impl(object):
##    def QueryAtTurn(self, Index):
##        u"Returns the turn through which the index'th adjacent edge found with FindAdjacent passes, and the weight value of the turn."
##        #return adjacentTurnEID, adjacentTurnWeightValue
##
##    def QueryAdjacentJunctions(self, Count):
##        u'Returns the opposite junctions of the adjacent edges found with FindAdjacent into the specified user-defined array.'
##        #return adjacentJunctionEIDs, adjacentJunctionsWeightValue
##
##    @property
##    def Network(self):
##        u'Underlying network of this forward star cursor.'
##        #return Network
##
##    def FindAdjacent(self, fromEdgeEID, AtJunctionEID):
##        u'Finds the edge elements that are adjacent to the given junction element and returns the count.'
##        #return adjacentEdgesCount
##
##    def QueryAdjacentEdge(self, Index):
##        u"Returns index'th adjacent edge found with FindAdjacent, its orientation, and its weight value."
##        #return adjacentEdgeEID, reverseOrientation, adjacentEdgeWeightValue
##
##    def QueryAdjacentEdges(self, Count):
##        u'Returns the adjacent edges found with FindAdjacent into the specified user-defined array.'
##        #return adjacentEdgeEIDs, reverseOrientation, adjacentEdgesWeightValue
##
##    def QueryAdjacentJunction(self, Index):
##        u"Returns the opposite junction of the index'th adjacent edge found with FindAdjacent, and the weight value for this junction."
##        #return adjacentJunctionEID, adjacentJunctionWeightValue
##
##    def QueryAtTurns(self, Count):
##        u'Returns the turns through which the adjacent edges found with FindAdjacent passes into the user-defined array.'
##        #return adjacentTurnEIDs, adjacentTurnsWeightValue
##

class IEnumTable(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through the classes.'
    _iid_ = GUID('{B3CBC2E1-28E2-4BED-830D-D30CD500DC1C}')
    _idlflags_ = ['oleautomation']
IEnumTable._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next attributed relationship.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'oneClass' )),
    COMMETHOD([helpstring(u'Resets enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumTable implementation
##class IEnumTable_Impl(object):
##    def Reset(self):
##        u'Resets enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next attributed relationship.'
##        #return oneClass
##

class ITinSurfaceElement(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control TIN surface elements.'
    _iid_ = GUID('{FF7E9000-D0DD-11D2-9F76-00C04F8ECE27}')
    _idlflags_ = ['oleautomation']
ITinSurfaceElement._methods_ = [
    COMMETHOD(['propget', helpstring(u'The z value of the element.')], HRESULT, 'Elevation',
              ( ['retval', 'out'], POINTER(c_double), 'pElevation' )),
    COMMETHOD(['propget', helpstring(u'The slope of the element in degrees.')], HRESULT, 'SlopeDegrees',
              ( ['retval', 'out'], POINTER(c_double), 'pSlope' )),
    COMMETHOD(['propget', helpstring(u'The aspect of the element in degrees.')], HRESULT, 'AspectDegrees',
              ( ['retval', 'out'], POINTER(c_double), 'pAspect' )),
    COMMETHOD(['propget', helpstring(u'The face tag value of the triangle associated with the element.')], HRESULT, 'FaceTagValue',
              ( ['retval', 'out'], POINTER(c_int), 'pValue' )),
    COMMETHOD(['propget', helpstring(u'The node tag value of the associated triangle node closest to the element.')], HRESULT, 'NodeTagValue',
              ( ['retval', 'out'], POINTER(c_int), 'pValue' )),
    COMMETHOD(['hidden', helpstring(u'The triangle referenced by the element.'), 'propget'], HRESULT, 'Triangle',
              ( ['retval', 'out'], POINTER(POINTER(ITinTriangle)), 'ppTriangle' )),
]
################################################################
## code template for ITinSurfaceElement implementation
##class ITinSurfaceElement_Impl(object):
##    @property
##    def Elevation(self):
##        u'The z value of the element.'
##        #return pElevation
##
##    @property
##    def FaceTagValue(self):
##        u'The face tag value of the triangle associated with the element.'
##        #return pValue
##
##    @property
##    def SlopeDegrees(self):
##        u'The slope of the element in degrees.'
##        #return pSlope
##
##    @property
##    def AspectDegrees(self):
##        u'The aspect of the element in degrees.'
##        #return pAspect
##
##    @property
##    def NodeTagValue(self):
##        u'The node tag value of the associated triangle node closest to the element.'
##        #return pValue
##
##    @property
##    def Triangle(self):
##        u'The triangle referenced by the element.'
##        #return ppTriangle
##


# values for enumeration 'esriRasterTableTypeEnum'
esriRasterTableIndex = 0
esriRasterTableValue = 1
esriRasterTableInvalid = 99
esriRasterTableTypeEnum = c_int # enum
class IMetadataSynchronizer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control what happens when synchronization occurs.'
    _iid_ = GUID('{6A07CA46-9575-4CFC-A0D4-F2C8F9D30569}')
    _idlflags_ = ['oleautomation']
IMetadataSynchronizer._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the metadata synchronizer.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The class ID of the metadata synchronizer.')], HRESULT, 'ClassID',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'ClassID' )),
    COMMETHOD([helpstring(u'Updates the metadata item using the value passed in.')], HRESULT, 'Update',
              ( ['in'], POINTER(IXmlPropertySet), 'PropertySet' ),
              ( ['in'], BSTR, 'itemDesc' ),
              ( ['in'], VARIANT, 'Value' )),
]
################################################################
## code template for IMetadataSynchronizer implementation
##class IMetadataSynchronizer_Impl(object):
##    @property
##    def ClassID(self):
##        u'The class ID of the metadata synchronizer.'
##        #return ClassID
##
##    @property
##    def Name(self):
##        u'The name of the metadata synchronizer.'
##        #return Name
##
##    def Update(self, PropertySet, itemDesc, Value):
##        u'Updates the metadata item using the value passed in.'
##        #return 
##

class XMLIndex(CoClass):
    u'XML Index Object.'
    _reg_clsid_ = GUID('{18EC559B-07BE-4F98-8960-206636BA259A}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IIndex(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about the index.'
    _iid_ = GUID('{2063FD01-4CE0-11D1-89DB-006097AFF44E}')
    _idlflags_ = ['oleautomation']
class IIndexEdit(IIndex):
    _case_insensitive_ = True
    u'Provides access to members that modify the index.'
    _iid_ = GUID('{2063FD02-4CE0-11D1-89DB-006097AFF44E}')
    _idlflags_ = ['oleautomation']
XMLIndex._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IIndex, IIndexEdit, IXMLIndex, IXMLIndexEdit, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe]

class EnumVersionInfo(CoClass):
    u'EnumVersionInfo Object.'
    _reg_clsid_ = GUID('{23A7329F-AB83-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IEnumVersionInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate version information.'
    _iid_ = GUID('{C0D27014-D933-11D1-AA7D-00C04FA37585}')
    _idlflags_ = ['oleautomation']
EnumVersionInfo._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumVersionInfo]

class IConflictClass(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the conflict class.'
    _iid_ = GUID('{AB22306B-8A2F-11D2-AAE3-00C04FA37585}')
    _idlflags_ = ['oleautomation']
IEnumConflictClass._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next conflict class in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IConflictClass)), 'conflictClass' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumConflictClass implementation
##class IEnumConflictClass_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next conflict class in the enumeration sequence.'
##        #return conflictClass
##

class INetTopology(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that get information about the elements adjacent to the specified element.'
    _iid_ = GUID('{803B5FF1-0AB3-11D1-9CD6-00805F74D243}')
    _idlflags_ = []
INetTopology._methods_ = [
    COMMETHOD([helpstring(u'Returns the network element IDs of the junctions adjacent to the specified edge.')], HRESULT, 'GetFromToJunctionEIDs',
              ( ['in'], c_int, 'edgeEID' ),
              ( ['out'], POINTER(c_int), 'FromJunctionEID' ),
              ( ['out'], POINTER(c_int), 'ToJunctionEID' )),
    COMMETHOD([helpstring(u'Returns the number of edges adjacent to the specified junction.')], HRESULT, 'GetAdjacentEdgeCount',
              ( ['in'], c_int, 'AtJunctionEID' ),
              ( ['retval', 'out'], POINTER(c_int), 'adjacentEdgesCount' )),
    COMMETHOD([helpstring(u"Returns the network element ID of the index'th adjacent edge to the specified junction.")], HRESULT, 'GetAdjacentEdge',
              ( ['in'], c_int, 'AtJunctionEID' ),
              ( ['in'], c_int, 'Index' ),
              ( ['out'], POINTER(c_int), 'adjacentEdge' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'reverseOrientation' )),
    COMMETHOD(['hidden', helpstring(u'Returns the network element IDs of all the edges adjacent to the specified junction.')], HRESULT, 'GetAdjacentEdges',
              ( ['in'], c_int, 'AtJunctionEID' ),
              ( ['in'], c_int, 'adjacentEdgesCount' ),
              ( ['out'], POINTER(c_int), 'adjacentEdges' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'reverseOrientation' )),
]
################################################################
## code template for INetTopology implementation
##class INetTopology_Impl(object):
##    def GetAdjacentEdge(self, AtJunctionEID, Index):
##        u"Returns the network element ID of the index'th adjacent edge to the specified junction."
##        #return adjacentEdge, reverseOrientation
##
##    def GetFromToJunctionEIDs(self, edgeEID):
##        u'Returns the network element IDs of the junctions adjacent to the specified edge.'
##        #return FromJunctionEID, ToJunctionEID
##
##    def GetAdjacentEdges(self, AtJunctionEID, adjacentEdgesCount):
##        u'Returns the network element IDs of all the edges adjacent to the specified junction.'
##        #return adjacentEdges, reverseOrientation
##
##    def GetAdjacentEdgeCount(self, AtJunctionEID):
##        u'Returns the number of edges adjacent to the specified junction.'
##        #return adjacentEdgesCount
##

class EnumXMLIndexTemplate(CoClass):
    u'XML Index Template Enumerator Object.'
    _reg_clsid_ = GUID('{A11F14EC-E6F1-4504-AFA1-5CC6FF912212}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IEnumXMLIndexTemplate(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'A simple enumerator object for XML Index Templates.'
    _iid_ = GUID('{1C36DCB3-46A3-4FB9-AFA6-AE22799F25DD}')
    _idlflags_ = ['oleautomation']
EnumXMLIndexTemplate._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumXMLIndexTemplate]

class ITableSortCallBack(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that compare field values for a table sort operation.'
    _iid_ = GUID('{341943F3-9450-11D2-A087-0000F8775BF9}')
    _idlflags_ = ['oleautomation']
class IEnumIDs(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through IDs.'
    _iid_ = GUID('{7D84B001-1521-11D2-89ED-006097AFF44E}')
    _idlflags_ = ['oleautomation']
ITableSort._methods_ = [
    COMMETHOD(['propputref', helpstring(u'The table as a source of the data to sort on.')], HRESULT, 'Table',
              ( ['in'], POINTER(ITable), 'Table' )),
    COMMETHOD(['propputref', helpstring(u'The selection set as a source of the data to sort on. Cancels Cursor.')], HRESULT, 'SelectionSet',
              ( ['in'], POINTER(ISelectionSet), 'SelectionSet' )),
    COMMETHOD(['propputref', helpstring(u'The cursor of the data to sort on. Ensure that sorting fields are available. Cancels SelectionSet.')], HRESULT, 'Cursor',
              ( ['in'], POINTER(ICursor), 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The query filter on table or selection set.')], HRESULT, 'QueryFilter',
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' )),
    COMMETHOD(['propget', helpstring(u'The query filter on table or selection set.')], HRESULT, 'QueryFilter',
              ( ['retval', 'out'], POINTER(POINTER(IQueryFilter)), 'QueryFilter' )),
    COMMETHOD(['propput', helpstring(u'Comma list of field names to sort on.')], HRESULT, 'Fields',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Field sort order.')], HRESULT, 'Ascending',
              ( ['in'], BSTR, 'Field' ),
              ( ['in'], VARIANT_BOOL, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Number of characters to sort on, for string fields. A null (default) sorts on the whole string.')], HRESULT, 'SortCharacters',
              ( ['in'], BSTR, 'Field' ),
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Character fields case sensitive. Default: False.')], HRESULT, 'CaseSensitive',
              ( ['in'], BSTR, 'Field' ),
              ( ['in'], VARIANT_BOOL, 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'Compare call back interface. Specify Null (default) for normal behavior.')], HRESULT, 'Compare',
              ( ['in'], POINTER(ITableSortCallBack), 'rhs' )),
    COMMETHOD(['propget', helpstring(u'List of sorted IDs.')], HRESULT, 'IDs',
              ( ['retval', 'out'], POINTER(POINTER(IEnumIDs)), 'EnumIDs' )),
    COMMETHOD(['propget', helpstring(u'Cursor of sorted rows.')], HRESULT, 'Rows',
              ( ['retval', 'out'], POINTER(POINTER(ICursor)), 'Cursor' )),
    COMMETHOD([helpstring(u'Sort rows.')], HRESULT, 'Sort',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITrackCancel), 'TrackCancel' )),
    COMMETHOD(['hidden', helpstring(u'A id by its index value.'), 'propget'], HRESULT, 'IDByIndex',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(c_int), 'IdVal' )),
    COMMETHOD(['propget', helpstring(u'The table as a source of the data to sort on.')], HRESULT, 'Table',
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'Table' )),
    COMMETHOD(['propget', helpstring(u'The selection set as a source of the data to sort on. Cancels Cursor.')], HRESULT, 'SelectionSet',
              ( ['retval', 'out'], POINTER(POINTER(ISelectionSet)), 'SelectionSet' )),
]
################################################################
## code template for ITableSort implementation
##class ITableSort_Impl(object):
##    def Sort(self, TrackCancel):
##        u'Sort rows.'
##        #return 
##
##    @property
##    def IDByIndex(self, Index):
##        u'A id by its index value.'
##        #return IdVal
##
##    def Compare(self, rhs):
##        u'Compare call back interface. Specify Null (default) for normal behavior.'
##        #return 
##
##    @property
##    def Rows(self):
##        u'Cursor of sorted rows.'
##        #return Cursor
##
##    def _set(self, rhs):
##        u'Comma list of field names to sort on.'
##    Fields = property(fset = _set, doc = _set.__doc__)
##
##    @property
##    def IDs(self):
##        u'List of sorted IDs.'
##        #return EnumIDs
##
##    def _set(self, Field, rhs):
##        u'Field sort order.'
##    Ascending = property(fset = _set, doc = _set.__doc__)
##
##    def Cursor(self, rhs):
##        u'The cursor of the data to sort on. Ensure that sorting fields are available. Cancels SelectionSet.'
##        #return 
##
##    def _set(self, Field, rhs):
##        u'Character fields case sensitive. Default: False.'
##    CaseSensitive = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, Field, rhs):
##        u'Number of characters to sort on, for string fields. A null (default) sorts on the whole string.'
##    SortCharacters = property(fset = _set, doc = _set.__doc__)
##
##    @property
##    def QueryFilter(self, QueryFilter):
##        u'The query filter on table or selection set.'
##        #return 
##
##    @property
##    def Table(self, Table):
##        u'The table as a source of the data to sort on.'
##        #return 
##
##    @property
##    def SelectionSet(self, SelectionSet):
##        u'The selection set as a source of the data to sort on. Cancels Cursor.'
##        #return 
##

class IFeatureWorkspaceManage2(IFeatureWorkspaceManage):
    _case_insensitive_ = True
    u'Provides access to dataset deletion and renaming, table and index analysis, field validation and version and object class registration.'
    _iid_ = GUID('{7B041AFB-1AD6-45AB-9C34-4E98B41DF506}')
    _idlflags_ = ['oleautomation']
IFeatureWorkspaceManage2._methods_ = [
    COMMETHOD([helpstring(u'Gets fully qualified feature class name by object class id.')], HRESULT, 'GetObjectClassNameByID',
              ( ['in'], c_int, 'ObjectClassID' ),
              ( ['retval', 'out'], POINTER(BSTR), 'qname' )),
    COMMETHOD([helpstring(u'Gets fully qualified relationship class name by relationship class id.')], HRESULT, 'GetRelationshipClassNameByID',
              ( ['in'], c_int, 'relClassId' ),
              ( ['retval', 'out'], POINTER(BSTR), 'qname' )),
]
################################################################
## code template for IFeatureWorkspaceManage2 implementation
##class IFeatureWorkspaceManage2_Impl(object):
##    def GetObjectClassNameByID(self, ObjectClassID):
##        u'Gets fully qualified feature class name by object class id.'
##        #return qname
##
##    def GetRelationshipClassNameByID(self, relClassId):
##        u'Gets fully qualified relationship class name by relationship class id.'
##        #return qname
##

class NetWeight(CoClass):
    u'A container for defining a weight on the network.'
    _reg_clsid_ = GUID('{3EBBE031-557D-11D1-B254-0000F878229E}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
NetWeight._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetWeight, INetWeightEdit, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

class IGPRangeDomain2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'.'
    _iid_ = GUID('{E5FD9A61-A3A4-46A5-A72D-DB8F585201A6}')
    _idlflags_ = ['oleautomation']
IGPRangeDomain2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The minimum value for the associated attribute.')], HRESULT, 'MinValue',
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The minimum value for the associated attribute.')], HRESULT, 'MinValue',
              ( ['in'], VARIANT, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The maximum value for the associated attribute.')], HRESULT, 'MaxValue',
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The maximum value for the associated attribute.')], HRESULT, 'MaxValue',
              ( ['in'], VARIANT, 'Value' )),
]
################################################################
## code template for IGPRangeDomain2 implementation
##class IGPRangeDomain2_Impl(object):
##    def _get(self):
##        u'The maximum value for the associated attribute.'
##        #return Value
##    def _set(self, Value):
##        u'The maximum value for the associated attribute.'
##    MaxValue = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The minimum value for the associated attribute.'
##        #return Value
##    def _set(self, Value):
##        u'The minimum value for the associated attribute.'
##    MinValue = property(_get, _set, doc = _set.__doc__)
##

class IFeatureWorkspaceManage3(IFeatureWorkspaceManage2):
    _case_insensitive_ = True
    u'Provides access to dataset deletion and renaming, table and index analysis, field validation and version and object class registration.'
    _iid_ = GUID('{E219DF6C-A539-47DE-9E04-67BBDCF5CBAE}')
    _idlflags_ = ['oleautomation']
IFeatureWorkspaceManage3._methods_ = [
    COMMETHOD([helpstring(u'Analyze the system tables of the database to generate DBMS statistics on them.')], HRESULT, 'AnalyzeSystemTables'),
    COMMETHOD([helpstring(u'Rebuild indices on key ArcSDE system tables.')], HRESULT, 'RebuildSystemTableIndexes'),
    COMMETHOD([helpstring(u'Checks is an object has archiving enabled.')], HRESULT, 'IsArchivingEnabled',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'Name' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsArchivingEnabled' )),
]
################################################################
## code template for IFeatureWorkspaceManage3 implementation
##class IFeatureWorkspaceManage3_Impl(object):
##    def RebuildSystemTableIndexes(self):
##        u'Rebuild indices on key ArcSDE system tables.'
##        #return 
##
##    def IsArchivingEnabled(self, Name):
##        u'Checks is an object has archiving enabled.'
##        #return IsArchivingEnabled
##
##    def AnalyzeSystemTables(self):
##        u'Analyze the system tables of the database to generate DBMS statistics on them.'
##        #return 
##

class IGPCodedValueDomain2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'.'
    _iid_ = GUID('{4BC49489-93A3-4945-9C24-E3E1BCA04664}')
    _idlflags_ = ['oleautomation']
IGPCodedValueDomain2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of codes for the associated attribute.')], HRESULT, 'CodeCount',
              ( ['retval', 'out'], POINTER(c_int), 'values' )),
    COMMETHOD(['propget', helpstring(u'The code name for the specified code index.')], HRESULT, 'Name',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The value for the specified code index.')], HRESULT, 'Value',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
    COMMETHOD([helpstring(u'Adds a (value, name) code.')], HRESULT, 'AddCode',
              ( ['in'], VARIANT, 'Value' ),
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD([helpstring(u'Deletes a code with the specified value.')], HRESULT, 'DeleteCode',
              ( ['in'], VARIANT, 'Value' )),
]
################################################################
## code template for IGPCodedValueDomain2 implementation
##class IGPCodedValueDomain2_Impl(object):
##    def AddCode(self, Value, Name):
##        u'Adds a (value, name) code.'
##        #return 
##
##    def DeleteCode(self, Value):
##        u'Deletes a code with the specified value.'
##        #return 
##
##    @property
##    def CodeCount(self):
##        u'The number of codes for the associated attribute.'
##        #return values
##
##    @property
##    def Value(self, Index):
##        u'The value for the specified code index.'
##        #return Value
##
##    @property
##    def Name(self, Index):
##        u'The code name for the specified code index.'
##        #return Name
##

class ITinFeatureEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to methods that control TIN 'features'."
    _iid_ = GUID('{73B80FC1-FF33-11D1-A549-0000F8774F0F}')
    _idlflags_ = []
class ITinFeatureSeed(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to control TIN elements' properties."
    _iid_ = GUID('{BB5DBC74-B9CA-11D5-ABBB-0008C73FD50C}')
    _idlflags_ = ['oleautomation']
ITinFeatureEdit._methods_ = [
    COMMETHOD([helpstring(u"Initiates memory edit mode. Use ITinEdit::SaveAs to persist. Don't use Save.")], HRESULT, 'StartInMemoryEditing',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsSuccessful' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the specified TIN is in in-memory-edit mode.')], HRESULT, 'IsInMemoryEditMode',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsInEditMode' )),
    COMMETHOD(['restricted', helpstring(u'Apply constrained Delaunay from now on.')], HRESULT, 'SetToConstrainedDelaunay'),
    COMMETHOD([helpstring(u'Extracts polyline. The seed must be a special edge, or an edge with tagValue.')], HRESULT, 'ExtractPolyline',
              ( ['in'], POINTER(ITinFeatureSeed), 'pSeed' ),
              ( ['in'], VARIANT_BOOL, 'bGetZ' ),
              ( ['in'], VARIANT_BOOL, 'bSkipDensifiedNodes' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolyline)), 'ppPolyline' )),
    COMMETHOD([helpstring(u'Extracts polygon.')], HRESULT, 'ExtractPolygon',
              ( ['in'], POINTER(ITinFeatureSeed), 'pSeed' ),
              ( ['in'], VARIANT_BOOL, 'bGetZ' ),
              ( ['in'], VARIANT_BOOL, 'bSkipDensifiedNodes' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon)), 'ppPolygon' )),
    COMMETHOD([helpstring(u'Converts qualified edges to a polyline feature class.')], HRESULT, 'ConvertToPolylines',
              ( [], POINTER(IFeatureClass), 'pFeatureClass' ),
              ( ['in'], POINTER(ITinDynamicFilter), 'pFilter' ),
              ( ['in'], VARIANT_BOOL, 'bSkipDensifiedNodes' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pFieldName' )),
    COMMETHOD([helpstring(u'Converts qualified triangles to a polygon feature class.')], HRESULT, 'ConvertToPolygons',
              ( [], POINTER(IFeatureClass), 'pFeatureClass' ),
              ( ['in'], POINTER(ITinDynamicFilter), 'pFilter' ),
              ( ['in'], VARIANT_BOOL, 'bStopAtEnforcedEdge' ),
              ( ['in'], VARIANT_BOOL, 'bSkipDensifiedNodes' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pFieldName' )),
    COMMETHOD(['propput', helpstring(u'Indicates if a polyline related process (e.g., ExtractPolyline) should stop at juncture.')], HRESULT, 'StopAtJuncture',
              ( ['in'], VARIANT_BOOL, 'pbStop' )),
    COMMETHOD(['propget', helpstring(u'Indicates if a polyline related process (e.g., ExtractPolyline) should stop at juncture.')], HRESULT, 'StopAtJuncture',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbStop' )),
    COMMETHOD(['propput', helpstring(u'Indicates if a polygon related process (e.g., ExtractPolygon) should stop when reach an enforced edge.')], HRESULT, 'StopAtEnforcedEdge',
              ( ['in'], VARIANT_BOOL, 'pbStop' )),
    COMMETHOD(['propget', helpstring(u'Indicates if a polygon related process (e.g., ExtractPolygon) should stop when reach an enforced edge.')], HRESULT, 'StopAtEnforcedEdge',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbStop' )),
    COMMETHOD(['propput', helpstring(u'The TIN nodes or edges to be ignored in conflict detection (used by processes such as CanAdd and CanMove).')], HRESULT, 'ElementsIgnoredInConflictTest',
              ( ['in'], c_int, 'pElementsExcluded' )),
    COMMETHOD(['propget', helpstring(u'The TIN nodes or edges to be ignored in conflict detection (used by processes such as CanAdd and CanMove).')], HRESULT, 'ElementsIgnoredInConflictTest',
              ( ['retval', 'out'], POINTER(c_int), 'pElementsExcluded' )),
    COMMETHOD([helpstring(u'Checks if the specified shape can be added without creating spatial conflict.')], HRESULT, 'CanAdd',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pShape' ),
              ( ['in'], c_double, 'spacing' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbCanAdd' )),
    COMMETHOD([helpstring(u'Checks if the embedded object can be replaced by the new shape without creating spatial conflict.')], HRESULT, 'CanReplace',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pShape' ),
              ( ['in'], POINTER(ITinFeatureSeed), 'pSeed' ),
              ( ['in'], c_double, 'spacing' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbCanReplace' )),
    COMMETHOD(['restricted', helpstring(u'Checks if the embedded object can be moved (continuously) to a new location without creating spatial conflict.')], HRESULT, 'CanDisplace',
              ( ['in'], POINTER(ITinFeatureSeed), 'pSeed' ),
              ( ['in'], c_double, 'dx' ),
              ( ['in'], c_double, 'dy' ),
              ( [], c_double, 'spacing' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbCanDisplace' )),
    COMMETHOD([helpstring(u'Checks if the embedded object can be relocated to a new location without creating spatial conflict.')], HRESULT, 'CanMove',
              ( ['in'], POINTER(ITinFeatureSeed), 'pSeed' ),
              ( ['in'], c_double, 'dx' ),
              ( ['in'], c_double, 'dy' ),
              ( [], c_double, 'spacing' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbCanMove' )),
    COMMETHOD([helpstring(u'Checks if the embedded polyline/polygon can be rotated without creating spatial conflict. pOrigin can be NULL or Nothing.')], HRESULT, 'CanRotate',
              ( ['in'], POINTER(ITinFeatureSeed), 'pSeed' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pOrigin' ),
              ( ['in'], c_double, 'Angle' ),
              ( ['in'], c_double, 'spacing' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbCanRotate' )),
    COMMETHOD([helpstring(u'Checks if the embedded polygon can be expanded or shrinked without creating spatial conflict. pOrigin can be NULL or Nothing.')], HRESULT, 'CanScalePolygon',
              ( ['in'], POINTER(ITinTriangle), 'pSeed' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pOrigin' ),
              ( ['in'], c_double, 'Scale' ),
              ( ['in'], c_double, 'spacing' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbCanScale' )),
    COMMETHOD([helpstring(u'Checks if a new polygon/polyline vertex can be added without creating spatial conflict.')], HRESULT, 'CanAddVertex',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pPoly' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pNewPoint' ),
              ( ['in'], VARIANT_BOOL, 'bClose' ),
              ( ['in'], c_double, 'spacing' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbCanAdd' )),
    COMMETHOD([helpstring(u'Checks if a polygon/polyline vertex can be deleted without creating spatial conflict.')], HRESULT, 'CanDeleteVertex',
              ( ['in'], POINTER(ITinNode), 'pNode' ),
              ( ['in'], POINTER(ITinFeatureSeed), 'pSeed' ),
              ( ['in'], c_double, 'spacing' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbCanDelete' )),
    COMMETHOD([helpstring(u'Checks if a polygon/polyline vertex can be moved to a new location without creating spatial conflict.')], HRESULT, 'CanMoveVertex',
              ( ['in'], POINTER(ITinNode), 'pNode' ),
              ( ['in'], POINTER(ITinFeatureSeed), 'pSeed' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPoint), 'pNewLocation' ),
              ( ['in'], c_double, 'spacing' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbCanMove' )),
    COMMETHOD([helpstring(u'Adds a 3D point to the TIN. pSeed can be NULL or Nothing.')], HRESULT, 'AddPointZ',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( ['in'], c_int, 'TagValue' ),
              ( [], POINTER(ITinNode), 'pSeed' )),
    COMMETHOD([helpstring(u'Adds Z-aware polygon. pSeed can be NULL or Nothing.')], HRESULT, 'AddPolygonZ',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon), 'pShape' ),
              ( ['in'], esriTinEdgeType, 'Type' ),
              ( ['in'], c_int, 'TagValue' ),
              ( ['in'], c_int, 'edgeTagValue' ),
              ( ['in'], c_int, 'NodeTagValue' ),
              ( [], POINTER(ITinTriangle), 'pSeed' )),
    COMMETHOD([helpstring(u'Adds polygon. pSeed can be NULL or Nothing.')], HRESULT, 'AddPolygon',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon), 'pShape' ),
              ( ['in'], esriTinEdgeType, 'Type' ),
              ( ['in'], c_int, 'TagValue' ),
              ( ['in'], c_int, 'edgeTagValue' ),
              ( ['in'], c_int, 'NodeTagValue' ),
              ( [], POINTER(ITinTriangle), 'pSeed' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pZ' )),
    COMMETHOD([helpstring(u'Adds Z-aware polyline. pSeed can be NULL or Nothing.')], HRESULT, 'AddPolylineZ',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolyline), 'pShape' ),
              ( ['in'], esriTinEdgeType, 'Type' ),
              ( ['in'], c_int, 'TagValue' ),
              ( ['in'], c_int, 'NodeTagValue' ),
              ( [], POINTER(ITinEdge), 'pSeed' )),
    COMMETHOD([helpstring(u'Adds polyline. pSeed can be NULL or Nothing.')], HRESULT, 'AddPolyline',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolyline), 'pShape' ),
              ( ['in'], esriTinEdgeType, 'Type' ),
              ( ['in'], c_int, 'TagValue' ),
              ( ['in'], c_int, 'NodeTagValue' ),
              ( [], POINTER(ITinEdge), 'pSeed' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pZ' )),
    COMMETHOD([helpstring(u'Adds polygons/polylines.')], HRESULT, 'AddPolyObjects',
              ( ['in'], POINTER(IFeatureClass), 'pFeatureClass' ),
              ( ['in'], POINTER(IQueryFilter), 'pFilter' ),
              ( ['in'], POINTER(IField), 'pHeightField' ),
              ( ['in'], POINTER(IField), 'pValueField' ),
              ( ['in'], VARIANT_BOOL, 'bSetEdgeTagValue' ),
              ( ['in'], VARIANT_BOOL, 'bSetNodeTagValue' ),
              ( ['in'], esriTinEdgeType, 'Type' )),
    COMMETHOD([helpstring(u'Deletes the embedded point/polygon/polyline represented by the specified seed.')], HRESULT, 'Delete',
              ( ['in'], POINTER(ITinFeatureSeed), 'pSeed' )),
    COMMETHOD([helpstring(u'Moves the embedded point/polygon/polyline represented by the specified seed.')], HRESULT, 'Move',
              ( ['in'], POINTER(ITinFeatureSeed), 'pSeed' ),
              ( ['in'], c_double, 'dx' ),
              ( ['in'], c_double, 'dy' ),
              ( ['in'], VARIANT_BOOL, 'bGetNewZ' )),
    COMMETHOD([helpstring(u'Rotates the embedded polygon/polyline represented by the specified seed. pOrigin can be NULL or Nothing.')], HRESULT, 'Rotate',
              ( ['in'], POINTER(ITinFeatureSeed), 'pSeed' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pOrigin' ),
              ( [], c_double, 'Angle' ),
              ( ['in'], VARIANT_BOOL, 'bGetNewZ' )),
    COMMETHOD([helpstring(u'Expands or shrinks the embedded polygon represented by the specified seed. pOrigin can be NULL or Nothing.')], HRESULT, 'ScalePolygon',
              ( ['in'], POINTER(ITinTriangle), 'pSeed' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pOrigin' ),
              ( [], c_double, 'Scale' ),
              ( ['in'], VARIANT_BOOL, 'bGetNewZ' )),
    COMMETHOD([helpstring(u'Removes islands whose area is smaller than the specified value, from the embedded polygon represented by the specified seed. Remove all holes if the value is zero.')], HRESULT, 'RemoveIslands',
              ( ['in'], POINTER(ITinTriangle), 'pSeed' ),
              ( ['in'], c_double, 'Area' ),
              ( [], VARIANT_BOOL, 'bKeepNodes' ),
              ( [], VARIANT_BOOL, 'bZeroTag' )),
    COMMETHOD([helpstring(u'Merges two embedded polygons sharing the specified common edge.')], HRESULT, 'Merge',
              ( ['in'], POINTER(ITinEdge), 'pCommonEdge' ),
              ( ['in'], c_int, 'newValue' ),
              ( ['in'], VARIANT_BOOL, 'bKeepCommonNodes' )),
    COMMETHOD([helpstring(u'Deletes the specified vertex from an embedded polygon/polyline.')], HRESULT, 'DeleteVertex',
              ( ['in'], POINTER(ITinNode), 'pNode' ),
              ( ['in'], POINTER(ITinFeatureSeed), 'pSeed' )),
    COMMETHOD([helpstring(u'Moves the specified vertex of an embedded polygon/polyline to a new location.')], HRESULT, 'MoveVertex',
              ( ['in'], POINTER(ITinNode), 'pNode' ),
              ( ['in'], POINTER(ITinFeatureSeed), 'pSeed' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPoint), 'pNewLocation' ),
              ( ['in'], VARIANT_BOOL, 'bGetNewZ' )),
    COMMETHOD(['hidden', helpstring(u'Queries the first two non-densified nodes of a line segment represented by the specified edge).')], HRESULT, 'QueryAdjacentVertices',
              ( ['in'], POINTER(ITinFeatureSeed), 'pSeedEdge' ),
              ( [], POINTER(ITinNode), 'pBehind' ),
              ( [], POINTER(ITinNode), 'pFront' )),
    COMMETHOD([helpstring(u'Finds a cluster of nodes, each node in the group has at least one neighbor, to which the distance is smaller, or equal to, the specified value.')], HRESULT, 'ClusterPoints',
              ( ['in'], POINTER(ITinNode), 'pSeed' ),
              ( ['in'], c_double, 'spacing' ),
              ( ['in'], POINTER(ITinFilter), 'pFilter' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumTinNode)), 'ppNodes' )),
    COMMETHOD([helpstring(u'Returns TRUE if specified node is shared by more than two enforced edges.')], HRESULT, 'IsNodeShared',
              ( ['in'], POINTER(ITinNode), 'pNode' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pIsShared' )),
    COMMETHOD([helpstring(u'Refresh cached TIN tag values.')], HRESULT, 'RefreshTagValues'),
]
################################################################
## code template for ITinFeatureEdit implementation
##class ITinFeatureEdit_Impl(object):
##    def _get(self):
##        u'The TIN nodes or edges to be ignored in conflict detection (used by processes such as CanAdd and CanMove).'
##        #return pElementsExcluded
##    def _set(self, pElementsExcluded):
##        u'The TIN nodes or edges to be ignored in conflict detection (used by processes such as CanAdd and CanMove).'
##    ElementsIgnoredInConflictTest = property(_get, _set, doc = _set.__doc__)
##
##    def IsNodeShared(self, pNode):
##        u'Returns TRUE if specified node is shared by more than two enforced edges.'
##        #return pIsShared
##
##    def CanDeleteVertex(self, pNode, pSeed, spacing):
##        u'Checks if a polygon/polyline vertex can be deleted without creating spatial conflict.'
##        #return pbCanDelete
##
##    def RemoveIslands(self, pSeed, Area, bKeepNodes, bZeroTag):
##        u'Removes islands whose area is smaller than the specified value, from the embedded polygon represented by the specified seed. Remove all holes if the value is zero.'
##        #return 
##
##    def ExtractPolyline(self, pSeed, bGetZ, bSkipDensifiedNodes):
##        u'Extracts polyline. The seed must be a special edge, or an edge with tagValue.'
##        #return ppPolyline
##
##    def StartInMemoryEditing(self):
##        u"Initiates memory edit mode. Use ITinEdit::SaveAs to persist. Don't use Save."
##        #return pbIsSuccessful
##
##    def _get(self):
##        u'Indicates if a polyline related process (e.g., ExtractPolyline) should stop at juncture.'
##        #return pbStop
##    def _set(self, pbStop):
##        u'Indicates if a polyline related process (e.g., ExtractPolyline) should stop at juncture.'
##    StopAtJuncture = property(_get, _set, doc = _set.__doc__)
##
##    def AddPolyline(self, pShape, Type, TagValue, NodeTagValue, pSeed, pZ):
##        u'Adds polyline. pSeed can be NULL or Nothing.'
##        #return 
##
##    def MoveVertex(self, pNode, pSeed, pNewLocation, bGetNewZ):
##        u'Moves the specified vertex of an embedded polygon/polyline to a new location.'
##        #return 
##
##    def ClusterPoints(self, pSeed, spacing, pFilter):
##        u'Finds a cluster of nodes, each node in the group has at least one neighbor, to which the distance is smaller, or equal to, the specified value.'
##        #return ppNodes
##
##    def CanReplace(self, pShape, pSeed, spacing):
##        u'Checks if the embedded object can be replaced by the new shape without creating spatial conflict.'
##        #return pbCanReplace
##
##    def AddPolylineZ(self, pShape, Type, TagValue, NodeTagValue, pSeed):
##        u'Adds Z-aware polyline. pSeed can be NULL or Nothing.'
##        #return 
##
##    def SetToConstrainedDelaunay(self):
##        u'Apply constrained Delaunay from now on.'
##        #return 
##
##    def CanDisplace(self, pSeed, dx, dy, spacing):
##        u'Checks if the embedded object can be moved (continuously) to a new location without creating spatial conflict.'
##        #return pbCanDisplace
##
##    def AddPolyObjects(self, pFeatureClass, pFilter, pHeightField, pValueField, bSetEdgeTagValue, bSetNodeTagValue, Type):
##        u'Adds polygons/polylines.'
##        #return 
##
##    def ConvertToPolygons(self, pFeatureClass, pFilter, bStopAtEnforcedEdge, bSkipDensifiedNodes, pFieldName):
##        u'Converts qualified triangles to a polygon feature class.'
##        #return 
##
##    def ConvertToPolylines(self, pFeatureClass, pFilter, bSkipDensifiedNodes, pFieldName):
##        u'Converts qualified edges to a polyline feature class.'
##        #return 
##
##    def DeleteVertex(self, pNode, pSeed):
##        u'Deletes the specified vertex from an embedded polygon/polyline.'
##        #return 
##
##    def CanScalePolygon(self, pSeed, pOrigin, Scale, spacing):
##        u'Checks if the embedded polygon can be expanded or shrinked without creating spatial conflict. pOrigin can be NULL or Nothing.'
##        #return pbCanScale
##
##    def CanRotate(self, pSeed, pOrigin, Angle, spacing):
##        u'Checks if the embedded polyline/polygon can be rotated without creating spatial conflict. pOrigin can be NULL or Nothing.'
##        #return pbCanRotate
##
##    def Rotate(self, pSeed, pOrigin, Angle, bGetNewZ):
##        u'Rotates the embedded polygon/polyline represented by the specified seed. pOrigin can be NULL or Nothing.'
##        #return 
##
##    def ExtractPolygon(self, pSeed, bGetZ, bSkipDensifiedNodes):
##        u'Extracts polygon.'
##        #return ppPolygon
##
##    def AddPolygon(self, pShape, Type, TagValue, edgeTagValue, NodeTagValue, pSeed, pZ):
##        u'Adds polygon. pSeed can be NULL or Nothing.'
##        #return 
##
##    def Merge(self, pCommonEdge, newValue, bKeepCommonNodes):
##        u'Merges two embedded polygons sharing the specified common edge.'
##        #return 
##
##    def AddPolygonZ(self, pShape, Type, TagValue, edgeTagValue, NodeTagValue, pSeed):
##        u'Adds Z-aware polygon. pSeed can be NULL or Nothing.'
##        #return 
##
##    def RefreshTagValues(self):
##        u'Refresh cached TIN tag values.'
##        #return 
##
##    def CanMoveVertex(self, pNode, pSeed, pNewLocation, spacing):
##        u'Checks if a polygon/polyline vertex can be moved to a new location without creating spatial conflict.'
##        #return pbCanMove
##
##    def QueryAdjacentVertices(self, pSeedEdge, pBehind, pFront):
##        u'Queries the first two non-densified nodes of a line segment represented by the specified edge).'
##        #return 
##
##    def Delete(self, pSeed):
##        u'Deletes the embedded point/polygon/polyline represented by the specified seed.'
##        #return 
##
##    def ScalePolygon(self, pSeed, pOrigin, Scale, bGetNewZ):
##        u'Expands or shrinks the embedded polygon represented by the specified seed. pOrigin can be NULL or Nothing.'
##        #return 
##
##    def CanAdd(self, pShape, spacing):
##        u'Checks if the specified shape can be added without creating spatial conflict.'
##        #return pbCanAdd
##
##    def Move(self, pSeed, dx, dy, bGetNewZ):
##        u'Moves the embedded point/polygon/polyline represented by the specified seed.'
##        #return 
##
##    def AddPointZ(self, pPoint, TagValue, pSeed):
##        u'Adds a 3D point to the TIN. pSeed can be NULL or Nothing.'
##        #return 
##
##    def CanMove(self, pSeed, dx, dy, spacing):
##        u'Checks if the embedded object can be relocated to a new location without creating spatial conflict.'
##        #return pbCanMove
##
##    def CanAddVertex(self, pPoly, pNewPoint, bClose, spacing):
##        u'Checks if a new polygon/polyline vertex can be added without creating spatial conflict.'
##        #return pbCanAdd
##
##    def _get(self):
##        u'Indicates if a polygon related process (e.g., ExtractPolygon) should stop when reach an enforced edge.'
##        #return pbStop
##    def _set(self, pbStop):
##        u'Indicates if a polygon related process (e.g., ExtractPolygon) should stop when reach an enforced edge.'
##    StopAtEnforcedEdge = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def IsInMemoryEditMode(self):
##        u'Indicates if the specified TIN is in in-memory-edit mode.'
##        #return pbIsInEditMode
##


# values for enumeration 'esriSearchOrder'
esriSearchOrderSpatial = 0
esriSearchOrderAttribute = 1
esriSearchOrder = c_int # enum
class RecordSet(CoClass):
    u'Esri Record Set object.'
    _reg_clsid_ = GUID('{B517E8C7-6EC0-46E0-80BB-D61ED691C5CE}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IRecordSetInit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to methods that allow construction of recordsets based on source row or feature collections.'
    _iid_ = GUID('{40D32697-0B40-4023-8D73-20E004B5377B}')
    _idlflags_ = ['oleautomation']
RecordSet._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRecordSet, IRecordSet2, IRecordSetInit, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

IVersionEdit2._methods_ = [
    COMMETHOD([helpstring(u'Reconciles the current version with a target version.')], HRESULT, 'Reconcile2',
              ( ['in'], BSTR, 'VersionName' ),
              ( ['in'], VARIANT_BOOL, 'acquireLock' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'foundConflicts' )),
]
################################################################
## code template for IVersionEdit2 implementation
##class IVersionEdit2_Impl(object):
##    def Reconcile2(self, VersionName, acquireLock):
##        u'Reconciles the current version with a target version.'
##        #return foundConflicts
##

class IRebuildIndexes(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that rebuild dataset indexes.'
    _iid_ = GUID('{D77CD399-A952-4E9F-A17C-7F2BC587146D}')
    _idlflags_ = ['oleautomation']
IRebuildIndexes._methods_ = [
    COMMETHOD([helpstring(u'Rebuild databases indexes of the dataset.')], HRESULT, 'RebuildIndexes',
              ( ['in'], VARIANT_BOOL, 'deltaOnly' )),
]
################################################################
## code template for IRebuildIndexes implementation
##class IRebuildIndexes_Impl(object):
##    def RebuildIndexes(self, deltaOnly):
##        u'Rebuild databases indexes of the dataset.'
##        #return 
##

class IVersionedTable(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to methods that apply to versioned tables.'
    _iid_ = GUID('{AA983A4D-8488-11D2-AAE2-00C04FA37585}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriDifferenceType'
esriDifferenceTypeInsert = 0
esriDifferenceTypeDeleteNoChange = 1
esriDifferenceTypeUpdateNoChange = 2
esriDifferenceTypeUpdateUpdate = 3
esriDifferenceTypeUpdateDelete = 4
esriDifferenceTypeDeleteUpdate = 5
esriDifferenceType = c_int # enum
class IDifferenceCursor(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the version difference cursor.'
    _iid_ = GUID('{3791E745-7995-11D2-AADE-00C04FA37585}')
    _idlflags_ = ['oleautomation']
IVersionedTable._methods_ = [
    COMMETHOD([helpstring(u'Returns an object cursor that can be used to retrieve rows by difference type.')], HRESULT, 'Differences',
              ( ['in'], POINTER(ITable), 'differenceTable' ),
              ( ['in'], esriDifferenceType, 'differenceType' ),
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' ),
              ( ['retval', 'out'], POINTER(POINTER(IDifferenceCursor)), 'Cursor' )),
]
################################################################
## code template for IVersionedTable implementation
##class IVersionedTable_Impl(object):
##    def Differences(self, differenceTable, differenceType, QueryFilter):
##        u'Returns an object cursor that can be used to retrieve rows by difference type.'
##        #return Cursor
##

IWorkspaceDomains2._methods_ = [
    COMMETHOD([helpstring(u'Alters an existing domain in the workspace.')], HRESULT, 'AlterDomain',
              ( ['in'], POINTER(IDomain), 'Domain' )),
]
################################################################
## code template for IWorkspaceDomains2 implementation
##class IWorkspaceDomains2_Impl(object):
##    def AlterDomain(self, Domain):
##        u'Alters an existing domain in the workspace.'
##        #return 
##

IGPHistoricalMarker._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the historical marker.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the historical marker.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The timestamp of the historical marker.')], HRESULT, 'TimeStamp',
              ( ['retval', 'out'], POINTER(VARIANT), 'tstamp' )),
    COMMETHOD(['propput', helpstring(u'The timestamp of the historical marker.')], HRESULT, 'TimeStamp',
              ( ['in'], VARIANT, 'tstamp' )),
]
################################################################
## code template for IGPHistoricalMarker implementation
##class IGPHistoricalMarker_Impl(object):
##    def _get(self):
##        u'The timestamp of the historical marker.'
##        #return tstamp
##    def _set(self, tstamp):
##        u'The timestamp of the historical marker.'
##    TimeStamp = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the historical marker.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the historical marker.'
##    Name = property(_get, _set, doc = _set.__doc__)
##

IVersionEdit3._methods_ = [
    COMMETHOD([helpstring(u'Reconciles the current version with a target version.')], HRESULT, 'Reconcile3',
              ( ['in'], BSTR, 'VersionName' ),
              ( ['in'], VARIANT_BOOL, 'acquireLock' ),
              ( ['in'], VARIANT_BOOL, 'abortIfConflicts' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'foundConflicts' )),
]
################################################################
## code template for IVersionEdit3 implementation
##class IVersionEdit3_Impl(object):
##    def Reconcile3(self, VersionName, acquireLock, abortIfConflicts):
##        u'Reconciles the current version with a target version.'
##        #return foundConflicts
##

class IVersionedView(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to methods that control versioned views.'
    _iid_ = GUID('{7B5E7005-329F-11D4-9FB9-00C04F6BDF0C}')
    _idlflags_ = []
IVersionedView._methods_ = [
    COMMETHOD(['propget', helpstring(u'Does the table have a versioned view.')], HRESULT, 'HasVersionedView',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasVersionedView' )),
    COMMETHOD(['propget', helpstring(u'The name of the associated versioned view.')], HRESULT, 'VersionedViewName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD([helpstring(u'Create a versioned view.')], HRESULT, 'CreateVersionedView',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD([helpstring(u'Drop the versioned view.')], HRESULT, 'DropVersionedView'),
]
################################################################
## code template for IVersionedView implementation
##class IVersionedView_Impl(object):
##    @property
##    def HasVersionedView(self):
##        u'Does the table have a versioned view.'
##        #return HasVersionedView
##
##    @property
##    def VersionedViewName(self):
##        u'The name of the associated versioned view.'
##        #return Name
##
##    def DropVersionedView(self):
##        u'Drop the versioned view.'
##        #return 
##
##    def CreateVersionedView(self, Name):
##        u'Create a versioned view.'
##        #return 
##

IDEGeoDataServerType._methods_ = [
]
################################################################
## code template for IDEGeoDataServerType implementation
##class IDEGeoDataServerType_Impl(object):

IDEServerObject._methods_ = [
    COMMETHOD(['propget', helpstring(u'The server object type.')], HRESULT, 'ServerObjectType',
              ( ['retval', 'out'], POINTER(BSTR), 'soType' )),
    COMMETHOD(['propput', helpstring(u'The server object type.')], HRESULT, 'ServerObjectType',
              ( ['in'], BSTR, 'soType' )),
    COMMETHOD(['propget', helpstring(u'The url to the server object.')], HRESULT, 'URL',
              ( ['retval', 'out'], POINTER(BSTR), 'theUrl' )),
    COMMETHOD(['propput', helpstring(u'The url to the server object.')], HRESULT, 'URL',
              ( ['in'], BSTR, 'theUrl' )),
]
################################################################
## code template for IDEServerObject implementation
##class IDEServerObject_Impl(object):
##    def _get(self):
##        u'The server object type.'
##        #return soType
##    def _set(self, soType):
##        u'The server object type.'
##    ServerObjectType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The url to the server object.'
##        #return theUrl
##    def _set(self, theUrl):
##        u'The url to the server object.'
##    URL = property(_get, _set, doc = _set.__doc__)
##

class IVersionEdit4(IVersionEdit3):
    _case_insensitive_ = True
    u'Provides access to members that return information about versions and posting of versions.'
    _iid_ = GUID('{5D9EDDD2-9549-4778-BC30-DB190902C6E7}')
    _idlflags_ = ['oleautomation']
IVersionEdit4._methods_ = [
    COMMETHOD([helpstring(u'Reconciles the current version with a target version.')], HRESULT, 'Reconcile4',
              ( ['in'], BSTR, 'VersionName' ),
              ( ['in'], VARIANT_BOOL, 'acquireLock' ),
              ( ['in'], VARIANT_BOOL, 'abortIfConflicts' ),
              ( ['in'], VARIANT_BOOL, 'ChildWins' ),
              ( ['in'], VARIANT_BOOL, 'ColumnLevel' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'foundConflicts' )),
]
################################################################
## code template for IVersionEdit4 implementation
##class IVersionEdit4_Impl(object):
##    def Reconcile4(self, VersionName, acquireLock, abortIfConflicts, ChildWins, ColumnLevel):
##        u'Reconciles the current version with a target version.'
##        #return foundConflicts
##

class IDEGeoDataServer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe GeoDataServer objects.'
    _iid_ = GUID('{D8DE3B6C-8231-43CA-A442-D6536B755B3F}')
    _idlflags_ = ['oleautomation']
IDEGeoDataServer._methods_ = [
]
################################################################
## code template for IDEGeoDataServer implementation
##class IDEGeoDataServer_Impl(object):

IDERasterDataset._methods_ = [
    COMMETHOD(['propget', helpstring(u'The format of this RasterRataset.')], HRESULT, 'Format',
              ( ['retval', 'out'], POINTER(BSTR), 'Format' )),
    COMMETHOD(['propput', helpstring(u'The format of this RasterRataset.')], HRESULT, 'Format',
              ( ['in'], BSTR, 'Format' )),
    COMMETHOD(['propget', helpstring(u'The compression technique applied to this RasterDataset.')], HRESULT, 'CompressionType',
              ( ['retval', 'out'], POINTER(BSTR), 'comp' )),
    COMMETHOD(['propput', helpstring(u'The compression technique applied to this RasterDataset.')], HRESULT, 'CompressionType',
              ( ['in'], BSTR, 'comp' )),
    COMMETHOD(['propget', helpstring(u'The sensor type of this RasterDataset.')], HRESULT, 'SensorType',
              ( ['retval', 'out'], POINTER(BSTR), 'sensor' )),
    COMMETHOD(['propput', helpstring(u'The sensor type of this RasterDataset.')], HRESULT, 'SensorType',
              ( ['in'], BSTR, 'sensor' )),
    COMMETHOD(['propget', helpstring(u'The number of bands in the collection.')], HRESULT, 'BandCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propput', helpstring(u'The number of bands in the collection.')], HRESULT, 'BandCount',
              ( ['in'], c_int, 'Count' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the dataset is temporary.')], HRESULT, 'Permanent',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'b' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the dataset is temporary.')], HRESULT, 'Permanent',
              ( ['in'], VARIANT_BOOL, 'b' )),
]
################################################################
## code template for IDERasterDataset implementation
##class IDERasterDataset_Impl(object):
##    def _get(self):
##        u'The sensor type of this RasterDataset.'
##        #return sensor
##    def _set(self, sensor):
##        u'The sensor type of this RasterDataset.'
##    SensorType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The compression technique applied to this RasterDataset.'
##        #return comp
##    def _set(self, comp):
##        u'The compression technique applied to this RasterDataset.'
##    CompressionType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The number of bands in the collection.'
##        #return Count
##    def _set(self, Count):
##        u'The number of bands in the collection.'
##    BandCount = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the dataset is temporary.'
##        #return b
##    def _set(self, b):
##        u'Indicates if the dataset is temporary.'
##    Permanent = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The format of this RasterRataset.'
##        #return Format
##    def _set(self, Format):
##        u'The format of this RasterRataset.'
##    Format = property(_get, _set, doc = _set.__doc__)
##

IVersionEvents._methods_ = [
    COMMETHOD([helpstring(u'This event is fired during reconciliation, after conflicts are detected. It can be used by application developers to filter found conflicts.')], HRESULT, 'OnConflictsDetected',
              ( [], POINTER(VARIANT_BOOL), 'conflictsRemoved' ),
              ( [], POINTER(VARIANT_BOOL), 'errorOccurred' ),
              ( [], POINTER(BSTR), 'errorString' )),
    COMMETHOD([helpstring(u'This event is fired after the version is reconciled, associating it with a new database state. Applications must discard or refresh any cached row objects.')], HRESULT, 'OnReconcile',
              ( ['in'], BSTR, 'targetVersionName' ),
              ( ['in'], VARIANT_BOOL, 'HasConflicts' )),
    COMMETHOD([helpstring(u'This event is fired after the version is refreshed, associating it with a new database state. Applications must discard or refresh any cached row objects.')], HRESULT, 'OnRefreshVersion'),
    COMMETHOD([helpstring(u'This event is fired after the version is changed in place to represent a different version, associating it with a new database state. Applications must discard or refresh any cached row objects.')], HRESULT, 'OnRedefineVersion',
              ( ['in'], BSTR, 'oldVersionName' ),
              ( ['in'], BSTR, 'newVersionName' )),
]
################################################################
## code template for IVersionEvents implementation
##class IVersionEvents_Impl(object):
##    def OnConflictsDetected(self, conflictsRemoved, errorOccurred, errorString):
##        u'This event is fired during reconciliation, after conflicts are detected. It can be used by application developers to filter found conflicts.'
##        #return 
##
##    def OnReconcile(self, targetVersionName, HasConflicts):
##        u'This event is fired after the version is reconciled, associating it with a new database state. Applications must discard or refresh any cached row objects.'
##        #return 
##
##    def OnRefreshVersion(self):
##        u'This event is fired after the version is refreshed, associating it with a new database state. Applications must discard or refresh any cached row objects.'
##        #return 
##
##    def OnRedefineVersion(self, oldVersionName, newVersionName):
##        u'This event is fired after the version is changed in place to represent a different version, associating it with a new database state. Applications must discard or refresh any cached row objects.'
##        #return 
##

class IFieldInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to properties that give extended information on the field.'
    _iid_ = GUID('{A2BAAE2C-969B-11D2-AE77-080009EC732A}')
    _idlflags_ = ['oleautomation']
IFieldInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the field is visible.')], HRESULT, 'Visible',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Visible' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the field is visible.')], HRESULT, 'Visible',
              ( ['in'], VARIANT_BOOL, 'Visible' )),
    COMMETHOD(['propget', helpstring(u'The alias for the field.')], HRESULT, 'Alias',
              ( ['retval', 'out'], POINTER(BSTR), 'AliasName' )),
    COMMETHOD(['propput', helpstring(u'The alias for the field.')], HRESULT, 'Alias',
              ( ['in'], BSTR, 'AliasName' )),
    COMMETHOD(['propget', helpstring(u'The number format for the field (invalid if non-numeric field).')], HRESULT, 'NumberFormat',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.INumberFormat)), 'Format' )),
    COMMETHOD(['propputref', helpstring(u'The number format for the field (invalid if non-numeric field).')], HRESULT, 'NumberFormat',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.INumberFormat), 'Format' )),
    COMMETHOD(['propget', helpstring(u'The string representation of a given value based on the current field information.')], HRESULT, 'AsString',
              ( ['in'], VARIANT, 'Value' ),
              ( ['retval', 'out'], POINTER(BSTR), 'stringRep' )),
]
################################################################
## code template for IFieldInfo implementation
##class IFieldInfo_Impl(object):
##    def _get(self):
##        u'Indicates if the field is visible.'
##        #return Visible
##    def _set(self, Visible):
##        u'Indicates if the field is visible.'
##    Visible = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def AsString(self, Value):
##        u'The string representation of a given value based on the current field information.'
##        #return stringRep
##
##    def NumberFormat(self, Format):
##        u'The number format for the field (invalid if non-numeric field).'
##        #return 
##
##    def _get(self):
##        u'The alias for the field.'
##        #return AliasName
##    def _set(self, AliasName):
##        u'The alias for the field.'
##    Alias = property(_get, _set, doc = _set.__doc__)
##

class INameMapping(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage name mapping and conflicts between two locations.'
    _iid_ = GUID('{36A4D96F-F5D5-11D3-8120-00C04F686238}')
    _idlflags_ = ['oleautomation']
IEnumNameMapping._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next Copy Name Mapping object.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(INameMapping)), 'info' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Finds a particular source name.')], HRESULT, 'FindDatasetName',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['retval', 'out'], POINTER(POINTER(INameMapping)), 'info' )),
    COMMETHOD([helpstring(u'Finds a particular Domain.')], HRESULT, 'FindDomain',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(INameMapping)), 'info' )),
]
################################################################
## code template for IEnumNameMapping implementation
##class IEnumNameMapping_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def FindDatasetName(self, Name, Type):
##        u'Finds a particular source name.'
##        #return info
##
##    def FindDomain(self, Name):
##        u'Finds a particular Domain.'
##        #return info
##
##    def Next(self):
##        u'Retrieves the next Copy Name Mapping object.'
##        #return info
##

IReplicaDataset._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the dataset.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'rName' )),
    COMMETHOD(['propget', helpstring(u'The type of the dataset.')], HRESULT, 'Type',
              ( ['retval', 'out'], POINTER(esriDatasetType), 'DatasetType' )),
    COMMETHOD(['propget', helpstring(u'The ID of the dataset.')], HRESULT, 'DatasetID',
              ( ['retval', 'out'], POINTER(c_int), 'DatasetID' )),
    COMMETHOD(['propget', helpstring(u'The owner of the dataset in the master geodatabase.')], HRESULT, 'ParentOwner',
              ( ['retval', 'out'], POINTER(BSTR), 'dsParentOwner' )),
    COMMETHOD(['propget', helpstring(u'The name of the master geodatabase the dataset was checked out from.')], HRESULT, 'ParentDatabase',
              ( ['retval', 'out'], POINTER(BSTR), 'dsParentDatabase' )),
    COMMETHOD(['propget', helpstring(u'The ID of the replica associated with this dataset.')], HRESULT, 'ReplicaID',
              ( ['retval', 'out'], POINTER(c_int), 'rID' )),
]
################################################################
## code template for IReplicaDataset implementation
##class IReplicaDataset_Impl(object):
##    @property
##    def ParentDatabase(self):
##        u'The name of the master geodatabase the dataset was checked out from.'
##        #return dsParentDatabase
##
##    @property
##    def Name(self):
##        u'The name of the dataset.'
##        #return rName
##
##    @property
##    def ReplicaID(self):
##        u'The ID of the replica associated with this dataset.'
##        #return rID
##
##    @property
##    def ParentOwner(self):
##        u'The owner of the dataset in the master geodatabase.'
##        #return dsParentOwner
##
##    @property
##    def Type(self):
##        u'The type of the dataset.'
##        #return DatasetType
##
##    @property
##    def DatasetID(self):
##        u'The ID of the dataset.'
##        #return DatasetID
##

class IGeometryResultOptions(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to methods that control geometry options.'
    _iid_ = GUID('{F0FCF561-C0DF-4D3C-A562-51063550522D}')
    _idlflags_ = ['oleautomation']
IGeometryResultOptions._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if MaximumSegmentLength and MaximumDeviation will be honored to densify geometry in the results.')], HRESULT, 'DensifyGeometries',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'doDensify' )),
    COMMETHOD(['propput', helpstring(u'Indicates if MaximumSegmentLength and MaximumDeviation will be honored to densify geometry in the results.')], HRESULT, 'DensifyGeometries',
              ( ['in'], VARIANT_BOOL, 'doDensify' )),
    COMMETHOD(['propget', helpstring(u'The maximum segment length.')], HRESULT, 'MaximumSegmentLength',
              ( ['retval', 'out'], POINTER(c_double), 'maxSegLen' )),
    COMMETHOD(['propput', helpstring(u'The maximum segment length.')], HRESULT, 'MaximumSegmentLength',
              ( ['in'], c_double, 'maxSegLen' )),
    COMMETHOD(['propget', helpstring(u'The maximum deviation.')], HRESULT, 'MaximumDeviation',
              ( ['retval', 'out'], POINTER(c_double), 'maxDev' )),
    COMMETHOD(['propput', helpstring(u'The maximum deviation.')], HRESULT, 'MaximumDeviation',
              ( ['in'], c_double, 'maxDev' )),
    COMMETHOD(['propget', helpstring(u'Indicates whether MaximumAllowableOffset will be honored to generalize the geometry in the results.')], HRESULT, 'GeneralizeGeometries',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'doGeneralize' )),
    COMMETHOD(['propput', helpstring(u'Indicates whether MaximumAllowableOffset will be honored to generalize the geometry in the results.')], HRESULT, 'GeneralizeGeometries',
              ( ['in'], VARIANT_BOOL, 'doGeneralize' )),
    COMMETHOD(['propget', helpstring(u'The maximum allowable offset.')], HRESULT, 'MaximumAllowableOffset',
              ( ['retval', 'out'], POINTER(c_double), 'maxOffset' )),
    COMMETHOD(['propput', helpstring(u'The maximum allowable offset.')], HRESULT, 'MaximumAllowableOffset',
              ( ['in'], c_double, 'maxOffset' )),
]
################################################################
## code template for IGeometryResultOptions implementation
##class IGeometryResultOptions_Impl(object):
##    def _get(self):
##        u'The maximum segment length.'
##        #return maxSegLen
##    def _set(self, maxSegLen):
##        u'The maximum segment length.'
##    MaximumSegmentLength = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The maximum allowable offset.'
##        #return maxOffset
##    def _set(self, maxOffset):
##        u'The maximum allowable offset.'
##    MaximumAllowableOffset = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The maximum deviation.'
##        #return maxDev
##    def _set(self, maxDev):
##        u'The maximum deviation.'
##    MaximumDeviation = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates whether MaximumAllowableOffset will be honored to generalize the geometry in the results.'
##        #return doGeneralize
##    def _set(self, doGeneralize):
##        u'Indicates whether MaximumAllowableOffset will be honored to generalize the geometry in the results.'
##    GeneralizeGeometries = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if MaximumSegmentLength and MaximumDeviation will be honored to densify geometry in the results.'
##        #return doDensify
##    def _set(self, doDensify):
##        u'Indicates if MaximumSegmentLength and MaximumDeviation will be honored to densify geometry in the results.'
##    DensifyGeometries = property(_get, _set, doc = _set.__doc__)
##

class IGPTopologyMembership(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to members that describe the properties of a feature class' topology membership."
    _iid_ = GUID('{E8D97CAE-9362-4E48-AA85-ABA1D8FD628D}')
    _idlflags_ = ['oleautomation']
IGPTopologyMembership._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the Topology this feature class participates in.')], HRESULT, 'TopologyName',
              ( ['retval', 'out'], POINTER(BSTR), 'TopologyName' )),
    COMMETHOD(['propput', helpstring(u'The name of the Topology this feature class participates in.')], HRESULT, 'TopologyName',
              ( ['in'], BSTR, 'TopologyName' )),
    COMMETHOD(['propget', helpstring(u'The weight of the feature class in the topology.')], HRESULT, 'Weight',
              ( ['retval', 'out'], POINTER(c_double), 'Weight' )),
    COMMETHOD(['propput', helpstring(u'The weight of the feature class in the topology.')], HRESULT, 'Weight',
              ( ['in'], c_double, 'Weight' )),
    COMMETHOD(['propget', helpstring(u'The XYRank of the feature class in the topology.')], HRESULT, 'XYRank',
              ( ['retval', 'out'], POINTER(c_int), 'XYRank' )),
    COMMETHOD(['propput', helpstring(u'The XYRank of the feature class in the topology.')], HRESULT, 'XYRank',
              ( ['in'], c_int, 'XYRank' )),
    COMMETHOD(['propget', helpstring(u'The ZRank of the feature class in the topology.')], HRESULT, 'ZRank',
              ( ['retval', 'out'], POINTER(c_int), 'ZRank' )),
    COMMETHOD(['propput', helpstring(u'The ZRank of the feature class in the topology.')], HRESULT, 'ZRank',
              ( ['in'], c_int, 'ZRank' )),
    COMMETHOD(['propget', helpstring(u'Indicates if event notification is fired on validate.')], HRESULT, 'EventNotificationOnValidate',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'eventNotification' )),
    COMMETHOD(['propput', helpstring(u'Indicates if event notification is fired on validate.')], HRESULT, 'EventNotificationOnValidate',
              ( ['in'], VARIANT_BOOL, 'eventNotification' )),
]
################################################################
## code template for IGPTopologyMembership implementation
##class IGPTopologyMembership_Impl(object):
##    def _get(self):
##        u'The ZRank of the feature class in the topology.'
##        #return ZRank
##    def _set(self, ZRank):
##        u'The ZRank of the feature class in the topology.'
##    ZRank = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if event notification is fired on validate.'
##        #return eventNotification
##    def _set(self, eventNotification):
##        u'Indicates if event notification is fired on validate.'
##    EventNotificationOnValidate = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The weight of the feature class in the topology.'
##        #return Weight
##    def _set(self, Weight):
##        u'The weight of the feature class in the topology.'
##    Weight = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the Topology this feature class participates in.'
##        #return TopologyName
##    def _set(self, TopologyName):
##        u'The name of the Topology this feature class participates in.'
##    TopologyName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The XYRank of the feature class in the topology.'
##        #return XYRank
##    def _set(self, XYRank):
##        u'The XYRank of the feature class in the topology.'
##    XYRank = property(_get, _set, doc = _set.__doc__)
##

class DEGdbUtilities(CoClass):
    u'Geodatabase Data Element Utilities object.'
    _reg_clsid_ = GUID('{48F71B4D-72CE-42AA-A45C-5C180F6E78E8}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDEGdbUtilities(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to utility functions concerning data elements.'
    _iid_ = GUID('{BD65B611-AA51-462F-A11A-B0BA223D9E9C}')
    _idlflags_ = ['oleautomation']
class IDEGdbUtilities2(IDEGdbUtilities):
    _case_insensitive_ = True
    u'Provides access to utility functions concerning data elements.'
    _iid_ = GUID('{BD65B611-AA51-462F-A11A-B0BA223D9E9E}')
    _idlflags_ = ['oleautomation']
DEGdbUtilities._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEGdbUtilities2]

class IFeatureDatasetManage(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to modify the M Domain of a feature dataset.'
    _iid_ = GUID('{E02CCCE7-3490-11D3-9FBD-00C04F6BC724}')
    _idlflags_ = ['oleautomation']
IFeatureDatasetManage._methods_ = [
    COMMETHOD([helpstring(u'Updates the M domain based of the current M extent.')], HRESULT, 'UpdateMDomain'),
]
################################################################
## code template for IFeatureDatasetManage implementation
##class IFeatureDatasetManage_Impl(object):
##    def UpdateMDomain(self):
##        u'Updates the M domain based of the current M extent.'
##        #return 
##

class IMetadataSynchronizerManager(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control which metadata synchronizers are used to update metadata.'
    _iid_ = GUID('{7D41E96F-9216-4F4B-9F9D-7A524AECFBCC}')
    _idlflags_ = ['oleautomation']
IMetadataSynchronizerManager._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of available synchronizers.')], HRESULT, 'NumSynchronizers',
              ( ['retval', 'out'], POINTER(c_int), 'NumSynchronizers' )),
    COMMETHOD([helpstring(u'Gets the nth synchronizer.')], HRESULT, 'GetSynchronizer',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IMetadataSynchronizer)), 'synchronizer' )),
    COMMETHOD([helpstring(u'Set the synchronizer to be enabled or disabled.')], HRESULT, 'SetEnabled',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], VARIANT_BOOL, 'Enabled' )),
    COMMETHOD([helpstring(u'Indicates whether the Nth synchronizer is enabled.')], HRESULT, 'GetEnabled',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Enabled' )),
]
################################################################
## code template for IMetadataSynchronizerManager implementation
##class IMetadataSynchronizerManager_Impl(object):
##    def SetEnabled(self, Index, Enabled):
##        u'Set the synchronizer to be enabled or disabled.'
##        #return 
##
##    def GetSynchronizer(self, Index):
##        u'Gets the nth synchronizer.'
##        #return synchronizer
##
##    def GetEnabled(self, Index):
##        u'Indicates whether the Nth synchronizer is enabled.'
##        #return Enabled
##
##    @property
##    def NumSynchronizers(self):
##        u'The number of available synchronizers.'
##        #return NumSynchronizers
##

IDERelationshipClassEx._methods_ = [
    COMMETHOD(['propget', helpstring(u'The names of the origin classes.')], HRESULT, 'OriginClassNames',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'OriginClassNames' )),
    COMMETHOD(['propputref', helpstring(u'The names of the origin classes.')], HRESULT, 'OriginClassNames',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'OriginClassNames' )),
    COMMETHOD(['propget', helpstring(u'The names of the destination classes.')], HRESULT, 'DestinationClassNames',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'DestinationClassNames' )),
    COMMETHOD(['propputref', helpstring(u'The names of the destination classes.')], HRESULT, 'DestinationClassNames',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'DestinationClassNames' )),
    COMMETHOD(['propget', helpstring(u'An array with the relationship class keys (IGPRelationshipClassKey) of the origin classes.')], HRESULT, 'OriginClassKeys',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'OriginClassKeys' )),
    COMMETHOD(['propputref', helpstring(u'An array with the relationship class keys (IGPRelationshipClassKey) of the origin classes.')], HRESULT, 'OriginClassKeys',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'OriginClassKeys' )),
    COMMETHOD(['propget', helpstring(u'An array with the relationship class keys (IGPRelationshipClassKey) of the destination classes.')], HRESULT, 'DestinationClassKeys',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'DestinationClassNames' )),
    COMMETHOD(['propputref', helpstring(u'An array with the relationship class keys (IGPRelationshipClassKey) of the destination classes.')], HRESULT, 'DestinationClassKeys',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'DestinationClassNames' )),
    COMMETHOD(['propget', helpstring(u'Key type for the relationship class (Dual or Single).')], HRESULT, 'KeyType',
              ( ['retval', 'out'], POINTER(esriRelKeyType), 'KeyType' )),
    COMMETHOD(['propput', helpstring(u'Key type for the relationship class (Dual or Single).')], HRESULT, 'KeyType',
              ( ['in'], esriRelKeyType, 'KeyType' )),
    COMMETHOD(['propget', helpstring(u'Class key used for the relationship class (Undefined, ClassID or Class Code).')], HRESULT, 'ClassKey',
              ( ['retval', 'out'], POINTER(esriRelClassKey), 'ClassKey' )),
    COMMETHOD(['propput', helpstring(u'Class key used for the relationship class (Undefined, ClassID or Class Code).')], HRESULT, 'ClassKey',
              ( ['in'], esriRelClassKey, 'ClassKey' )),
    COMMETHOD(['propget', helpstring(u'Indicates if origin and destination sets intersect.')], HRESULT, 'IsReflexive',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'reflexive' )),
    COMMETHOD(['propput', helpstring(u'Indicates if origin and destination sets intersect.')], HRESULT, 'IsReflexive',
              ( ['in'], VARIANT_BOOL, 'reflexive' )),
    COMMETHOD(['propget', helpstring(u'The forward path label for the relationship class.')], HRESULT, 'ForwardPathLabel',
              ( ['retval', 'out'], POINTER(BSTR), 'label' )),
    COMMETHOD(['propput', helpstring(u'The forward path label for the relationship class.')], HRESULT, 'ForwardPathLabel',
              ( ['in'], BSTR, 'label' )),
    COMMETHOD(['propget', helpstring(u'The backward path label for the relationship class.')], HRESULT, 'BackwardPathLabel',
              ( ['retval', 'out'], POINTER(BSTR), 'label' )),
    COMMETHOD(['propput', helpstring(u'The backward path label for the relationship class.')], HRESULT, 'BackwardPathLabel',
              ( ['in'], BSTR, 'label' )),
    COMMETHOD(['propget', helpstring(u'The cardinality for the relationship class.')], HRESULT, 'Cardinality',
              ( ['retval', 'out'], POINTER(esriRelCardinality), 'relCardinality' )),
    COMMETHOD(['propput', helpstring(u'The cardinality for the relationship class.')], HRESULT, 'Cardinality',
              ( ['in'], esriRelCardinality, 'relCardinality' )),
    COMMETHOD(['propget', helpstring(u'The notification direction for the relationship class.')], HRESULT, 'Notification',
              ( ['retval', 'out'], POINTER(esriRelNotification), 'Notification' )),
    COMMETHOD(['propput', helpstring(u'The notification direction for the relationship class.')], HRESULT, 'Notification',
              ( ['in'], esriRelNotification, 'Notification' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the relationships in this relationship class have attributes.')], HRESULT, 'IsAttributed',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'attributed' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the relationships in this relationship class have attributes.')], HRESULT, 'IsAttributed',
              ( [], VARIANT_BOOL, 'attributed' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the relationship class represents a composite relationship in which the origin object class represents the composite object.')], HRESULT, 'IsComposite',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'composite' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the relationship class represents a composite relationship in which the origin object class represents the composite object.')], HRESULT, 'IsComposite',
              ( ['in'], VARIANT_BOOL, 'composite' )),
    COMMETHOD(['propget', helpstring(u'The relationship rules that apply to this relationship class.')], HRESULT, 'RelationshipRules',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'Rules' )),
    COMMETHOD(['propputref', helpstring(u'The relationship rules that apply to this relationship class.')], HRESULT, 'RelationshipRules',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'Rules' )),
]
################################################################
## code template for IDERelationshipClassEx implementation
##class IDERelationshipClassEx_Impl(object):
##    def _get(self):
##        u'Indicates if the relationships in this relationship class have attributes.'
##        #return attributed
##    def _set(self, attributed):
##        u'Indicates if the relationships in this relationship class have attributes.'
##    IsAttributed = property(_get, _set, doc = _set.__doc__)
##
##    def OriginClassKeys(self, OriginClassKeys):
##        u'An array with the relationship class keys (IGPRelationshipClassKey) of the origin classes.'
##        #return 
##
##    def _get(self):
##        u'The backward path label for the relationship class.'
##        #return label
##    def _set(self, label):
##        u'The backward path label for the relationship class.'
##    BackwardPathLabel = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Key type for the relationship class (Dual or Single).'
##        #return KeyType
##    def _set(self, KeyType):
##        u'Key type for the relationship class (Dual or Single).'
##    KeyType = property(_get, _set, doc = _set.__doc__)
##
##    def DestinationClassNames(self, DestinationClassNames):
##        u'The names of the destination classes.'
##        #return 
##
##    def DestinationClassKeys(self, DestinationClassNames):
##        u'An array with the relationship class keys (IGPRelationshipClassKey) of the destination classes.'
##        #return 
##
##    def _get(self):
##        u'Indicates if the relationship class represents a composite relationship in which the origin object class represents the composite object.'
##        #return composite
##    def _set(self, composite):
##        u'Indicates if the relationship class represents a composite relationship in which the origin object class represents the composite object.'
##    IsComposite = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Class key used for the relationship class (Undefined, ClassID or Class Code).'
##        #return ClassKey
##    def _set(self, ClassKey):
##        u'Class key used for the relationship class (Undefined, ClassID or Class Code).'
##    ClassKey = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The notification direction for the relationship class.'
##        #return Notification
##    def _set(self, Notification):
##        u'The notification direction for the relationship class.'
##    Notification = property(_get, _set, doc = _set.__doc__)
##
##    def OriginClassNames(self, OriginClassNames):
##        u'The names of the origin classes.'
##        #return 
##
##    def _get(self):
##        u'The cardinality for the relationship class.'
##        #return relCardinality
##    def _set(self, relCardinality):
##        u'The cardinality for the relationship class.'
##    Cardinality = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The forward path label for the relationship class.'
##        #return label
##    def _set(self, label):
##        u'The forward path label for the relationship class.'
##    ForwardPathLabel = property(_get, _set, doc = _set.__doc__)
##
##    def RelationshipRules(self, Rules):
##        u'The relationship rules that apply to this relationship class.'
##        #return 
##
##    def _get(self):
##        u'Indicates if origin and destination sets intersect.'
##        #return reflexive
##    def _set(self, reflexive):
##        u'Indicates if origin and destination sets intersect.'
##    IsReflexive = property(_get, _set, doc = _set.__doc__)
##

IWorkspaceStatus._methods_ = [
    COMMETHOD(['propget', helpstring(u'The workspace this status refers to.')], HRESULT, 'Workspace',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'Workspace' )),
    COMMETHOD(['propget', helpstring(u'The current connection status of the workspace.')], HRESULT, 'ConnectionStatus',
              ( ['retval', 'out'], POINTER(esriWorkspaceConnectionStatus), 'cstatus' )),
]
################################################################
## code template for IWorkspaceStatus implementation
##class IWorkspaceStatus_Impl(object):
##    @property
##    def ConnectionStatus(self):
##        u'The current connection status of the workspace.'
##        #return cstatus
##
##    @property
##    def Workspace(self):
##        u'The workspace this status refers to.'
##        #return Workspace
##

class ITinSurface(ISurface):
    _case_insensitive_ = True
    u'Provides access to members that control TIN surfaces.'
    _iid_ = GUID('{73B80FBD-FF33-11D1-A549-0000F8774F0F}')
    _idlflags_ = []
class ITinSurface2(ITinSurface):
    _case_insensitive_ = True
    u'Provides access to members that control TIN surfaces.'
    _iid_ = GUID('{249CD6B0-8441-42E7-BBE6-2CAE4A1DAC9A}')
    _idlflags_ = []

# values for enumeration 'esriSurfaceInterpolationType'
esriLinearInterpolation = 0
esriNaturalNeighborInterpolation = 1
esriNaturalNeighborZmin = 2
esriNaturalNeighborZmax = 3
esriNaturalNeighborZaverage = 4
esriNaturalNeighborZnearest = 5
esriNaturalNeighborIDW = 6
esriSurfaceInterpolationType = c_int # enum
ITinSurface._methods_ = [
    COMMETHOD(['propput', helpstring(u'The elevation interpolation method for rasterization.')], HRESULT, 'RasterInterpolationMethod',
              ( ['in'], esriSurfaceInterpolationType, 'pType' )),
    COMMETHOD(['propget', helpstring(u'The elevation interpolation method for rasterization.')], HRESULT, 'RasterInterpolationMethod',
              ( ['retval', 'out'], POINTER(esriSurfaceInterpolationType), 'pType' )),
    COMMETHOD(['propput', helpstring(u'The vector indicating the direction of the light source relative to the scene.')], HRESULT, 'SunPosition',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPosition' )),
    COMMETHOD(['propget', helpstring(u'The vector indicating the direction of the light source relative to the scene.')], HRESULT, 'SunPosition',
              ( ['retval', 'out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPosition' )),
    COMMETHOD(['hidden', helpstring(u'Returns the hillshade brightness value of the plane defined by the three points.')], HRESULT, 'GetIntensity',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPi' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPj' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPk' ),
              ( ['retval', 'out'], POINTER(c_double), 'pIntensity' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'QueryElevationBand',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPi' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPj' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPk' ),
              ( ['in'], c_double, 'zLowerBound' ),
              ( ['in'], c_double, 'zUpperBound' ),
              ( ['out'], POINTER(c_int), 'pCount' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pRegion' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'GetTriNormal',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPi' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPj' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPk' ),
              ( ['retval', 'out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pNormal' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'GetUnitTriNormal',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPi' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPj' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPk' ),
              ( ['retval', 'out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pNormal' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'GetTriSlopeRadians',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPi' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPj' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPk' ),
              ( ['retval', 'out'], POINTER(c_double), 'pSlope' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'GetTriSlopeDegrees',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPi' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPj' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPk' ),
              ( ['retval', 'out'], POINTER(c_double), 'pSlope' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'GetTriSlopePercent',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPi' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPj' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPk' ),
              ( ['retval', 'out'], POINTER(c_double), 'pSlope' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'GetTriAspectRadians',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPi' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPj' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPk' ),
              ( ['retval', 'out'], POINTER(c_double), 'pAspect' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'GetTriAspectDegrees',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPi' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPj' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPk' ),
              ( ['retval', 'out'], POINTER(c_double), 'pAspect' )),
    COMMETHOD([helpstring(u'Returns the surface element at the specified location.')], HRESULT, 'GetSurfaceElement',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinSurfaceElement)), 'ppElement' )),
    COMMETHOD([helpstring(u"Returns portion of the TIN's volume above or below an input z value.")], HRESULT, 'GetPartialVolumeAndArea',
              ( ['in'], c_double, 'referenceHeight' ),
              ( ['in'], esriPlaneReferenceType, 'Type' ),
              ( ['in'], POINTER(IEnumTinTriangle), 'pTriangles' ),
              ( ['in', 'out', 'optional'], POINTER(VARIANT), 'pVolume' ),
              ( ['in', 'out', 'optional'], POINTER(VARIANT), 'pSurfaceArea' ),
              ( ['in', 'out', 'optional'], POINTER(VARIANT), 'pProjectedArea' )),
]
################################################################
## code template for ITinSurface implementation
##class ITinSurface_Impl(object):
##    def _get(self):
##        u'The elevation interpolation method for rasterization.'
##        #return pType
##    def _set(self, pType):
##        u'The elevation interpolation method for rasterization.'
##    RasterInterpolationMethod = property(_get, _set, doc = _set.__doc__)
##
##    def GetIntensity(self, pPi, pPj, pPk):
##        u'Returns the hillshade brightness value of the plane defined by the three points.'
##        #return pIntensity
##
##    def GetPartialVolumeAndArea(self, referenceHeight, Type, pTriangles):
##        u"Returns portion of the TIN's volume above or below an input z value."
##        #return pVolume, pSurfaceArea, pProjectedArea
##
##    def GetTriSlopePercent(self, pPi, pPj, pPk):
##        u'Restricted.'
##        #return pSlope
##
##    def _get(self):
##        u'The vector indicating the direction of the light source relative to the scene.'
##        #return pPosition
##    def _set(self, pPosition):
##        u'The vector indicating the direction of the light source relative to the scene.'
##    SunPosition = property(_get, _set, doc = _set.__doc__)
##
##    def GetTriAspectDegrees(self, pPi, pPj, pPk):
##        u'Restricted.'
##        #return pAspect
##
##    def GetTriSlopeRadians(self, pPi, pPj, pPk):
##        u'Restricted.'
##        #return pSlope
##
##    def GetSurfaceElement(self, pPoint):
##        u'Returns the surface element at the specified location.'
##        #return ppElement
##
##    def GetTriAspectRadians(self, pPi, pPj, pPk):
##        u'Restricted.'
##        #return pAspect
##
##    def QueryElevationBand(self, pPi, pPj, pPk, zLowerBound, zUpperBound):
##        u'Restricted.'
##        #return pCount, pRegion
##
##    def GetTriSlopeDegrees(self, pPi, pPj, pPk):
##        u'Restricted.'
##        #return pSlope
##
##    def GetTriNormal(self, pPi, pPj, pPk):
##        u'Restricted.'
##        #return pNormal
##
##    def GetUnitTriNormal(self, pPi, pPj, pPk):
##        u'Restricted.'
##        #return pNormal
##

ITinSurface2._methods_ = [
    COMMETHOD([helpstring(u'Interpolate the input Polygon and output as a Multipatch.')], HRESULT, 'InterpolateAsMultiPatch',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon), 'pShape' ),
              ( ['in'], c_int, 'maxStripSize' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IMultiPatch)), 'ppMultiPatch' )),
    COMMETHOD([helpstring(u'Convert TIN into Multipatches.')], HRESULT, 'ConvertToMultiPatches',
              ( ['in'], POINTER(IFeatureClass), 'pFeatureClass' ),
              ( ['in'], c_int, 'maxPatchSize' ),
              ( ['in'], c_int, 'maxStripSize' )),
    COMMETHOD([helpstring(u'Outputs a new TIN with reduced number of nodes.')], HRESULT, 'DecimateNodes',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'pAreaOfInterest' ),
              ( ['in'], c_double, 'ZTolerance' ),
              ( ['in'], VARIANT_BOOL, 'bCopyBreakline' ),
              ( ['in'], POINTER(VARIANT), 'pMaxRemainingNodeCount' ),
              ( ['out'], POINTER(POINTER(ITin)), 'ppNewTin' ),
              ( ['in', 'out', 'optional'], POINTER(VARIANT), 'pbToleranceAchieved' )),
    COMMETHOD([helpstring(u'Outputs a new TIN with reduced number of nodes.')], HRESULT, 'DecimateNodesByCount',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'pAreaOfInterest' ),
              ( ['in'], c_int, 'maxRemainingNodeCount' ),
              ( ['in'], VARIANT_BOOL, 'bCopyBreakline' ),
              ( ['out'], POINTER(POINTER(ITin)), 'ppNewTin' )),
    COMMETHOD(['restricted', helpstring(u'Outputs a generalized TIN.')], HRESULT, 'Generalize',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'pAreaOfInterest' ),
              ( ['in'], c_double, 'ZTolerance' ),
              ( ['in'], POINTER(VARIANT), 'pMaxRemainingNodeCount' ),
              ( ['out'], POINTER(POINTER(ITin)), 'ppNewTin' ),
              ( ['in', 'out', 'optional'], POINTER(VARIANT), 'pbToleranceAchieved' )),
    COMMETHOD(['restricted', helpstring(u'Outputs a generalized TIN.')], HRESULT, 'GeneralizeByNodeCount',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'pAreaOfInterest' ),
              ( ['in'], c_int, 'maxRemainingNodeCount' ),
              ( ['out'], POINTER(POINTER(ITin)), 'ppNewTin' )),
    COMMETHOD([helpstring(u'Returns the intersections of the query ray and the surface.')], HRESULT, 'LocateMultiple',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IRay), 'pRay' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IMultipoint)), 'ppLocations' )),
]
################################################################
## code template for ITinSurface2 implementation
##class ITinSurface2_Impl(object):
##    def DecimateNodesByCount(self, pAreaOfInterest, maxRemainingNodeCount, bCopyBreakline):
##        u'Outputs a new TIN with reduced number of nodes.'
##        #return ppNewTin
##
##    def DecimateNodes(self, pAreaOfInterest, ZTolerance, bCopyBreakline, pMaxRemainingNodeCount):
##        u'Outputs a new TIN with reduced number of nodes.'
##        #return ppNewTin, pbToleranceAchieved
##
##    def ConvertToMultiPatches(self, pFeatureClass, maxPatchSize, maxStripSize):
##        u'Convert TIN into Multipatches.'
##        #return 
##
##    def InterpolateAsMultiPatch(self, pShape, maxStripSize):
##        u'Interpolate the input Polygon and output as a Multipatch.'
##        #return ppMultiPatch
##
##    def GeneralizeByNodeCount(self, pAreaOfInterest, maxRemainingNodeCount):
##        u'Outputs a generalized TIN.'
##        #return ppNewTin
##
##    def Generalize(self, pAreaOfInterest, ZTolerance, pMaxRemainingNodeCount):
##        u'Outputs a generalized TIN.'
##        #return ppNewTin, pbToleranceAchieved
##
##    def LocateMultiple(self, pRay):
##        u'Returns the intersections of the query ray and the surface.'
##        #return ppLocations
##

class IFeatureClassWrite(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to low level.'
    _iid_ = GUID('{B3E3A101-C50C-11D1-8876-0000F877762D}')
    _idlflags_ = ['oleautomation']
IFeatureClassWrite._methods_ = [
    COMMETHOD([helpstring(u'Stores a feature to the database, does not trigger OnStore event.')], HRESULT, 'WriteFeature',
              ( ['in'], POINTER(IFeature), 'Feature' )),
    COMMETHOD([helpstring(u'Stores a set of features to the database, does not trigger OnStore events.')], HRESULT, 'WriteFeatures',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'features' )),
    COMMETHOD([helpstring(u'Deletes a feature from the database, does not trigger OnDelete event.')], HRESULT, 'RemoveFeature',
              ( ['in'], POINTER(IFeature), 'Feature' )),
    COMMETHOD([helpstring(u'Deletes a set of features from the database, does not trigger OnDelete events.')], HRESULT, 'RemoveFeatures',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'features' )),
]
################################################################
## code template for IFeatureClassWrite implementation
##class IFeatureClassWrite_Impl(object):
##    def RemoveFeatures(self, features):
##        u'Deletes a set of features from the database, does not trigger OnDelete events.'
##        #return 
##
##    def RemoveFeature(self, Feature):
##        u'Deletes a feature from the database, does not trigger OnDelete event.'
##        #return 
##
##    def WriteFeature(self, Feature):
##        u'Stores a feature to the database, does not trigger OnStore event.'
##        #return 
##
##    def WriteFeatures(self, features):
##        u'Stores a set of features to the database, does not trigger OnStore events.'
##        #return 
##

class IFieldInfo2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to properties that give extended information on the field.'
    _iid_ = GUID('{8FEA7378-8BB3-4A2F-8A61-338B17A1E661}')
    _idlflags_ = ['oleautomation']
IFieldInfo2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the field is visible.')], HRESULT, 'Visible',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Visible' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the field is visible.')], HRESULT, 'Visible',
              ( ['in'], VARIANT_BOOL, 'Visible' )),
    COMMETHOD(['propget', helpstring(u'The alias for the field.')], HRESULT, 'Alias',
              ( ['retval', 'out'], POINTER(BSTR), 'AliasName' )),
    COMMETHOD(['propput', helpstring(u'The alias for the field.')], HRESULT, 'Alias',
              ( ['in'], BSTR, 'AliasName' )),
    COMMETHOD(['propget', helpstring(u'The number format for the field (invalid if non-numeric field).')], HRESULT, 'NumberFormat',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.INumberFormat)), 'Format' )),
    COMMETHOD(['propputref', helpstring(u'The number format for the field (invalid if non-numeric field).')], HRESULT, 'NumberFormat',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.INumberFormat), 'Format' )),
    COMMETHOD(['propget', helpstring(u'The string representation of a given value based on the current field information.')], HRESULT, 'AsString',
              ( ['in'], VARIANT, 'Value' ),
              ( ['retval', 'out'], POINTER(BSTR), 'stringRep' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the field value should be the ratio of itself.')], HRESULT, 'ValueAsRatio',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'ratio' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the field value should be the ratio of itself.')], HRESULT, 'ValueAsRatio',
              ( ['in'], VARIANT_BOOL, 'ratio' )),
]
################################################################
## code template for IFieldInfo2 implementation
##class IFieldInfo2_Impl(object):
##    def _get(self):
##        u'Indicates if the field is visible.'
##        #return Visible
##    def _set(self, Visible):
##        u'Indicates if the field is visible.'
##    Visible = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def AsString(self, Value):
##        u'The string representation of a given value based on the current field information.'
##        #return stringRep
##
##    def _get(self):
##        u'Indicates if the field value should be the ratio of itself.'
##        #return ratio
##    def _set(self, ratio):
##        u'Indicates if the field value should be the ratio of itself.'
##    ValueAsRatio = property(_get, _set, doc = _set.__doc__)
##
##    def NumberFormat(self, Format):
##        u'The number format for the field (invalid if non-numeric field).'
##        #return 
##
##    def _get(self):
##        u'The alias for the field.'
##        #return AliasName
##    def _set(self, AliasName):
##        u'The alias for the field.'
##    Alias = property(_get, _set, doc = _set.__doc__)
##

class IGPDatasetExtension(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return workspace extension information.'
    _iid_ = GUID('{CF2BE146-E51F-4F03-AAAD-B352867A8AE1}')
    _idlflags_ = ['oleautomation']
IGPDatasetExtension._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the extension.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The clsid of the extension.')], HRESULT, 'CLSID',
              ( ['retval', 'out'], POINTER(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.GUID), 'CLSID' )),
    COMMETHOD(['propput', helpstring(u'The name of the extension.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propput', helpstring(u'The clsid of the extension.')], HRESULT, 'CLSID',
              ( ['in'], comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.GUID, 'CLSID' )),
]
################################################################
## code template for IGPDatasetExtension implementation
##class IGPDatasetExtension_Impl(object):
##    def _get(self):
##        u'The name of the extension.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the extension.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The clsid of the extension.'
##        #return CLSID
##    def _set(self, CLSID):
##        u'The clsid of the extension.'
##    CLSID = property(_get, _set, doc = _set.__doc__)
##


# values for enumeration 'esriNetworkClassAncillaryRole'
esriNCARNone = 0
esriNCARSourceSink = 1
esriNetworkClassAncillaryRole = c_int # enum
IGPGeometricNetworkMembership._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the Geometric Network this feature participates in.')], HRESULT, 'GeometricNetworkName',
              ( ['retval', 'out'], POINTER(BSTR), 'GeometricNetworkName' )),
    COMMETHOD(['propput', helpstring(u'The name of the Geometric Network this feature participates in.')], HRESULT, 'GeometricNetworkName',
              ( ['in'], BSTR, 'GeometricNetworkName' )),
    COMMETHOD(['propget', helpstring(u'The possible network ancillary roles of the contained Features.')], HRESULT, 'NetworkAncillaryRole',
              ( ['retval', 'out'], POINTER(esriNetworkClassAncillaryRole), 'Role' )),
    COMMETHOD(['propput', helpstring(u'The possible network ancillary roles of the contained Features.')], HRESULT, 'NetworkAncillaryRole',
              ( ['in'], esriNetworkClassAncillaryRole, 'Role' )),
    COMMETHOD(['propget', helpstring(u'The enabled field.')], HRESULT, 'EnabledFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propput', helpstring(u'The enabled field.')], HRESULT, 'EnabledFieldName',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'The ancillary role field.')], HRESULT, 'AncillaryRoleFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propput', helpstring(u'The ancillary role field.')], HRESULT, 'AncillaryRoleFieldName',
              ( ['in'], BSTR, 'FieldName' )),
]
################################################################
## code template for IGPGeometricNetworkMembership implementation
##class IGPGeometricNetworkMembership_Impl(object):
##    def _get(self):
##        u'The enabled field.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The enabled field.'
##    EnabledFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The ancillary role field.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The ancillary role field.'
##    AncillaryRoleFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the Geometric Network this feature participates in.'
##        #return GeometricNetworkName
##    def _set(self, GeometricNetworkName):
##        u'The name of the Geometric Network this feature participates in.'
##    GeometricNetworkName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The possible network ancillary roles of the contained Features.'
##        #return Role
##    def _set(self, Role):
##        u'The possible network ancillary roles of the contained Features.'
##    NetworkAncillaryRole = property(_get, _set, doc = _set.__doc__)
##

class IReplicaDescription2(IReplicaDescription):
    _case_insensitive_ = True
    u'Provides access to members which set and return the properties of a ReplicaDescription object.'
    _iid_ = GUID('{AA08B5AC-B67E-4E8B-9154-891C3CFFCBCE}')
    _idlflags_ = ['oleautomation']
class IReplicaDescription3(IReplicaDescription2):
    _case_insensitive_ = True
    u'Provides access to members which set and return the properties of a ReplicaDescription object.'
    _iid_ = GUID('{B9CFADEA-B314-419A-841D-517C6BE19E3D}')
    _idlflags_ = ['oleautomation']
class IReplicaDescription4(IReplicaDescription3):
    _case_insensitive_ = True
    u'Provides access to members which set and return the properties of a ReplicaDescription object.'
    _iid_ = GUID('{CD9668C2-D755-44FD-97F6-B1649E1C3F6E}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriDataExtractionType'
esriDataExtraction = 1
esriDataCheckOut = 2
esriDataReplication = 3
esriDataXMLExport = 4
esriDataXMLCheckOut = 5
esriDataXMLExtraction = 6
esriDataXMLReplication = 7
esriRegisterXMLCheckOut = 8
esriRegisterCheckOut = 9
esriRegisterXMLReplica = 10
esriRegisterReplica = 11
esriDataExtractionType = c_int # enum

# values for enumeration 'esriReplicaModelType'
esriModelTypeSimple = 1
esriModelTypeFullGeodatabase = 2
esriReplicaModelType = c_int # enum
IReplicaDescription._methods_ = [
    COMMETHOD([helpstring(u'Defines the datasets to replica or extract and the output geodatabase.')], HRESULT, 'Init',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IEnumName), 'enumNames' ),
              ( ['in'], POINTER(IWorkspaceName), 'OutputWSName' ),
              ( ['in'], VARIANT_BOOL, 'ReuseSchema' ),
              ( ['in'], esriDataExtractionType, 'deType' )),
    COMMETHOD(['propget', helpstring(u'A list of dataset names to include in a replica.')], HRESULT, 'DatasetNames',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IEnumName)), 'enumNames' )),
    COMMETHOD(['propget', helpstring(u'The number of table type objects that will be checked out.')], HRESULT, 'TableNameCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The name of a dataset to check out.')], HRESULT, 'TableName',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'DatasetName' )),
    COMMETHOD(['propput', helpstring(u'Indicates if a table is to be excluded from a replica.')], HRESULT, 'TableExcluded',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], VARIANT_BOOL, 'exclude' )),
    COMMETHOD(['propget', helpstring(u'Indicates if a table is to be excluded from a replica.')], HRESULT, 'TableExcluded',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'exclude' )),
    COMMETHOD(['propput', helpstring(u'Defines whether to output the data as simple datasets or as they are defined in the master geodatabase.')], HRESULT, 'ReplicaModelType',
              ( ['in'], esriReplicaModelType, 'ModelType' )),
    COMMETHOD(['propget', helpstring(u'Defines whether to output the data as simple datasets or as they are defined in the master geodatabase.')], HRESULT, 'ReplicaModelType',
              ( ['retval', 'out'], POINTER(esriReplicaModelType), 'ModelType' )),
    COMMETHOD([helpstring(u'Gets the index number of a dataset.')], HRESULT, 'FindTable',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'DatasetName' ),
              ( ['retval', 'out'], POINTER(c_int), 'Index' )),
    COMMETHOD([helpstring(u'Adding dataset names to the existing list of replica description dataset names.')], HRESULT, 'AddDatasetNames',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IEnumName), 'DatasetNames' )),
    COMMETHOD(['propput', helpstring(u'Indicates if a dataset is private or not.')], HRESULT, 'IsPrivateTable',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], VARIANT_BOOL, 'IsPrivate' )),
    COMMETHOD(['propget', helpstring(u'Indicates if a dataset is private or not.')], HRESULT, 'IsPrivateTable',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsPrivate' )),
]
################################################################
## code template for IReplicaDescription implementation
##class IReplicaDescription_Impl(object):
##    @property
##    def DatasetNames(self):
##        u'A list of dataset names to include in a replica.'
##        #return enumNames
##
##    def FindTable(self, DatasetName):
##        u'Gets the index number of a dataset.'
##        #return Index
##
##    @property
##    def TableName(self, Index):
##        u'The name of a dataset to check out.'
##        #return DatasetName
##
##    def _get(self):
##        u'Defines whether to output the data as simple datasets or as they are defined in the master geodatabase.'
##        #return ModelType
##    def _set(self, ModelType):
##        u'Defines whether to output the data as simple datasets or as they are defined in the master geodatabase.'
##    ReplicaModelType = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def TableNameCount(self):
##        u'The number of table type objects that will be checked out.'
##        #return Count
##
##    def Init(self, enumNames, OutputWSName, ReuseSchema, deType):
##        u'Defines the datasets to replica or extract and the output geodatabase.'
##        #return 
##
##    def _get(self, Index):
##        u'Indicates if a dataset is private or not.'
##        #return IsPrivate
##    def _set(self, Index, IsPrivate):
##        u'Indicates if a dataset is private or not.'
##    IsPrivateTable = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self, Index):
##        u'Indicates if a table is to be excluded from a replica.'
##        #return exclude
##    def _set(self, Index, exclude):
##        u'Indicates if a table is to be excluded from a replica.'
##    TableExcluded = property(_get, _set, doc = _set.__doc__)
##
##    def AddDatasetNames(self, DatasetNames):
##        u'Adding dataset names to the existing list of replica description dataset names.'
##        #return 
##

IReplicaDescription2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if related objects have been replicated or not.')], HRESULT, 'FetchRelatedObjects',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'GetRelatedObjects' )),
    COMMETHOD([helpstring(u'Gets the index number of a dataset.')], HRESULT, 'FindTable2',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], BSTR, 'database' ),
              ( ['in'], BSTR, 'Owner' ),
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['retval', 'out'], POINTER(c_int), 'Index' )),
    COMMETHOD([helpstring(u'Gets the relationship class description.')], HRESULT, 'FindRelationshipClassInfoByName',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], BSTR, 'database' ),
              ( ['in'], BSTR, 'Owner' ),
              ( ['retval', 'out'], POINTER(POINTER(IRelationshipClassInfo)), 'RelDescription' )),
    COMMETHOD([helpstring(u'Gets the relationship class description.')], HRESULT, 'FindRelationshipClassInfo',
              ( ['in'], POINTER(IRelationshipClassName), 'RCName' ),
              ( ['retval', 'out'], POINTER(POINTER(IRelationshipClassInfo)), 'RelDescription' )),
    COMMETHOD(['propget', helpstring(u'An enumeration that describes settings for each relationship class in the replica.')], HRESULT, 'RelationshipClassesInfo',
              ( ['retval', 'out'], POINTER(POINTER(IEnumRelationshipClassInfo)), 'EnumRelInfo' )),
]
################################################################
## code template for IReplicaDescription2 implementation
##class IReplicaDescription2_Impl(object):
##    @property
##    def FetchRelatedObjects(self):
##        u'Indicates if related objects have been replicated or not.'
##        #return GetRelatedObjects
##
##    def FindRelationshipClassInfo(self, RCName):
##        u'Gets the relationship class description.'
##        #return RelDescription
##
##    def FindRelationshipClassInfoByName(self, Name, database, Owner):
##        u'Gets the relationship class description.'
##        #return RelDescription
##
##    def FindTable2(self, Name, database, Owner, Type):
##        u'Gets the index number of a dataset.'
##        #return Index
##
##    @property
##    def RelationshipClassesInfo(self):
##        u'An enumeration that describes settings for each relationship class in the replica.'
##        #return EnumRelInfo
##

IReplicaDescription3._methods_ = [
    COMMETHOD(['propput', helpstring(u'Gets the Replica access type.')], HRESULT, 'AccessType',
              ( ['in'], esriReplicaAccessType, 'AccessType' )),
    COMMETHOD(['propget', helpstring(u'Gets the Replica access type.')], HRESULT, 'AccessType',
              ( ['retval', 'out'], POINTER(esriReplicaAccessType), 'AccessType' )),
]
################################################################
## code template for IReplicaDescription3 implementation
##class IReplicaDescription3_Impl(object):
##    def _get(self):
##        u'Gets the Replica access type.'
##        #return AccessType
##    def _set(self, AccessType):
##        u'Gets the Replica access type.'
##    AccessType = property(_get, _set, doc = _set.__doc__)
##

IReplicaDescription4._methods_ = [
    COMMETHOD(['propput', helpstring(u'Gets the Replica UseArchiving Option.')], HRESULT, 'UseArchiving',
              ( ['in'], VARIANT_BOOL, 'UseArchiving' )),
    COMMETHOD(['propget', helpstring(u'Gets the Replica UseArchiving Option.')], HRESULT, 'UseArchiving',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'UseArchiving' )),
    COMMETHOD(['propget', helpstring(u'Set the replicated object target name.')], HRESULT, 'ReplicaEnumNameMapping',
              ( ['retval', 'out'], POINTER(POINTER(IEnumNameMapping)), 'EnumNameMapping' )),
]
################################################################
## code template for IReplicaDescription4 implementation
##class IReplicaDescription4_Impl(object):
##    def _get(self):
##        u'Gets the Replica UseArchiving Option.'
##        #return UseArchiving
##    def _set(self, UseArchiving):
##        u'Gets the Replica UseArchiving Option.'
##    UseArchiving = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def ReplicaEnumNameMapping(self):
##        u'Set the replicated object target name.'
##        #return EnumNameMapping
##

class GeometryResultOptions(CoClass):
    u'Esri Geometry export options object.'
    _reg_clsid_ = GUID('{9466DF6B-AC1F-4FBE-92E3-85E25CB06E2A}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
GeometryResultOptions._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGeometryResultOptions, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDocumentVersionSupportGEN]

class ITinWorkspace(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control TIN workspace functionality.'
    _iid_ = GUID('{AA2EE0D8-4C34-11D2-A56F-0000F8774F0F}')
    _idlflags_ = ['oleautomation']
ITinWorkspace._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the given BSTR name is a TIN.')], HRESULT, 'IsTin',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsTin' )),
    COMMETHOD(['restricted', helpstring(u'Indicates if the given BSTR name is a TIN.'), 'propget'], HRESULT, 'IsTinByFullName',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsTin' )),
    COMMETHOD([helpstring(u'Opens an existing TIN.')], HRESULT, 'OpenTin',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(ITin)), 'ppTin' )),
]
################################################################
## code template for ITinWorkspace implementation
##class ITinWorkspace_Impl(object):
##    @property
##    def IsTinByFullName(self, Name):
##        u'Indicates if the given BSTR name is a TIN.'
##        #return pbIsTin
##
##    @property
##    def IsTin(self, Name):
##        u'Indicates if the given BSTR name is a TIN.'
##        #return pbIsTin
##
##    def OpenTin(self, Name):
##        u'Opens an existing TIN.'
##        #return ppTin
##

class IGPSubtype(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about the subtypes in a table data element.'
    _iid_ = GUID('{60CC7230-E78D-4E22-B3C2-069E8FE8AC42}')
    _idlflags_ = ['oleautomation']
IGPSubtype._methods_ = [
    COMMETHOD(['propput', helpstring(u'The name of the subtype.')], HRESULT, 'SubtypeName',
              ( ['in'], BSTR, 'SubtypeName' )),
    COMMETHOD(['propget', helpstring(u'The name of the subtype.')], HRESULT, 'SubtypeName',
              ( ['retval', 'out'], POINTER(BSTR), 'SubtypeName' )),
    COMMETHOD(['propput', helpstring(u'The code of the subtype.')], HRESULT, 'SubtypeCode',
              ( ['in'], c_int, 'SubtypeCode' )),
    COMMETHOD(['propget', helpstring(u'The code of the subtype.')], HRESULT, 'SubtypeCode',
              ( ['retval', 'out'], POINTER(c_int), 'SubtypeCode' )),
    COMMETHOD(['propput', helpstring(u"The field's default value.")], HRESULT, 'DefaultValue',
              ( ['in'], BSTR, 'FieldName' ),
              ( ['in'], VARIANT, 'Value' )),
    COMMETHOD(['propget', helpstring(u"The field's default value.")], HRESULT, 'DefaultValue',
              ( ['in'], BSTR, 'FieldName' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
    COMMETHOD(['propput', helpstring(u"The field's domain.")], HRESULT, 'DomainName',
              ( ['in'], BSTR, 'FieldName' ),
              ( ['in'], BSTR, 'DomainName' )),
    COMMETHOD(['propget', helpstring(u"The field's domain.")], HRESULT, 'DomainName',
              ( ['in'], BSTR, 'FieldName' ),
              ( ['retval', 'out'], POINTER(BSTR), 'DomainName' )),
]
################################################################
## code template for IGPSubtype implementation
##class IGPSubtype_Impl(object):
##    def _get(self):
##        u'The name of the subtype.'
##        #return SubtypeName
##    def _set(self, SubtypeName):
##        u'The name of the subtype.'
##    SubtypeName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self, FieldName):
##        u"The field's default value."
##        #return Value
##    def _set(self, FieldName, Value):
##        u"The field's default value."
##    DefaultValue = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The code of the subtype.'
##        #return SubtypeCode
##    def _set(self, SubtypeCode):
##        u'The code of the subtype.'
##    SubtypeCode = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self, FieldName):
##        u"The field's domain."
##        #return DomainName
##    def _set(self, FieldName, DomainName):
##        u"The field's domain."
##    DomainName = property(_get, _set, doc = _set.__doc__)
##

class GPRelationshipClassKey(CoClass):
    u'The (GP) Relationship Class Key Object.'
    _reg_clsid_ = GUID('{5DCA4E1F-81A4-41C3-B160-818D22FC50B0}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGPRelationshipClassKey(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to methods that describe a key of a relationship class data element.'
    _iid_ = GUID('{7C2C531E-4882-40F5-BACE-323EF546D33C}')
    _idlflags_ = ['oleautomation']
GPRelationshipClassKey._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPRelationshipClassKey, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

IFeatureClassName._methods_ = [
    COMMETHOD(['propget', helpstring(u'The feature class shape type.')], HRESULT, 'ShapeType',
              ( ['retval', 'out'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType), 'Type' )),
    COMMETHOD(['propput', helpstring(u'The feature class shape type.')], HRESULT, 'ShapeType',
              ( ['in'], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType, 'Type' )),
    COMMETHOD(['propget', helpstring(u'The Feature Dataset Name object.')], HRESULT, 'FeatureDatasetName',
              ( ['retval', 'out'], POINTER(POINTER(IDatasetName)), 'FeatureDatasetName' )),
    COMMETHOD(['propputref', helpstring(u'The Feature Dataset Name object.')], HRESULT, 'FeatureDatasetName',
              ( ['in'], POINTER(IDatasetName), 'FeatureDatasetName' )),
    COMMETHOD(['propget', helpstring(u'The feature type for this feature class name.')], HRESULT, 'FeatureType',
              ( ['retval', 'out'], POINTER(esriFeatureType), 'Type' )),
    COMMETHOD(['propput', helpstring(u'The feature type for this feature class name.')], HRESULT, 'FeatureType',
              ( ['in'], esriFeatureType, 'Type' )),
    COMMETHOD(['propget', helpstring(u'The spatial column name for this feature class name.')], HRESULT, 'ShapeFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The spatial column name for this feature class name.')], HRESULT, 'ShapeFieldName',
              ( ['in'], BSTR, 'Name' )),
]
################################################################
## code template for IFeatureClassName implementation
##class IFeatureClassName_Impl(object):
##    def _get(self):
##        u'The feature type for this feature class name.'
##        #return Type
##    def _set(self, Type):
##        u'The feature type for this feature class name.'
##    FeatureType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The spatial column name for this feature class name.'
##        #return Name
##    def _set(self, Name):
##        u'The spatial column name for this feature class name.'
##    ShapeFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def FeatureDatasetName(self, FeatureDatasetName):
##        u'The Feature Dataset Name object.'
##        #return 
##
##    def _get(self):
##        u'The feature class shape type.'
##        #return Type
##    def _set(self, Type):
##        u'The feature class shape type.'
##    ShapeType = property(_get, _set, doc = _set.__doc__)
##


# values for enumeration 'esriTinError'
E_TIN_WORKSPACE_EXISTS = -2147219456
E_TIN_WORKSPACE_NOT_CONNECTED = -2147219455
E_TIN_WORKSPACE_ALREADY_CONNECTED = -2147219454
E_TIN_EMPTY_OBJECT = -2147219453
E_TIN_WRONG_DATASET_TYPE = -2147219452
E_TIN_WRONG_TOPOLOGY = -2147219451
E_TIN_NUMERIC_LIMIT = -2147219450
E_TIN_FAILED_TO_OPEN = -2147219449
E_TIN_FAILED_TO_SAVE = -2147219448
E_TIN_FAILED_TO_COPY = -2147219447
E_TIN_FAILED_TO_RENAME = -2147219446
E_TIN_FAILED_TO_DELETE = -2147219445
E_TIN_FILE_EXISTS = -2147219444
E_TIN_OPERATION_NOT_SUPPORTED = -2147219443
E_TIN_OUT_OF_MEMORY = -2147219442
E_TIN_IN_EDIT_MODE = -2147219441
E_TIN_NOT_IN_EDIT_MODE = -2147219440
E_TIN_CANNOT_CREATE_GEOMETRY = -2147219439
E_TIN_POLYGON_NOT_DEFINED = -2147219438
E_TIN_POLYLINE_NOT_DEFINED = -2147219437
E_TIN_HAS_VOID_Z = -2147219436
E_TIN_HAS_NO_VALUE = -2147219435
E_TIN_NODE_UNDELETABL = -2147219434
E_TIN_FIELD_ALREADY_EXISTS = -2147219433
E_TIN_OBJECT_NOT_EMPTY = -2147219432
E_TIN_WRONG_FIELD_TYPE = -2147219431
E_TIN_WRONG_GEOMETRY_TYPE = -2147219430
E_TIN_NEED_VALUE = -2147219429
E_TIN_FAILED_TO_OVER_WRITE = -2147219428
E_TIN_ZERO_VALUE = -2147219427
E_TIN_INDEX_OUT_OF_RANGE = -2147219426
E_TIN_INVALID_NAME = -2147219425
E_TIN_ALREADY_INITIALIZED = -2147219424
E_TIN_MEMORY_TIN = -2147219423
E_TIN_FAILED_TO_SWAP = -2147219422
E_TIN_NAN = -2147219421
E_TIN_SUPER_NODE = -2147219420
E_TIN_FAILED_TO_CREATE_FILE = -2147219419
E_TIN_FAILED_TO_OPEN_FILE = -2147219418
E_TIN_FAILED_TO_DELETE_FILE = -2147219417
E_TIN_GEOMETRY_HAS_NO_Z = -2147219416
E_TIN_WRONG_VARIANT_TYPE = -2147219415
E_TIN_WRONG_SURFACE_TYPE = -2147219414
E_TIN_WRONG_ELEMENT_TYPE = -2147219413
E_TIN_DIFFERENT_TIN = -2147219412
E_TIN_FIELD_ERROR = -2147219411
E_TIN_NEED_TRIANGLE_SEED = -2147219410
E_TIN_WRONG_SEED_TYPE = -2147219409
E_TIN_WRONG_GEN_SEED = -2147219408
E_TIN_FAILED_UPDATE_SEED = -2147219407
E_TIN_NODE_SHARED = -2147219406
E_TIN_INTERNAL_ERROR = -2147219405
E_TIN_FILTER_REQUIRED = -2147219404
E_TIN_NO_SPATIALREF_INFO = -2147219403
E_TIN_NOT_PROJECTED_SYSTEM = -2147219402
E_TIN_METADATA_ERROR = -2147219401
E_TIN_CANNOT_CREATE_OBJ = -2147219400
E_TIN_UPDATE_ERROR = -2147219399
E_TIN_BAD_CLASS_BREAKS = -2147219398
E_TIN_BAD_CLASS_CODES = -2147219397
E_TIN_UNSUPPORTED_SPATIAL_REFERENCE = -2147219396
E_TIN_LICENSE_NOT_AVAILABLE = -2147219395
E_TIN_EXTENSION_DISABLED = -2147219394
E_TIN_BELOW_V8 = -2147219393
E_TIN_IN_MEMORY_EDIT = -2147219392
E_TIN_WRONG_EDGE_TYPE = -2147219391
E_TIN_BAD_VALUE = -2147219390
E_TIN_FATAL = -2147219389
E_TIN_FDS_FATAL = -2147219388
E_TIN_CANCELLED = -2147219387
E_TIN_MUST_BE_DELAUNAY = -2147219386
E_TIN_XML_CORRUPTED = -2147219385
E_TIN_INVALID_LANDXML_FILE = -2147219384
E_TIN_FAILED_RESET_EXTENT = -2147219383
E_TIN_NULL_FIELD_VALUE = -2147219382
E_TIN_UNHANDLED_EXCEPTION = -2147219381
esriTinError = c_int # enum
class ITinImporter(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides methods to import TIN from external formats (LandXML for example).'
    _iid_ = GUID('{D7EFF758-0095-41A4-AB6C-E4A87F35BEDB}')
    _idlflags_ = ['oleautomation']
ITinImporter._methods_ = [
    COMMETHOD([helpstring(u'Imports TIN from LandXML file.')], HRESULT, 'ImportFromLandXML',
              ( ['in'], BSTR, 'xmlName' ),
              ( ['in'], BSTR, 'TinName' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'pIndices' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITrackCancel), 'pTrackCancel' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'ppOutTinNames' )),
    COMMETHOD([helpstring(u'Gets the names of the TINs from LandXML file.')], HRESULT, 'GetTinNamesFromLandXML',
              ( ['in'], BSTR, 'xmlName' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITrackCancel), 'pTrackCancel' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'ppOutTinNames' )),
]
################################################################
## code template for ITinImporter implementation
##class ITinImporter_Impl(object):
##    def GetTinNamesFromLandXML(self, xmlName, pTrackCancel):
##        u'Gets the names of the TINs from LandXML file.'
##        #return ppOutTinNames
##
##    def ImportFromLandXML(self, xmlName, TinName, pIndices, pTrackCancel):
##        u'Imports TIN from LandXML file.'
##        #return ppOutTinNames
##

class IFieldInfo3(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to properties that give extended information on the field.'
    _iid_ = GUID('{CA074AE5-0C07-4548-B228-CB0ABDD68098}')
    _idlflags_ = ['oleautomation']
IFieldInfo3._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the field is visible.')], HRESULT, 'Visible',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Visible' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the field is visible.')], HRESULT, 'Visible',
              ( ['in'], VARIANT_BOOL, 'Visible' )),
    COMMETHOD(['propget', helpstring(u'The alias for the field.')], HRESULT, 'Alias',
              ( ['retval', 'out'], POINTER(BSTR), 'AliasName' )),
    COMMETHOD(['propput', helpstring(u'The alias for the field.')], HRESULT, 'Alias',
              ( ['in'], BSTR, 'AliasName' )),
    COMMETHOD(['propget', helpstring(u'The number format for the field (invalid if non-numeric field).')], HRESULT, 'NumberFormat',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.INumberFormat)), 'Format' )),
    COMMETHOD(['propputref', helpstring(u'The number format for the field (invalid if non-numeric field).')], HRESULT, 'NumberFormat',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.INumberFormat), 'Format' )),
    COMMETHOD(['propget', helpstring(u'The string representation of a given value based on the current field information.')], HRESULT, 'AsString',
              ( ['in'], VARIANT, 'Value' ),
              ( ['retval', 'out'], POINTER(BSTR), 'stringRep' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the field value should be the ratio of itself.')], HRESULT, 'ValueAsRatio',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'ratio' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the field value should be the ratio of itself.')], HRESULT, 'ValueAsRatio',
              ( ['in'], VARIANT_BOOL, 'ratio' )),
    COMMETHOD(['propget', helpstring(u'Indicates how the field should be presented.')], HRESULT, 'Highlight',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Highlight' )),
    COMMETHOD(['propput', helpstring(u'Indicates how the field should be presented.')], HRESULT, 'Highlight',
              ( ['in'], VARIANT_BOOL, 'Highlight' )),
    COMMETHOD(['propget', helpstring(u'Indicates how the field should be presented.')], HRESULT, 'Readonly',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'readonlyField' )),
    COMMETHOD(['propput', helpstring(u'Indicates how the field should be presented.')], HRESULT, 'Readonly',
              ( ['in'], VARIANT_BOOL, 'readonlyField' )),
]
################################################################
## code template for IFieldInfo3 implementation
##class IFieldInfo3_Impl(object):
##    def NumberFormat(self, Format):
##        u'The number format for the field (invalid if non-numeric field).'
##        #return 
##
##    def _get(self):
##        u'The alias for the field.'
##        #return AliasName
##    def _set(self, AliasName):
##        u'The alias for the field.'
##    Alias = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the field is visible.'
##        #return Visible
##    def _set(self, Visible):
##        u'Indicates if the field is visible.'
##    Visible = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates how the field should be presented.'
##        #return readonlyField
##    def _set(self, readonlyField):
##        u'Indicates how the field should be presented.'
##    Readonly = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates how the field should be presented.'
##        #return Highlight
##    def _set(self, Highlight):
##        u'Indicates how the field should be presented.'
##    Highlight = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def AsString(self, Value):
##        u'The string representation of a given value based on the current field information.'
##        #return stringRep
##
##    def _get(self):
##        u'Indicates if the field value should be the ratio of itself.'
##        #return ratio
##    def _set(self, ratio):
##        u'Indicates if the field value should be the ratio of itself.'
##    ValueAsRatio = property(_get, _set, doc = _set.__doc__)
##

class WorkspaceEditEvents2(CoClass):
    u'WorkspaceEditEvents2 Class.'
    _reg_clsid_ = GUID('{796C3852-86C5-414D-A65F-9C790283EF22}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IWorkspaceEditEvents2(IWorkspaceEditEvents):
    _case_insensitive_ = True
    u'Provides access to events that occur to a workspace in the context of editing it.'
    _iid_ = GUID('{05F7628F-7875-4819-8948-6377CE8062BA}')
    _idlflags_ = ['oleautomation']
WorkspaceEditEvents2._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown]
WorkspaceEditEvents2._outgoing_interfaces_ = [IWorkspaceEditEvents2]

class GPWorkspaceExtension(CoClass):
    u'The (GP) Workspace Extension Object.'
    _reg_clsid_ = GUID('{8B233DBE-0591-459B-BFD1-468D2DB5267D}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGPWorkspaceExtension(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return workspace extension information.'
    _iid_ = GUID('{CF2BE146-E51F-4F03-AAAD-B352867A8AE0}')
    _idlflags_ = ['oleautomation']
GPWorkspaceExtension._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPWorkspaceExtension, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class TinPolyline(CoClass):
    u'The Esri TinPolyline component.'
    _reg_clsid_ = GUID('{2FA264B6-A214-11D3-AB4B-0008C73FD50C}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinPolyline._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITinPolyline, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]


# values for enumeration 'esriXYEventError'
XYEVENT_E_INVALID_X_NAME = -2147201023
XYEVENT_E_INVALID_X_TYPE = -2147201022
XYEVENT_E_INVALID_Y_NAME = -2147201021
XYEVENT_E_INVALID_Y_TYPE = -2147201020
XYEVENT_E_INVALID_Z_NAME = -2147201019
XYEVENT_E_INVALID_Z_TYPE = -2147201018
XYEVENT_E_CANT_SELECT = -2147201017
XYEVENT_E_SOURCENAME_NOT_SETUP = -2147201016
XYEVENT_E_CANT_DELETE_FIELD = -2147201015
esriXYEventError = c_int # enum
class GPSubtype(CoClass):
    u'The (GP) Subtype Object.'
    _reg_clsid_ = GUID('{741B5302-2917-4AAB-952A-DF5F0E019EB6}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
GPSubtype._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPSubtype, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]


# values for enumeration 'esriSpatialRelEnum'
esriSpatialRelUndefined = 0
esriSpatialRelIntersects = 1
esriSpatialRelEnvelopeIntersects = 2
esriSpatialRelIndexIntersects = 3
esriSpatialRelTouches = 4
esriSpatialRelOverlaps = 5
esriSpatialRelCrosses = 6
esriSpatialRelWithin = 7
esriSpatialRelContains = 8
esriSpatialRelRelation = 9
esriSpatialRelEnum = c_int # enum
class GPDatasetExtension(CoClass):
    u'The (GP) Dataset Extension Object.'
    _reg_clsid_ = GUID('{8B233DBE-0591-459B-BFD1-468D2DB5267E}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
GPDatasetExtension._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPDatasetExtension, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class IQueryTableName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provide access to associated query description object.'
    _iid_ = GUID('{EF234C65-4FC8-473F-8CA1-94B3DBC39B5B}')
    _idlflags_ = ['oleautomation']
class IQueryDescription(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Query information'
    _iid_ = GUID('{2E060684-E14C-44D3-858A-442AB6A0A863}')
    _idlflags_ = ['oleautomation']
IQueryTableName._methods_ = [
    COMMETHOD(['propput', helpstring(u'QueryDescription object')], HRESULT, 'QueryDescription',
              ( ['in'], POINTER(IQueryDescription), 'ppQueryDescription' )),
    COMMETHOD(['propget', helpstring(u'QueryDescription object')], HRESULT, 'QueryDescription',
              ( ['retval', 'out'], POINTER(POINTER(IQueryDescription)), 'ppQueryDescription' )),
    COMMETHOD(['propput', helpstring(u'Query string')], HRESULT, 'Query',
              ( ['in'], BSTR, 'pQuery' )),
    COMMETHOD(['propget', helpstring(u'Query string')], HRESULT, 'Query',
              ( ['retval', 'out'], POINTER(BSTR), 'pQuery' )),
]
################################################################
## code template for IQueryTableName implementation
##class IQueryTableName_Impl(object):
##    def _get(self):
##        u'Query string'
##        #return pQuery
##    def _set(self, pQuery):
##        u'Query string'
##    Query = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'QueryDescription object'
##        #return ppQueryDescription
##    def _set(self, ppQueryDescription):
##        u'QueryDescription object'
##    QueryDescription = property(_get, _set, doc = _set.__doc__)
##

class AttributedRelationship(CoClass):
    u'Esri Attributed Relationship object.'
    _reg_clsid_ = GUID('{A07E9CB1-9A95-11D2-891A-0000F877762D}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IRelationship(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about the relationship.'
    _iid_ = GUID('{22B00696-8895-11D2-8A0D-006097AFF44E}')
    _idlflags_ = ['oleautomation']
AttributedRelationship._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRow, IRowBuffer, IRowEvents, IValidate, IRowChanges, IRowCompare, IRowEdit, IRelationship, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class IEnumFeatureClass(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that hand out enumerated featureclasses and reset the enumeration.'
    _iid_ = GUID('{D4803EE5-79F4-11D0-97FC-0080C7F79481}')
    _idlflags_ = ['oleautomation']
IFeatureClassContainer._methods_ = [
    COMMETHOD(['propget', helpstring(u'The FeatureClass associated with the specified index value.')], HRESULT, 'Class',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureClass)), 'FeatureClass' )),
    COMMETHOD(['propget', helpstring(u'The FeatureClass with the specified ID.')], HRESULT, 'ClassByID',
              ( ['in'], c_int, 'ID' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureClass)), 'FeatureClass' )),
    COMMETHOD(['propget', helpstring(u'The FeatureClass with the specified name.')], HRESULT, 'ClassByName',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureClass)), 'FeatureClass' )),
    COMMETHOD(['propget', helpstring(u'The number of FeatureClasses in this container.')], HRESULT, 'ClassCount',
              ( ['retval', 'out'], POINTER(c_int), 'numClasses' )),
    COMMETHOD(['propget', helpstring(u'An enumerator over the FeatureClasses.')], HRESULT, 'Classes',
              ( ['retval', 'out'], POINTER(POINTER(IEnumFeatureClass)), 'featureClasses' )),
]
################################################################
## code template for IFeatureClassContainer implementation
##class IFeatureClassContainer_Impl(object):
##    @property
##    def ClassByID(self, ID):
##        u'The FeatureClass with the specified ID.'
##        #return FeatureClass
##
##    @property
##    def Classes(self):
##        u'An enumerator over the FeatureClasses.'
##        #return featureClasses
##
##    @property
##    def ClassCount(self):
##        u'The number of FeatureClasses in this container.'
##        #return numClasses
##
##    @property
##    def Class(self, ClassIndex):
##        u'The FeatureClass associated with the specified index value.'
##        #return FeatureClass
##
##    @property
##    def ClassByName(self, Name):
##        u'The FeatureClass with the specified name.'
##        #return FeatureClass
##

class GPRangeDomain2(CoClass):
    u'The (GP) Range Domain Object.'
    _reg_clsid_ = GUID('{2BFAEDBF-D251-452F-B39D-5C7A9D318478}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGPDomain2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'.'
    _iid_ = GUID('{1060AB89-DC4A-4A63-AE01-E1F2DA1DE886}')
    _idlflags_ = ['oleautomation']
GPRangeDomain2._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPDomain2, IGPRangeDomain2, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class HistoricalVersionMarker(CoClass):
    _reg_clsid_ = GUID('{30965A12-613F-4532-9856-2C641F01512D}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
HistoricalVersionMarker._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IHistoricalMarker]


# values for enumeration 'esriTinQualification'
esriTinAll = 1
esriTinInsideTin = 2
esriTinInsideDataArea = 4
esriTinSingleEdge = 8
esriTinDoubleEdges = 16
esriTinQualification = c_int # enum
class GPCodedValueDomain2(CoClass):
    u'The (GP) Coded Value Domain Object.'
    _reg_clsid_ = GUID('{83B0AAE8-01AC-4C74-949C-DCB8C2BBD629}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
GPCodedValueDomain2._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPDomain2, IGPCodedValueDomain2, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class IRasterFieldInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to additional field information for those tables with raster fields.'
    _iid_ = GUID('{90FB59F1-D310-11D5-9B74-0000F8780619}')
    _idlflags_ = ['oleautomation']
IRasterFieldInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'The raster field.')], HRESULT, 'RasterField',
              ( ['retval', 'out'], POINTER(POINTER(IField)), 'Field' )),
    COMMETHOD(['propget', helpstring(u'Convenience method to get the raster field name without getting the raster field.')], HRESULT, 'RasterFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
]
################################################################
## code template for IRasterFieldInfo implementation
##class IRasterFieldInfo_Impl(object):
##    @property
##    def RasterFieldName(self):
##        u'Convenience method to get the raster field name without getting the raster field.'
##        #return FieldName
##
##    @property
##    def RasterField(self):
##        u'The raster field.'
##        #return Field
##

class ITopologyErrorFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about topology errors.'
    _iid_ = GUID('{F6EF5C20-B9CC-4BFA-B40D-4F0ABB83F3FA}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriTopologyRuleType'
esriTRTAny = -1
esriTRTFeatureLargerThanClusterTolerance = 0
esriTRTAreaNoGaps = 1
esriTRTAreaNoOverlap = 3
esriTRTAreaCoveredByAreaClass = 4
esriTRTAreaAreaCoverEachOther = 5
esriTRTAreaCoveredByArea = 7
esriTRTAreaNoOverlapArea = 8
esriTRTLineCoveredByAreaBoundary = 10
esriTRTLineInsideArea = 11
esriTRTPointCoveredByAreaBoundary = 13
esriTRTPointProperlyInsideArea = 15
esriTRTAreaContainOnePoint = 16
esriTRTLineNoOverlap = 19
esriTRTLineNoIntersection = 20
esriTRTLineNoDangles = 21
esriTRTLineNoPseudos = 22
esriTRTLineCoveredByLineClass = 26
esriTRTLineNoOverlapLine = 28
esriTRTPointCoveredByLine = 29
esriTRTPointCoveredByLineEndpoint = 31
esriTRTPointDisjoint = 34
esriTRTPointCoincidePoint = 35
esriTRTAreaBoundaryCoveredByLine = 37
esriTRTAreaBoundaryCoveredByAreaBoundary = 38
esriTRTLineNoSelfOverlap = 39
esriTRTLineNoSelfIntersect = 40
esriTRTLineNoIntersectOrInteriorTouch = 41
esriTRTLineEndpointCoveredByPoint = 42
esriTRTAreaContainPoint = 43
esriTRTLineNoMultipart = 44
esriTRTLineNoIntersectLine = 45
esriTRTLineNoIntersectOrInteriorTouchLine = 46
esriTopologyRuleType = c_int # enum
ITopologyErrorFeature._methods_ = [
    COMMETHOD(['propget', helpstring(u'ID of the error.')], HRESULT, 'ErrorID',
              ( ['retval', 'out'], POINTER(c_int), 'ID' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this topology error feature has been deleted.')], HRESULT, 'IsDeleted',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'deleted' )),
    COMMETHOD(['propget', helpstring(u'ObjectID of the origin feature that created the topology error.')], HRESULT, 'OriginOID',
              ( ['retval', 'out'], POINTER(c_int), 'OID' )),
    COMMETHOD(['propget', helpstring(u'ObjectClassID of the origin feature that created the topology error.')], HRESULT, 'OriginClassID',
              ( ['retval', 'out'], POINTER(c_int), 'ClassID' )),
    COMMETHOD(['propget', helpstring(u'ObjectID of the destination feature that created the topology error.')], HRESULT, 'DestinationOID',
              ( ['retval', 'out'], POINTER(c_int), 'OID' )),
    COMMETHOD(['propget', helpstring(u'ObjectClassID of the destination feature that created the topology error.')], HRESULT, 'DestinationClassID',
              ( ['retval', 'out'], POINTER(c_int), 'ClassID' )),
    COMMETHOD(['propget', helpstring(u'Indicates if topology error is an exception.')], HRESULT, 'IsException',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'exception' )),
    COMMETHOD(['propget', helpstring(u'The topology rule that caused the topology error.')], HRESULT, 'TopologyRule',
              ( ['retval', 'out'], POINTER(POINTER(IRule)), 'Rule' )),
    COMMETHOD(['propget', helpstring(u'The Object Class for the row.')], HRESULT, 'TopologyRuleType',
              ( ['retval', 'out'], POINTER(esriTopologyRuleType), 'ruleType' )),
    COMMETHOD(['propget', helpstring(u'The geometry type of the topology error.')], HRESULT, 'ShapeType',
              ( ['retval', 'out'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType), 'GeometryType' )),
]
################################################################
## code template for ITopologyErrorFeature implementation
##class ITopologyErrorFeature_Impl(object):
##    @property
##    def ShapeType(self):
##        u'The geometry type of the topology error.'
##        #return GeometryType
##
##    @property
##    def DestinationOID(self):
##        u'ObjectID of the destination feature that created the topology error.'
##        #return OID
##
##    @property
##    def IsException(self):
##        u'Indicates if topology error is an exception.'
##        #return exception
##
##    @property
##    def TopologyRuleType(self):
##        u'The Object Class for the row.'
##        #return ruleType
##
##    @property
##    def ErrorID(self):
##        u'ID of the error.'
##        #return ID
##
##    @property
##    def DestinationClassID(self):
##        u'ObjectClassID of the destination feature that created the topology error.'
##        #return ClassID
##
##    @property
##    def OriginOID(self):
##        u'ObjectID of the origin feature that created the topology error.'
##        #return OID
##
##    @property
##    def OriginClassID(self):
##        u'ObjectClassID of the origin feature that created the topology error.'
##        #return ClassID
##
##    @property
##    def TopologyRule(self):
##        u'The topology rule that caused the topology error.'
##        #return Rule
##
##    @property
##    def IsDeleted(self):
##        u'Indicates if this topology error feature has been deleted.'
##        #return deleted
##

class ITableAttachments(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to table attachments.'
    _iid_ = GUID('{8FA8C2B0-5EA0-47C3-BBD2-509487498154}')
    _idlflags_ = ['oleautomation']
class IAttachmentManager(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{52067577-796D-421A-8502-8F10D4EBD1FE}')
    _idlflags_ = ['oleautomation']
ITableAttachments._methods_ = [
    COMMETHOD(['propget', helpstring(u'The attachment manager.')], HRESULT, 'AttachmentManager',
              ( ['retval', 'out'], POINTER(POINTER(IAttachmentManager)), 'AttachmentManager' )),
    COMMETHOD(['propget', helpstring(u'Does the table have attachments.')], HRESULT, 'HasAttachments',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'hasAttachment' )),
    COMMETHOD([helpstring(u'Add the table attachments.')], HRESULT, 'AddAttachments'),
    COMMETHOD([helpstring(u'Delete the table attachments.')], HRESULT, 'DeleteAttachments'),
]
################################################################
## code template for ITableAttachments implementation
##class ITableAttachments_Impl(object):
##    @property
##    def HasAttachments(self):
##        u'Does the table have attachments.'
##        #return hasAttachment
##
##    def AddAttachments(self):
##        u'Add the table attachments.'
##        #return 
##
##    def DeleteAttachments(self):
##        u'Delete the table attachments.'
##        #return 
##
##    @property
##    def AttachmentManager(self):
##        u'The attachment manager.'
##        #return AttachmentManager
##

IQueryFilterDefinition._methods_ = [
    COMMETHOD(['propget', helpstring(u'A clause that will be appended to the SELECT statement, following the where clause. Most commonly used for clauses like ORDER BY.')], HRESULT, 'PostfixClause',
              ( ['retval', 'out'], POINTER(BSTR), 'clause' )),
    COMMETHOD(['propput', helpstring(u'A clause that will be appended to the SELECT statement, following the where clause. Most commonly used for clauses like ORDER BY.')], HRESULT, 'PostfixClause',
              ( ['in'], BSTR, 'clause' )),
    COMMETHOD(['propget', helpstring(u'The filter definitions specified for this query filter.')], HRESULT, 'FilterDefs',
              ( ['retval', 'out'], POINTER(POINTER(IFilterDefs)), 'filters' )),
    COMMETHOD(['propputref', helpstring(u'The filter definitions specified for this query filter.')], HRESULT, 'FilterDefs',
              ( ['in'], POINTER(IFilterDefs), 'filters' )),
]
################################################################
## code template for IQueryFilterDefinition implementation
##class IQueryFilterDefinition_Impl(object):
##    def FilterDefs(self, filters):
##        u'The filter definitions specified for this query filter.'
##        #return 
##
##    def _get(self):
##        u'A clause that will be appended to the SELECT statement, following the where clause. Most commonly used for clauses like ORDER BY.'
##        #return clause
##    def _set(self, clause):
##        u'A clause that will be appended to the SELECT statement, following the where clause. Most commonly used for clauses like ORDER BY.'
##    PostfixClause = property(_get, _set, doc = _set.__doc__)
##

class ITopologyFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Indicator interface for a topology feature.'
    _iid_ = GUID('{BA4F2C93-78A1-43E8-A711-95D31966C32D}')
    _idlflags_ = ['oleautomation']
ITopologyFeature._methods_ = [
]
################################################################
## code template for ITopologyFeature implementation
##class ITopologyFeature_Impl(object):


# values for enumeration 'esriTopologyElementType'
esriTopologyNode = 1
esriTopologyEdge = 2
esriTopologyFace = 4
esriTopologyElementType = c_int # enum
class ITopologyContainer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that create, add, and hand out topologies.'
    _iid_ = GUID('{C2A33A05-ADAB-4FC9-938C-CB0E14476686}')
    _idlflags_ = ['oleautomation']
class ITopologyContainer2(ITopologyContainer):
    _case_insensitive_ = True
    u'Provides access to members that create, add, and hand out topologies.'
    _iid_ = GUID('{F6146622-E8F8-496E-9D50-800594FF3378}')
    _idlflags_ = ['oleautomation']
ITopologyContainer._methods_ = [
    COMMETHOD(['propget', helpstring(u'The topology at the specified index.')], HRESULT, 'Topology',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(ITopology)), 'Topology' )),
    COMMETHOD(['propget', helpstring(u'The topology with the specified name.')], HRESULT, 'TopologyByName',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(ITopology)), 'Topology' )),
    COMMETHOD(['propget', helpstring(u'The topology with the specified ID.')], HRESULT, 'TopologyByID',
              ( ['in'], c_int, 'ID' ),
              ( ['retval', 'out'], POINTER(POINTER(ITopology)), 'Topology' )),
    COMMETHOD(['propget', helpstring(u'The number of topologies in the container.')], HRESULT, 'TopologyCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD([helpstring(u'Creates a new topology.')], HRESULT, 'CreateTopology',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], c_double, 'ClusterTolerance' ),
              ( ['in'], c_int, 'maxGeneratedErrorCount' ),
              ( ['in'], BSTR, 'ConfigurationKeyword' ),
              ( ['retval', 'out'], POINTER(POINTER(ITopology)), 'Topology' )),
    COMMETHOD(['propget', helpstring(u'The default cluster tolerance as per the topology engine.')], HRESULT, 'DefaultClusterTolerance',
              ( ['retval', 'out'], POINTER(c_double), 'ClusterTolerance' )),
    COMMETHOD(['propget', helpstring(u'The minimal cluster tolerance as per the topology engine.')], HRESULT, 'MinimumClusterTolerance',
              ( ['retval', 'out'], POINTER(c_double), 'ClusterTolerance' )),
    COMMETHOD(['propget', helpstring(u'The maximal cluster tolerance as per the topology engine.')], HRESULT, 'MaximumClusterTolerance',
              ( ['retval', 'out'], POINTER(c_double), 'ClusterTolerance' )),
]
################################################################
## code template for ITopologyContainer implementation
##class ITopologyContainer_Impl(object):
##    @property
##    def TopologyCount(self):
##        u'The number of topologies in the container.'
##        #return Count
##
##    @property
##    def MaximumClusterTolerance(self):
##        u'The maximal cluster tolerance as per the topology engine.'
##        #return ClusterTolerance
##
##    def CreateTopology(self, Name, ClusterTolerance, maxGeneratedErrorCount, ConfigurationKeyword):
##        u'Creates a new topology.'
##        #return Topology
##
##    @property
##    def TopologyByID(self, ID):
##        u'The topology with the specified ID.'
##        #return Topology
##
##    @property
##    def DefaultClusterTolerance(self):
##        u'The default cluster tolerance as per the topology engine.'
##        #return ClusterTolerance
##
##    @property
##    def MinimumClusterTolerance(self):
##        u'The minimal cluster tolerance as per the topology engine.'
##        #return ClusterTolerance
##
##    @property
##    def TopologyByName(self, Name):
##        u'The topology with the specified name.'
##        #return Topology
##
##    @property
##    def Topology(self, Index):
##        u'The topology at the specified index.'
##        #return Topology
##

ITopologyContainer2._methods_ = [
    COMMETHOD([helpstring(u'Creates a new topology.')], HRESULT, 'CreateTopologyEx',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], c_double, 'ClusterTolerance' ),
              ( ['in'], c_double, 'ZClusterTolerance' ),
              ( ['in'], c_int, 'maxGeneratedErrorCount' ),
              ( ['in'], BSTR, 'ConfigurationKeyword' ),
              ( ['retval', 'out'], POINTER(POINTER(ITopology)), 'Topology' )),
    COMMETHOD(['propget', helpstring(u'The default z cluster tolerance as per the topology engine.')], HRESULT, 'DefaultZClusterTolerance',
              ( ['retval', 'out'], POINTER(c_double), 'ZClusterTolerance' )),
    COMMETHOD(['propget', helpstring(u'The minimal z cluster tolerance as per the topology engine.')], HRESULT, 'MinimumZClusterTolerance',
              ( ['retval', 'out'], POINTER(c_double), 'ZClusterTolerance' )),
    COMMETHOD(['propget', helpstring(u'The maximal z cluster tolerance as per the topology engine.')], HRESULT, 'MaximumZClusterTolerance',
              ( ['retval', 'out'], POINTER(c_double), 'ZClusterTolerance' )),
]
################################################################
## code template for ITopologyContainer2 implementation
##class ITopologyContainer2_Impl(object):
##    @property
##    def DefaultZClusterTolerance(self):
##        u'The default z cluster tolerance as per the topology engine.'
##        #return ZClusterTolerance
##
##    @property
##    def MinimumZClusterTolerance(self):
##        u'The minimal z cluster tolerance as per the topology engine.'
##        #return ZClusterTolerance
##
##    @property
##    def MaximumZClusterTolerance(self):
##        u'The maximal z cluster tolerance as per the topology engine.'
##        #return ZClusterTolerance
##
##    def CreateTopologyEx(self, Name, ClusterTolerance, ZClusterTolerance, maxGeneratedErrorCount, ConfigurationKeyword):
##        u'Creates a new topology.'
##        #return Topology
##

class GeoDatabaseHelper(CoClass):
    u'GeoDatabaseHelper object. Providing helper methods for GeoDatabase objects.'
    _reg_clsid_ = GUID('{4E35DA0B-C5D1-4AC9-BD62-B36B4155EE4B}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGeoDatabaseBridge(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to methods usable in all supported languages.'
    _iid_ = GUID('{9999E240-ECD1-4979-83E6-B557748C18B7}')
    _idlflags_ = ['oleautomation']
class IGeoDatabaseBridge2(IGeoDatabaseBridge):
    _case_insensitive_ = True
    u'Provides access to methods usable in all supported languages.'
    _iid_ = GUID('{84A92BC8-EE99-4D54-8547-8F6F7181F777}')
    _idlflags_ = ['oleautomation']
GeoDatabaseHelper._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGeoDatabaseBridge, IGeoDatabaseBridge2]

class XYEventSourceName(CoClass):
    u'A name object that defines the objects needed to create an XY event layer.'
    _reg_clsid_ = GUID('{309AA920-EAEC-11D3-9F8A-00C04F6BDF06}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IXYEventSourceName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the XY event source name properties.'
    _iid_ = GUID('{07F0CE74-EAEB-11D3-9F8A-00C04F6BDF06}')
    _idlflags_ = ['oleautomation']
XYEventSourceName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, IFeatureClassName, IXYEventSourceName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class XYEvent2FieldsProperties(CoClass):
    u'Defines the fields needed for an xy event layer, requiring atleast X and Y fields.'
    _reg_clsid_ = GUID('{71045CA2-7902-11D4-9FE5-00C04F6BDF06}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IXYEvent2FieldsProperties(IXYEventProperties):
    _case_insensitive_ = True
    u'Provides access to members that define the fields needed to create an XY event layer. A minimum of two fields (X and Y) are required.'
    _iid_ = GUID('{71045C9E-7902-11D4-9FE5-00C04F6BDF06}')
    _idlflags_ = ['oleautomation']
XYEvent2FieldsProperties._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IXYEventProperties, IXYEvent2FieldsProperties, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class XYEventSource(CoClass):
    u'XY event source object.'
    _reg_clsid_ = GUID('{4B194345-A3E3-11D4-9FF0-00C04F6BDF06}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDatasetEditInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that maintain dataset editing information.'
    _iid_ = GUID('{234C31C1-9740-11D1-89E2-006097AFF44E}')
    _idlflags_ = ['oleautomation']
class ITableCapabilities(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about and manage tables.'
    _iid_ = GUID('{8B0338B9-3B3D-11D4-9FBB-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
class ISubtypes(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return and modify subtype information.'
    _iid_ = GUID('{AEF78514-848F-11D2-AABA-00C04FA37B82}')
    _idlflags_ = ['oleautomation']
class IObjectClassInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to method that indicates whether an object can bypass the store method.'
    _iid_ = GUID('{872E54F4-619F-11D3-9F7D-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
class IObjectClassInfo2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to method that indicates whether an object can be modified outside of an edit session.'
    _iid_ = GUID('{2840C37D-0513-11D4-9FA7-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
class IXYEventSource(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that allow interaction with an existing XY Event Layer.'
    _iid_ = GUID('{681441E2-EAEA-11D3-9F8A-00C04F6BDF06}')
    _idlflags_ = ['oleautomation']
class IVirtualTable(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Indicator interface that identifies temporary memory tables.'
    _iid_ = GUID('{8006FF00-6A8B-4476-BDEF-0765C11B53EB}')
    _idlflags_ = ['oleautomation']
XYEventSource._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDataset, IDatasetEdit, IDatasetEditInfo, IClass, ITable, ITableCapabilities, IObjectClass, ISubtypes, IObjectClassInfo, IObjectClassInfo2, IFeatureClass, IGeoDataset, IEventSource, IXYEventSource, IVirtualTable]
XYEventSource._outgoing_interfaces_ = [IObjectClassEvents, IObjectClassSchemaEvents]


# values for enumeration 'esriSetOperation'
esriSetUnion = 1
esriSetIntersection = 2
esriSetDifference = 3
esriSetSymDifference = 4
esriSetOperation = c_int # enum

# values for enumeration 'esriSelectionType'
esriSelectionTypeIDSet = 1
esriSelectionTypeSnapshot = 2
esriSelectionTypeHybrid = 3
esriSelectionType = c_int # enum

# values for enumeration 'esriSelectionOption'
esriSelectionOptionNormal = 1
esriSelectionOptionOnlyOne = 2
esriSelectionOptionEmpty = 3
esriSelectionOption = c_int # enum
ISelectionSet._methods_ = [
    COMMETHOD(['propget', helpstring(u'The full name of the selection set.')], HRESULT, 'FullName',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The Table or FeatureClass over which the selection set is defined.')], HRESULT, 'Target',
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'Target' )),
    COMMETHOD([helpstring(u'Makes the SelectionSet permanent. By default SelectionSets are deleted when released.')], HRESULT, 'MakePermanent'),
    COMMETHOD(['propget', helpstring(u'The number of  oids in the selection set.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'numObjectIds' )),
    COMMETHOD([helpstring(u'Adds an object id to the selection set.')], HRESULT, 'Add',
              ( ['in'], c_int, 'OID' )),
    COMMETHOD([helpstring(u"Adds a list of  object id's to the selection set.")], HRESULT, 'AddList',
              ( ['in'], c_int, 'Count' ),
              ( ['in'], POINTER(c_int), 'OIDList' )),
    COMMETHOD([helpstring(u'Combines this selection set with another selection set using the specified set operation.')], HRESULT, 'Combine',
              ( ['in'], POINTER(ISelectionSet), 'otherSet' ),
              ( ['in'], esriSetOperation, 'setOp' ),
              ( ['out'], POINTER(POINTER(ISelectionSet)), 'resultSet' )),
    COMMETHOD([helpstring(u'Returns a cursor that can be used to retrieve the objects specified by a query over this selection set.')], HRESULT, 'Search',
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' ),
              ( ['in'], VARIANT_BOOL, 'Recycling' ),
              ( ['out'], POINTER(POINTER(ICursor)), 'Cursor' )),
    COMMETHOD([helpstring(u'Returns a new selection That contains the object ids selected by a query over this selection set.')], HRESULT, 'Select',
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' ),
              ( ['in'], esriSelectionType, 'selType' ),
              ( ['in'], esriSelectionOption, 'selOption' ),
              ( ['in'], POINTER(IWorkspace), 'selectionContainer' ),
              ( ['retval', 'out'], POINTER(POINTER(ISelectionSet)), 'SelectionSet' )),
    COMMETHOD([helpstring(u'Refreshes the state of a snapshot selection.')], HRESULT, 'Refresh'),
    COMMETHOD(['propget', helpstring(u'Enumerates the object ids in the selection set.')], HRESULT, 'IDs',
              ( ['retval', 'out'], POINTER(POINTER(IEnumIDs)), 'EnumIDs' )),
    COMMETHOD([helpstring(u"Removes a list of  object id's from the selection set.")], HRESULT, 'RemoveList',
              ( ['in'], c_int, 'Count' ),
              ( ['in'], POINTER(c_int), 'OIDList' )),
]
################################################################
## code template for ISelectionSet implementation
##class ISelectionSet_Impl(object):
##    @property
##    def Count(self):
##        u'The number of  oids in the selection set.'
##        #return numObjectIds
##
##    def Search(self, QueryFilter, Recycling):
##        u'Returns a cursor that can be used to retrieve the objects specified by a query over this selection set.'
##        #return Cursor
##
##    @property
##    def Target(self):
##        u'The Table or FeatureClass over which the selection set is defined.'
##        #return Target
##
##    def Select(self, QueryFilter, selType, selOption, selectionContainer):
##        u'Returns a new selection That contains the object ids selected by a query over this selection set.'
##        #return SelectionSet
##
##    def Refresh(self):
##        u'Refreshes the state of a snapshot selection.'
##        #return 
##
##    @property
##    def IDs(self):
##        u'Enumerates the object ids in the selection set.'
##        #return EnumIDs
##
##    def Add(self, OID):
##        u'Adds an object id to the selection set.'
##        #return 
##
##    def Combine(self, otherSet, setOp):
##        u'Combines this selection set with another selection set using the specified set operation.'
##        #return resultSet
##
##    def MakePermanent(self):
##        u'Makes the SelectionSet permanent. By default SelectionSets are deleted when released.'
##        #return 
##
##    @property
##    def FullName(self):
##        u'The full name of the selection set.'
##        #return Name
##
##    def RemoveList(self, Count, OIDList):
##        u"Removes a list of  object id's from the selection set."
##        #return 
##
##    def AddList(self, Count, OIDList):
##        u"Adds a list of  object id's to the selection set."
##        #return 
##

class IRasterCatalog(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the behavior and properties of a raster catalog.'
    _iid_ = GUID('{BA56286B-9344-4E5C-8EEE-119583764885}')
    _idlflags_ = ['oleautomation']
IRasterWorkspaceEx._methods_ = [
    COMMETHOD([helpstring(u'Creates a new raster dataset.')], HRESULT, 'CreateRasterDataset',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], c_int, 'numBands' ),
              ( ['in'], rstPixelType, 'PixelType' ),
              ( ['in'], POINTER(IRasterStorageDef), 'StorageDef' ),
              ( ['in'], BSTR, 'ConfigKeyword' ),
              ( ['in'], POINTER(IRasterDef), 'RasterDef' ),
              ( ['in'], POINTER(IGeometryDef), 'GeometryDef' ),
              ( ['retval', 'out'], POINTER(POINTER(IRasterDataset)), 'Dataset' )),
    COMMETHOD([helpstring(u'Creates a new raster dataset from another seed Raster.')], HRESULT, 'SaveAsRasterDataset',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IRaster), 'Raster' ),
              ( ['in'], POINTER(IRasterStorageDef), 'StorageDef' ),
              ( ['in'], BSTR, 'ConfigKeyword' ),
              ( ['in'], POINTER(IRasterDef), 'RasterDef' ),
              ( ['in'], POINTER(IGeometryDef), 'GeometryDef' ),
              ( ['retval', 'out'], POINTER(POINTER(IRasterDataset)), 'Dataset' )),
    COMMETHOD([helpstring(u'Opens an existing raster dataset.')], HRESULT, 'OpenRasterDataset',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IRasterDataset)), 'Dataset' )),
    COMMETHOD([helpstring(u'Deletes a raster dataset.')], HRESULT, 'DeleteRasterDataset',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD([helpstring(u'Registers as a RasterDataset.')], HRESULT, 'RegisterAsRasterDataset',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IGeometryDef), 'GeometryDef' )),
    COMMETHOD([helpstring(u'Creates a new raster catalog.')], HRESULT, 'CreateRasterCatalog',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IFields), 'Fields' ),
              ( ['in'], BSTR, 'ShapeFieldName' ),
              ( ['in'], BSTR, 'RasterFieldName' ),
              ( ['in'], BSTR, 'ConfigKeyword' ),
              ( ['retval', 'out'], POINTER(POINTER(IRasterCatalog)), 'Catalog' )),
    COMMETHOD([helpstring(u'Opens an existing raster catalog.')], HRESULT, 'OpenRasterCatalog',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IRasterCatalog)), 'Catalog' )),
    COMMETHOD([helpstring(u'Deletes a raster catalog.')], HRESULT, 'DeleteRasterCatalog',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD([helpstring(u'Registers as a RasterCatalog.')], HRESULT, 'RegisterAsRasterCatalog',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], BSTR, 'OIDFieldName' ),
              ( ['in'], POINTER(IGeometryDef), 'GeometryDef' )),
]
################################################################
## code template for IRasterWorkspaceEx implementation
##class IRasterWorkspaceEx_Impl(object):
##    def OpenRasterCatalog(self, Name):
##        u'Opens an existing raster catalog.'
##        #return Catalog
##
##    def SaveAsRasterDataset(self, Name, Raster, StorageDef, ConfigKeyword, RasterDef, GeometryDef):
##        u'Creates a new raster dataset from another seed Raster.'
##        #return Dataset
##
##    def DeleteRasterDataset(self, Name):
##        u'Deletes a raster dataset.'
##        #return 
##
##    def CreateRasterDataset(self, Name, numBands, PixelType, StorageDef, ConfigKeyword, RasterDef, GeometryDef):
##        u'Creates a new raster dataset.'
##        #return Dataset
##
##    def OpenRasterDataset(self, Name):
##        u'Opens an existing raster dataset.'
##        #return Dataset
##
##    def RegisterAsRasterDataset(self, Name, GeometryDef):
##        u'Registers as a RasterDataset.'
##        #return 
##
##    def DeleteRasterCatalog(self, Name):
##        u'Deletes a raster catalog.'
##        #return 
##
##    def RegisterAsRasterCatalog(self, Name, OIDFieldName, GeometryDef):
##        u'Registers as a RasterCatalog.'
##        #return 
##
##    def CreateRasterCatalog(self, Name, Fields, ShapeFieldName, RasterFieldName, ConfigKeyword):
##        u'Creates a new raster catalog.'
##        #return Catalog
##

IMetadataEdit._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if metadata can be edited.')], HRESULT, 'CanEditMetadata',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanEdit' )),
]
################################################################
## code template for IMetadataEdit implementation
##class IMetadataEdit_Impl(object):
##    @property
##    def CanEditMetadata(self):
##        u'Indicates if metadata can be edited.'
##        #return CanEdit
##

class DEGlobeServer(CoClass):
    u'MapServer Object Data Element object.'
    _reg_clsid_ = GUID('{9ADF8E53-B3FC-4348-B0C1-27BF1A5F5F39}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDEGlobeServer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe GlobeServer objects.'
    _iid_ = GUID('{37F862C8-BD6C-4840-A0E9-5F0B5CAADBBD}')
    _idlflags_ = ['oleautomation']
DEGlobeServer._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEGlobeServer, IDEServerObject, IDataElement, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDocumentVersionSupportGEN, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]


# values for enumeration 'esriNetworkTurnParticipationType'
esriNTPTNone = 0
esriNTPTInterior = 1
esriNTPTExterior = 2
esriNetworkTurnParticipationType = c_int # enum
INetworkEdge._methods_ = [
    COMMETHOD([dispid(100), helpstring(u'Direction in which this network edge element is oriented relative to the direction of its source object.'), 'propget'], HRESULT, 'Direction',
              ( ['retval', 'out'], POINTER(esriNetworkEdgeDirection), 'Direction' )),
    COMMETHOD([dispid(110), helpstring(u'Queries the positions along the source object at which the from-end and to-end of the network edge element lies.')], HRESULT, 'QueryPositions',
              ( ['out'], POINTER(c_double), 'fromPosition' ),
              ( ['out'], POINTER(c_double), 'toPosition' )),
    COMMETHOD([dispid(130), helpstring(u'Direction of travel at the from-end of the network edge element.'), 'propget'], HRESULT, 'FromAzimuth',
              ( ['retval', 'out'], POINTER(c_double), 'FromAzimuth' )),
    COMMETHOD([dispid(140), helpstring(u'Direction of travel at the to-end of the network edge element.'), 'propget'], HRESULT, 'ToAzimuth',
              ( ['retval', 'out'], POINTER(c_double), 'ToAzimuth' )),
    COMMETHOD([dispid(150), helpstring(u'Participation of this network edge element within a network turn element.'), 'propget'], HRESULT, 'TurnParticipationType',
              ( ['retval', 'out'], POINTER(esriNetworkTurnParticipationType), 'turnParticipation' )),
    COMMETHOD([dispid(160), helpstring(u'Position along the source object at which the specified position along the network edge element lies.'), 'propget'], HRESULT, 'PositionAlongObject',
              ( ['in'], c_double, 'positionAlongElement' ),
              ( ['retval', 'out'], POINTER(c_double), 'PositionAlongObject' )),
    COMMETHOD([dispid(170), helpstring(u'Number of network turn elements in which this network edge element participates.'), 'propget'], HRESULT, 'TurnCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD([dispid(180), helpstring(u"Queries the index'th network turn element in which this network edge element participates.")], HRESULT, 'QueryTurn',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(INetworkTurn), 'Turn' )),
    COMMETHOD([dispid(190), helpstring(u'Queries the network edge element corresponding to the reverse traversal of this network edge element.')], HRESULT, 'QueryEdgeInOtherDirection',
              ( ['in'], POINTER(INetworkEdge), 'Edge' )),
    COMMETHOD([dispid(200), helpstring(u'Queries the network junction elements adjacent to this network edge element.')], HRESULT, 'QueryJunctions',
              ( ['in'], POINTER(INetworkJunction), 'FromJunction' ),
              ( ['in'], POINTER(INetworkJunction), 'ToJunction' )),
]
################################################################
## code template for INetworkEdge implementation
##class INetworkEdge_Impl(object):
##    def QueryTurn(self, Index, Turn):
##        u"Queries the index'th network turn element in which this network edge element participates."
##        #return 
##
##    @property
##    def Direction(self):
##        u'Direction in which this network edge element is oriented relative to the direction of its source object.'
##        #return Direction
##
##    @property
##    def TurnCount(self):
##        u'Number of network turn elements in which this network edge element participates.'
##        #return Count
##
##    def QueryPositions(self):
##        u'Queries the positions along the source object at which the from-end and to-end of the network edge element lies.'
##        #return fromPosition, toPosition
##
##    def QueryJunctions(self, FromJunction, ToJunction):
##        u'Queries the network junction elements adjacent to this network edge element.'
##        #return 
##
##    @property
##    def ToAzimuth(self):
##        u'Direction of travel at the to-end of the network edge element.'
##        #return ToAzimuth
##
##    @property
##    def TurnParticipationType(self):
##        u'Participation of this network edge element within a network turn element.'
##        #return turnParticipation
##
##    @property
##    def FromAzimuth(self):
##        u'Direction of travel at the from-end of the network edge element.'
##        #return FromAzimuth
##
##    def QueryEdgeInOtherDirection(self, Edge):
##        u'Queries the network edge element corresponding to the reverse traversal of this network edge element.'
##        #return 
##
##    @property
##    def PositionAlongObject(self, positionAlongElement):
##        u'Position along the source object at which the specified position along the network edge element lies.'
##        #return PositionAlongObject
##

class INetworkScriptEvaluatorFunctions(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IDispatch):
    _case_insensitive_ = True
    u'Provides access to scriptable members in a network script evaluator.'
    _iid_ = GUID('{58718F2B-880F-41F2-82CE-3BB3144C6866}')
    _idlflags_ = ['dual', 'oleautomation']
INetworkScriptEvaluatorFunctions._methods_ = [
    COMMETHOD([dispid(10), helpstring(u'The value of the parameter.'), 'propget'], HRESULT, 'ParameterValueByName',
              ( ['in'], BSTR, 'parameterName' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'parameterValue' )),
]
################################################################
## code template for INetworkScriptEvaluatorFunctions implementation
##class INetworkScriptEvaluatorFunctions_Impl(object):
##    @property
##    def ParameterValueByName(self, parameterName):
##        u'The value of the parameter.'
##        #return parameterValue
##

IShields._methods_ = [
    COMMETHOD(['propget', helpstring(u'The field name whose values contain the street type.')], HRESULT, 'TypeFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The field name whose values contain the street type.')], HRESULT, 'TypeFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The field name whose values contain the house number.')], HRESULT, 'NumberFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The field name whose values contain the house number.')], HRESULT, 'NumberFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The field name whose values contain the whole address description.')], HRESULT, 'CombinedFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The field name whose values contain the whole address description.')], HRESULT, 'CombinedFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the combined field should be used for directions.')], HRESULT, 'UseCombinedField',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'useCombined' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the combined field should be used for directions.')], HRESULT, 'UseCombinedField',
              ( ['in'], VARIANT_BOOL, 'useCombined' )),
    COMMETHOD(['propget', helpstring(u'The number of shields.')], HRESULT, 'ShieldCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The shield type by index.')], HRESULT, 'ShieldType',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(BSTR), 'Type' )),
    COMMETHOD(['propget', helpstring(u'The shield description by index.')], HRESULT, 'ShieldDescription',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(BSTR), 'Type' )),
    COMMETHOD([helpstring(u'Adds a shield of the given type.')], HRESULT, 'AddShield',
              ( ['in'], BSTR, 'Type' ),
              ( ['in'], BSTR, 'Description' )),
    COMMETHOD([helpstring(u'Deletes a shield by index.')], HRESULT, 'DeleteShield',
              ( ['in'], c_int, 'Index' )),
]
################################################################
## code template for IShields implementation
##class IShields_Impl(object):
##    @property
##    def ShieldType(self, Index):
##        u'The shield type by index.'
##        #return Type
##
##    def _get(self):
##        u'Indicates if the combined field should be used for directions.'
##        #return useCombined
##    def _set(self, useCombined):
##        u'Indicates if the combined field should be used for directions.'
##    UseCombinedField = property(_get, _set, doc = _set.__doc__)
##
##    def AddShield(self, Type, Description):
##        u'Adds a shield of the given type.'
##        #return 
##
##    def _get(self):
##        u'The field name whose values contain the whole address description.'
##        #return Name
##    def _set(self, Name):
##        u'The field name whose values contain the whole address description.'
##    CombinedFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The field name whose values contain the street type.'
##        #return Name
##    def _set(self, Name):
##        u'The field name whose values contain the street type.'
##    TypeFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def DeleteShield(self, Index):
##        u'Deletes a shield by index.'
##        #return 
##
##    @property
##    def ShieldCount(self):
##        u'The number of shields.'
##        #return Count
##
##    @property
##    def ShieldDescription(self, Index):
##        u'The shield description by index.'
##        #return Type
##
##    def _get(self):
##        u'The field name whose values contain the house number.'
##        #return Name
##    def _set(self, Name):
##        u'The field name whose values contain the house number.'
##    NumberFieldName = property(_get, _set, doc = _set.__doc__)
##

class INetworkQuery3(INetworkQuery2):
    _case_insensitive_ = True
    u'Provides access to members that query the elements of the network dataset.'
    _iid_ = GUID('{C8451F72-CA7E-47D1-8E07-D545073DEDCE}')
    _idlflags_ = ['oleautomation']
INetworkQuery3._methods_ = [
    COMMETHOD([helpstring(u'Refreshes the current dynamic traffic data referenced by the network dataset based on the specified time and usage.')], HRESULT, 'RefreshDynamicTrafficData',
              ( ['in'], c_double, 'utcTime' ),
              ( ['in'], esriNetworkTimeUsage, 'utcTimeUsage' ),
              ( ['out'], POINTER(c_double), 'pDynamicTrafficUTCStartTime' ),
              ( ['out'], POINTER(c_double), 'pDynamicTrafficUTCEndTime' )),
]
################################################################
## code template for INetworkQuery3 implementation
##class INetworkQuery3_Impl(object):
##    def RefreshDynamicTrafficData(self, utcTime, utcTimeUsage):
##        u'Refreshes the current dynamic traffic data referenced by the network dataset based on the specified time and usage.'
##        #return pDynamicTrafficUTCStartTime, pDynamicTrafficUTCEndTime
##

class IInvalidArea(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that modify an invalidated area object.'
    _iid_ = GUID('{A802BA73-D947-11D1-8484-0000F875B9C6}')
    _idlflags_ = ['oleautomation']
IInvalidArea._methods_ = [
    COMMETHOD(['propget', helpstring(u'The display that will be invalidated.')], HRESULT, 'Display',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IScreenDisplay)), 'dpy' )),
    COMMETHOD(['propputref', helpstring(u'The display that will be invalidated.')], HRESULT, 'Display',
              ( ['in'], POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IScreenDisplay), 'dpy' )),
    COMMETHOD([helpstring(u'Add IFeature, IGeometry, ISet, or IEnumFeature.')], HRESULT, 'Add',
              ( ['in'], POINTER(IUnknown), 'thing' )),
    COMMETHOD([helpstring(u'Invalidate the display.')], HRESULT, 'Invalidate',
              ( [], c_short, 'screenCache' )),
]
################################################################
## code template for IInvalidArea implementation
##class IInvalidArea_Impl(object):
##    def Invalidate(self, screenCache):
##        u'Invalidate the display.'
##        #return 
##
##    def Add(self, thing):
##        u'Add IFeature, IGeometry, ISet, or IEnumFeature.'
##        #return 
##
##    def Display(self, dpy):
##        u'The display that will be invalidated.'
##        #return 
##

IEnumIDs._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next id in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(c_int), 'ID' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumIDs implementation
##class IEnumIDs_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next id in the enumeration sequence.'
##        #return ID
##


# values for enumeration 'esriSQLFunctionName'
esriSQL_MIN = 1
esriSQL_MAX = 2
esriSQL_COUNT = 3
esriSQL_SUM = 4
esriSQL_AVG = 5
esriSQL_VAR = 6
esriSQL_STDDEV = 7
esriSQL_CONCAT = 8
esriSQL_LEADING = 9
esriSQL_LOWER = 10
esriSQL_TRAILING = 11
esriSQL_SUBSTRING = 12
esriSQL_SUBSTRINGBYTES = 13
esriSQL_UPPER = 14
esriSQL_ASCII = 15
esriSQL_CHAR = 16
esriSQL_SOUNDEX = 17
esriSQL_TRANSLATE = 18
esriSQL_TRIM = 19
esriSQL_ABS = 20
esriSQL_ACOS = 21
esriSQL_ASIN = 22
esriSQL_ATAN = 23
esriSQL_CEILING = 24
esriSQL_COS = 25
esriSQL_FLOOR = 26
esriSQL_LOG = 27
esriSQL_LN = 28
esriSQL_MOD = 29
esriSQL_SIGN = 30
esriSQL_SIN = 31
esriSQL_TAN = 32
esriSQL_LOG10 = 33
esriSQL_POWER = 34
esriSQL_ROUND = 35
esriSQL_TRUNCATE = 36
esriSQL_SINH = 37
esriSQL_COSH = 38
esriSQL_TANH = 39
esriSQL_HEX = 40
esriSQL_EXTRACT = 41
esriSQL_BITLENGTH = 42
esriSQL_CHARLENGTH = 43
esriSQL_OCTETLENGTH = 44
esriSQL_POSITION = 45
esriSQL_CURRENTDATE = 46
esriSQL_CURRENTTIME = 47
esriSQL_CURRENTUSER = 48
esriSQL_COALESCE = 49
esriSQL_CONVERT = 50
esriSQL_CAST = 51
esriSQL_CURRENTTIMESTAMP = 52
esriSQL_NULLIF = 53
esriSQL_VAR_SAMP = 54
esriSQL_VAR_POP = 55
esriSQL_STDDEV_SAMP = 56
esriSQL_STDDEV_POP = 57
esriSQLFunctionName = c_int # enum

# values for enumeration 'esriSQLSpecialCharacters'
esriSQL_WildcardManyMatch = 1
esriSQL_WildcardSingleMatch = 2
esriSQL_DelimitedIdentifierPrefix = 3
esriSQL_DelimitedIdentifierSuffix = 4
esriSQL_EscapeKeyPrefix = 5
esriSQL_EscapeKeySuffix = 6
esriSQLSpecialCharacters = c_int # enum
ISQLSyntax._methods_ = [
    COMMETHOD([helpstring(u'Given a database, owner, and table name, return its fully qualified name.')], HRESULT, 'QualifyTableName',
              ( ['in'], BSTR, 'dbName' ),
              ( ['in'], BSTR, 'OwnerName' ),
              ( ['in'], BSTR, 'TableName' ),
              ( ['retval', 'out'], POINTER(BSTR), 'FullName' )),
    COMMETHOD([helpstring(u'Given a table name and column name, returns its fully qualified name.')], HRESULT, 'QualifyColumnName',
              ( ['in'], BSTR, 'TableName' ),
              ( ['in'], BSTR, 'columnName' ),
              ( ['retval', 'out'], POINTER(BSTR), 'FullName' )),
    COMMETHOD([helpstring(u'Given a table name, determine its qualification parts.')], HRESULT, 'ParseTableName',
              ( ['in'], BSTR, 'FullName' ),
              ( ['out'], POINTER(BSTR), 'dbName' ),
              ( ['out'], POINTER(BSTR), 'OwnerName' ),
              ( ['out'], POINTER(BSTR), 'TableName' )),
    COMMETHOD([helpstring(u'Given a column name, determine its qualification parts.')], HRESULT, 'ParseColumnName',
              ( ['in'], BSTR, 'FullName' ),
              ( ['out'], POINTER(BSTR), 'dbName' ),
              ( ['out'], POINTER(BSTR), 'OwnerName' ),
              ( ['out'], POINTER(BSTR), 'TableName' ),
              ( ['out'], POINTER(BSTR), 'columnName' )),
    COMMETHOD([helpstring(u'DBMS dependent SQL function names.')], HRESULT, 'GetFunctionName',
              ( ['in'], esriSQLFunctionName, 'sqlFunc' ),
              ( ['retval', 'out'], POINTER(BSTR), 'sqlFunctionName' )),
    COMMETHOD([helpstring(u'Special DBMS dependent SQL characters.')], HRESULT, 'GetSpecialCharacter',
              ( ['in'], esriSQLSpecialCharacters, 'sqlSC' ),
              ( ['retval', 'out'], POINTER(BSTR), 'specialChar' )),
    COMMETHOD([helpstring(u'Supported SQL predicates.')], HRESULT, 'GetSupportedPredicates',
              ( ['retval', 'out'], POINTER(c_int), 'predicates' )),
    COMMETHOD([helpstring(u'Supported SQL clauses.')], HRESULT, 'GetSupportedClauses',
              ( ['retval', 'out'], POINTER(c_int), 'clauses' )),
    COMMETHOD([helpstring(u"True if DBMS's identifiers are case sensitive.")], HRESULT, 'GetIdentifierCase',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isCaseSensitive' )),
    COMMETHOD([helpstring(u"True if DBMS's quoted identifiers are case sensitive.")], HRESULT, 'GetDelimitedIdentifierCase',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isCaseSensitive' )),
    COMMETHOD([helpstring(u'True if string comparisons are case sensitive.')], HRESULT, 'GetStringComparisonCase',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isCaseSensitive' )),
    COMMETHOD([helpstring(u'The list of DBMS specific reserved keywords.')], HRESULT, 'GetKeywords',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IEnumBSTR)), 'keywords' )),
    COMMETHOD([helpstring(u'The list of invalid characters used in literals (if any).')], HRESULT, 'GetInvalidCharacters',
              ( ['retval', 'out'], POINTER(BSTR), 'InvalidChars' )),
    COMMETHOD([helpstring(u'The list of invalid characters used in literals (if any).')], HRESULT, 'GetInvalidStartingCharacters',
              ( ['retval', 'out'], POINTER(BSTR), 'InvalidChars' )),
]
################################################################
## code template for ISQLSyntax implementation
##class ISQLSyntax_Impl(object):
##    def ParseTableName(self, FullName):
##        u'Given a table name, determine its qualification parts.'
##        #return dbName, OwnerName, TableName
##
##    def GetInvalidStartingCharacters(self):
##        u'The list of invalid characters used in literals (if any).'
##        #return InvalidChars
##
##    def GetStringComparisonCase(self):
##        u'True if string comparisons are case sensitive.'
##        #return isCaseSensitive
##
##    def GetInvalidCharacters(self):
##        u'The list of invalid characters used in literals (if any).'
##        #return InvalidChars
##
##    def QualifyColumnName(self, TableName, columnName):
##        u'Given a table name and column name, returns its fully qualified name.'
##        #return FullName
##
##    def GetKeywords(self):
##        u'The list of DBMS specific reserved keywords.'
##        #return keywords
##
##    def GetIdentifierCase(self):
##        u"True if DBMS's identifiers are case sensitive."
##        #return isCaseSensitive
##
##    def GetSpecialCharacter(self, sqlSC):
##        u'Special DBMS dependent SQL characters.'
##        #return specialChar
##
##    def ParseColumnName(self, FullName):
##        u'Given a column name, determine its qualification parts.'
##        #return dbName, OwnerName, TableName, columnName
##
##    def GetDelimitedIdentifierCase(self):
##        u"True if DBMS's quoted identifiers are case sensitive."
##        #return isCaseSensitive
##
##    def GetFunctionName(self, sqlFunc):
##        u'DBMS dependent SQL function names.'
##        #return sqlFunctionName
##
##    def GetSupportedPredicates(self):
##        u'Supported SQL predicates.'
##        #return predicates
##
##    def QualifyTableName(self, dbName, OwnerName, TableName):
##        u'Given a database, owner, and table name, return its fully qualified name.'
##        #return FullName
##
##    def GetSupportedClauses(self):
##        u'Supported SQL clauses.'
##        #return clauses
##


# values for enumeration 'esriSchemaLock'
esriSharedSchemaLock = 1
esriExclusiveSchemaLock = 2
esriSchemaLock = c_int # enum
class IEnumSchemaLockInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for enumerating lock info.'
    _iid_ = GUID('{A67958D7-226E-11D3-80B2-00C04F686238}')
    _idlflags_ = ['oleautomation']
ISchemaLock._methods_ = [
    COMMETHOD([helpstring(u'Changes a schema lock.')], HRESULT, 'ChangeSchemaLock',
              ( ['in'], esriSchemaLock, 'schemaLock' )),
    COMMETHOD([helpstring(u'The list of current locks.')], HRESULT, 'GetCurrentSchemaLocks',
              ( ['out'], POINTER(POINTER(IEnumSchemaLockInfo)), 'schemaLockInfo' )),
]
################################################################
## code template for ISchemaLock implementation
##class ISchemaLock_Impl(object):
##    def GetCurrentSchemaLocks(self):
##        u'The list of current locks.'
##        #return schemaLockInfo
##
##    def ChangeSchemaLock(self, schemaLock):
##        u'Changes a schema lock.'
##        #return 
##

class ITinValueFilter(ITinFilter):
    _case_insensitive_ = True
    u'Provides access to members that control TIN value filters.'
    _iid_ = GUID('{4EEE3277-FA94-11D2-AE10-000000000000}')
    _idlflags_ = ['oleautomation']
class ITinValueFilter2(ITinValueFilter):
    _case_insensitive_ = True
    u'Provides access to members that control TIN value filters.'
    _iid_ = GUID('{3110A889-298B-4849-8ABB-7A3383FD1A4E}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriTinBoundType'
esriTinClassBreaks = 0
esriTinSimpleBounds = 1
esriTinUniqueValue = 2
esriTinSimpleBoundsExclude = 3
esriTinBoundType = c_int # enum
ITinValueFilter._methods_ = [
    COMMETHOD(['propput', helpstring(u'The lower bound of the filter.')], HRESULT, 'LowerBound',
              ( ['in'], c_int, 'pLowerBound' )),
    COMMETHOD(['propget', helpstring(u'The lower bound of the filter.')], HRESULT, 'LowerBound',
              ( ['retval', 'out'], POINTER(c_int), 'pLowerBound' )),
    COMMETHOD(['propput', helpstring(u'The upper bound of the filter.')], HRESULT, 'UpperBound',
              ( ['in'], c_int, 'pUpperBound' )),
    COMMETHOD(['propget', helpstring(u'The upper bound of the filter.')], HRESULT, 'UpperBound',
              ( ['retval', 'out'], POINTER(c_int), 'pUpperBound' )),
    COMMETHOD(['propputref', helpstring(u'The classification categories of the filter.')], HRESULT, 'ClassBreaks',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'ppBreaks' )),
    COMMETHOD(['propget', helpstring(u'The classification categories of the filter.')], HRESULT, 'ClassBreaks',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray)), 'ppBreaks' )),
    COMMETHOD(['propputref', helpstring(u"The filter's numeric values used to represent each class.")], HRESULT, 'ClassBreakCodes',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'ppCodes' )),
    COMMETHOD(['propget', helpstring(u"The filter's numeric values used to represent each class.")], HRESULT, 'ClassBreakCodes',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray)), 'ppCodes' )),
    COMMETHOD(['propput', helpstring(u'The unique value of the filter.')], HRESULT, 'UniqueValue',
              ( ['in'], c_int, 'pValue' )),
    COMMETHOD(['propget', helpstring(u'The unique value of the filter.')], HRESULT, 'UniqueValue',
              ( ['retval', 'out'], POINTER(c_int), 'pValue' )),
    COMMETHOD(['propput', helpstring(u'The active boundary of the filter.')], HRESULT, 'ActiveBound',
              ( ['in'], esriTinBoundType, 'pType' )),
    COMMETHOD(['propget', helpstring(u'The active boundary of the filter.')], HRESULT, 'ActiveBound',
              ( ['retval', 'out'], POINTER(esriTinBoundType), 'pType' )),
]
################################################################
## code template for ITinValueFilter implementation
##class ITinValueFilter_Impl(object):
##    def _get(self):
##        u'The lower bound of the filter.'
##        #return pLowerBound
##    def _set(self, pLowerBound):
##        u'The lower bound of the filter.'
##    LowerBound = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The active boundary of the filter.'
##        #return pType
##    def _set(self, pType):
##        u'The active boundary of the filter.'
##    ActiveBound = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The upper bound of the filter.'
##        #return pUpperBound
##    def _set(self, pUpperBound):
##        u'The upper bound of the filter.'
##    UpperBound = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The unique value of the filter.'
##        #return pValue
##    def _set(self, pValue):
##        u'The unique value of the filter.'
##    UniqueValue = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def ClassBreakCodes(self, ppCodes):
##        u"The filter's numeric values used to represent each class."
##        #return 
##
##    @property
##    def ClassBreaks(self, ppBreaks):
##        u'The classification categories of the filter.'
##        #return 
##

ITinValueFilter2._methods_ = [
    COMMETHOD(['propput', helpstring(u'Indicates if zero tag value should be excluded.')], HRESULT, 'ZeroTagValueExcluded',
              ( ['in'], VARIANT_BOOL, 'pbExcludeZeroTagValue' )),
    COMMETHOD(['propget', helpstring(u'Indicates if zero tag value should be excluded.')], HRESULT, 'ZeroTagValueExcluded',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbExcludeZeroTagValue' )),
]
################################################################
## code template for ITinValueFilter2 implementation
##class ITinValueFilter2_Impl(object):
##    def _get(self):
##        u'Indicates if zero tag value should be excluded.'
##        #return pbExcludeZeroTagValue
##    def _set(self, pbExcludeZeroTagValue):
##        u'Indicates if zero tag value should be excluded.'
##    ZeroTagValueExcluded = property(_get, _set, doc = _set.__doc__)
##


# values for enumeration 'esriMetadataSyncAction'
esriMSAAccessed = 0
esriMSAAlways = 1
esriMSACreated = 2
esriMSANotCreated = 3
esriMSAOverwrite = 4
esriMSASelective = 5
esriMetadataSyncAction = c_int # enum
INetworkJunction._methods_ = [
    COMMETHOD([dispid(100), helpstring(u'Number of network edge elements adjacent to this network junction element.'), 'propget'], HRESULT, 'EdgeCount',
              ( ['retval', 'out'], POINTER(c_int), 'adjacentEdgeCount' )),
    COMMETHOD([dispid(110), helpstring(u'Number of network turn elements anchored at this network junction.'), 'propget'], HRESULT, 'TurnCount',
              ( ['retval', 'out'], POINTER(c_int), 'TurnCount' )),
    COMMETHOD([dispid(150), helpstring(u"Queries the index'th network edge element adjacent to this network junction element.")], HRESULT, 'QueryEdge',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], VARIANT_BOOL, 'leavingJunction' ),
              ( ['in'], POINTER(INetworkEdge), 'Edge' )),
    COMMETHOD([dispid(160), helpstring(u"Queries the index'th network turn element anchored at this network junction element.")], HRESULT, 'QueryTurn',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(INetworkTurn), 'Turn' )),
    COMMETHOD([dispid(170), helpstring(u'Queries the point object corresponding to this network junction element.')], HRESULT, 'QueryPoint',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'point' )),
]
################################################################
## code template for INetworkJunction implementation
##class INetworkJunction_Impl(object):
##    def QueryTurn(self, Index, Turn):
##        u"Queries the index'th network turn element anchored at this network junction element."
##        #return 
##
##    def QueryEdge(self, Index, leavingJunction, Edge):
##        u"Queries the index'th network edge element adjacent to this network junction element."
##        #return 
##
##    @property
##    def TurnCount(self):
##        u'Number of network turn elements anchored at this network junction.'
##        #return TurnCount
##
##    def QueryPoint(self, point):
##        u'Queries the point object corresponding to this network junction element.'
##        #return 
##
##    @property
##    def EdgeCount(self):
##        u'Number of network edge elements adjacent to this network junction element.'
##        #return adjacentEdgeCount
##

class IWorkspaceFactoryFileExtensions(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members describing the set of extensions handled by the workspace factory.'
    _iid_ = GUID('{9EA6F82B-80AE-4702-9906-2C90AC40C227}')
    _idlflags_ = ['oleautomation']
IWorkspaceFactoryFileExtensions._methods_ = [
    COMMETHOD(['propget', helpstring(u'Returns the complete set of delimited file extensions supported by this factory.')], HRESULT, 'RelevantExtensions',
              ( ['retval', 'out'], POINTER(BSTR), 'extSet' )),
    COMMETHOD(['propget', helpstring(u'Returns the active set of delimited file extensions supported by this factory.')], HRESULT, 'ActivationExtensions',
              ( ['retval', 'out'], POINTER(BSTR), 'extSet' )),
]
################################################################
## code template for IWorkspaceFactoryFileExtensions implementation
##class IWorkspaceFactoryFileExtensions_Impl(object):
##    @property
##    def ActivationExtensions(self):
##        u'Returns the active set of delimited file extensions supported by this factory.'
##        #return extSet
##
##    @property
##    def RelevantExtensions(self):
##        u'Returns the complete set of delimited file extensions supported by this factory.'
##        #return extSet
##

class RasterCatalogClassDescription(CoClass):
    u'Esri RasterCatalog Class Description.'
    _reg_clsid_ = GUID('{69B9E430-9F7D-4689-B6E7-9611928E6036}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IObjectClassDescription(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control Object Class Description.'
    _iid_ = GUID('{6A68BEBC-8B1B-11D2-A06C-0000F877EBD6}')
    _idlflags_ = ['oleautomation']
class IFeatureClassDescription(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control Feature Class Description.'
    _iid_ = GUID('{6A68BEBE-8B1B-11D2-A06C-0000F877EBD6}')
    _idlflags_ = ['oleautomation']
RasterCatalogClassDescription._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IObjectClassDescription, IFeatureClassDescription]

class RasterCatalogHelper(CoClass):
    u'A helper for RasterCatalog.'
    _reg_clsid_ = GUID('{04D7FADE-B9E6-4B18-AA22-B424A17E7FB5}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IRasterCatalogHelper(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a RasterCatalog helper.'
    _iid_ = GUID('{0E1096F4-7499-4604-8408-88A0CAB3EEAB}')
    _idlflags_ = ['oleautomation']
class IRasterCatalogHelper2(IRasterCatalogHelper):
    _case_insensitive_ = True
    u'Provides access to additional RasterCatalog utilities.'
    _iid_ = GUID('{A8231C9B-1158-4EA1-A27D-11075DF88534}')
    _idlflags_ = ['oleautomation']
RasterCatalogHelper._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRasterCatalogHelper, IRasterCatalogHelper2]

class Pnt(CoClass):
    u'A 2D point for representing raster dimension and location in pixels.'
    _reg_clsid_ = GUID('{064087E4-09B9-4892-A893-FCA89BB171D1}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Pnt._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IPnt]

class DENetworkDatasetType(CoClass):
    u'Network Dataset Data Element Type object.'
    _reg_clsid_ = GUID('{4B24F738-C123-43E6-8DD9-CBF057F10AD0}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDENetworkDatasetType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to an indicator interface for network dataset data element type objects.'
    _iid_ = GUID('{5C83A1A5-382E-4F2B-A59E-F8C645FBF36B}')
    _idlflags_ = ['oleautomation']
DENetworkDatasetType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDENetworkDatasetType, IDEGeoDatasetType, IDEDatasetType, IDataElementType, IGxFilterInfo, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class IDataElements(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the DataElements Interface.'
    _iid_ = GUID('{98252E86-5228-4BCE-8034-E07E0B2EBA94}')
    _idlflags_ = ['oleautomation']
IDataElements._methods_ = [
    COMMETHOD(['propget', helpstring(u'The data element count.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The data element at the specified position.')], HRESULT, 'Element',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IDataElement)), 'DataElement' )),
    COMMETHOD([helpstring(u'Removes the data element at the specified position.')], HRESULT, 'Remove',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD([helpstring(u'Removes all data elements.')], HRESULT, 'RemoveAll'),
    COMMETHOD([helpstring(u'Adds a data element.')], HRESULT, 'Add',
              ( ['in'], POINTER(IDataElement), 'DataElement' )),
    COMMETHOD([helpstring(u'Adds a data element at the specified position.')], HRESULT, 'Insert',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(IDataElement), 'DataElement' )),
]
################################################################
## code template for IDataElements implementation
##class IDataElements_Impl(object):
##    @property
##    def Count(self):
##        u'The data element count.'
##        #return Count
##
##    def Insert(self, Index, DataElement):
##        u'Adds a data element at the specified position.'
##        #return 
##
##    def Remove(self, Index):
##        u'Removes the data element at the specified position.'
##        #return 
##
##    @property
##    def Element(self, Index):
##        u'The data element at the specified position.'
##        #return DataElement
##
##    def RemoveAll(self):
##        u'Removes all data elements.'
##        #return 
##
##    def Add(self, DataElement):
##        u'Adds a data element.'
##        #return 
##

class INetworkBuild(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for changing the schema of a network dataset and building it.'
    _iid_ = GUID('{99CA1A8E-0301-4089-B939-1634E45F14A3}')
    _idlflags_ = ['oleautomation']
INetworkBuild._methods_ = [
    COMMETHOD([helpstring(u'Adds the given attribute to the schema of the network dataset.')], HRESULT, 'AddAttribute',
              ( ['in'], POINTER(INetworkAttribute), 'Attribute' )),
    COMMETHOD([helpstring(u'Adds the given source to the schema of the network dataset.')], HRESULT, 'AddSource',
              ( ['in'], POINTER(INetworkSource), 'Source' )),
    COMMETHOD([helpstring(u'Deletes the given attribute from the network dataset.')], HRESULT, 'DeleteAttribute',
              ( ['in'], POINTER(INetworkAttribute), 'Attribute' )),
    COMMETHOD([helpstring(u'Deletes the given source from the network dataset.')], HRESULT, 'DeleteSource',
              ( ['in'], POINTER(INetworkSource), 'Source' )),
    COMMETHOD([helpstring(u'Updates the schema for the network dataset based upon the given data element.')], HRESULT, 'UpdateSchema',
              ( ['in'], POINTER(IDENetworkDataset), 'DataElement' )),
    COMMETHOD([helpstring(u'Builds the network dataset for the given extent.')], HRESULT, 'BuildNetwork',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'areaToBuild' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'affectedArea' )),
]
################################################################
## code template for INetworkBuild implementation
##class INetworkBuild_Impl(object):
##    def DeleteAttribute(self, Attribute):
##        u'Deletes the given attribute from the network dataset.'
##        #return 
##
##    def UpdateSchema(self, DataElement):
##        u'Updates the schema for the network dataset based upon the given data element.'
##        #return 
##
##    def AddSource(self, Source):
##        u'Adds the given source to the schema of the network dataset.'
##        #return 
##
##    def AddAttribute(self, Attribute):
##        u'Adds the given attribute to the schema of the network dataset.'
##        #return 
##
##    def DeleteSource(self, Source):
##        u'Deletes the given source from the network dataset.'
##        #return 
##
##    def BuildNetwork(self, areaToBuild):
##        u'Builds the network dataset for the given extent.'
##        #return affectedArea
##

ITrafficDataManager._methods_ = [
    COMMETHOD([helpstring(u'Starts a new edit session for tracking edits to a new dynamic traffic file.')], HRESULT, 'StartEditing',
              ( ['in'], c_double, 'feedUTCStartTime' ),
              ( ['in'], c_int, 'estimatedKeyCount' ),
              ( ['in'], c_int, 'timeSliceCount' ),
              ( ['in'], c_double, 'firstTimeSliceUTCStartTime' ),
              ( ['in'], c_int, 'TimeSliceDurationInMinutes' ),
              ( ['in'], esriNetworkAttributeUnits, 'speedUnits' ),
              ( ['in'], c_int, 'updateIntervalInMinutes' ),
              ( ['in'], c_int, 'feedVersionNumber' )),
    COMMETHOD([helpstring(u'Inserts the speed values per time slice for the specified TMC key.')], HRESULT, 'Insert',
              ( ['in'], c_ulong, 'key' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDoubleArray), 'pTimeSliceSpeeds' )),
    COMMETHOD([helpstring(u'Stops the current edit session and writes all current edits to a new dynamic traffic file in the specified folder.')], HRESULT, 'StopEditing',
              ( ['in'], BSTR, 'feedFolderPath' ),
              ( ['in'], VARIANT_BOOL, 'createCompressedFile' )),
    COMMETHOD([helpstring(u'Deletes all dynamic traffic files in the specified folder which are older than the specified cutoff date.')], HRESULT, 'DeleteData',
              ( ['in'], BSTR, 'feedFolderPath' ),
              ( ['in'], c_double, 'utcCutoffDate' )),
    COMMETHOD([helpstring(u'Converts a TMC string to a unique integer key value.')], HRESULT, 'ConvertTMCToKey',
              ( ['in'], BSTR, 'tmcCode' ),
              ( ['retval', 'out'], POINTER(c_ulong), 'pKey' )),
]
################################################################
## code template for ITrafficDataManager implementation
##class ITrafficDataManager_Impl(object):
##    def Insert(self, key, pTimeSliceSpeeds):
##        u'Inserts the speed values per time slice for the specified TMC key.'
##        #return 
##
##    def DeleteData(self, feedFolderPath, utcCutoffDate):
##        u'Deletes all dynamic traffic files in the specified folder which are older than the specified cutoff date.'
##        #return 
##
##    def StartEditing(self, feedUTCStartTime, estimatedKeyCount, timeSliceCount, firstTimeSliceUTCStartTime, TimeSliceDurationInMinutes, speedUnits, updateIntervalInMinutes, feedVersionNumber):
##        u'Starts a new edit session for tracking edits to a new dynamic traffic file.'
##        #return 
##
##    def ConvertTMCToKey(self, tmcCode):
##        u'Converts a TMC string to a unique integer key value.'
##        #return pKey
##
##    def StopEditing(self, feedFolderPath, createCompressedFile):
##        u'Stops the current edit session and writes all current edits to a new dynamic traffic file in the specified folder.'
##        #return 
##

class GPReplica(CoClass):
    u'A GPReplica object'
    _reg_clsid_ = GUID('{E5524DFC-66E0-49B0-88E7-094040C98F74}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGPReplica2(IGPReplica):
    _case_insensitive_ = True
    _iid_ = GUID('{4202A324-D1DE-46D9-8469-F14ED363F12C}')
    _idlflags_ = ['oleautomation']
GPReplica._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPValue, IGPReplica, IGPReplica2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

IRangeDomain._methods_ = [
    COMMETHOD(['propget', helpstring(u'The minimum value for the associated attribute.')], HRESULT, 'MinValue',
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The minimum value for the associated attribute.')], HRESULT, 'MinValue',
              ( ['in'], VARIANT, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The maximum value for the associated attribute.')], HRESULT, 'MaxValue',
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The maximum value for the associated attribute.')], HRESULT, 'MaxValue',
              ( ['in'], VARIANT, 'Value' )),
]
################################################################
## code template for IRangeDomain implementation
##class IRangeDomain_Impl(object):
##    def _get(self):
##        u'The maximum value for the associated attribute.'
##        #return Value
##    def _set(self, Value):
##        u'The maximum value for the associated attribute.'
##    MaxValue = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The minimum value for the associated attribute.'
##        #return Value
##    def _set(self, Value):
##        u'The minimum value for the associated attribute.'
##    MinValue = property(_get, _set, doc = _set.__doc__)
##

class GPReplicas(CoClass):
    u'A collection of GPReplica objects.'
    _reg_clsid_ = GUID('{CE61437F-0CAE-4148-AF5B-CD8832213CF1}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGPReplicas(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the GPReplicas Interface.'
    _iid_ = GUID('{12AE744E-EB1D-46F5-8E94-650EA55BC9F9}')
    _idlflags_ = ['oleautomation']
GPReplicas._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPReplicas, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist]

class IArchivableClass(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to properties and methods of an archivable class.'
    _iid_ = GUID('{C1EAA4CE-BF6D-4956-B4CF-8AEFC0568B83}')
    _idlflags_ = ['oleautomation']
IArchivableClass._methods_ = [
    COMMETHOD(['propget', helpstring(u'The archive table associated with this archivable class.')], HRESULT, 'Archive',
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'archiveTable' )),
    COMMETHOD(['propget', helpstring(u'The archive registration information associated with this archivable class.')], HRESULT, 'ArchiveRegistrationInfo',
              ( ['retval', 'out'], POINTER(POINTER(IArchiveRegistrationInfo)), 'archiveRegInfo' )),
]
################################################################
## code template for IArchivableClass implementation
##class IArchivableClass_Impl(object):
##    @property
##    def Archive(self):
##        u'The archive table associated with this archivable class.'
##        #return archiveTable
##
##    @property
##    def ArchiveRegistrationInfo(self):
##        u'The archive registration information associated with this archivable class.'
##        #return archiveRegInfo
##

class ICodedValueDomain(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return and modify coded value domain values.'
    _iid_ = GUID('{FCB6BF33-475D-11D2-9932-0000F80372B4}')
    _idlflags_ = ['oleautomation']
ICodedValueDomain._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of codes for the associated attribute.')], HRESULT, 'CodeCount',
              ( ['retval', 'out'], POINTER(c_int), 'values' )),
    COMMETHOD(['propget', helpstring(u'The code name for the specified code index.')], HRESULT, 'Name',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The value for the specified code index.')], HRESULT, 'Value',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
    COMMETHOD([helpstring(u'Adds a (value, name) code.')], HRESULT, 'AddCode',
              ( ['in'], VARIANT, 'Value' ),
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD([helpstring(u'Deletes a code with the specified value.')], HRESULT, 'DeleteCode',
              ( ['in'], VARIANT, 'Value' )),
]
################################################################
## code template for ICodedValueDomain implementation
##class ICodedValueDomain_Impl(object):
##    def AddCode(self, Value, Name):
##        u'Adds a (value, name) code.'
##        #return 
##
##    def DeleteCode(self, Value):
##        u'Deletes a code with the specified value.'
##        #return 
##
##    @property
##    def CodeCount(self):
##        u'The number of codes for the associated attribute.'
##        #return values
##
##    @property
##    def Value(self, Index):
##        u'The value for the specified code index.'
##        #return Value
##
##    @property
##    def Name(self, Index):
##        u'The code name for the specified code index.'
##        #return Name
##

class GPReplicaDescription(CoClass):
    u'Defines the data to replicate or extract.'
    _reg_clsid_ = GUID('{F163839A-58B8-45B9-93AD-88803E0FA50F}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
GPReplicaDescription._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPReplicaDescription, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class IEnumDatasetName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through Dataset Names.'
    _iid_ = GUID('{89E75919-C287-11D1-AA77-00C04FA33A15}')
    _idlflags_ = ['oleautomation']
IDatasetContainerName._methods_ = [
    COMMETHOD(['propget', helpstring(u'An enumerator over the specified dataset names in this FeatureDataset.')], HRESULT, 'DatasetNames',
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumDatasetName)), 'DatasetNames' )),
]
################################################################
## code template for IDatasetContainerName implementation
##class IDatasetContainerName_Impl(object):
##    @property
##    def DatasetNames(self, Type):
##        u'An enumerator over the specified dataset names in this FeatureDataset.'
##        #return DatasetNames
##

class IObjectClassContainer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return object classes by name, ID and index.'
    _iid_ = GUID('{F5625307-3565-4D1F-839E-3705E882DC48}')
    _idlflags_ = ['oleautomation']
class IEnumObjectClass(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that hand out enumerated object classes and reset the enumeration.'
    _iid_ = GUID('{705E133D-FCB6-43D5-9F6A-694198C85C20}')
    _idlflags_ = ['oleautomation']
IObjectClassContainer._methods_ = [
    COMMETHOD(['propget', helpstring(u'The object class with the specified ID.')], HRESULT, 'ObjectClassByID',
              ( ['in'], c_int, 'ID' ),
              ( ['retval', 'out'], POINTER(POINTER(IObjectClass)), 'ObjectClass' )),
    COMMETHOD(['propget', helpstring(u'The object class with the specified name.')], HRESULT, 'ObjectClassByName',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IObjectClass)), 'ObjectClass' )),
    COMMETHOD(['propget', helpstring(u'The number of object classes in this container.')], HRESULT, 'ObjectClassCount',
              ( ['retval', 'out'], POINTER(c_int), 'numClasses' )),
    COMMETHOD(['propget', helpstring(u'An enumerator over the object classes.')], HRESULT, 'ObjectClasses',
              ( ['retval', 'out'], POINTER(POINTER(IEnumObjectClass)), 'ObjectClasses' )),
]
################################################################
## code template for IObjectClassContainer implementation
##class IObjectClassContainer_Impl(object):
##    @property
##    def ObjectClassByID(self, ID):
##        u'The object class with the specified ID.'
##        #return ObjectClass
##
##    @property
##    def ObjectClassByName(self, Name):
##        u'The object class with the specified name.'
##        #return ObjectClass
##
##    @property
##    def ObjectClasses(self):
##        u'An enumerator over the object classes.'
##        #return ObjectClasses
##
##    @property
##    def ObjectClassCount(self):
##        u'The number of object classes in this container.'
##        #return numClasses
##

class GPReplicaDataset(CoClass):
    u'A replica dataset.'
    _reg_clsid_ = GUID('{72477E3C-85CE-49DE-AA3E-5D55909C22EA}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGPReplicaDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return the properties of a replica dataset.'
    _iid_ = GUID('{7B913E1B-4DE7-4D37-82FC-81E458964CD6}')
    _idlflags_ = ['oleautomation']
class IGPReplicaDataset2(IGPReplicaDataset):
    _case_insensitive_ = True
    _iid_ = GUID('{484704EE-1F3C-4342-961B-0337217CF20A}')
    _idlflags_ = ['oleautomation']
GPReplicaDataset._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPValue, IGPReplicaDataset, IGPReplicaDataset2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class IDEGeometricNetwork(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe geometric network data elements.'
    _iid_ = GUID('{ACDBE3C0-E303-43E1-8038-8B391692F267}')
    _idlflags_ = ['oleautomation']
class IDEGeometricNetwork2(IDEGeometricNetwork):
    _case_insensitive_ = True
    u'Provides access to members that describe geometric network data elements.'
    _iid_ = GUID('{4169EF6E-9E94-45C2-AF70-509A62A0D1EC}')
    _idlflags_ = ['oleautomation']
IDEGeometricNetwork._methods_ = [
    COMMETHOD(['propget', helpstring(u'The connectivity rules associated with the network.')], HRESULT, 'Rules',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'Rules' )),
    COMMETHOD(['propputref', helpstring(u'The connectivity rules associated with the network.')], HRESULT, 'Rules',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'Rules' )),
    COMMETHOD(['propget', helpstring(u'The type of associated logical network.')], HRESULT, 'NetworkType',
              ( ['retval', 'out'], POINTER(esriNetworkType), 'Type' )),
    COMMETHOD(['propput', helpstring(u'The type of associated logical network.')], HRESULT, 'NetworkType',
              ( ['in'], esriNetworkType, 'Type' )),
    COMMETHOD(['propget', helpstring(u'The FeatureClass containing the OrphanJunctionFeatures.')], HRESULT, 'OrphanJunctionFeatureClassName',
              ( ['retval', 'out'], POINTER(BSTR), 'FeatureClass' )),
    COMMETHOD(['propput', helpstring(u'The FeatureClass containing the OrphanJunctionFeatures.')], HRESULT, 'OrphanJunctionFeatureClassName',
              ( ['in'], BSTR, 'FeatureClass' )),
    COMMETHOD(['propget', helpstring(u'The feature classes involved in the geometric network.')], HRESULT, 'FeatureClassNames',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'FeatureClassNames' )),
    COMMETHOD(['propputref', helpstring(u'The feature classes involved in the geometric network.')], HRESULT, 'FeatureClassNames',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'FeatureClassNames' )),
    COMMETHOD(['propget', helpstring(u'The weights of the geometric network.')], HRESULT, 'NetworkWeights',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'netWeights' )),
    COMMETHOD(['propputref', helpstring(u'The weights of the geometric network.')], HRESULT, 'NetworkWeights',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'netWeights' )),
    COMMETHOD(['propget', helpstring(u'The weight associations of the geometric network.')], HRESULT, 'WeightAssociations',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'WeightAssociations' )),
    COMMETHOD(['propputref', helpstring(u'The weight associations of the geometric network.')], HRESULT, 'WeightAssociations',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'WeightAssociations' )),
]
################################################################
## code template for IDEGeometricNetwork implementation
##class IDEGeometricNetwork_Impl(object):
##    def Rules(self, Rules):
##        u'The connectivity rules associated with the network.'
##        #return 
##
##    def FeatureClassNames(self, FeatureClassNames):
##        u'The feature classes involved in the geometric network.'
##        #return 
##
##    def NetworkWeights(self, netWeights):
##        u'The weights of the geometric network.'
##        #return 
##
##    def _get(self):
##        u'The type of associated logical network.'
##        #return Type
##    def _set(self, Type):
##        u'The type of associated logical network.'
##    NetworkType = property(_get, _set, doc = _set.__doc__)
##
##    def WeightAssociations(self, WeightAssociations):
##        u'The weight associations of the geometric network.'
##        #return 
##
##    def _get(self):
##        u'The FeatureClass containing the OrphanJunctionFeatures.'
##        #return FeatureClass
##    def _set(self, FeatureClass):
##        u'The FeatureClass containing the OrphanJunctionFeatures.'
##    OrphanJunctionFeatureClassName = property(_get, _set, doc = _set.__doc__)
##

IDEGeometricNetwork2._methods_ = [
    COMMETHOD(['propput', helpstring(u'Indicates if Z coordinates are used for connectivity.')], HRESULT, 'UseZsForConnectivity',
              ( ['in'], VARIANT_BOOL, 'UseZsForConnectivity' )),
    COMMETHOD(['propget', helpstring(u'Indicates if Z coordinates are used for connectivity.')], HRESULT, 'UseZsForConnectivity',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'UseZsForConnectivity' )),
    COMMETHOD(['propput', helpstring(u'XY snap tolerance.')], HRESULT, 'XYSnapTolerance',
              ( ['in'], c_double, 'XYSnapTolerance' )),
    COMMETHOD(['propget', helpstring(u'XY snap tolerance.')], HRESULT, 'XYSnapTolerance',
              ( ['retval', 'out'], POINTER(c_double), 'XYSnapTolerance' )),
    COMMETHOD(['propput', helpstring(u'Z snap tolerance.')], HRESULT, 'ZSnapTolerance',
              ( ['in'], c_double, 'ZSnapTolerance' )),
    COMMETHOD(['propget', helpstring(u'Z snap tolerance.')], HRESULT, 'ZSnapTolerance',
              ( ['retval', 'out'], POINTER(c_double), 'ZSnapTolerance' )),
    COMMETHOD(['propput', helpstring(u'Indicates if network conflicts should be reduced during reconcile.')], HRESULT, 'ReduceNetworkConflicts',
              ( ['in'], VARIANT_BOOL, 'ReduceNetworkConflicts' )),
    COMMETHOD(['propget', helpstring(u'Indicates if network conflicts should be reduced during reconcile.')], HRESULT, 'ReduceNetworkConflicts',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'ReduceNetworkConflicts' )),
]
################################################################
## code template for IDEGeometricNetwork2 implementation
##class IDEGeometricNetwork2_Impl(object):
##    def _get(self):
##        u'Indicates if Z coordinates are used for connectivity.'
##        #return UseZsForConnectivity
##    def _set(self, UseZsForConnectivity):
##        u'Indicates if Z coordinates are used for connectivity.'
##    UseZsForConnectivity = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'XY snap tolerance.'
##        #return XYSnapTolerance
##    def _set(self, XYSnapTolerance):
##        u'XY snap tolerance.'
##    XYSnapTolerance = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if network conflicts should be reduced during reconcile.'
##        #return ReduceNetworkConflicts
##    def _set(self, ReduceNetworkConflicts):
##        u'Indicates if network conflicts should be reduced during reconcile.'
##    ReduceNetworkConflicts = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Z snap tolerance.'
##        #return ZSnapTolerance
##    def _set(self, ZSnapTolerance):
##        u'Z snap tolerance.'
##    ZSnapTolerance = property(_get, _set, doc = _set.__doc__)
##

class ICodedValueDomain2(ICodedValueDomain):
    _case_insensitive_ = True
    u'Provides access to members that sort a coded value domain.'
    _iid_ = GUID('{057E88C6-0E61-426E-B4BB-D192C481CF1F}')
    _idlflags_ = []
ICodedValueDomain2._methods_ = [
    COMMETHOD([helpstring(u'Sort the codes in the coded value domain by name.')], HRESULT, 'SortByName',
              ( [], VARIANT_BOOL, 'descending' )),
    COMMETHOD([helpstring(u'Sort the codes in the coded value domain by value.')], HRESULT, 'SortByValue',
              ( [], VARIANT_BOOL, 'descending' )),
]
################################################################
## code template for ICodedValueDomain2 implementation
##class ICodedValueDomain2_Impl(object):
##    def SortByValue(self, descending):
##        u'Sort the codes in the coded value domain by value.'
##        #return 
##
##    def SortByName(self, descending):
##        u'Sort the codes in the coded value domain by name.'
##        #return 
##

class IDatasetContainer2(IDatasetContainer):
    _case_insensitive_ = True
    u'Provides access to members that return datasets by name, ID and index.'
    _iid_ = GUID('{C826E861-DBFA-4B86-95FE-8352E287E284}')
    _idlflags_ = ['oleautomation']
class IEnumDatasetType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate over a set of dataset types.'
    _iid_ = GUID('{1D34B6A8-55FD-4CE5-9A10-B2294F35FF6D}')
    _idlflags_ = ['oleautomation']
IDatasetContainer2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The dataset associated with the specified index value and dataset type.')], HRESULT, 'Dataset',
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IDataset)), 'Dataset' )),
    COMMETHOD(['propget', helpstring(u'An enumerator over the datasets of the specified type.')], HRESULT, 'Datasets',
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumDataset)), 'Datasets' )),
    COMMETHOD(['propget', helpstring(u'The number of datasets of the specified type in this container.')], HRESULT, 'DatasetCount',
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The dataset of the specified type with the specified name.')], HRESULT, 'DatasetByName',
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IDataset)), 'Dataset' )),
    COMMETHOD(['propget', helpstring(u'The names of all the datasets with the specified type.')], HRESULT, 'DatasetNames',
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumDatasetName)), 'Names' )),
    COMMETHOD(['propget', helpstring(u'The names of all the datasets with the specified type.')], HRESULT, 'DatasetTypes',
              ( ['retval', 'out'], POINTER(POINTER(IEnumDatasetType)), 'types' )),
    COMMETHOD([helpstring(u'Given a data element, create a dataset in this container.')], HRESULT, 'CreateDataset',
              ( ['in'], POINTER(IDEDataset), 'DataElement' ),
              ( ['retval', 'out'], POINTER(POINTER(IDataset)), 'Dataset' )),
]
################################################################
## code template for IDatasetContainer2 implementation
##class IDatasetContainer2_Impl(object):
##    @property
##    def Datasets(self, Type):
##        u'An enumerator over the datasets of the specified type.'
##        #return Datasets
##
##    @property
##    def DatasetNames(self, Type):
##        u'The names of all the datasets with the specified type.'
##        #return Names
##
##    def CreateDataset(self, DataElement):
##        u'Given a data element, create a dataset in this container.'
##        #return Dataset
##
##    @property
##    def DatasetTypes(self):
##        u'The names of all the datasets with the specified type.'
##        #return types
##
##    @property
##    def DatasetCount(self, Type):
##        u'The number of datasets of the specified type in this container.'
##        #return Count
##
##    @property
##    def Dataset(self, Type, Index):
##        u'The dataset associated with the specified index value and dataset type.'
##        #return Dataset
##
##    @property
##    def DatasetByName(self, Type, Name):
##        u'The dataset of the specified type with the specified name.'
##        #return Dataset
##

class GPReplicaDatasets(CoClass):
    u'A collection of replica dataset objects.'
    _reg_clsid_ = GUID('{FC68EC62-CDA0-4497-9977-B45820268A43}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGPReplicaDatasets(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that define replica datasets'
    _iid_ = GUID('{871E789A-BB4D-4CF6-822E-6B6BEFA4E76E}')
    _idlflags_ = ['oleautomation']
GPReplicaDatasets._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPReplicaDatasets, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class IStringDomain(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return and modify string domain values.'
    _iid_ = GUID('{FCB6BF34-475D-11D2-9932-0000F80372B4}')
    _idlflags_ = ['oleautomation']
IStringDomain._methods_ = [
    COMMETHOD(['propget', helpstring(u'The format for the associated string attribute.')], HRESULT, 'Format',
              ( ['retval', 'out'], POINTER(BSTR), 'Format' )),
    COMMETHOD(['propput', helpstring(u'The format for the associated string attribute.')], HRESULT, 'Format',
              ( ['in'], BSTR, 'Format' )),
]
################################################################
## code template for IStringDomain implementation
##class IStringDomain_Impl(object):
##    def _get(self):
##        u'The format for the associated string attribute.'
##        #return Format
##    def _set(self, Format):
##        u'The format for the associated string attribute.'
##    Format = property(_get, _set, doc = _set.__doc__)
##

class ITinSurface3(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control TIN surfaces.'
    _iid_ = GUID('{6FC85CBE-929C-4482-8192-2959D4E673CD}')
    _idlflags_ = ['oleautomation']
ITinSurface3._methods_ = [
    COMMETHOD(['propput', helpstring(u'The elevation interpolation method.')], HRESULT, 'InterpolationMethod',
              ( ['in'], esriSurfaceInterpolationType, 'pType' )),
    COMMETHOD(['propget', helpstring(u'The elevation interpolation method.')], HRESULT, 'InterpolationMethod',
              ( ['retval', 'out'], POINTER(esriSurfaceInterpolationType), 'pType' )),
    COMMETHOD([helpstring(u'Interpolate the z-coordinate of the specified location.')], HRESULT, 'InterpolateZ',
              ( ['in'], c_double, 'X' ),
              ( ['in'], c_double, 'Y' ),
              ( ['retval', 'out'], POINTER(c_double), 'pZ' )),
    COMMETHOD([helpstring(u"Returns TIN's volume/area above or below an input z value.")], HRESULT, 'GetVolumeAndArea',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pAOI' ),
              ( ['in'], c_double, 'referenceHeight' ),
              ( ['in'], esriPlaneReferenceType, 'Type' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'pbIsOutsideDataArea' ),
              ( ['in', 'out', 'optional'], POINTER(VARIANT), 'pVolume' ),
              ( ['in', 'out', 'optional'], POINTER(VARIANT), 'pSurfaceArea' ),
              ( ['in', 'out', 'optional'], POINTER(VARIANT), 'pProjectedArea' )),
    COMMETHOD([helpstring(u'Intersect with a reference TIN.')], HRESULT, 'Intersect',
              ( ['in'], POINTER(ITinSurface), 'pReferenceSurface' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pAOI' ),
              ( ['in'], POINTER(IFeatureClass), 'pOutFeatureClass' ),
              ( ['in'], BSTR, 'volumeFieldName' ),
              ( ['in'], BSTR, 'surfaceAreaFieldName' ),
              ( ['in'], BSTR, 'codeFieldName' )),
    COMMETHOD([helpstring(u'Returns the vector normal to the specified triangle.')], HRESULT, 'QueryTriangleNormal',
              ( ['in'], c_int, 'Triangle' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IVector3D), 'pNormal' )),
    COMMETHOD([helpstring(u'Returns the first intersection of the query ray and the TIN.')], HRESULT, 'QueryLocate',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IRay), 'pRay' ),
              ( ['in'], c_int, 'hint' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pLocation' )),
    COMMETHOD([helpstring(u'Returns the intersections of the query ray and the TIN.')], HRESULT, 'QueryLocateWithinDistance',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IRay), 'pRay' ),
              ( ['in'], c_double, 'maxDistance' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pLocations' )),
    COMMETHOD([helpstring(u'Extract part of the TIN.')], HRESULT, 'Extract',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon), 'pBoundary' ),
              ( ['in'], esriTinEdgeType, 'boundaryEdgeType' ),
              ( ['in'], c_int, 'boundaryEdgeValue' ),
              ( ['in'], VARIANT_BOOL, 'bConstrainedDelaunay' ),
              ( ['in'], VARIANT_BOOL, 'bAllowEdgeSwapping' ),
              ( ['retval', 'out'], POINTER(POINTER(ITin)), 'ppSubTin' )),
    COMMETHOD(['propput', helpstring(u'The profile weeding tolerance.')], HRESULT, 'ProfileWeedTolerance',
              ( ['in'], c_double, 'pTolerance' )),
    COMMETHOD(['propget', helpstring(u'The profile weeding tolerance.')], HRESULT, 'ProfileWeedTolerance',
              ( ['retval', 'out'], POINTER(c_double), 'pTolerance' )),
]
################################################################
## code template for ITinSurface3 implementation
##class ITinSurface3_Impl(object):
##    def _get(self):
##        u'The profile weeding tolerance.'
##        #return pTolerance
##    def _set(self, pTolerance):
##        u'The profile weeding tolerance.'
##    ProfileWeedTolerance = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The elevation interpolation method.'
##        #return pType
##    def _set(self, pType):
##        u'The elevation interpolation method.'
##    InterpolationMethod = property(_get, _set, doc = _set.__doc__)
##
##    def QueryLocateWithinDistance(self, pRay, maxDistance, pLocations):
##        u'Returns the intersections of the query ray and the TIN.'
##        #return 
##
##    def GetVolumeAndArea(self, pAOI, referenceHeight, Type):
##        u"Returns TIN's volume/area above or below an input z value."
##        #return pbIsOutsideDataArea, pVolume, pSurfaceArea, pProjectedArea
##
##    def QueryTriangleNormal(self, Triangle, pNormal):
##        u'Returns the vector normal to the specified triangle.'
##        #return 
##
##    def Intersect(self, pReferenceSurface, pAOI, pOutFeatureClass, volumeFieldName, surfaceAreaFieldName, codeFieldName):
##        u'Intersect with a reference TIN.'
##        #return 
##
##    def QueryLocate(self, pRay, hint, pLocation):
##        u'Returns the first intersection of the query ray and the TIN.'
##        #return 
##
##    def InterpolateZ(self, X, Y):
##        u'Interpolate the z-coordinate of the specified location.'
##        #return pZ
##
##    def Extract(self, pBoundary, boundaryEdgeType, boundaryEdgeValue, bConstrainedDelaunay, bAllowEdgeSwapping):
##        u'Extract part of the TIN.'
##        #return ppSubTin
##

class IConnectivityRule(IRule):
    _case_insensitive_ = True
    u'Indicator interface that identifies connectivity rules.'
    _iid_ = GUID('{F366A3FA-5362-11D2-AB1B-000000000000}')
    _idlflags_ = ['oleautomation']
class IEdgeConnectivityRule(IConnectivityRule):
    _case_insensitive_ = True
    u'Provides access to members that supply information about, modify and manage edge-edge connectivity rules.'
    _iid_ = GUID('{F290D9E2-58E5-11D2-AB26-000000000000}')
    _idlflags_ = ['oleautomation']
IConnectivityRule._methods_ = [
]
################################################################
## code template for IConnectivityRule implementation
##class IConnectivityRule_Impl(object):

IEdgeConnectivityRule._methods_ = [
    COMMETHOD(['propget', helpstring(u'The ID of the default junction feature class.')], HRESULT, 'DefaultJunctionClassID',
              ( ['retval', 'out'], POINTER(c_int), 'ClassID' )),
    COMMETHOD(['propput', helpstring(u'The ID of the default junction feature class.')], HRESULT, 'DefaultJunctionClassID',
              ( ['in'], c_int, 'ClassID' )),
    COMMETHOD(['propget', helpstring(u'The subtype value of the default junction feature class.')], HRESULT, 'DefaultJunctionSubtypeCode',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The subtype value of the default junction feature class.')], HRESULT, 'DefaultJunctionSubtypeCode',
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The ID of the source NetworkEdge feature class.')], HRESULT, 'FromEdgeClassID',
              ( ['retval', 'out'], POINTER(c_int), 'ClassID' )),
    COMMETHOD(['propput', helpstring(u'The ID of the source NetworkEdge feature class.')], HRESULT, 'FromEdgeClassID',
              ( ['in'], c_int, 'ClassID' )),
    COMMETHOD(['propget', helpstring(u'The subtype value of the source NetworkEdge feature class.')], HRESULT, 'FromEdgeSubtypeCode',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The subtype value of the source NetworkEdge feature class.')], HRESULT, 'FromEdgeSubtypeCode',
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The ID of the destination NetworkEdge feature class.')], HRESULT, 'ToEdgeClassID',
              ( ['retval', 'out'], POINTER(c_int), 'ClassID' )),
    COMMETHOD(['propput', helpstring(u'The ID of the destination NetworkEdge feature class.')], HRESULT, 'ToEdgeClassID',
              ( ['in'], c_int, 'ClassID' )),
    COMMETHOD(['propget', helpstring(u'The subtype value of the target NetworkEdge feature class.')], HRESULT, 'ToEdgeSubtypeCode',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The subtype value of the target NetworkEdge feature class.')], HRESULT, 'ToEdgeSubtypeCode',
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The number of valid Junctions.')], HRESULT, 'JunctionCount',
              ( ['retval', 'out'], POINTER(c_int), 'values' )),
    COMMETHOD(['propget', helpstring(u'The specified permissible value for the associated attribute.')], HRESULT, 'JunctionClassID',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propget', helpstring(u'The specified permissible value for the associated attribute.')], HRESULT, 'JunctionSubtypeCode',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(c_int), 'SubtypeCode' )),
    COMMETHOD([helpstring(u'The permissible values for the associated attribute.')], HRESULT, 'AddJunction',
              ( ['in'], c_int, 'ClassID' ),
              ( ['in'], c_int, 'SubtypeCode' )),
    COMMETHOD([helpstring(u'Indicates whether the specified junction class id is in the valid junction list.')], HRESULT, 'ContainsJunction',
              ( ['in'], c_int, 'ClassID' ),
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'contained' )),
    COMMETHOD([helpstring(u'The specified permissible value for the associated attribute.')], HRESULT, 'GetJunctionInfo',
              ( ['in'], c_int, 'Index' ),
              ( ['out'], POINTER(c_int), 'ClassID' ),
              ( ['out'], POINTER(c_int), 'SubtypeCode' )),
]
################################################################
## code template for IEdgeConnectivityRule implementation
##class IEdgeConnectivityRule_Impl(object):
##    def _get(self):
##        u'The ID of the default junction feature class.'
##        #return ClassID
##    def _set(self, ClassID):
##        u'The ID of the default junction feature class.'
##    DefaultJunctionClassID = property(_get, _set, doc = _set.__doc__)
##
##    def ContainsJunction(self, ClassID, SubtypeCode):
##        u'Indicates whether the specified junction class id is in the valid junction list.'
##        #return contained
##
##    @property
##    def JunctionCount(self):
##        u'The number of valid Junctions.'
##        #return values
##
##    def _get(self):
##        u'The subtype value of the source NetworkEdge feature class.'
##        #return Value
##    def _set(self, Value):
##        u'The subtype value of the source NetworkEdge feature class.'
##    FromEdgeSubtypeCode = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The ID of the source NetworkEdge feature class.'
##        #return ClassID
##    def _set(self, ClassID):
##        u'The ID of the source NetworkEdge feature class.'
##    FromEdgeClassID = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The ID of the destination NetworkEdge feature class.'
##        #return ClassID
##    def _set(self, ClassID):
##        u'The ID of the destination NetworkEdge feature class.'
##    ToEdgeClassID = property(_get, _set, doc = _set.__doc__)
##
##    def AddJunction(self, ClassID, SubtypeCode):
##        u'The permissible values for the associated attribute.'
##        #return 
##
##    def GetJunctionInfo(self, Index):
##        u'The specified permissible value for the associated attribute.'
##        #return ClassID, SubtypeCode
##
##    def _get(self):
##        u'The subtype value of the target NetworkEdge feature class.'
##        #return Value
##    def _set(self, Value):
##        u'The subtype value of the target NetworkEdge feature class.'
##    ToEdgeSubtypeCode = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def JunctionClassID(self, Index):
##        u'The specified permissible value for the associated attribute.'
##        #return Value
##
##    @property
##    def JunctionSubtypeCode(self, Index):
##        u'The specified permissible value for the associated attribute.'
##        #return SubtypeCode
##
##    def _get(self):
##        u'The subtype value of the default junction feature class.'
##        #return Value
##    def _set(self, Value):
##        u'The subtype value of the default junction feature class.'
##    DefaultJunctionSubtypeCode = property(_get, _set, doc = _set.__doc__)
##

class GPReplicaOptions(CoClass):
    u'Defines replica options.'
    _reg_clsid_ = GUID('{5F18882D-8E9E-4A36-B566-071EE728298A}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGPReplicaOptions(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{C75F38CC-F589-42CD-9A85-B0BE9B7FCD2B}')
    _idlflags_ = ['oleautomation']
class IGPReplicaOptions2(IGPReplicaOptions):
    _case_insensitive_ = True
    _iid_ = GUID('{C2D25F91-087A-4B2E-BFE1-2DBAC9CD6128}')
    _idlflags_ = ['oleautomation']
GPReplicaOptions._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPReplicaOptions, IGPReplicaOptions2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

IGPWorkspaceExtension._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the extension.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The clsid of the extension.')], HRESULT, 'CLSID',
              ( ['retval', 'out'], POINTER(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.GUID), 'CLSID' )),
    COMMETHOD(['propput', helpstring(u'The name of the extension.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propput', helpstring(u'The clsid of the extension.')], HRESULT, 'CLSID',
              ( ['in'], comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.GUID, 'CLSID' )),
]
################################################################
## code template for IGPWorkspaceExtension implementation
##class IGPWorkspaceExtension_Impl(object):
##    def _get(self):
##        u'The name of the extension.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the extension.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The clsid of the extension.'
##        #return CLSID
##    def _set(self, CLSID):
##        u'The clsid of the extension.'
##    CLSID = property(_get, _set, doc = _set.__doc__)
##

IEnumDatasetName._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next feature class in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IDatasetName)), 'DatasetName' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumDatasetName implementation
##class IEnumDatasetName_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next feature class in the enumeration sequence.'
##        #return DatasetName
##

class DENetworkDataset(CoClass):
    u'Network Dataset Data Element object.'
    _reg_clsid_ = GUID('{FF8808B7-E50C-45FE-84EA-1C061D7431F6}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDENetworkDataset2(IDENetworkDataset):
    _case_insensitive_ = True
    u'Provides access to members that describe network dataset data elements.'
    _iid_ = GUID('{9EC0957A-9127-4084-8D0D-D4341101A15E}')
    _idlflags_ = ['oleautomation']
DENetworkDataset._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEDataset, IDEGeoDataset, IDENetworkDataset, IDENetworkDataset2, IDataElement, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe]

IDEGeoDataset._methods_ = [
    COMMETHOD(['propget', helpstring(u'The extent of the coverage.')], HRESULT, 'Extent',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'Extent' )),
    COMMETHOD(['propputref', helpstring(u'The extent of the coverage.')], HRESULT, 'Extent',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'Extent' )),
    COMMETHOD(['propget', helpstring(u'The spatial reference of the geodataset.')], HRESULT, 'SpatialReference',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference)), 'SpatialReference' )),
    COMMETHOD(['propputref', helpstring(u'The spatial reference of the geodataset.')], HRESULT, 'SpatialReference',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference' )),
]
################################################################
## code template for IDEGeoDataset implementation
##class IDEGeoDataset_Impl(object):
##    def Extent(self, Extent):
##        u'The extent of the coverage.'
##        #return 
##
##    def SpatialReference(self, SpatialReference):
##        u'The spatial reference of the geodataset.'
##        #return 
##

class IDataElementHelper(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that allow you to get a reference to a DataElement.'
    _iid_ = GUID('{11DE55F8-84D3-4B69-B157-A1D969859FC2}')
    _idlflags_ = ['oleautomation']
IDataElementHelper._methods_ = [
    COMMETHOD(['propget', helpstring(u'The data element for this data element helper.')], HRESULT, 'DataElement',
              ( ['retval', 'out'], POINTER(POINTER(IDataElement)), 'DataElement' )),
]
################################################################
## code template for IDataElementHelper implementation
##class IDataElementHelper_Impl(object):
##    @property
##    def DataElement(self):
##        u'The data element for this data element helper.'
##        #return DataElement
##

class SystemJunctionSource(CoClass):
    u'A container for describing a network dataset source where junction elements are generated automatically when the network is built.'
    _reg_clsid_ = GUID('{619F181F-4A40-4A95-BCEB-5CA7C8C63B60}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
SystemJunctionSource._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkSource, ISystemJunctionSource]

class IDatasetContainer3(IDatasetContainer2):
    _case_insensitive_ = True
    u'Provides access to members that return datasets by name, ID and index.'
    _iid_ = GUID('{1B7498C6-F47B-4AC6-A716-835B702A9CAC}')
    _idlflags_ = ['oleautomation']
IDatasetContainer3._methods_ = [
    COMMETHOD(['propget', helpstring(u'The dataset associated with the specified index value and dataset type.')], HRESULT, 'DatasetByID',
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['in'], c_int, 'DatasetID' ),
              ( ['retval', 'out'], POINTER(POINTER(IDataset)), 'Dataset' )),
]
################################################################
## code template for IDatasetContainer3 implementation
##class IDatasetContainer3_Impl(object):
##    @property
##    def DatasetByID(self, Type, DatasetID):
##        u'The dataset associated with the specified index value and dataset type.'
##        #return Dataset
##

class IIndexes(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about the index collection.'
    _iid_ = GUID('{2063FD03-4CE0-11D1-89DB-006097AFF44E}')
    _idlflags_ = ['oleautomation']
IDETable._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the table has an object id field.')], HRESULT, 'HasOID',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasOID' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the table has an object id field.')], HRESULT, 'HasOID',
              ( ['in'], VARIANT_BOOL, 'HasOID' )),
    COMMETHOD(['propget', helpstring(u'The name of the OID Field.')], HRESULT, 'OIDFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'OIDFieldName' )),
    COMMETHOD(['propput', helpstring(u'The name of the OID Field.')], HRESULT, 'OIDFieldName',
              ( ['in'], BSTR, 'OIDFieldName' )),
    COMMETHOD(['propget', helpstring(u'The list of Indexes.')], HRESULT, 'Indexes',
              ( ['retval', 'out'], POINTER(POINTER(IIndexes)), 'Indexes' )),
    COMMETHOD(['propputref', helpstring(u'The list of Indexes.')], HRESULT, 'Indexes',
              ( ['in'], POINTER(IIndexes), 'Indexes' )),
    COMMETHOD(['propget', helpstring(u'The list of Fields.')], HRESULT, 'Fields',
              ( ['retval', 'out'], POINTER(POINTER(IFields)), 'Fields' )),
    COMMETHOD(['propputref', helpstring(u'The list of Fields.')], HRESULT, 'Fields',
              ( ['in'], POINTER(IFields), 'Fields' )),
]
################################################################
## code template for IDETable implementation
##class IDETable_Impl(object):
##    def _get(self):
##        u'The name of the OID Field.'
##        #return OIDFieldName
##    def _set(self, OIDFieldName):
##        u'The name of the OID Field.'
##    OIDFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def Fields(self, Fields):
##        u'The list of Fields.'
##        #return 
##
##    def _get(self):
##        u'Indicates if the table has an object id field.'
##        #return HasOID
##    def _set(self, HasOID):
##        u'Indicates if the table has an object id field.'
##    HasOID = property(_get, _set, doc = _set.__doc__)
##
##    def Indexes(self, Indexes):
##        u'The list of Indexes.'
##        #return 
##

IDEGdbTable._methods_ = [
    COMMETHOD(['propget', helpstring(u'The GUID for the COM Class (CoClass) corresponding to instances of the object class represented by the table data element.')], HRESULT, 'CLSID',
              ( ['retval', 'out'], POINTER(BSTR), 'ClassID' )),
    COMMETHOD(['propput', helpstring(u'The GUID for the COM Class (CoClass) corresponding to instances of the object class represented by the table data element.')], HRESULT, 'CLSID',
              ( ['in'], BSTR, 'ClassID' )),
    COMMETHOD(['propget', helpstring(u'The GUID for the COM Class (CoClass) corresponding to the class extension of the object class represented by the table data element.')], HRESULT, 'EXTCLSID',
              ( ['retval', 'out'], POINTER(BSTR), 'ClassID' )),
    COMMETHOD(['propput', helpstring(u'The GUID for the COM Class (CoClass) corresponding to the class extension of the object class represented by the table data element.')], HRESULT, 'EXTCLSID',
              ( ['in'], BSTR, 'ClassID' )),
    COMMETHOD(['propget', helpstring(u'The properties for the class extension.')], HRESULT, 'ExtensionProperties',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'PropertySet' )),
    COMMETHOD(['propputref', helpstring(u'The properties for the class extension.')], HRESULT, 'ExtensionProperties',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'PropertySet' )),
    COMMETHOD(['propget', helpstring(u'The name of the Subtype Field.')], HRESULT, 'SubtypeFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propput', helpstring(u'The name of the Subtype Field.')], HRESULT, 'SubtypeFieldName',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'The default subtype code.')], HRESULT, 'DefaultSubtypeCode',
              ( ['retval', 'out'], POINTER(c_int), 'SubtypeCode' )),
    COMMETHOD(['propput', helpstring(u'The default subtype code.')], HRESULT, 'DefaultSubtypeCode',
              ( ['in'], c_int, 'SubtypeCode' )),
    COMMETHOD(['propget', helpstring(u'The set of Subtypes.')], HRESULT, 'Subtypes',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'Subtypes' )),
    COMMETHOD(['propputref', helpstring(u'The set of Subtypes.')], HRESULT, 'Subtypes',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'Subtypes' )),
    COMMETHOD(['propget', helpstring(u'The alias name for the table.')], HRESULT, 'AliasName',
              ( ['retval', 'out'], POINTER(BSTR), 'AliasName' )),
    COMMETHOD(['propput', helpstring(u'The alias name for the table.')], HRESULT, 'AliasName',
              ( ['in'], BSTR, 'AliasName' )),
    COMMETHOD(['propget', helpstring(u'The model name for the table.')], HRESULT, 'ModelName',
              ( ['retval', 'out'], POINTER(BSTR), 'ModelName' )),
    COMMETHOD(['propput', helpstring(u'The model name for the table.')], HRESULT, 'ModelName',
              ( ['in'], BSTR, 'ModelName' )),
    COMMETHOD(['propget', helpstring(u'The names of the Relationship Classes this object class participates in.')], HRESULT, 'RelationshipClassNames',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'RelationshipClassNames' )),
    COMMETHOD(['propputref', helpstring(u'The names of the Relationship Classes this object class participates in.')], HRESULT, 'RelationshipClassNames',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'RelationshipClassNames' )),
    COMMETHOD(['propget', helpstring(u'The set of controller memberships for the table.')], HRESULT, 'ControllerMemberships',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'ControllerMemberships' )),
    COMMETHOD(['propputref', helpstring(u'The set of controller memberships for the table.')], HRESULT, 'ControllerMemberships',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'ControllerMemberships' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the table has a GlobalID field.')], HRESULT, 'HasGlobalID',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasGlobalID' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the table has a GlobalID field.')], HRESULT, 'HasGlobalID',
              ( ['in'], VARIANT_BOOL, 'HasGlobalID' )),
    COMMETHOD(['propget', helpstring(u'The name of the GlobalID Field.')], HRESULT, 'GlobalIDFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'GlobalIDFieldName' )),
    COMMETHOD(['propput', helpstring(u'The name of the GlobalID Field.')], HRESULT, 'GlobalIDFieldName',
              ( ['in'], BSTR, 'GlobalIDFieldName' )),
    COMMETHOD(['propget', helpstring(u'The name of the raster field.')], HRESULT, 'RasterFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propput', helpstring(u'The name of the raster field.')], HRESULT, 'RasterFieldName',
              ( ['in'], BSTR, 'FieldName' )),
]
################################################################
## code template for IDEGdbTable implementation
##class IDEGdbTable_Impl(object):
##    def _get(self):
##        u'The model name for the table.'
##        #return ModelName
##    def _set(self, ModelName):
##        u'The model name for the table.'
##    ModelName = property(_get, _set, doc = _set.__doc__)
##
##    def ControllerMemberships(self, ControllerMemberships):
##        u'The set of controller memberships for the table.'
##        #return 
##
##    def RelationshipClassNames(self, RelationshipClassNames):
##        u'The names of the Relationship Classes this object class participates in.'
##        #return 
##
##    def _get(self):
##        u'Indicates if the table has a GlobalID field.'
##        #return HasGlobalID
##    def _set(self, HasGlobalID):
##        u'Indicates if the table has a GlobalID field.'
##    HasGlobalID = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The default subtype code.'
##        #return SubtypeCode
##    def _set(self, SubtypeCode):
##        u'The default subtype code.'
##    DefaultSubtypeCode = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the raster field.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The name of the raster field.'
##    RasterFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The alias name for the table.'
##        #return AliasName
##    def _set(self, AliasName):
##        u'The alias name for the table.'
##    AliasName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The GUID for the COM Class (CoClass) corresponding to instances of the object class represented by the table data element.'
##        #return ClassID
##    def _set(self, ClassID):
##        u'The GUID for the COM Class (CoClass) corresponding to instances of the object class represented by the table data element.'
##    CLSID = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the Subtype Field.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The name of the Subtype Field.'
##    SubtypeFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The GUID for the COM Class (CoClass) corresponding to the class extension of the object class represented by the table data element.'
##        #return ClassID
##    def _set(self, ClassID):
##        u'The GUID for the COM Class (CoClass) corresponding to the class extension of the object class represented by the table data element.'
##    EXTCLSID = property(_get, _set, doc = _set.__doc__)
##
##    def Subtypes(self, Subtypes):
##        u'The set of Subtypes.'
##        #return 
##
##    def _get(self):
##        u'The name of the GlobalID Field.'
##        #return GlobalIDFieldName
##    def _set(self, GlobalIDFieldName):
##        u'The name of the GlobalID Field.'
##    GlobalIDFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def ExtensionProperties(self, PropertySet):
##        u'The properties for the class extension.'
##        #return 
##

class IJunctionConnectivityRule(IConnectivityRule):
    _case_insensitive_ = True
    u'Provides access to members that supply information about, modify and manage junction-edge connectivity rules.'
    _iid_ = GUID('{F290D9E3-58E5-11D2-AB26-000000000000}')
    _idlflags_ = ['oleautomation']
IJunctionConnectivityRule._methods_ = [
    COMMETHOD(['propget', helpstring(u'The ID of the NetworkEdge FeatureClass.')], HRESULT, 'EdgeClassID',
              ( ['retval', 'out'], POINTER(c_int), 'ClassID' )),
    COMMETHOD(['propput', helpstring(u'The ID of the NetworkEdge FeatureClass.')], HRESULT, 'EdgeClassID',
              ( ['in'], c_int, 'ClassID' )),
    COMMETHOD(['propget', helpstring(u'The subtype value of the NetworkEdge FeatureClass.')], HRESULT, 'EdgeSubtypeCode',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The subtype value of the NetworkEdge FeatureClass.')], HRESULT, 'EdgeSubtypeCode',
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The minimum cardinality value of the NetworkEdge FeatureClass.')], HRESULT, 'EdgeMinimumCardinality',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The minimum cardinality value of the NetworkEdge FeatureClass.')], HRESULT, 'EdgeMinimumCardinality',
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The maxnimum cardinality value of the NetworkEdge FeatureClass.')], HRESULT, 'EdgeMaximumCardinality',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The maxnimum cardinality value of the NetworkEdge FeatureClass.')], HRESULT, 'EdgeMaximumCardinality',
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The ID of the NetworkJunction FeatureClass.')], HRESULT, 'JunctionClassID',
              ( ['retval', 'out'], POINTER(c_int), 'ClassID' )),
    COMMETHOD(['propput', helpstring(u'The ID of the NetworkJunction FeatureClass.')], HRESULT, 'JunctionClassID',
              ( ['in'], c_int, 'ClassID' )),
    COMMETHOD(['propget', helpstring(u'The subtype value of the NetworkJunction FeatureClass.')], HRESULT, 'JunctionSubtypeCode',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The subtype value of the NetworkJunction FeatureClass.')], HRESULT, 'JunctionSubtypeCode',
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The minimum cardinality value of the NetworkJunction FeatureClass.')], HRESULT, 'JunctionMinimumCardinality',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The minimum cardinality value of the NetworkJunction FeatureClass.')], HRESULT, 'JunctionMinimumCardinality',
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The maximum cardinality value of the NetworkJunction FeatureClass.')], HRESULT, 'JunctionMaximumCardinality',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The maximum cardinality value of the NetworkJunction FeatureClass.')], HRESULT, 'JunctionMaximumCardinality',
              ( ['in'], c_int, 'Value' )),
]
################################################################
## code template for IJunctionConnectivityRule implementation
##class IJunctionConnectivityRule_Impl(object):
##    def _get(self):
##        u'The maxnimum cardinality value of the NetworkEdge FeatureClass.'
##        #return Value
##    def _set(self, Value):
##        u'The maxnimum cardinality value of the NetworkEdge FeatureClass.'
##    EdgeMaximumCardinality = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The ID of the NetworkEdge FeatureClass.'
##        #return ClassID
##    def _set(self, ClassID):
##        u'The ID of the NetworkEdge FeatureClass.'
##    EdgeClassID = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The minimum cardinality value of the NetworkJunction FeatureClass.'
##        #return Value
##    def _set(self, Value):
##        u'The minimum cardinality value of the NetworkJunction FeatureClass.'
##    JunctionMinimumCardinality = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The ID of the NetworkJunction FeatureClass.'
##        #return ClassID
##    def _set(self, ClassID):
##        u'The ID of the NetworkJunction FeatureClass.'
##    JunctionClassID = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The subtype value of the NetworkJunction FeatureClass.'
##        #return Value
##    def _set(self, Value):
##        u'The subtype value of the NetworkJunction FeatureClass.'
##    JunctionSubtypeCode = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The subtype value of the NetworkEdge FeatureClass.'
##        #return Value
##    def _set(self, Value):
##        u'The subtype value of the NetworkEdge FeatureClass.'
##    EdgeSubtypeCode = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The maximum cardinality value of the NetworkJunction FeatureClass.'
##        #return Value
##    def _set(self, Value):
##        u'The maximum cardinality value of the NetworkJunction FeatureClass.'
##    JunctionMaximumCardinality = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The minimum cardinality value of the NetworkEdge FeatureClass.'
##        #return Value
##    def _set(self, Value):
##        u'The minimum cardinality value of the NetworkEdge FeatureClass.'
##    EdgeMinimumCardinality = property(_get, _set, doc = _set.__doc__)
##

IQueryFilter._methods_ = [
    COMMETHOD(['propget', helpstring(u'The comma delimited list of field names for the filter.')], HRESULT, 'SubFields',
              ( ['retval', 'out'], POINTER(BSTR), 'SubFields' )),
    COMMETHOD(['propput', helpstring(u'The comma delimited list of field names for the filter.')], HRESULT, 'SubFields',
              ( ['in'], BSTR, 'SubFields' )),
    COMMETHOD([helpstring(u'Appends a single field name to the list of sub-fields.')], HRESULT, 'AddField',
              ( ['in'], BSTR, 'subField' )),
    COMMETHOD(['propget', helpstring(u'The where clause for the filter.')], HRESULT, 'WhereClause',
              ( ['retval', 'out'], POINTER(BSTR), 'WhereClause' )),
    COMMETHOD(['propput', helpstring(u'The where clause for the filter.')], HRESULT, 'WhereClause',
              ( ['in'], BSTR, 'WhereClause' )),
    COMMETHOD(['propget', helpstring(u'The spatial reference in which to output geometry for a given field.')], HRESULT, 'OutputSpatialReference',
              ( ['in'], BSTR, 'FieldName' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference)), 'OutputSpatialReference' )),
    COMMETHOD(['propputref', helpstring(u'The spatial reference in which to output geometry for a given field.')], HRESULT, 'OutputSpatialReference',
              ( ['in'], BSTR, 'FieldName' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'OutputSpatialReference' )),
]
################################################################
## code template for IQueryFilter implementation
##class IQueryFilter_Impl(object):
##    def _get(self):
##        u'The where clause for the filter.'
##        #return WhereClause
##    def _set(self, WhereClause):
##        u'The where clause for the filter.'
##    WhereClause = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The comma delimited list of field names for the filter.'
##        #return SubFields
##    def _set(self, SubFields):
##        u'The comma delimited list of field names for the filter.'
##    SubFields = property(_get, _set, doc = _set.__doc__)
##
##    def OutputSpatialReference(self, FieldName, OutputSpatialReference):
##        u'The spatial reference in which to output geometry for a given field.'
##        #return 
##
##    def AddField(self, subField):
##        u'Appends a single field name to the list of sub-fields.'
##        #return 
##

class JunctionFeatureSource(CoClass):
    u'A container for describing a network dataset source whose junction elements are derived from point feature geometry.'
    _reg_clsid_ = GUID('{74C871BD-648E-40C0-A46A-E38521216A7B}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IJunctionFeatureSource(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of a network dataset source whose junction elements are derived from point geometry.'
    _iid_ = GUID('{442ACE6E-78CA-452F-91E9-405534CC9D27}')
    _idlflags_ = ['oleautomation']
JunctionFeatureSource._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkSource, IJunctionFeatureSource]

class TurnFeatureSource(CoClass):
    u'A container for describing a network dataset source whose elements are derived from turn feature geometry.'
    _reg_clsid_ = GUID('{44BB047B-C080-4597-B36B-E56905983C4C}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TurnFeatureSource._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkSource, ITurnFeatureSource]

ITransactionsOptions._methods_ = [
    COMMETHOD(['propput', helpstring(u'The auto commit interval is the number of modification operations before a database commit is executed.')], HRESULT, 'AutoCommitInterval',
              ( ['in'], c_int, 'interval' )),
    COMMETHOD(['propget', helpstring(u'The auto commit interval is the number of modification operations before a database commit is executed.')], HRESULT, 'AutoCommitInterval',
              ( ['retval', 'out'], POINTER(c_int), 'interval' )),
]
################################################################
## code template for ITransactionsOptions implementation
##class ITransactionsOptions_Impl(object):
##    def _get(self):
##        u'The auto commit interval is the number of modification operations before a database commit is executed.'
##        #return interval
##    def _set(self, interval):
##        u'The auto commit interval is the number of modification operations before a database commit is executed.'
##    AutoCommitInterval = property(_get, _set, doc = _set.__doc__)
##

IDEEditorTracking._methods_ = [
    COMMETHOD(['propget', helpstring(u'The property to determine if Editor Tracking is enabled on this data element.')], HRESULT, 'EditorTrackingEnabled',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isEditorTrackingEnabled' )),
    COMMETHOD(['propput', helpstring(u'The property to determine if Editor Tracking is enabled on this data element.')], HRESULT, 'EditorTrackingEnabled',
              ( ['in'], VARIANT_BOOL, 'isEditorTrackingEnabled' )),
    COMMETHOD(['propget', helpstring(u'The name of the creator field.')], HRESULT, 'CreatorFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'CreatorFieldName' )),
    COMMETHOD(['propput', helpstring(u'The name of the creator field.')], HRESULT, 'CreatorFieldName',
              ( ['in'], BSTR, 'CreatorFieldName' )),
    COMMETHOD(['propget', helpstring(u'The name of the creation time field.')], HRESULT, 'CreatedAtFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'CreatedAtFieldName' )),
    COMMETHOD(['propput', helpstring(u'The name of the creation time field.')], HRESULT, 'CreatedAtFieldName',
              ( ['in'], BSTR, 'CreatedAtFieldName' )),
    COMMETHOD(['propget', helpstring(u'The name of the editor field.')], HRESULT, 'EditorFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'EditorFieldName' )),
    COMMETHOD(['propput', helpstring(u'The name of the editor field.')], HRESULT, 'EditorFieldName',
              ( ['in'], BSTR, 'EditorFieldName' )),
    COMMETHOD(['propget', helpstring(u'The name of the edit time field.')], HRESULT, 'EditedAtFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'EditedAtFieldName' )),
    COMMETHOD(['propput', helpstring(u'The name of the edit time field.')], HRESULT, 'EditedAtFieldName',
              ( ['in'], BSTR, 'EditedAtFieldName' )),
    COMMETHOD(['propget', helpstring(u'The property to determine Editor Tracking times are recorded in UTC.')], HRESULT, 'IsTimeInUTC',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsTimeInUTC' )),
    COMMETHOD(['propput', helpstring(u'The property to determine Editor Tracking times are recorded in UTC.')], HRESULT, 'IsTimeInUTC',
              ( ['in'], VARIANT_BOOL, 'IsTimeInUTC' )),
]
################################################################
## code template for IDEEditorTracking implementation
##class IDEEditorTracking_Impl(object):
##    def _get(self):
##        u'The name of the edit time field.'
##        #return EditedAtFieldName
##    def _set(self, EditedAtFieldName):
##        u'The name of the edit time field.'
##    EditedAtFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The property to determine if Editor Tracking is enabled on this data element.'
##        #return isEditorTrackingEnabled
##    def _set(self, isEditorTrackingEnabled):
##        u'The property to determine if Editor Tracking is enabled on this data element.'
##    EditorTrackingEnabled = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the editor field.'
##        #return EditorFieldName
##    def _set(self, EditorFieldName):
##        u'The name of the editor field.'
##    EditorFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The property to determine Editor Tracking times are recorded in UTC.'
##        #return IsTimeInUTC
##    def _set(self, IsTimeInUTC):
##        u'The property to determine Editor Tracking times are recorded in UTC.'
##    IsTimeInUTC = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the creator field.'
##        #return CreatorFieldName
##    def _set(self, CreatorFieldName):
##        u'The name of the creator field.'
##    CreatorFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the creation time field.'
##        #return CreatedAtFieldName
##    def _set(self, CreatedAtFieldName):
##        u'The name of the creation time field.'
##    CreatedAtFieldName = property(_get, _set, doc = _set.__doc__)
##

class NetworkAttributeParameter(CoClass):
    u'A container for describing a network attribute parameter.'
    _reg_clsid_ = GUID('{BA43AB15-045D-4EB1-8526-EA65C4548D4A}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class INetworkAttributeParameter(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of a parameter of a network attribute.'
    _iid_ = GUID('{51E6E103-27B3-472F-9502-001C631064B3}')
    _idlflags_ = ['oleautomation']
class INetworkAttributeParameter2(INetworkAttributeParameter):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of a parameter of a network attribute.'
    _iid_ = GUID('{D4EF63A8-E754-4B09-B282-AFBC6DCBF5E9}')
    _idlflags_ = ['oleautomation']
NetworkAttributeParameter._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkAttributeParameter, INetworkAttributeParameter2]

class GeoDBDataTransfer(CoClass):
    u'Transfers data to/from GeoDatabases.'
    _reg_clsid_ = GUID('{5F0A6DA5-E0E7-11D3-8118-00C04F686238}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IFeatureProgress(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members used to handle events from converting featureclass/table.'
    _iid_ = GUID('{29D3B6DD-3917-11D2-AADF-00C04FA33C20}')
    _idlflags_ = ['oleautomation']
GeoDBDataTransfer._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGeoDBDataTransfer, IGeoDBDataTransfer2, comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IConnectionPointContainer]
GeoDBDataTransfer._outgoing_interfaces_ = [IFeatureProgress]

class IRelQueryTableName2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that define a relationship query table name.'
    _iid_ = GUID('{7042B894-FB07-4BC4-917D-15E282BA1B27}')
    _idlflags_ = ['oleautomation']
IRelQueryTableName2._methods_ = [
    COMMETHOD(['propputref', helpstring(u'The name object for the RelationshipClass that defines the RelQueryTable.')], HRESULT, 'RelationshipClassName',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'relClassName' )),
    COMMETHOD(['propget', helpstring(u'The name object for the RelationshipClass that defines the RelQueryTable.')], HRESULT, 'RelationshipClassName',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'relClassName' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the originPrimaryClass of the RelationshipClass is the SourceTable.')], HRESULT, 'ForwardDirection',
              ( ['in'], VARIANT_BOOL, 'forward' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the originPrimaryClass of the RelationshipClass is the SourceTable.')], HRESULT, 'ForwardDirection',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'forward' )),
    COMMETHOD(['propputref', helpstring(u'A QueryFilter applied to a cursor opened from the RelQueryTable.')], HRESULT, 'SrcQueryFilter',
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' )),
    COMMETHOD(['propget', helpstring(u'A QueryFilter applied to a cursor opened from the RelQueryTable.')], HRESULT, 'SrcQueryFilter',
              ( ['retval', 'out'], POINTER(POINTER(IQueryFilter)), 'QueryFilter' )),
    COMMETHOD(['propputref', helpstring(u'A SelectionSet applied to a cursor opened from the RelQueryTable.')], HRESULT, 'SrcSelectionSet',
              ( ['in'], POINTER(ISelectionSet), 'SelectionSet' )),
    COMMETHOD(['propget', helpstring(u'A SelectionSet applied to a cursor opened from the RelQueryTable.')], HRESULT, 'SrcSelectionSet',
              ( ['retval', 'out'], POINTER(POINTER(ISelectionSet)), 'SelectionSet' )),
    COMMETHOD(['propput', helpstring(u'The destination dataset columns available in a cursor opened from the RelTableTable.')], HRESULT, 'TargetColumns',
              ( ['in'], BSTR, 'TargetColumns' )),
    COMMETHOD(['propget', helpstring(u'The destination dataset columns available in a cursor opened from the RelTableTable.')], HRESULT, 'TargetColumns',
              ( ['retval', 'out'], POINTER(BSTR), 'TargetColumns' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the join is processed on the client.')], HRESULT, 'DoNotPushJoinToDB',
              ( ['in'], VARIANT_BOOL, 'DoNotPushJoinToDB' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the join is processed on the client.')], HRESULT, 'DoNotPushJoinToDB',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'DoNotPushJoinToDB' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the type of join will be a left outer join.')], HRESULT, 'LeftOuterJoin',
              ( ['in'], VARIANT_BOOL, 'LeftOuterJoin' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the type of join will be a left outer join.')], HRESULT, 'LeftOuterJoin',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'LeftOuterJoin' )),
    COMMETHOD(['propget', helpstring(u'Indicates if Fire row changed events.')], HRESULT, 'FireRowChangedEvents',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'fireRowEvents' )),
    COMMETHOD(['propput', helpstring(u'Indicates if Fire row changed events.')], HRESULT, 'FireRowChangedEvents',
              ( ['in'], VARIANT_BOOL, 'fireRowEvents' )),
]
################################################################
## code template for IRelQueryTableName2 implementation
##class IRelQueryTableName2_Impl(object):
##    @property
##    def SrcQueryFilter(self, QueryFilter):
##        u'A QueryFilter applied to a cursor opened from the RelQueryTable.'
##        #return 
##
##    def _get(self):
##        u'Indicates if the originPrimaryClass of the RelationshipClass is the SourceTable.'
##        #return forward
##    def _set(self, forward):
##        u'Indicates if the originPrimaryClass of the RelationshipClass is the SourceTable.'
##    ForwardDirection = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the join is processed on the client.'
##        #return DoNotPushJoinToDB
##    def _set(self, DoNotPushJoinToDB):
##        u'Indicates if the join is processed on the client.'
##    DoNotPushJoinToDB = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if Fire row changed events.'
##        #return fireRowEvents
##    def _set(self, fireRowEvents):
##        u'Indicates if Fire row changed events.'
##    FireRowChangedEvents = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The destination dataset columns available in a cursor opened from the RelTableTable.'
##        #return TargetColumns
##    def _set(self, TargetColumns):
##        u'The destination dataset columns available in a cursor opened from the RelTableTable.'
##    TargetColumns = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the type of join will be a left outer join.'
##        #return LeftOuterJoin
##    def _set(self, LeftOuterJoin):
##        u'Indicates if the type of join will be a left outer join.'
##    LeftOuterJoin = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def RelationshipClassName(self, relClassName):
##        u'The name object for the RelationshipClass that defines the RelQueryTable.'
##        #return 
##
##    @property
##    def SrcSelectionSet(self, SelectionSet):
##        u'A SelectionSet applied to a cursor opened from the RelQueryTable.'
##        #return 
##

class NetworkAttribute(CoClass):
    u'A container for describing a network dataset attribute.'
    _reg_clsid_ = GUID('{A86F7CE3-37E0-4BEF-B66C-72B41796CF03}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class INetworkAttribute2(INetworkAttribute):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of an attribute in a network dataset.'
    _iid_ = GUID('{18793A18-1432-4B6E-ADFC-63470D92223F}')
    _idlflags_ = ['oleautomation']
class INetworkAttribute3(INetworkAttribute2):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of an attribute in a network dataset.'
    _iid_ = GUID('{64C3D5A7-7C12-4290-B458-15D8C76CD688}')
    _idlflags_ = ['oleautomation']
NetworkAttribute._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkAttribute, INetworkAttribute2, INetworkAttribute3]

class IFeatureClassManage(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to update the extent of a feature class.'
    _iid_ = GUID('{0FB7A29C-11AA-406B-8096-26AC8EA27BA6}')
    _idlflags_ = ['oleautomation']
IFeatureClassManage._methods_ = [
    COMMETHOD([helpstring(u'Updates the XY, M, Z extent.')], HRESULT, 'UpdateExtent'),
]
################################################################
## code template for IFeatureClassManage implementation
##class IFeatureClassManage_Impl(object):
##    def UpdateExtent(self):
##        u'Updates the XY, M, Z extent.'
##        #return 
##

class EvaluatedNetworkAttribute(CoClass):
    u'A container for describing a network dataset attribute and its evaluators.'
    _reg_clsid_ = GUID('{CF8D7B2F-628B-4F9D-B149-D5DB3CD32A35}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IEvaluatedNetworkAttribute2(IEvaluatedNetworkAttribute):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of an evaluated attribute in a network dataset.'
    _iid_ = GUID('{B330F518-D166-42B9-A7EA-015CF104C41D}')
    _idlflags_ = ['oleautomation']
EvaluatedNetworkAttribute._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkAttribute, INetworkAttribute2, INetworkAttribute3, IEvaluatedNetworkAttribute, IEvaluatedNetworkAttribute2]

class NetworkConstantEvaluator(CoClass):
    u'A container for describing a network attribute evaluator whose values are derived from a constant value.'
    _reg_clsid_ = GUID('{318C4B91-F5D2-467A-996C-0AB51B0D8FF2}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class INetworkConstantEvaluator(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of a network attribute evaluator whose values are derived from a constant value.'
    _iid_ = GUID('{2CE6CE13-A6AC-4633-BBA3-FF1B294CEE02}')
    _idlflags_ = ['oleautomation']
NetworkConstantEvaluator._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkEvaluator, INetworkEvaluator2, INetworkConstantEvaluator, INetworkEvaluatorSetup, IGPDescribe]

class DirectionsFieldMapping(CoClass):
    u'A container for a directions field mapping.'
    _reg_clsid_ = GUID('{1AAADF55-7530-4CA5-9D41-90FF94C91C5A}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDirectionsFieldMapping(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the properties for directions field mapping.'
    _iid_ = GUID('{83A34C32-8230-4F0E-A647-E63765CE7AF4}')
    _idlflags_ = ['oleautomation']
DirectionsFieldMapping._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDirectionsFieldMapping]

class IGeometricNetworkName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that set and return the associated feature dataset name object.'
    _iid_ = GUID('{CEB75D36-9A95-11D2-AACF-00C04FA37B82}')
    _idlflags_ = ['oleautomation']
IGeometricNetworkName._methods_ = [
    COMMETHOD(['propget', helpstring(u'The Feature Dataset Name that the network belongs to.')], HRESULT, 'FeatureDatasetName',
              ( ['retval', 'out'], POINTER(POINTER(IDatasetName)), 'FeatureDatasetName' )),
    COMMETHOD(['propputref', helpstring(u'The Feature Dataset Name that the network belongs to.')], HRESULT, 'FeatureDatasetName',
              ( ['in'], POINTER(IDatasetName), 'FeatureDatasetName' )),
]
################################################################
## code template for IGeometricNetworkName implementation
##class IGeometricNetworkName_Impl(object):
##    def FeatureDatasetName(self, FeatureDatasetName):
##        u'The Feature Dataset Name that the network belongs to.'
##        #return 
##

class ILocatorUI(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to members that control the locator's user interface."
    _iid_ = GUID('{E0F10B77-EB7C-11D2-9F47-00C04F8ED1C4}')
    _idlflags_ = ['oleautomation']
class ILocatorStyle(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to locator style properties.'
    _iid_ = GUID('{CFC5EF8C-4FCC-40DE-928A-21B354EAE9BD}')
    _idlflags_ = ['oleautomation']
class ILocatorWorkspace(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for managing the locators in the locator workspace.'
    _iid_ = GUID('{AE5A3A08-F756-11D2-9F4F-00C04F8ED1C4}')
    _idlflags_ = ['oleautomation']
class ILocator(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe general locator properties.'
    _iid_ = GUID('{655C5C62-6478-11D3-9F57-00C04F6BDF06}')
    _idlflags_ = ['oleautomation']
ILocatorUI._methods_ = [
    COMMETHOD([helpstring(u'Opens the user interface to create a new locator.')], HRESULT, 'CreateLocator',
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'parentWindow' ),
              ( ['in'], POINTER(ILocatorStyle), 'locatorStyle' ),
              ( ['in'], POINTER(ILocatorWorkspace), 'locWks' ),
              ( ['in'], BSTR, 'connectionName' ),
              ( ['retval', 'out'], POINTER(POINTER(ILocator)), 'locator' )),
    COMMETHOD([helpstring(u'Opens the user interface to view or modify the properties of a locator.')], HRESULT, 'LocatorProperties',
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'parentWindow' ),
              ( ['in'], POINTER(ILocator), 'locator' ),
              ( ['in'], BSTR, 'Title' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Ok' )),
    COMMETHOD([helpstring(u'Opens the user interface to locate a table.')], HRESULT, 'MatchTable',
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'parentWindow' ),
              ( ['in'], POINTER(ITable), 'tableOfLocations' ),
              ( ['in'], POINTER(ILocator), 'locator' ),
              ( ['in', 'out'], POINTER(BSTR), 'pathForGxBrowser' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'resultDatasetName' )),
]
################################################################
## code template for ILocatorUI implementation
##class ILocatorUI_Impl(object):
##    def MatchTable(self, parentWindow, tableOfLocations, locator):
##        u'Opens the user interface to locate a table.'
##        #return pathForGxBrowser, resultDatasetName
##
##    def LocatorProperties(self, parentWindow, locator, Title):
##        u'Opens the user interface to view or modify the properties of a locator.'
##        #return Ok
##
##    def CreateLocator(self, parentWindow, locatorStyle, locWks, connectionName):
##        u'Opens the user interface to create a new locator.'
##        #return locator
##

class IClassSchemaEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to member to modify an object class schema.'
    _iid_ = GUID('{64654191-E2E8-11D2-8A56-000000000000}')
    _idlflags_ = ['oleautomation']
IClassSchemaEdit._methods_ = [
    COMMETHOD([helpstring(u'Registers this class with the database, assigning it a class id and creating an object id column.')], HRESULT, 'RegisterAsObjectClass',
              ( ['in'], BSTR, 'suggestedOIDFieldName' ),
              ( ['in'], BSTR, 'ConfigKeyword' ),
              ( ['retval', 'out'], POINTER(c_int), 'ObjectClassID' )),
    COMMETHOD([helpstring(u'Changes the instance COM class associated with this database class.')], HRESULT, 'AlterInstanceCLSID',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'InstanceCLSID' )),
    COMMETHOD([helpstring(u'Changes the class extension COM class associated with this database class.')], HRESULT, 'AlterClassExtensionCLSID',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'ClassExtensionCLSID' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'classExtensionProperties' )),
    COMMETHOD([helpstring(u'The alias name of the object class.')], HRESULT, 'AlterAliasName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD([helpstring(u'The alias name of the object class field.')], HRESULT, 'AlterFieldAliasName',
              ( ['in'], BSTR, 'FieldName' ),
              ( ['in'], BSTR, 'AliasName' )),
    COMMETHOD([helpstring(u'The model name of the object class.')], HRESULT, 'AlterModelName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD([helpstring(u'The model name of the object class field.')], HRESULT, 'AlterFieldModelName',
              ( ['in'], BSTR, 'FieldName' ),
              ( ['in'], BSTR, 'ModelName' )),
    COMMETHOD([helpstring(u'The default domain of the object class field.')], HRESULT, 'AlterDomain',
              ( ['in'], BSTR, 'FieldName' ),
              ( ['in'], POINTER(IDomain), 'Domain' )),
    COMMETHOD([helpstring(u'The default value of the object class field.')], HRESULT, 'AlterDefaultValue',
              ( ['in'], BSTR, 'FieldName' ),
              ( ['in'], VARIANT, 'Value' )),
]
################################################################
## code template for IClassSchemaEdit implementation
##class IClassSchemaEdit_Impl(object):
##    def AlterAliasName(self, Name):
##        u'The alias name of the object class.'
##        #return 
##
##    def AlterModelName(self, Name):
##        u'The model name of the object class.'
##        #return 
##
##    def AlterClassExtensionCLSID(self, ClassExtensionCLSID, classExtensionProperties):
##        u'Changes the class extension COM class associated with this database class.'
##        #return 
##
##    def AlterDefaultValue(self, FieldName, Value):
##        u'The default value of the object class field.'
##        #return 
##
##    def AlterInstanceCLSID(self, InstanceCLSID):
##        u'Changes the instance COM class associated with this database class.'
##        #return 
##
##    def AlterFieldAliasName(self, FieldName, AliasName):
##        u'The alias name of the object class field.'
##        #return 
##
##    def AlterDomain(self, FieldName, Domain):
##        u'The default domain of the object class field.'
##        #return 
##
##    def AlterFieldModelName(self, FieldName, ModelName):
##        u'The model name of the object class field.'
##        #return 
##
##    def RegisterAsObjectClass(self, suggestedOIDFieldName, ConfigKeyword):
##        u'Registers this class with the database, assigning it a class id and creating an object id column.'
##        #return ObjectClassID
##

class FGDCSynchronizer(CoClass):
    u'Esri FGDC Synchronizer object.'
    _reg_clsid_ = GUID('{1D8F7EFD-2B53-4045-BBDB-AB160C05A9F9}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
FGDCSynchronizer._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IMetadataSynchronizer]

class JSONConverterGdb(CoClass):
    u'All-in-one JSON conversion for the GeoDatabase library. Supports all previous JSON interfaces in the GeoDatabase, namely IJSONSerializer, IJSONDeserializer, IExternalSerializerGdb, IExternalDeserializerGdb'
    _reg_clsid_ = GUID('{90C68873-1A9E-4562-A07F-8E9C6729AB11}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IExternalSerializerGdb(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides high-level serialization methods for AMF and JSON formats.'
    _iid_ = GUID('{EED3EEA0-A5A5-49E8-B23C-BA29AE21D3DA}')
    _idlflags_ = ['oleautomation']
class IExternalDeserializerGdb(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides high-level deserialization methods for AMF and JSON formats.'
    _iid_ = GUID('{B3021BE9-C152-4DF8-AA79-3D834190DA67}')
    _idlflags_ = ['oleautomation']
class IJSONConverterGdb(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides high-level deserialization methods for JSON.'
    _iid_ = GUID('{F28D230E-0F29-4022-B84F-E7E955A9A873}')
    _idlflags_ = ['oleautomation']
JSONConverterGdb._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IJSONSerializer, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IJSONDeserializer, IExternalSerializerGdb, IExternalDeserializerGdb, IJSONConverterGdb, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class IDatasetEditEx(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to more information on the status of datasets being edited.'
    _iid_ = GUID('{60E8162B-1AE0-11D4-9FB1-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
IDatasetEditEx._methods_ = [
    COMMETHOD([helpstring(u'True if the dataset is being edited, else returns the reason why it is not editable.')], HRESULT, 'IsBeingEdited',
              ( ['out'], POINTER(VARIANT_BOOL), 'IsBeingEdited' ),
              ( ['out'], POINTER(HRESULT), 'hrReason' )),
]
################################################################
## code template for IDatasetEditEx implementation
##class IDatasetEditEx_Impl(object):
##    def IsBeingEdited(self):
##        u'True if the dataset is being edited, else returns the reason why it is not editable.'
##        #return IsBeingEdited, hrReason
##

class MetadataSynchronizer(CoClass):
    u'Esri Metadata Synchronizer object (singleton).'
    _reg_clsid_ = GUID('{C10124EE-3648-445E-A16B-9D2755FBD690}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
MetadataSynchronizer._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IMetadataSynchronizer, IMetadataSynchronizerManager]

class MemoryRelationshipClass(CoClass):
    u'A relationship class object that is stored in memory.'
    _reg_clsid_ = GUID('{224BF65E-D9B1-11D3-A154-0000F8775BF9}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
MemoryRelationshipClass._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDataset, IRelationshipClass, IRelationshipClass2]

class RelQueryTableFactory(CoClass):
    u'Object used to create join table objects.'
    _reg_clsid_ = GUID('{9B4E4D0C-753A-43BB-83FB-BA16F6652E1C}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IRelQueryTableFactory(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that open a join table.'
    _iid_ = GUID('{B3949D86-3078-4F3B-9DC8-651053366119}')
    _idlflags_ = ['oleautomation']
RelQueryTableFactory._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRelQueryTableFactory]

class IDatasetName2(IDatasetName):
    _case_insensitive_ = True
    u'Provides access to members that supply dataset name information.'
    _iid_ = GUID('{033D515E-0F94-4C23-8EB8-DAFF16B1F17B}')
    _idlflags_ = ['oleautomation']
IDatasetName._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the dataset.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the dataset.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The type of the dataset.')], HRESULT, 'Type',
              ( ['retval', 'out'], POINTER(esriDatasetType), 'Type' )),
    COMMETHOD(['propget', helpstring(u'The category of the dataset.')], HRESULT, 'Category',
              ( ['retval', 'out'], POINTER(BSTR), 'Category' )),
    COMMETHOD(['propput', helpstring(u'The category of the dataset.')], HRESULT, 'Category',
              ( ['in'], BSTR, 'Category' )),
    COMMETHOD(['propget', helpstring(u'The WorkspaceName of the DatasetName.')], HRESULT, 'WorkspaceName',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspaceName)), 'WorkspaceName' )),
    COMMETHOD(['propputref', helpstring(u'The WorkspaceName of the DatasetName.')], HRESULT, 'WorkspaceName',
              ( ['in'], POINTER(IWorkspaceName), 'WorkspaceName' )),
    COMMETHOD(['propget', helpstring(u'Subset names contained within this dataset name.')], HRESULT, 'SubsetNames',
              ( ['retval', 'out'], POINTER(POINTER(IEnumDatasetName)), 'SubsetNames' )),
]
################################################################
## code template for IDatasetName implementation
##class IDatasetName_Impl(object):
##    def _get(self):
##        u'The category of the dataset.'
##        #return Category
##    def _set(self, Category):
##        u'The category of the dataset.'
##    Category = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def SubsetNames(self):
##        u'Subset names contained within this dataset name.'
##        #return SubsetNames
##
##    @property
##    def Type(self):
##        u'The type of the dataset.'
##        #return Type
##
##    def _get(self):
##        u'The name of the dataset.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the dataset.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def WorkspaceName(self, WorkspaceName):
##        u'The WorkspaceName of the DatasetName.'
##        #return 
##

IDatasetName2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The names of the dataset of the specified type.')], HRESULT, 'ControllerNames',
              ( ['in'], esriDatasetType, 'DatasetType' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumDatasetName)), 'DatasetNames' )),
    COMMETHOD(['propputref', helpstring(u'Add a DatasetName.')], HRESULT, 'ControllerName',
              ( ['in'], POINTER(IDatasetName), 'rhs' )),
]
################################################################
## code template for IDatasetName2 implementation
##class IDatasetName2_Impl(object):
##    def ControllerName(self, rhs):
##        u'Add a DatasetName.'
##        #return 
##
##    @property
##    def ControllerNames(self, DatasetType):
##        u'The names of the dataset of the specified type.'
##        #return DatasetNames
##

class DocumentationInfo(CoClass):
    u'Provides access to DocumentationInfo object.'
    _reg_clsid_ = GUID('{8BC2E4F6-0264-41BF-B2FE-347C0BBDD361}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DocumentationInfo._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDocumentationInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist]

class RelQueryTable(CoClass):
    u'An object that joins two datasets based on common data values.'
    _reg_clsid_ = GUID('{365F6148-1D24-11D3-9F5C-00C04F6BC886}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IRelQueryTable(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that define the Tables and the RelationshipClass used in a join.'
    _iid_ = GUID('{E9075692-7072-11D3-A11E-0000F8775BF9}')
    _idlflags_ = ['oleautomation']
class IRelQueryTableSettings(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that RelQueryTable behavior.'
    _iid_ = GUID('{FDA93763-EB76-40A6-BA53-EDDAEFCDDE07}')
    _idlflags_ = ['oleautomation']
class IRelQueryTableInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that provide information about joins.'
    _iid_ = GUID('{D5A1B5BC-9A9F-4A40-BF34-69800D27EBE3}')
    _idlflags_ = ['oleautomation']
class IRelQueryTableManage(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage the query tables.'
    _iid_ = GUID('{C27587AB-AB36-4203-B9BD-D7906CF27B7C}')
    _idlflags_ = ['oleautomation']
RelQueryTable._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDataset, IClass, ITable, IObjectClass, IFeatureClass, ITableCapabilities, comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IConnectionPointContainer, IRelQueryTable, IRelQueryTableSettings, IRelQueryTableInfo, IVirtualTable, IRelQueryTableManage]
RelQueryTable._outgoing_interfaces_ = [IObjectClassEvents]

class ItemInfo(CoClass):
    u'Item Info coclass.'
    _reg_clsid_ = GUID('{B75A7B90-51C5-408E-9807-E63ACE560448}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IItemInfo2(IItemInfo):
    _case_insensitive_ = True
    u'Provides access to members of item info.'
    _iid_ = GUID('{9D3C440D-837E-4D7B-AB0D-60E8A4542000}')
    _idlflags_ = ['oleautomation']
ItemInfo._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IItemInfo, IItemInfo2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist]

class RelQueryCursor(CoClass):
    u'A cursor that is opened from a RelQueryTable.'
    _reg_clsid_ = GUID('{365F6149-1D24-11D3-9F5C-00C04F6BC886}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
RelQueryCursor._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ICursor, IFeatureCursor]

class NamesEnumerator(CoClass):
    u'Esri Name Enumerator object.'
    _reg_clsid_ = GUID('{27301BE1-6800-11D4-8155-00C04F686238}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
NamesEnumerator._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IEnumName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IEnumNameEdit]

class QueryDef(CoClass):
    u'Esri Query Definition object.'
    _reg_clsid_ = GUID('{FBF57160-A05D-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
QueryDef._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IQueryDef]

class RelQueryRow(CoClass):
    u'A row defined by a join of the datasets in a RelQueryTable.'
    _reg_clsid_ = GUID('{365F614A-1D24-11D3-9F5C-00C04F6BC886}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
RelQueryRow._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRow, IObject, IRowBuffer, IFeature, IFeatureBuffer, IFeatureDraw, IFeatureProject]

class IDatasetNameFileStat(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control DatasetName file-based statistics.'
    _iid_ = GUID('{9DB4594F-DC4B-457A-AE2E-FFEA8BD8D72E}')
    _idlflags_ = ['oleautomation']
IDatasetNameFileStat._methods_ = [
    COMMETHOD(['propput', helpstring(u'The date modified/created/accessed.')], HRESULT, 'StatTime',
              ( ['in'], esriDatasetFileStatTimeMode, 'dateMode' ),
              ( ['in'], c_int, 'pTime' )),
    COMMETHOD(['propget', helpstring(u'The date modified/created/accessed.')], HRESULT, 'StatTime',
              ( ['in'], esriDatasetFileStatTimeMode, 'dateMode' ),
              ( ['retval', 'out'], POINTER(c_int), 'pTime' )),
    COMMETHOD(['propput', helpstring(u'The size.')], HRESULT, 'StatSize',
              ( ['in'], c_int, 'pSize' )),
    COMMETHOD(['propget', helpstring(u'The size.')], HRESULT, 'StatSize',
              ( ['retval', 'out'], POINTER(c_int), 'pSize' )),
    COMMETHOD(['propput', helpstring(u'The access mode.')], HRESULT, 'StatMode',
              ( ['in'], esriDatasetFileStatAccessMode, 'pAccessMode' )),
    COMMETHOD(['propget', helpstring(u'The access mode.')], HRESULT, 'StatMode',
              ( ['retval', 'out'], POINTER(esriDatasetFileStatAccessMode), 'pAccessMode' )),
]
################################################################
## code template for IDatasetNameFileStat implementation
##class IDatasetNameFileStat_Impl(object):
##    def _get(self, dateMode):
##        u'The date modified/created/accessed.'
##        #return pTime
##    def _set(self, dateMode, pTime):
##        u'The date modified/created/accessed.'
##    StatTime = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The access mode.'
##        #return pAccessMode
##    def _set(self, pAccessMode):
##        u'The access mode.'
##    StatMode = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The size.'
##        #return pSize
##    def _set(self, pSize):
##        u'The size.'
##    StatSize = property(_get, _set, doc = _set.__doc__)
##

class ItemInfos(CoClass):
    u'An array of ItemInfo objects.'
    _reg_clsid_ = GUID('{3EB14159-D61C-436C-8FCA-597085FCBC12}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
ItemInfos._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IItemInfos, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist]

class IDatasetNameFileSize(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control DatasetName file size over 2GB'
    _iid_ = GUID('{62AE7F20-59E5-44AF-8DBA-FA4DA33B6AF7}')
    _idlflags_ = ['oleautomation']
IDatasetNameFileSize._methods_ = [
    COMMETHOD(['propget', helpstring(u'The size. 64bit Value')], HRESULT, 'Size64',
              ( ['retval', 'out'], POINTER(c_ulonglong), 'Size64' )),
]
################################################################
## code template for IDatasetNameFileSize implementation
##class IDatasetNameFileSize_Impl(object):
##    @property
##    def Size64(self):
##        u'The size. 64bit Value'
##        #return Size64
##

class EnumTableVersionChanges(CoClass):
    u'Esri EnumTableVersionChanges object.'
    _reg_clsid_ = GUID('{74975793-50C8-4420-B2ED-928232B16449}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IEnumTableVersionChanges(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through the tables that have been changed.'
    _iid_ = GUID('{F7F1308A-8F93-40EF-932C-F3F359C221EE}')
    _idlflags_ = ['oleautomation']
class ICollectionTableVersionChanges(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members to modify the list of tables that have been changed.'
    _iid_ = GUID('{E1E2702E-8B9E-4322-A332-CAAE8770D657}')
    _idlflags_ = ['oleautomation']
EnumTableVersionChanges._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumTableVersionChanges, ICollectionTableVersionChanges]

class Relationship(CoClass):
    u'Esri Relationship object.'
    _reg_clsid_ = GUID('{AF10D717-A61B-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Relationship._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRelationship]

class FeatureDataset(CoClass):
    u'Esri Feature Dataset object.'
    _reg_clsid_ = GUID('{AA4596E4-A39C-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDatasetAnalyze(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that analyze a dataset.'
    _iid_ = GUID('{60262917-D53F-4E0B-86FF-A916C3FB26BC}')
    _idlflags_ = ['oleautomation']
class IGeoDatasetSchemaEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that change the schema of a GeoDataset.'
    _iid_ = GUID('{6B267C02-28CC-11D3-9F67-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
class INetworkCollection2(INetworkCollection):
    _case_insensitive_ = True
    u'Provides access to members that create and maintain information about geometric networks.'
    _iid_ = GUID('{A2B19ED3-0FE6-11D4-A0E5-00C04F6BDF0E}')
    _idlflags_ = ['oleautomation']
class IFeatureDatasetExtensionContainer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the collection of feature dataset extensions.'
    _iid_ = GUID('{23869B3A-1AD9-468B-9E52-6FDC3C261FDA}')
    _idlflags_ = ['oleautomation']
FeatureDataset._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDataset, IDatasetEdit, IDatasetEditInfo, IDatasetAnalyze, ISchemaLock, IGeoDataset, IGeoDatasetSchemaEdit, IFeatureDataset, INetworkCollection, INetworkCollection2, IFeatureClassContainer, IRelationshipClassContainer, IDatasetContainer, ITopologyContainer2, IFeatureDatasetExtensionContainer]

class IPlugInWorkspaceFactoryHelper2(IPlugInWorkspaceFactoryHelper):
    _case_insensitive_ = True
    u'Provides access to members that help the Plug-In workspace factory.'
    _iid_ = GUID('{A6BA6EDA-95A0-49B9-9EDF-A83099448798}')
    _idlflags_ = ['oleautomation']
IPlugInWorkspaceFactoryHelper2._methods_ = [
    COMMETHOD([helpstring(u'Opens a workspace helper for the workspace identified by the workspace string, using the connection properties.')], HRESULT, 'OpenWorkspaceEx',
              ( ['in'], BSTR, 'wksString' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'pConnectionProps' ),
              ( ['retval', 'out'], POINTER(POINTER(IPlugInWorkspaceHelper)), 'wksHelper' )),
]
################################################################
## code template for IPlugInWorkspaceFactoryHelper2 implementation
##class IPlugInWorkspaceFactoryHelper2_Impl(object):
##    def OpenWorkspaceEx(self, wksString, pConnectionProps):
##        u'Opens a workspace helper for the workspace identified by the workspace string, using the connection properties.'
##        #return wksHelper
##

class ISqlKeywordDictionary(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the members that control the dictionary for SQL Keywords.'
    _iid_ = GUID('{764F1A3D-3E8B-11D2-AAE0-00C04FA33C20}')
    _idlflags_ = ['oleautomation']
ISqlKeywordDictionary._methods_ = [
    COMMETHOD(['propput', helpstring(u'Provides access to members that maintain a list of SQL Keywords.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propget', helpstring(u'Number of invalid field names.')], HRESULT, 'Count',
              ( ['in'], POINTER(c_int), 'reservedWordCount' )),
    COMMETHOD([helpstring(u'Adds a new illegal field name.')], HRESULT, 'Add',
              ( ['in'], BSTR, 'reservedWord' )),
    COMMETHOD([helpstring(u'Removes a illegal field name form the list.')], HRESULT, 'Remove',
              ( ['in'], BSTR, 'reservedWord' )),
    COMMETHOD([helpstring(u'Resets the invalid field names to the state before you called Clear, Add, or Remove.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Clears all the invalid field names.')], HRESULT, 'Empty'),
    COMMETHOD([helpstring(u'Indicates if the word is illegal (Legal = false, Illegal = true).')], HRESULT, 'FindKeyword',
              ( ['in'], BSTR, 'keyword' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbFound' )),
]
################################################################
## code template for ISqlKeywordDictionary implementation
##class ISqlKeywordDictionary_Impl(object):
##    @property
##    def Count(self, reservedWordCount):
##        u'Number of invalid field names.'
##        #return 
##
##    def Reset(self):
##        u'Resets the invalid field names to the state before you called Clear, Add, or Remove.'
##        #return 
##
##    def _set(self, rhs):
##        u'Provides access to members that maintain a list of SQL Keywords.'
##    Name = property(fset = _set, doc = _set.__doc__)
##
##    def FindKeyword(self, keyword):
##        u'Indicates if the word is illegal (Legal = false, Illegal = true).'
##        #return pbFound
##
##    def Remove(self, reservedWord):
##        u'Removes a illegal field name form the list.'
##        #return 
##
##    def Add(self, reservedWord):
##        u'Adds a new illegal field name.'
##        #return 
##
##    def Empty(self):
##        u'Clears all the invalid field names.'
##        #return 
##

class RowBuffer(CoClass):
    u'Esri Row Buffer object.'
    _reg_clsid_ = GUID('{AF10D716-A61B-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
RowBuffer._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRowBuffer]

class IDatasetNameFileStat2(IDatasetNameFileStat):
    _case_insensitive_ = True
    u'Provides access to members that control DatasetName file-based statistics.'
    _iid_ = GUID('{49C5F97E-23D7-4E47-94A3-A2D300F2B50E}')
    _idlflags_ = ['oleautomation']
IDatasetNameFileStat2._methods_ = [
    COMMETHOD(['propput', helpstring(u'The size. 64 bit value')], HRESULT, 'StatSize64',
              ( ['in'], c_ulonglong, 'Size64' )),
    COMMETHOD(['propget', helpstring(u'The size. 64 bit value')], HRESULT, 'StatSize64',
              ( ['retval', 'out'], POINTER(c_ulonglong), 'Size64' )),
    COMMETHOD([helpstring(u'Refresh the file-based statistics')], HRESULT, 'RefreshStats'),
]
################################################################
## code template for IDatasetNameFileStat2 implementation
##class IDatasetNameFileStat2_Impl(object):
##    def _get(self):
##        u'The size. 64 bit value'
##        #return Size64
##    def _set(self, Size64):
##        u'The size. 64 bit value'
##    StatSize64 = property(_get, _set, doc = _set.__doc__)
##
##    def RefreshStats(self):
##        u'Refresh the file-based statistics'
##        #return 
##

IGPControllerMembership._methods_ = [
]
################################################################
## code template for IGPControllerMembership implementation
##class IGPControllerMembership_Impl(object):

class SelectionSet(CoClass):
    u'Esri Selection Set object.'
    _reg_clsid_ = GUID('{AF10D718-A61B-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
SelectionSet._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ISelectionSet, ISelectionSet2]

IRouteLocatorName._methods_ = [
    COMMETHOD(['propputref', helpstring(u'The route feature class name (Polyline with M feature class name).')], HRESULT, 'RouteFeatureClassName',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The route feature class name (Polyline with M feature class name).')], HRESULT, 'RouteFeatureClassName',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The route identifier field of the route feature class.')], HRESULT, 'RouteIDFieldName',
              ( ['in'], BSTR, 'RouteIDFieldName' )),
    COMMETHOD(['propget', helpstring(u'The route identifier field of the route feature class.')], HRESULT, 'RouteIDFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'RouteIDFieldName' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the Route ID is unique (Obsolete).')], HRESULT, 'RouteIDIsUnique',
              ( ['in'], VARIANT_BOOL, 'RouteIDIsUnique' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the Route ID is unique (Obsolete).')], HRESULT, 'RouteIDIsUnique',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'RouteIDIsUnique' )),
    COMMETHOD(['propput', helpstring(u'The route measure units.')], HRESULT, 'RouteMeasureUnit',
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.esriUnits, 'Units' )),
    COMMETHOD(['propget', helpstring(u'The route measure units.')], HRESULT, 'RouteMeasureUnit',
              ( ['retval', 'out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.esriUnits), 'Units' )),
    COMMETHOD(['propput', helpstring(u'The where clause that limits the routes that events can be located on.')], HRESULT, 'RouteWhereClause',
              ( ['in'], BSTR, 'WhereClause' )),
    COMMETHOD(['propget', helpstring(u'The where clause that limits the routes that events can be located on.')], HRESULT, 'RouteWhereClause',
              ( ['retval', 'out'], POINTER(BSTR), 'WhereClause' )),
]
################################################################
## code template for IRouteLocatorName implementation
##class IRouteLocatorName_Impl(object):
##    @property
##    def RouteFeatureClassName(self, Name):
##        u'The route feature class name (Polyline with M feature class name).'
##        #return 
##
##    def _get(self):
##        u'Indicates if the Route ID is unique (Obsolete).'
##        #return RouteIDIsUnique
##    def _set(self, RouteIDIsUnique):
##        u'Indicates if the Route ID is unique (Obsolete).'
##    RouteIDIsUnique = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The where clause that limits the routes that events can be located on.'
##        #return WhereClause
##    def _set(self, WhereClause):
##        u'The where clause that limits the routes that events can be located on.'
##    RouteWhereClause = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The route identifier field of the route feature class.'
##        #return RouteIDFieldName
##    def _set(self, RouteIDFieldName):
##        u'The route identifier field of the route feature class.'
##    RouteIDFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The route measure units.'
##        #return Units
##    def _set(self, Units):
##        u'The route measure units.'
##    RouteMeasureUnit = property(_get, _set, doc = _set.__doc__)
##

class Cursor(CoClass):
    u'Esri Cursor object.'
    _reg_clsid_ = GUID('{AF10D719-A61B-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Cursor._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ICursor]

class IWorkspaceEditInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control Workspace Editing Information.'
    _iid_ = GUID('{995D5C91-15C6-11D2-89ED-006097AFF44E}')
    _idlflags_ = ['oleautomation']
IWorkspaceEditInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the workspace supports edit sessions with the ability to discard edits on save.')], HRESULT, 'CanEdit',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanEdit' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the workspace supports edit sessions with the ability to undo individual edit operations.')], HRESULT, 'CanUndo',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanUndo' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the workspace supports edit sessions with the ability to redo undone operations.')], HRESULT, 'CanRedo',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanUndo' )),
]
################################################################
## code template for IWorkspaceEditInfo implementation
##class IWorkspaceEditInfo_Impl(object):
##    @property
##    def CanRedo(self):
##        u'Indicates if the workspace supports edit sessions with the ability to redo undone operations.'
##        #return CanUndo
##
##    @property
##    def CanEdit(self):
##        u'Indicates if the workspace supports edit sessions with the ability to discard edits on save.'
##        #return CanEdit
##
##    @property
##    def CanUndo(self):
##        u'Indicates if the workspace supports edit sessions with the ability to undo individual edit operations.'
##        #return CanUndo
##

class IEnumFieldError(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through field errors.'
    _iid_ = GUID('{C2C69253-4CCB-11D2-AAE7-00C04FA33C20}')
    _idlflags_ = ['oleautomation']
class IFieldError(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to field name errors.'
    _iid_ = GUID('{E013B817-4CCC-11D2-AAE7-00C04FA33C20}')
    _idlflags_ = ['oleautomation']
IEnumFieldError._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next field error in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IFieldError)), 'FieldError' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumFieldError implementation
##class IEnumFieldError_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next field error in the enumeration sequence.'
##        #return FieldError
##

class ObjectClass(CoClass):
    u'Esri Object Class object.'
    _reg_clsid_ = GUID('{AF10D71A-A61B-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IClassSchemaEdit2(IClassSchemaEdit):
    _case_insensitive_ = True
    u"Provides access to members that modify an object class's extension properties."
    _iid_ = GUID('{62F1F470-E991-11D3-80D3-00C04F601565}')
    _idlflags_ = ['oleautomation']
class IClassSchemaEdit3(IClassSchemaEdit2):
    _case_insensitive_ = True
    u"Provides access to members that modify an object class's extension properties."
    _iid_ = GUID('{4B35F814-0417-47E3-8DFC-CAD58746693B}')
    _idlflags_ = ['oleautomation']
class IClassSchemaEdit4(IClassSchemaEdit3):
    _case_insensitive_ = True
    u"Provides access to members that modify an object class's Editor Tracking properties."
    _iid_ = GUID('{7799996E-4EE7-4ABC-A553-5DA86F7A6144}')
    _idlflags_ = ['oleautomation']
class IClassSchemaEditEx(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that modify an object class schema.'
    _iid_ = GUID('{F14139C3-B498-4B42-AA6C-5960028554E0}')
    _idlflags_ = ['oleautomation']
ObjectClass._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDataset, IDatasetEdit, IDatasetEditInfo, IDatasetAnalyze, ISchemaLock, IClass, ITable, IObjectClass, IClassSchemaEdit, IClassSchemaEdit2, IClassSchemaEdit3, IClassSchemaEdit4, IClassSchemaEditEx, IModelInfo, ISubtypes, IValidation, IValidation2, IObjectClassInfo, IObjectClassInfo2, ITableCapabilities]

IWorkspaceReplicaDatasets._methods_ = [
    COMMETHOD(['propget', helpstring(u'A list of datasets based on a replica name.')], HRESULT, 'ReplicaDatasetsByName',
              ( ['in'], BSTR, 'ReplicaName' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumReplicaDataset)), 'enumReplicaDataset' )),
    COMMETHOD(['propget', helpstring(u'A list of datasets based on a replica ID.')], HRESULT, 'ReplicaDatasetsByID',
              ( ['in'], c_int, 'ReplicaID' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumReplicaDataset)), 'enumReplicaDataset' )),
]
################################################################
## code template for IWorkspaceReplicaDatasets implementation
##class IWorkspaceReplicaDatasets_Impl(object):
##    @property
##    def ReplicaDatasetsByName(self, ReplicaName):
##        u'A list of datasets based on a replica name.'
##        #return enumReplicaDataset
##
##    @property
##    def ReplicaDatasetsByID(self, ReplicaID):
##        u'A list of datasets based on a replica ID.'
##        #return enumReplicaDataset
##

class IFieldChecker(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the Field Checker.'
    _iid_ = GUID('{7370629B-3E8F-11D2-AAE0-00C04FA33C20}')
    _idlflags_ = ['oleautomation']
IFieldChecker._methods_ = [
    COMMETHOD([helpstring(u'Checks the validity of a list of field names.')], HRESULT, 'Validate',
              ( ['in'], POINTER(IFields), 'inputField' ),
              ( ['out'], POINTER(POINTER(IEnumFieldError)), 'error' ),
              ( ['out'], POINTER(POINTER(IFields)), 'fixedFields' )),
    COMMETHOD([helpstring(u'Checks the validity of a table name.')], HRESULT, 'ValidateTableName',
              ( ['in'], BSTR, 'TableName' ),
              ( ['out'], POINTER(BSTR), 'fixedName' ),
              ( ['retval', 'out'], POINTER(c_int), 'error' )),
    COMMETHOD([helpstring(u'Checks the validity of a field.')], HRESULT, 'ValidateField',
              ( ['in'], c_int, 'FieldIndex' ),
              ( ['in'], POINTER(IFields), 'inputFields' ),
              ( ['out'], POINTER(POINTER(IEnumFieldError)), 'error' ),
              ( ['out'], POINTER(POINTER(IFields)), 'fixedFields' )),
    COMMETHOD(['propget', helpstring(u'Workspace of the fieldchecker.')], HRESULT, 'ValidateWorkspace',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'ValidateWorkspace' )),
    COMMETHOD(['propputref', helpstring(u'Workspace of the fieldchecker.')], HRESULT, 'ValidateWorkspace',
              ( ['in'], POINTER(IWorkspace), 'ValidateWorkspace' )),
    COMMETHOD(['propget', helpstring(u'Input workspace of the fieldchecker.')], HRESULT, 'InputWorkspace',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'InputWorkspace' )),
    COMMETHOD(['propput', helpstring(u'Input workspace of the fieldchecker.')], HRESULT, 'InputWorkspace',
              ( ['in'], POINTER(IWorkspace), 'InputWorkspace' )),
    COMMETHOD(['propget', helpstring(u'Fieldchecker dictionary.')], HRESULT, 'ValidateDictionary',
              ( ['retval', 'out'], POINTER(POINTER(ISqlKeywordDictionary)), 'ValidateDictionary' )),
    COMMETHOD(['propputref', helpstring(u'Fieldchecker dictionary.')], HRESULT, 'ValidateDictionary',
              ( ['in'], POINTER(ISqlKeywordDictionary), 'ValidateDictionary' )),
]
################################################################
## code template for IFieldChecker implementation
##class IFieldChecker_Impl(object):
##    def _get(self):
##        u'Input workspace of the fieldchecker.'
##        #return InputWorkspace
##    def _set(self, InputWorkspace):
##        u'Input workspace of the fieldchecker.'
##    InputWorkspace = property(_get, _set, doc = _set.__doc__)
##
##    def ValidateWorkspace(self, ValidateWorkspace):
##        u'Workspace of the fieldchecker.'
##        #return 
##
##    def ValidateDictionary(self, ValidateDictionary):
##        u'Fieldchecker dictionary.'
##        #return 
##
##    def Validate(self, inputField):
##        u'Checks the validity of a list of field names.'
##        #return error, fixedFields
##
##    def ValidateField(self, FieldIndex, inputFields):
##        u'Checks the validity of a field.'
##        #return error, fixedFields
##
##    def ValidateTableName(self, TableName):
##        u'Checks the validity of a table name.'
##        #return fixedName, error
##


# values for enumeration 'esriFieldNameErrorType'
esriNoFieldError = 0
esriSQLReservedWord = 1
esriDuplicatedFieldName = 2
esriInvalidCharacter = 3
esriInvalidFieldNameLength = 4
esriFieldNameErrorType = c_int # enum
IFieldError._methods_ = [
    COMMETHOD(['propget', helpstring(u'Field index for the current field error.')], HRESULT, 'FieldIndex',
              ( ['retval', 'out'], POINTER(c_int), 'FieldIndex' )),
    COMMETHOD(['propget', helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'FieldError',
              ( ['retval', 'out'], POINTER(esriFieldNameErrorType), 'FieldError' )),
]
################################################################
## code template for IFieldError implementation
##class IFieldError_Impl(object):
##    @property
##    def FieldIndex(self):
##        u'Field index for the current field error.'
##        #return FieldIndex
##
##    @property
##    def FieldError(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return FieldError
##

class AttributedRelationshipClass(CoClass):
    u'Esri Attributed Relationship Class object.'
    _reg_clsid_ = GUID('{AF10D71E-A61B-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
AttributedRelationshipClass._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRelationshipClass, IDataset, IRelationshipClass2, ITable, IClass, ITableCapabilities, IDatasetEdit, IDatasetEditInfo, IRelClassSchemaEdit]

class EnumConflictClass(CoClass):
    u'Esri EnumConflictClass object.'
    _reg_clsid_ = GUID('{23A7329D-AB83-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
EnumConflictClass._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumConflictClass]

class EnumDatasetType(CoClass):
    u'Esri EnumDatasetType object.'
    _reg_clsid_ = GUID('{83AC9E2E-46B4-435B-92F9-84FD3D3C2BA8}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
EnumDatasetType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumDatasetType]

class EnumIDs(CoClass):
    u'Esri EnumIDs object.'
    _reg_clsid_ = GUID('{AF10D71F-A61B-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
EnumIDs._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumIDs]

class IMultiuserWorkspaceEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control Multiuser Workspace Editing.'
    _iid_ = GUID('{861573B8-DE0E-465A-90A9-1E5ABD99A8B5}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriMultiuserEditSessionMode'
esriMESMVersioned = 0
esriMESMNonVersioned = 1
esriMultiuserEditSessionMode = c_int # enum
IMultiuserWorkspaceEdit._methods_ = [
    COMMETHOD(['propget'], HRESULT, 'MultiuserEditSessionMode',
              ( ['retval', 'out'], POINTER(esriMultiuserEditSessionMode), 'esMode' )),
    COMMETHOD([], HRESULT, 'SupportsMultiuserEditSessionMode',
              ( ['in'], esriMultiuserEditSessionMode, 'esMode' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsSupported' )),
    COMMETHOD([], HRESULT, 'StartMultiuserEditing',
              ( ['in'], esriMultiuserEditSessionMode, 'esMode' )),
]
################################################################
## code template for IMultiuserWorkspaceEdit implementation
##class IMultiuserWorkspaceEdit_Impl(object):
##    @property
##    def MultiuserEditSessionMode(self):
##        '-no docstring-'
##        #return esMode
##
##    def StartMultiuserEditing(self, esMode):
##        '-no docstring-'
##        #return 
##
##    def SupportsMultiuserEditSessionMode(self, esMode):
##        '-no docstring-'
##        #return IsSupported
##

IExternalSerializerGdb._methods_ = [
    COMMETHOD([helpstring(u'Writes spatial reference object. Pass NULL as propname to write standalone JSON object.')], HRESULT, 'WriteSpatialReference',
              ( ['in'], BSTR, 'propname' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'pSR' )),
    COMMETHOD([helpstring(u'Writes geometry object.')], HRESULT, 'WriteGeometry',
              ( ['in'], BSTR, 'propname' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pGeom' )),
    COMMETHOD([helpstring(u'Writes feature row object')], HRESULT, 'WriteRow',
              ( ['in'], BSTR, 'propname' ),
              ( ['in'], POINTER(IRow), 'pRow' ),
              ( ['in'], POINTER(IFields), 'pFields' ),
              ( ['in'], _midlSAFEARRAY(c_int), 'rowFieldIndexes' ),
              ( ['in'], POINTER(IGeometryResultOptions), 'pGeomOpt' )),
    COMMETHOD([helpstring(u'Writes feature recordset.')], HRESULT, 'WriteRecordSet',
              ( ['in'], BSTR, 'propname' ),
              ( ['in'], POINTER(IRecordSet), 'pRecordset' ),
              ( ['in'], POINTER(IGeometryResultOptions), 'pGeomOpt' )),
    COMMETHOD([helpstring(u'Writes error object.')], HRESULT, 'WriteErrorObject',
              ( ['in'], BSTR, 'propname' ),
              ( ['in'], c_int, 'Code' ),
              ( ['in'], BSTR, 'Message' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'details' )),
    COMMETHOD([helpstring(u'Convenience method. Creates and returns error object as byte SAFEARRAY.')], HRESULT, 'GetErrorObject',
              ( ['in'], BSTR, 'propname' ),
              ( ['in'], c_int, 'Code' ),
              ( ['in'], BSTR, 'Message' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'details' ),
              ( ['retval', 'out'], POINTER(_midlSAFEARRAY(c_ubyte)), 'ppReturnBytes' )),
]
################################################################
## code template for IExternalSerializerGdb implementation
##class IExternalSerializerGdb_Impl(object):
##    def WriteGeometry(self, propname, pGeom):
##        u'Writes geometry object.'
##        #return 
##
##    def WriteSpatialReference(self, propname, pSR):
##        u'Writes spatial reference object. Pass NULL as propname to write standalone JSON object.'
##        #return 
##
##    def WriteErrorObject(self, propname, Code, Message, details):
##        u'Writes error object.'
##        #return 
##
##    def WriteRow(self, propname, pRow, pFields, rowFieldIndexes, pGeomOpt):
##        u'Writes feature row object'
##        #return 
##
##    def GetErrorObject(self, propname, Code, Message, details):
##        u'Convenience method. Creates and returns error object as byte SAFEARRAY.'
##        #return ppReturnBytes
##
##    def WriteRecordSet(self, propname, pRecordset, pGeomOpt):
##        u'Writes feature recordset.'
##        #return 
##

INetworkCollection2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The count of valid format numbers.')], HRESULT, 'FormatNumberCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The specified format number.')], HRESULT, 'FormatNumber',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(c_int), 'formatNum' )),
    COMMETHOD([helpstring(u'Returns the maximum storable feature class ID for the given format number.')], HRESULT, 'GetMaxStorableClassID',
              ( ['in'], c_int, 'formatNum' ),
              ( ['retval', 'out'], POINTER(c_int), 'maxClassID' )),
    COMMETHOD([helpstring(u'Creates a new GeometricNetwork with a configuration keyword in this FeatureDataset.')], HRESULT, 'CreateGeometricNetworkEx',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], esriNetworkType, 'NetworkType' ),
              ( ['in'], VARIANT_BOOL, 'buildNormalizedTables' ),
              ( ['in'], BSTR, 'ConfigKeyword' ),
              ( ['in'], c_int, 'formatNum' ),
              ( ['retval', 'out'], POINTER(POINTER(IGeometricNetwork)), 'Network' )),
]
################################################################
## code template for INetworkCollection2 implementation
##class INetworkCollection2_Impl(object):
##    def CreateGeometricNetworkEx(self, Name, NetworkType, buildNormalizedTables, ConfigKeyword, formatNum):
##        u'Creates a new GeometricNetwork with a configuration keyword in this FeatureDataset.'
##        #return Network
##
##    @property
##    def FormatNumberCount(self):
##        u'The count of valid format numbers.'
##        #return Count
##
##    @property
##    def FormatNumber(self, Index):
##        u'The specified format number.'
##        #return formatNum
##
##    def GetMaxStorableClassID(self, formatNum):
##        u'Returns the maximum storable feature class ID for the given format number.'
##        #return maxClassID
##

class INetTopologyEdit(INetTopology):
    _case_insensitive_ = True
    u'Provides access to members that add and delete network elements from the logical network.'
    _iid_ = GUID('{2395087D-02D5-11D1-9CD5-00805F74D243}')
    _idlflags_ = []
INetTopologyEdit._methods_ = [
    COMMETHOD([helpstring(u'Adds a junction element to the logical network.')], HRESULT, 'AddJunction',
              ( ['in'], POINTER(INetElementDescription), 'junctionDescription' ),
              ( ['retval', 'out'], POINTER(c_int), 'junctionEID' )),
    COMMETHOD([helpstring(u'Adds an edge element to the logical network between the specified junction elements.')], HRESULT, 'AddEdgeByEndEIDs',
              ( ['in'], POINTER(INetElementDescription), 'edgeDescription' ),
              ( ['in'], c_int, 'FromJunctionEID' ),
              ( ['in'], c_int, 'ToJunctionEID' ),
              ( ['retval', 'out'], POINTER(c_int), 'edgeEID' )),
    COMMETHOD([helpstring(u'Deletes the specified network element from the logical network.')], HRESULT, 'DeleteByID',
              ( ['in'], c_int, 'UserClassID' ),
              ( ['in'], c_int, 'UserID' ),
              ( ['in'], c_int, 'UserSubID' ),
              ( ['in'], esriElementType, 'ElementType' )),
    COMMETHOD([helpstring(u'Deletes the specified network element from the logical network.')], HRESULT, 'DeleteByEID',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], esriElementType, 'ElementType' )),
    COMMETHOD(['hidden', helpstring(u'Deletes the specified network elements from the logical network.')], HRESULT, 'DeleteByEIDs',
              ( ['in'], esriElementType, 'ElementType' ),
              ( ['in'], c_int, 'ElementCount' ),
              ( ['in'], POINTER(c_int), 'elementEIDs' )),
]
################################################################
## code template for INetTopologyEdit implementation
##class INetTopologyEdit_Impl(object):
##    def DeleteByEIDs(self, ElementType, ElementCount, elementEIDs):
##        u'Deletes the specified network elements from the logical network.'
##        #return 
##
##    def DeleteByID(self, UserClassID, UserID, UserSubID, ElementType):
##        u'Deletes the specified network element from the logical network.'
##        #return 
##
##    def AddEdgeByEndEIDs(self, edgeDescription, FromJunctionEID, ToJunctionEID):
##        u'Adds an edge element to the logical network between the specified junction elements.'
##        #return edgeEID
##
##    def AddJunction(self, junctionDescription):
##        u'Adds a junction element to the logical network.'
##        #return junctionEID
##
##    def DeleteByEID(self, EID, ElementType):
##        u'Deletes the specified network element from the logical network.'
##        #return 
##


# values for enumeration 'esriDataConverterError'
S_DATACONVERTER_OK = 0
E_DATACONVERTER_OPENFEATURECLASSFAILED = 513
E_DATACONVERTER_OPENTABLEFAILED = 514
E_DATACONVERTER_OPENFEATUREDATASETFAILED = 515
E_DATACONVERTER_OPENFEATUREWORKSPACEFAILED = 516
E_DATACONVERTER_CREATEFEATURECLASSFAILED = 517
E_DATACONVERTER_CREATETABLEFAILED = 518
E_DATACONVERTER_WRITEFEATURESFAILED = 519
E_DATACONVERTER_WRITEROWSFAILED = 520
E_DATACONVERTER_UNLOADFAILED = 521
E_DATACONVERTER_OPENCURSORFAILED = 522
E_DATACONVERTER_OPENINSERTCURSORFAILED = 523
E_DATACONVERTER_INSERTCURSORFAILED = 524
E_DATACONVERTER_CANCELLED = 525
E_DATACONVERTER_MATCHINPUTFIELDSETFAILED = 526
E_DATACONVERTER_FLUSHINSERTCURSORFAILED = 527
E_DATACONVERTER_ACQUIRESCHEMALOCKFAILED = 528
E_DATACONVERTER_INVALID_INPUT_DATASET_NAME = 529
E_DATACONVERTER_CANNOT_CREATE_FEATURE_DATASET = 530
E_DATACONVERTER_ERROR_READ_ROWS = 531
E_DATACONVERTER_ERROR_READ_ALL_ROWS = 532
esriDataConverterError = c_int # enum
class IReplicaEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that modify information for a replica.'
    _iid_ = GUID('{891AC2B8-4744-454C-8E16-1C46C38FC0B4}')
    _idlflags_ = ['oleautomation']
IReplicaEdit._methods_ = [
    COMMETHOD(['propput', helpstring(u'The ID of the replica.')], HRESULT, 'ReplicaID',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The name of the replica.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The master geodatabase login used to create the replica.')], HRESULT, 'Owner',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The name of the replica version.')], HRESULT, 'Version',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The ID of the replica reference in the master geodatabase.')], HRESULT, 'ParentID',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The date that the data was checked out.')], HRESULT, 'ReplicaDate',
              ( ['in'], c_double, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The guid of the replica.')], HRESULT, 'ReplicaGuid',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The replica version description.')], HRESULT, 'Description',
              ( ['in'], POINTER(IReplicaDescription), 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The connection string for the master geodatabase.')], HRESULT, 'ConnectionInfo',
              ( ['in'], POINTER(IWorkspaceName), 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Determines if the workspace is the replica geodatabase or the master geodatabase for the replica.')], HRESULT, 'ReplicaRole',
              ( ['in'], esriReplicaType, 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The replica datasets for this replica.')], HRESULT, 'ReplicaDatasets',
              ( ['in'], POINTER(IEnumReplicaDataset), 'rhs' )),
    COMMETHOD([helpstring(u'Init the replica from other replica.')], HRESULT, 'Init',
              ( ['in'], POINTER(IReplica), 'otherReplica' )),
]
################################################################
## code template for IReplicaEdit implementation
##class IReplicaEdit_Impl(object):
##    def _set(self, rhs):
##        u'The guid of the replica.'
##    ReplicaGuid = property(fset = _set, doc = _set.__doc__)
##
##    def ReplicaDatasets(self, rhs):
##        u'The replica datasets for this replica.'
##        #return 
##
##    def ConnectionInfo(self, rhs):
##        u'The connection string for the master geodatabase.'
##        #return 
##
##    def _set(self, rhs):
##        u'The date that the data was checked out.'
##    ReplicaDate = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The name of the replica.'
##    Name = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Determines if the workspace is the replica geodatabase or the master geodatabase for the replica.'
##    ReplicaRole = property(fset = _set, doc = _set.__doc__)
##
##    def Init(self, otherReplica):
##        u'Init the replica from other replica.'
##        #return 
##
##    def _set(self, rhs):
##        u'The ID of the replica.'
##    ReplicaID = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The name of the replica version.'
##    Version = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The ID of the replica reference in the master geodatabase.'
##    ParentID = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The master geodatabase login used to create the replica.'
##    Owner = property(fset = _set, doc = _set.__doc__)
##
##    def Description(self, rhs):
##        u'The replica version description.'
##        #return 
##

class ITopologyGraph(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the topology graph.'
    _iid_ = GUID('{4ADC1017-3C78-434B-A32C-1817A42EB857}')
    _idlflags_ = ['oleautomation']
class IEnumTGHitInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that interate through topology elements.'
    _iid_ = GUID('{BA303A42-6AFF-42F8-B457-85A689B051CA}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriTopologySelectionResultEnum'
esriTopologySelectionResultNew = 0
esriTopologySelectionResultAdd = 1
esriTopologySelectionResultSubtract = 2
esriTopologySelectionResultXOR = 3
esriTopologySelectionResultEnum = c_int # enum
class IEnumTopologyNode(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a set of topology nodes.'
    _iid_ = GUID('{0FCBD3ED-D810-40D3-92B1-1A7B451F0F4C}')
    _idlflags_ = ['oleautomation']
ITopologyGraph._methods_ = [
    COMMETHOD([helpstring(u'Removes all topological elements from the graph. Any client-side references to topo elements that came from this graph should be released.')], HRESULT, 'SetEmpty'),
    COMMETHOD([helpstring(u'Clears the specified selection set: whichType is a bitwise combination of esriTopologyNode, esriTopologyEdge.')], HRESULT, 'SetSelectionEmpty',
              ( [], c_int, 'whichType' )),
    COMMETHOD([helpstring(u'Creates topo elements from all topology feature classes covering the specified map extent.')], HRESULT, 'Build',
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'Extent' ),
              ( [], VARIANT_BOOL, 'preserveSelection' )),
    COMMETHOD(['propget', helpstring(u'The current extent of all topological elements in the graph. This may be different than the extent used to build the graph.')], HRESULT, 'Extent',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'Extent' )),
    COMMETHOD(['propget', helpstring(u'The extent used to build the graph.')], HRESULT, 'BuildExtent',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'Extent' )),
    COMMETHOD([helpstring(u'Locates an element of the graph nearest to the query point that is also within searchRadius units of it; whichElements is a bitwise combination of esriTopologyElement values.')], HRESULT, 'HitTest',
              ( ['in'], c_int, 'whichElements' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'QueryPoint' ),
              ( ['in'], c_double, 'searchRadius' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'hitPoint' ),
              ( ['out'], POINTER(c_double), 'hitDistance' ),
              ( ['out'], POINTER(POINTER(ITopologyElement)), 'hitElement' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'hit' )),
    COMMETHOD([helpstring(u'Locates all elements of the graph within searchRadius units of the query point; whichElements is a bitwise combination of esriTopologyElement values.')], HRESULT, 'EnumHitTest',
              ( [], c_int, 'whichElements' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'QueryPoint' ),
              ( [], c_double, 'searchRadius' ),
              ( ['out'], POINTER(POINTER(IEnumTGHitInfo)), 'hitInfo' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'hit' )),
    COMMETHOD(['propget', helpstring(u'The count of selected elements of the specified types; whichElements is a bitwise combination of esriTopologyElement values.')], HRESULT, 'SelectionCount',
              ( [], c_int, 'whichElements' ),
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD([helpstring(u'Adds the specified element to the selected subset of the graph.')], HRESULT, 'Select',
              ( [], esriTopologySelectionResultEnum, 'selectHow' ),
              ( [], POINTER(ITopologyElement), 'Element' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'SelectionChanged' )),
    COMMETHOD(['propget', helpstring(u'The enumerator for the selected nodes of the topology.')], HRESULT, 'NodeSelection',
              ( ['retval', 'out'], POINTER(POINTER(IEnumTopologyNode)), 'nodeEnumerator' )),
    COMMETHOD(['propget', helpstring(u'The enumerator for the selected edges of the topology.')], HRESULT, 'EdgeSelection',
              ( ['retval', 'out'], POINTER(POINTER(IEnumTopologyEdge)), 'edgeEnumerator' )),
    COMMETHOD(['propget', helpstring(u'The extent of the selected subset of the graph, optionally includes extent of all edges incident on selected nodes (or on nodes incident on selected edges); whichElements is a bitwise combination of esriTopologyElement values.')], HRESULT, 'SelectionExtent',
              ( [], c_int, 'whichElements' ),
              ( [], VARIANT_BOOL, 'includeAdjacent' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'Extent' )),
    COMMETHOD([helpstring(u'Applies the specified transformation to the selected elements of the graph.')], HRESULT, 'TransformSelection',
              ( [], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriTransformDirection, 'Direction' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ITransformation), 'transformation' ),
              ( [], VARIANT_BOOL, 'proportionalStretch' )),
    COMMETHOD([helpstring(u'Posts changes to topology elements back to their originating features. Must be used within an edit session and edit operation.')], HRESULT, 'Post',
              ( ['out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'InvalidArea' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the topology graph is posting.')], HRESULT, 'IsPosting',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'posting' )),
    COMMETHOD([helpstring(u'Reshapes (and possibly reinterpolates) the geometry of the specified edge.')], HRESULT, 'ReshapeEdgeGeometry',
              ( [], POINTER(ITopologyEdge), 'Edge' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPath), 'reshapeGeometry' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'reshaped' )),
    COMMETHOD(['propget', helpstring(u'The feature class and oid of each parent of the selected set of elements.')], HRESULT, 'SelectionParents',
              ( ['retval', 'out'], POINTER(POINTER(IEnumTopologyParent)), 'enumParents' )),
    COMMETHOD([helpstring(u'Selects parents of edges. SUbsequent edits to those edges will only be posted back to selected parents.')], HRESULT, 'SetParentSelected',
              ( [], POINTER(IFeatureClass), 'FeatureClass' ),
              ( [], c_int, 'fID' ),
              ( [], VARIANT_BOOL, 'selected' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'edgeSelectionChanged' )),
    COMMETHOD([helpstring(u'Creates a geometry corresponding to the current set of edges/nodes owned by the specified parent.')], HRESULT, 'GetParentGeometry',
              ( [], POINTER(IFeatureClass), 'FeatureClass' ),
              ( [], c_int, 'fID' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'theParentGeometry' )),
    COMMETHOD([helpstring(u'Creates a display feedback object to indicate the effect of a TransformSelection operation on the selected elements; whichElements is a bitwise combination of esriTopologyElement values.')], HRESULT, 'GetSelectionFeedback',
              ( [], c_int, 'whichElements' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'anchor' ),
              ( [], VARIANT_BOOL, 'proportionalStretch' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IDisplayFeedback)), 'selFeedback' )),
    COMMETHOD([helpstring(u'Change graph connectivity: Moves the specified node, along with any selected edges incident on it. A copy of the node, along with unselected edges, remains in the original location.')], HRESULT, 'SplitMoveNode',
              ( [], POINTER(ITopologyNode), 'nodeToSplit' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'moveTo' ),
              ( [], VARIANT_BOOL, 'proportionalStretch' )),
    COMMETHOD([helpstring(u'Creates a display feedback object to indicate the effect of a SplitMoveNode operation on the specified node.')], HRESULT, 'GetSplitMoveNodeFeedback',
              ( [], POINTER(ITopologyNode), 'nodeToSplit' ),
              ( [], VARIANT_BOOL, 'proportionalStretch' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'outputSR' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IDisplayFeedback)), 'feedback' )),
    COMMETHOD([helpstring(u'Adds a pseudo-node to the edge at the point on the edge closest to the input point. The node gets created at an existing vertex if one is located within the specified tolerance of the split point.')], HRESULT, 'SplitEdgeAtPoint',
              ( [], POINTER(ITopologyEdge), 'Edge' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'splitPoint' ),
              ( [], c_double, 'tolerance' ),
              ( ['out'], POINTER(POINTER(ITopologyEdge)), 'from' ),
              ( ['out'], POINTER(POINTER(ITopologyNode)), 'mid' ),
              ( ['out'], POINTER(POINTER(ITopologyEdge)), 'to' )),
    COMMETHOD([helpstring(u'Adds a pseudo-node to the edge at the specified distance along the edge. The node gets created at an existing vertex if one is located within the specified tolerance.')], HRESULT, 'SplitEdgeAtDistance',
              ( [], POINTER(ITopologyEdge), 'Edge' ),
              ( [], c_double, 'Distance' ),
              ( [], VARIANT_BOOL, 'asRatio' ),
              ( [], c_double, 'tolerance' ),
              ( ['out'], POINTER(POINTER(ITopologyEdge)), 'from' ),
              ( ['out'], POINTER(POINTER(ITopologyNode)), 'mid' ),
              ( ['out'], POINTER(POINTER(ITopologyEdge)), 'to' )),
    COMMETHOD([helpstring(u'Assigns the path geometry to the specified edge. Reinterpolatex vertex attributes for the edge if any exist.')], HRESULT, 'SetEdgeGeometry',
              ( [], POINTER(ITopologyEdge), 'Edge' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPath), 'Geometry' )),
    COMMETHOD([helpstring(u'Removes pseudo-nodes by combining edges incident on such nodes. Edges and nodes in the current selection are considered.')], HRESULT, 'DeletePseudoNodesFromSelection'),
    COMMETHOD([helpstring(u'Deletes the specified edge from its containing topology graph.')], HRESULT, 'DeleteEdge',
              ( [], POINTER(ITopologyEdge), 'Edge' )),
    COMMETHOD([helpstring(u'Selects nodes and/or edges that intersect the specified geometry; whichElements is a bitwise combination of esriTopologyElement values.')], HRESULT, 'SelectByGeometry',
              ( [], c_int, 'whichElements' ),
              ( [], esriTopologySelectionResultEnum, 'selectHow' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'Geometry' )),
    COMMETHOD([helpstring(u'Returns the set of nodes corresponding to the specified point or multipoint feature.')], HRESULT, 'GetParentNodes',
              ( [], POINTER(IFeatureClass), 'FeatureClass' ),
              ( [], c_int, 'fID' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumTopologyNode)), 'enumNode' )),
    COMMETHOD([helpstring(u'Returns the set of edges corresponding to the specified polyline or polygon feature.')], HRESULT, 'GetParentEdges',
              ( [], POINTER(IFeatureClass), 'FeatureClass' ),
              ( [], c_int, 'fID' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumTopologyEdge)), 'enumEdge' )),
    COMMETHOD(['propget', helpstring(u'The enumerator that provides access to all the edges.')], HRESULT, 'Edges',
              ( ['retval', 'out'], POINTER(POINTER(IEnumTopologyEdge)), 'edgeEnumerator' )),
    COMMETHOD(['propget', helpstring(u'The enumerator that provides access to all the nodes.')], HRESULT, 'Nodes',
              ( ['retval', 'out'], POINTER(POINTER(IEnumTopologyNode)), 'nodeEnumerator' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the topology graph contains the specified element.')], HRESULT, 'HasElement',
              ( [], POINTER(ITopologyElement), 'Element' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasElement' )),
    COMMETHOD([helpstring(u"Locates an element of the graph's selection nearest to the query point that is also within searchRadius units of it; whichElements is a bitwise combination of esriTopologyElement values.")], HRESULT, 'HitTestSelection',
              ( ['in'], c_int, 'whichElements' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'QueryPoint' ),
              ( ['in'], c_double, 'searchRadius' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'hitPoint' ),
              ( ['out'], POINTER(c_double), 'hitDistance' ),
              ( ['out'], POINTER(POINTER(ITopologyElement)), 'hitElement' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'hit' )),
]
################################################################
## code template for ITopologyGraph implementation
##class ITopologyGraph_Impl(object):
##    def SelectByGeometry(self, whichElements, selectHow, Geometry):
##        u'Selects nodes and/or edges that intersect the specified geometry; whichElements is a bitwise combination of esriTopologyElement values.'
##        #return 
##
##    def DeleteEdge(self, Edge):
##        u'Deletes the specified edge from its containing topology graph.'
##        #return 
##
##    @property
##    def EdgeSelection(self):
##        u'The enumerator for the selected edges of the topology.'
##        #return edgeEnumerator
##
##    @property
##    def SelectionParents(self):
##        u'The feature class and oid of each parent of the selected set of elements.'
##        #return enumParents
##
##    def HitTest(self, whichElements, QueryPoint, searchRadius, hitPoint):
##        u'Locates an element of the graph nearest to the query point that is also within searchRadius units of it; whichElements is a bitwise combination of esriTopologyElement values.'
##        #return hitDistance, hitElement, hit
##
##    def TransformSelection(self, Direction, transformation, proportionalStretch):
##        u'Applies the specified transformation to the selected elements of the graph.'
##        #return 
##
##    def Build(self, Extent, preserveSelection):
##        u'Creates topo elements from all topology feature classes covering the specified map extent.'
##        #return 
##
##    @property
##    def Edges(self):
##        u'The enumerator that provides access to all the edges.'
##        #return edgeEnumerator
##
##    def SplitEdgeAtPoint(self, Edge, splitPoint, tolerance):
##        u'Adds a pseudo-node to the edge at the point on the edge closest to the input point. The node gets created at an existing vertex if one is located within the specified tolerance of the split point.'
##        #return from, mid, to
##
##    def DeletePseudoNodesFromSelection(self):
##        u'Removes pseudo-nodes by combining edges incident on such nodes. Edges and nodes in the current selection are considered.'
##        #return 
##
##    def SplitEdgeAtDistance(self, Edge, Distance, asRatio, tolerance):
##        u'Adds a pseudo-node to the edge at the specified distance along the edge. The node gets created at an existing vertex if one is located within the specified tolerance.'
##        #return from, mid, to
##
##    def GetSelectionFeedback(self, whichElements, anchor, proportionalStretch):
##        u'Creates a display feedback object to indicate the effect of a TransformSelection operation on the selected elements; whichElements is a bitwise combination of esriTopologyElement values.'
##        #return selFeedback
##
##    @property
##    def BuildExtent(self):
##        u'The extent used to build the graph.'
##        #return Extent
##
##    def GetParentNodes(self, FeatureClass, fID):
##        u'Returns the set of nodes corresponding to the specified point or multipoint feature.'
##        #return enumNode
##
##    @property
##    def SelectionCount(self, whichElements):
##        u'The count of selected elements of the specified types; whichElements is a bitwise combination of esriTopologyElement values.'
##        #return Count
##
##    @property
##    def HasElement(self, Element):
##        u'Indicates if the topology graph contains the specified element.'
##        #return HasElement
##
##    def SetEmpty(self):
##        u'Removes all topological elements from the graph. Any client-side references to topo elements that came from this graph should be released.'
##        #return 
##
##    @property
##    def Extent(self):
##        u'The current extent of all topological elements in the graph. This may be different than the extent used to build the graph.'
##        #return Extent
##
##    def Post(self):
##        u'Posts changes to topology elements back to their originating features. Must be used within an edit session and edit operation.'
##        #return InvalidArea
##
##    def EnumHitTest(self, whichElements, QueryPoint, searchRadius):
##        u'Locates all elements of the graph within searchRadius units of the query point; whichElements is a bitwise combination of esriTopologyElement values.'
##        #return hitInfo, hit
##
##    def SetSelectionEmpty(self, whichType):
##        u'Clears the specified selection set: whichType is a bitwise combination of esriTopologyNode, esriTopologyEdge.'
##        #return 
##
##    def SetEdgeGeometry(self, Edge, Geometry):
##        u'Assigns the path geometry to the specified edge. Reinterpolatex vertex attributes for the edge if any exist.'
##        #return 
##
##    def ReshapeEdgeGeometry(self, Edge, reshapeGeometry):
##        u'Reshapes (and possibly reinterpolates) the geometry of the specified edge.'
##        #return reshaped
##
##    def SetParentSelected(self, FeatureClass, fID, selected):
##        u'Selects parents of edges. SUbsequent edits to those edges will only be posted back to selected parents.'
##        #return edgeSelectionChanged
##
##    def HitTestSelection(self, whichElements, QueryPoint, searchRadius, hitPoint):
##        u"Locates an element of the graph's selection nearest to the query point that is also within searchRadius units of it; whichElements is a bitwise combination of esriTopologyElement values."
##        #return hitDistance, hitElement, hit
##
##    def SplitMoveNode(self, nodeToSplit, moveTo, proportionalStretch):
##        u'Change graph connectivity: Moves the specified node, along with any selected edges incident on it. A copy of the node, along with unselected edges, remains in the original location.'
##        #return 
##
##    @property
##    def IsPosting(self):
##        u'Indicates if the topology graph is posting.'
##        #return posting
##
##    def GetParentEdges(self, FeatureClass, fID):
##        u'Returns the set of edges corresponding to the specified polyline or polygon feature.'
##        #return enumEdge
##
##    @property
##    def NodeSelection(self):
##        u'The enumerator for the selected nodes of the topology.'
##        #return nodeEnumerator
##
##    def GetParentGeometry(self, FeatureClass, fID):
##        u'Creates a geometry corresponding to the current set of edges/nodes owned by the specified parent.'
##        #return theParentGeometry
##
##    @property
##    def Nodes(self):
##        u'The enumerator that provides access to all the nodes.'
##        #return nodeEnumerator
##
##    @property
##    def SelectionExtent(self, whichElements, includeAdjacent):
##        u'The extent of the selected subset of the graph, optionally includes extent of all edges incident on selected nodes (or on nodes incident on selected edges); whichElements is a bitwise combination of esriTopologyElement values.'
##        #return Extent
##
##    def GetSplitMoveNodeFeedback(self, nodeToSplit, proportionalStretch, outputSR):
##        u'Creates a display feedback object to indicate the effect of a SplitMoveNode operation on the specified node.'
##        #return feedback
##
##    def Select(self, selectHow, Element):
##        u'Adds the specified element to the selected subset of the graph.'
##        #return SelectionChanged
##

class IAttachment(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members of an attachment.'
    _iid_ = GUID('{475E3D30-5478-46C2-9547-09AA7076DCE6}')
    _idlflags_ = ['oleautomation']
class IAttachment2(IAttachment):
    _case_insensitive_ = True
    u'Provides access to members of an attachment.'
    _iid_ = GUID('{475E3D30-5478-46C2-9547-09AA7076D787}')
    _idlflags_ = ['oleautomation']
IAttachment._methods_ = [
    COMMETHOD(['propget', helpstring(u'ID that uniquely identifies the attachment.')], HRESULT, 'AttachmentID',
              ( ['retval', 'out'], POINTER(c_int), 'attID' )),
    COMMETHOD(['propget', helpstring(u'Global ID that uniquely identifies the attachment.')], HRESULT, 'GlobalID',
              ( ['retval', 'out'], POINTER(BSTR), 'GlobalID' )),
    COMMETHOD(['propget', helpstring(u'Parent ID to which the attachment belongs.')], HRESULT, 'ParentID',
              ( ['retval', 'out'], POINTER(c_int), 'OID' )),
    COMMETHOD(['propput', helpstring(u'Name of the attachment.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'Name of the attachment.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'Content type that describes the attachment data.')], HRESULT, 'ContentType',
              ( ['in'], BSTR, 'ContentType' )),
    COMMETHOD(['propget', helpstring(u'Content type that describes the attachment data.')], HRESULT, 'ContentType',
              ( ['retval', 'out'], POINTER(BSTR), 'ContentType' )),
    COMMETHOD(['propget', helpstring(u'Size of the attachment data in bytes.')], HRESULT, 'Size',
              ( ['retval', 'out'], POINTER(c_int), 'Size' )),
    COMMETHOD(['propputref', helpstring(u'Attachment data.')], HRESULT, 'Data',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IMemoryBlobStream), 'Data' )),
    COMMETHOD(['propget', helpstring(u'Attachment data.')], HRESULT, 'Data',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IMemoryBlobStream)), 'Data' )),
]
################################################################
## code template for IAttachment implementation
##class IAttachment_Impl(object):
##    def _get(self):
##        u'Content type that describes the attachment data.'
##        #return ContentType
##    def _set(self, ContentType):
##        u'Content type that describes the attachment data.'
##    ContentType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Name of the attachment.'
##        #return Name
##    def _set(self, Name):
##        u'Name of the attachment.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def GlobalID(self):
##        u'Global ID that uniquely identifies the attachment.'
##        #return GlobalID
##
##    @property
##    def AttachmentID(self):
##        u'ID that uniquely identifies the attachment.'
##        #return attID
##
##    @property
##    def ParentID(self):
##        u'Parent ID to which the attachment belongs.'
##        #return OID
##
##    @property
##    def Data(self, Data):
##        u'Attachment data.'
##        #return 
##
##    @property
##    def Size(self):
##        u'Size of the attachment data in bytes.'
##        #return Size
##

IAttachment2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Parent global ID to which the attachment belongs.')], HRESULT, 'ParentGlobalID',
              ( ['retval', 'out'], POINTER(BSTR), 'ParentGlobalID' )),
]
################################################################
## code template for IAttachment2 implementation
##class IAttachment2_Impl(object):
##    @property
##    def ParentGlobalID(self):
##        u'Parent global ID to which the attachment belongs.'
##        #return ParentGlobalID
##

class INetworkForwardStarEx(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the configuration for this NetworkForwardStar object and query information about adjacent elements in the network dataset.'
    _iid_ = GUID('{25C310EB-BFF3-4A47-A694-3F17E16FBFDA}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriNetworkAttributeAdjustmentType'
esriNAATScale = 0
esriNAATAdd = 1
esriNAATReplace = 2
esriNetworkAttributeAdjustmentType = c_int # enum
INetworkForwardStarEx._methods_ = [
    COMMETHOD([helpstring(u'Finds all network elements that are adjacent to the given sequence of network elements.')], HRESULT, 'QueryAdjacencies',
              ( ['in'], POINTER(INetworkJunction), 'atJunction' ),
              ( ['in'], POINTER(INetworkEdge), 'fromEdge' ),
              ( ['in'], POINTER(INetworkEdge), 'lastExteriorEdge' ),
              ( ['in'], POINTER(INetworkForwardStarAdjacencies), 'adjacencies' )),
    COMMETHOD([helpstring(u'Performs a network junction element query by element ID and populates the given junction element object.')], HRESULT, 'QueryJunction',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], POINTER(INetworkJunction), 'Junction' )),
    COMMETHOD([helpstring(u'Performs a network edge element query by element ID and edge direction and populates the given edge element object.')], HRESULT, 'QueryEdge',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], esriNetworkEdgeDirection, 'Direction' ),
              ( ['in'], POINTER(INetworkEdge), 'Edge' )),
    COMMETHOD([helpstring(u'Performs a network turn element query by element ID and populates the given turn element object.')], HRESULT, 'QueryTurn',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], POINTER(INetworkTurn), 'Turn' )),
    COMMETHOD([helpstring(u'Returns the range of accessible positions from a query position along an edge element, respective to any existing restrictions along the edge.')], HRESULT, 'QueryTraversableRange',
              ( ['in'], POINTER(INetworkEdge), 'Edge' ),
              ( ['in'], c_double, 'queryPosition' ),
              ( ['out'], POINTER(c_double), 'fromPosition' ),
              ( ['out'], POINTER(c_double), 'toPosition' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'isFromPositionAccessible' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'isToPositionAccessible' )),
    COMMETHOD([helpstring(u'Returns the range of accessible positions within a specified attribute cutoff from a query position along an edge element, respective to any existing attribute adjustments along the edge.')], HRESULT, 'QueryAttributeCutoffRange',
              ( ['in'], POINTER(INetworkEdge), 'Edge' ),
              ( ['in'], POINTER(INetworkAttribute), 'Attribute' ),
              ( ['in'], c_double, 'queryPosition' ),
              ( ['in'], VARIANT, 'cutoffValue' ),
              ( ['out'], POINTER(c_double), 'fromPosition' ),
              ( ['out'], POINTER(c_double), 'toPosition' )),
    COMMETHOD(['propget', helpstring(u'Network dataset on which the NetworkForwardStar object is querying.')], HRESULT, 'NetworkDataset',
              ( ['retval', 'out'], POINTER(POINTER(INetworkDataset)), 'Network' )),
    COMMETHOD(['propget', helpstring(u'Policy on when to return the from-edge in the NetworkForwardStarAdjacencies object.')], HRESULT, 'BacktrackPolicy',
              ( ['retval', 'out'], POINTER(esriNetworkForwardStarBacktrack), 'Backtrack' )),
    COMMETHOD(['propput', helpstring(u'Policy on when to return the from-edge in the NetworkForwardStarAdjacencies object.')], HRESULT, 'BacktrackPolicy',
              ( ['in'], esriNetworkForwardStarBacktrack, 'Backtrack' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the NetworkForwardStar object is used to model forward traversal through the network dataset.')], HRESULT, 'IsForwardTraversal',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsForwardTraversal' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the NetworkForwardStar object is used to model forward traversal through the network dataset.')], HRESULT, 'IsForwardTraversal',
              ( ['in'], VARIANT_BOOL, 'IsForwardTraversal' )),
    COMMETHOD([helpstring(u'Adds a restriction network attribute to the NetworkForwardStar object to filter elements from adjacency queries.')], HRESULT, 'AddRestrictionAttribute',
              ( ['in'], POINTER(INetworkAttribute), 'Attribute' )),
    COMMETHOD(['propget', helpstring(u'Restriction network attribute by index in the NetworkForwardStar object.')], HRESULT, 'RestrictionAttribute',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(INetworkAttribute)), 'Attribute' )),
    COMMETHOD(['propget', helpstring(u'Number of restriction network attributes currently applied to the NetworkForwardStar object.')], HRESULT, 'RestrictionAttributeCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD([helpstring(u'Removes all restriction network attributes currently applied to the NetworkForwardStar object.')], HRESULT, 'RemoveRestrictionAttributes'),
    COMMETHOD(['propget', helpstring(u'Network attribute containing the hierarchy values for each network element.')], HRESULT, 'HierarchyAttribute',
              ( ['retval', 'out'], POINTER(POINTER(INetworkAttribute)), 'Attribute' )),
    COMMETHOD(['propputref', helpstring(u'Network attribute containing the hierarchy values for each network element.')], HRESULT, 'HierarchyAttribute',
              ( ['in'], POINTER(INetworkAttribute), 'Attribute' )),
    COMMETHOD(['propget', helpstring(u'Maximum hierarchy attribute value for elements permitted to be returned in the adjacency queries.')], HRESULT, 'MaxTraversableHierarchyValue',
              ( ['retval', 'out'], POINTER(c_int), 'MaxValue' )),
    COMMETHOD(['propput', helpstring(u'Maximum hierarchy attribute value for elements permitted to be returned in the adjacency queries.')], HRESULT, 'MaxTraversableHierarchyValue',
              ( ['in'], c_int, 'MaxValue' )),
    COMMETHOD([helpstring(u'Restricts a junction element from being returned in the adjacency queries.')], HRESULT, 'AddJunctionRestriction',
              ( ['in'], POINTER(INetworkJunction), 'Junction' )),
    COMMETHOD([helpstring(u'Restricts the traversability of a range on an edge element in the adjacency queries.')], HRESULT, 'AddEdgeRestriction',
              ( ['in'], POINTER(INetworkEdge), 'Edge' ),
              ( ['in'], c_double, 'fromPosition' ),
              ( ['in'], c_double, 'toPosition' )),
    COMMETHOD([helpstring(u'Restricts a turn in the adjacency queries.')], HRESULT, 'AddTurnRestriction',
              ( ['in'], POINTER(INetworkTurn), 'Turn' )),
    COMMETHOD([helpstring(u'Removes all element-specific restrictions currently applied to the NetworkForwardStar object.')], HRESULT, 'RemoveElementRestrictions'),
    COMMETHOD([helpstring(u'Adjusts the value of a network attribute for a junction element.')], HRESULT, 'AdjustJunctionAttributeValue',
              ( ['in'], POINTER(INetworkJunction), 'Junction' ),
              ( ['in'], POINTER(INetworkAttribute), 'Attribute' ),
              ( ['in'], esriNetworkAttributeAdjustmentType, 'adjustmentType' ),
              ( ['in'], VARIANT, 'Value' )),
    COMMETHOD([helpstring(u'Adjusts the value of a network attribute for a range on an edge element.')], HRESULT, 'AdjustEdgeAttributeValue',
              ( ['in'], POINTER(INetworkEdge), 'Edge' ),
              ( ['in'], c_double, 'fromPosition' ),
              ( ['in'], c_double, 'toPosition' ),
              ( ['in'], POINTER(INetworkAttribute), 'Attribute' ),
              ( ['in'], esriNetworkAttributeAdjustmentType, 'adjustmentType' ),
              ( ['in'], VARIANT, 'Value' )),
    COMMETHOD([helpstring(u'Adjusts the value of a network attribute for a turn element.')], HRESULT, 'AdjustTurnAttributeValue',
              ( ['in'], POINTER(INetworkTurn), 'Turn' ),
              ( ['in'], POINTER(INetworkAttribute), 'Attribute' ),
              ( ['in'], esriNetworkAttributeAdjustmentType, 'adjustmentType' ),
              ( ['in'], VARIANT, 'Value' )),
    COMMETHOD([helpstring(u'Removes all element-specific attribute value adjustments currently applied to the NetworkForwardStar object.')], HRESULT, 'RemoveAttributeValueAdjustments'),
    COMMETHOD(['propget', helpstring(u'Indicates if the given network element is restricted from traversal in the NetworkForwardStar object.')], HRESULT, 'IsRestricted',
              ( ['in'], POINTER(INetworkElement), 'Element' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsRestricted' )),
]
################################################################
## code template for INetworkForwardStarEx implementation
##class INetworkForwardStarEx_Impl(object):
##    def QueryTurn(self, EID, Turn):
##        u'Performs a network turn element query by element ID and populates the given turn element object.'
##        #return 
##
##    def AddTurnRestriction(self, Turn):
##        u'Restricts a turn in the adjacency queries.'
##        #return 
##
##    def AddEdgeRestriction(self, Edge, fromPosition, toPosition):
##        u'Restricts the traversability of a range on an edge element in the adjacency queries.'
##        #return 
##
##    def RemoveAttributeValueAdjustments(self):
##        u'Removes all element-specific attribute value adjustments currently applied to the NetworkForwardStar object.'
##        #return 
##
##    def QueryTraversableRange(self, Edge, queryPosition):
##        u'Returns the range of accessible positions from a query position along an edge element, respective to any existing restrictions along the edge.'
##        #return fromPosition, toPosition, isFromPositionAccessible, isToPositionAccessible
##
##    @property
##    def RestrictionAttribute(self, Index):
##        u'Restriction network attribute by index in the NetworkForwardStar object.'
##        #return Attribute
##
##    def _get(self):
##        u'Maximum hierarchy attribute value for elements permitted to be returned in the adjacency queries.'
##        #return MaxValue
##    def _set(self, MaxValue):
##        u'Maximum hierarchy attribute value for elements permitted to be returned in the adjacency queries.'
##    MaxTraversableHierarchyValue = property(_get, _set, doc = _set.__doc__)
##
##    def RemoveElementRestrictions(self):
##        u'Removes all element-specific restrictions currently applied to the NetworkForwardStar object.'
##        #return 
##
##    def QueryAdjacencies(self, atJunction, fromEdge, lastExteriorEdge, adjacencies):
##        u'Finds all network elements that are adjacent to the given sequence of network elements.'
##        #return 
##
##    def _get(self):
##        u'Policy on when to return the from-edge in the NetworkForwardStarAdjacencies object.'
##        #return Backtrack
##    def _set(self, Backtrack):
##        u'Policy on when to return the from-edge in the NetworkForwardStarAdjacencies object.'
##    BacktrackPolicy = property(_get, _set, doc = _set.__doc__)
##
##    def QueryAttributeCutoffRange(self, Edge, Attribute, queryPosition, cutoffValue):
##        u'Returns the range of accessible positions within a specified attribute cutoff from a query position along an edge element, respective to any existing attribute adjustments along the edge.'
##        #return fromPosition, toPosition
##
##    def AddJunctionRestriction(self, Junction):
##        u'Restricts a junction element from being returned in the adjacency queries.'
##        #return 
##
##    @property
##    def IsRestricted(self, Element):
##        u'Indicates if the given network element is restricted from traversal in the NetworkForwardStar object.'
##        #return IsRestricted
##
##    def _get(self):
##        u'Indicates if the NetworkForwardStar object is used to model forward traversal through the network dataset.'
##        #return IsForwardTraversal
##    def _set(self, IsForwardTraversal):
##        u'Indicates if the NetworkForwardStar object is used to model forward traversal through the network dataset.'
##    IsForwardTraversal = property(_get, _set, doc = _set.__doc__)
##
##    def AdjustTurnAttributeValue(self, Turn, Attribute, adjustmentType, Value):
##        u'Adjusts the value of a network attribute for a turn element.'
##        #return 
##
##    def HierarchyAttribute(self, Attribute):
##        u'Network attribute containing the hierarchy values for each network element.'
##        #return 
##
##    def AddRestrictionAttribute(self, Attribute):
##        u'Adds a restriction network attribute to the NetworkForwardStar object to filter elements from adjacency queries.'
##        #return 
##
##    def QueryEdge(self, EID, Direction, Edge):
##        u'Performs a network edge element query by element ID and edge direction and populates the given edge element object.'
##        #return 
##
##    @property
##    def RestrictionAttributeCount(self):
##        u'Number of restriction network attributes currently applied to the NetworkForwardStar object.'
##        #return Count
##
##    @property
##    def NetworkDataset(self):
##        u'Network dataset on which the NetworkForwardStar object is querying.'
##        #return Network
##
##    def AdjustEdgeAttributeValue(self, Edge, fromPosition, toPosition, Attribute, adjustmentType, Value):
##        u'Adjusts the value of a network attribute for a range on an edge element.'
##        #return 
##
##    def RemoveRestrictionAttributes(self):
##        u'Removes all restriction network attributes currently applied to the NetworkForwardStar object.'
##        #return 
##
##    def QueryJunction(self, EID, Junction):
##        u'Performs a network junction element query by element ID and populates the given junction element object.'
##        #return 
##
##    def AdjustJunctionAttributeValue(self, Junction, Attribute, adjustmentType, Value):
##        u'Adjusts the value of a network attribute for a junction element.'
##        #return 
##

class IEnumAttachment(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members of an attachment enumeration.'
    _iid_ = GUID('{034AA24A-5FC6-476F-8CA2-8374733D71C5}')
    _idlflags_ = ['oleautomation']
IEnumAttachment._methods_ = [
    COMMETHOD([], HRESULT, 'Reset'),
    COMMETHOD([], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IAttachment)), 'att' )),
]
################################################################
## code template for IEnumAttachment implementation
##class IEnumAttachment_Impl(object):
##    def Reset(self):
##        '-no docstring-'
##        #return 
##
##    def Next(self):
##        '-no docstring-'
##        #return att
##

class DERepresentationClass(CoClass):
    u'Representation Class Data Element object.'
    _reg_clsid_ = GUID('{ABA829A6-9C55-41EE-8C15-2DAA3821D565}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDERepresentationClass(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about representation class data elements.'
    _iid_ = GUID('{4494C7C5-4F45-4970-A4FD-8E611508B8AC}')
    _idlflags_ = ['oleautomation']
DERepresentationClass._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDERepresentationClass, IDEDataset, IDataElement, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDocumentVersionSupportGEN]

ITinPolyline._methods_ = [
    COMMETHOD([helpstring(u'The specified polyline as TIN nodes.')], HRESULT, 'AsNodes',
              ( ['retval', 'out'], POINTER(POINTER(IEnumTinNode)), 'ppNodes' )),
    COMMETHOD([helpstring(u'The specified polyline as triangle edges.')], HRESULT, 'AsEdges',
              ( ['retval', 'out'], POINTER(POINTER(IEnumTinEdge)), 'ppEdges' )),
    COMMETHOD([helpstring(u'The specified polyline as polyline geometry.')], HRESULT, 'AsPolyline',
              ( ['in'], POINTER(ITinFilter), 'pNodeFilter' ),
              ( ['in'], VARIANT_BOOL, 'bGetZ' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolyline)), 'ppPolyline' )),
]
################################################################
## code template for ITinPolyline implementation
##class ITinPolyline_Impl(object):
##    def AsNodes(self):
##        u'The specified polyline as TIN nodes.'
##        #return ppNodes
##
##    def AsEdges(self):
##        u'The specified polyline as triangle edges.'
##        #return ppEdges
##
##    def AsPolyline(self, pNodeFilter, bGetZ):
##        u'The specified polyline as polyline geometry.'
##        #return ppPolyline
##

class ITinEdgeArray(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control simple arrays of TIN edges.'
    _iid_ = GUID('{C0E04941-B08C-11D2-9F6A-00C04F8ECE27}')
    _idlflags_ = ['oleautomation']
ITinNode._methods_ = [
    COMMETHOD(['propget', helpstring(u'The x-coordinate of the specified node.')], HRESULT, 'X',
              ( ['retval', 'out'], POINTER(c_double), 'X' )),
    COMMETHOD(['propget', helpstring(u'The y-coordinate of the specified node.')], HRESULT, 'Y',
              ( ['retval', 'out'], POINTER(c_double), 'Y' )),
    COMMETHOD(['propget', helpstring(u'The z-coordinate of the specified node.')], HRESULT, 'Z',
              ( ['retval', 'out'], POINTER(c_double), 'Z' )),
    COMMETHOD([helpstring(u'Sets the node equal to a point.')], HRESULT, 'QueryAsPoint',
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' )),
    COMMETHOD([helpstring(u'Sets the node equal to a point with a z value.')], HRESULT, 'QueryAsWKSPointZ',
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPoint' )),
    COMMETHOD([helpstring(u'Returns all nodes comprising triangles sharing the specified node.')], HRESULT, 'GetAdjacentNodes',
              ( ['retval', 'out'], POINTER(POINTER(ITinNodeArray)), 'ppNodes' )),
    COMMETHOD([helpstring(u'Returns all edges sharing the specified node.')], HRESULT, 'GetIncidentEdges',
              ( ['retval', 'out'], POINTER(POINTER(ITinEdgeArray)), 'ppEdges' )),
    COMMETHOD([helpstring(u'Returns all triangles sharing the specified node.')], HRESULT, 'GetIncidentTriangles',
              ( ['retval', 'out'], POINTER(POINTER(ITinTriangleArray)), 'ppTriangles' )),
    COMMETHOD([helpstring(u'Returns the Voronoi-polygon region of the specified node.')], HRESULT, 'GetVoronoiRegion',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon), 'pClippingPolygon' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon)), 'ppRegion' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'IsSameNode',
              ( ['in'], POINTER(ITinNode), 'pNode' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsTheSame' )),
]
################################################################
## code template for ITinNode implementation
##class ITinNode_Impl(object):
##    def QueryAsPoint(self, pPoint):
##        u'Sets the node equal to a point.'
##        #return 
##
##    def GetIncidentEdges(self):
##        u'Returns all edges sharing the specified node.'
##        #return ppEdges
##
##    def IsSameNode(self, pNode):
##        u'Restricted.'
##        #return pbIsTheSame
##
##    def QueryAsWKSPointZ(self):
##        u'Sets the node equal to a point with a z value.'
##        #return pPoint
##
##    def GetIncidentTriangles(self):
##        u'Returns all triangles sharing the specified node.'
##        #return ppTriangles
##
##    def GetAdjacentNodes(self):
##        u'Returns all nodes comprising triangles sharing the specified node.'
##        #return ppNodes
##
##    @property
##    def Y(self):
##        u'The y-coordinate of the specified node.'
##        #return Y
##
##    @property
##    def X(self):
##        u'The x-coordinate of the specified node.'
##        #return X
##
##    @property
##    def Z(self):
##        u'The z-coordinate of the specified node.'
##        #return Z
##
##    def GetVoronoiRegion(self, pClippingPolygon):
##        u'Returns the Voronoi-polygon region of the specified node.'
##        #return ppRegion
##

IGPReplicaDatasets._methods_ = [
    COMMETHOD(['propget', helpstring(u'The dataset count.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'Returns the replica dataset at the specified position.')], HRESULT, 'Element',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IGPReplicaDataset)), 'GPReplicaDataset' )),
    COMMETHOD([helpstring(u'Removes the replica dataset at the specified position.')], HRESULT, 'Remove',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD([helpstring(u'Removes all replica dataset objects.')], HRESULT, 'RemoveAll'),
    COMMETHOD([helpstring(u'Adds replica dataset object.')], HRESULT, 'Add',
              ( ['in'], POINTER(IGPReplicaDataset), 'GPReplicaDataset' )),
    COMMETHOD([helpstring(u'Adds dataset filtered property at the specified position.')], HRESULT, 'Insert',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(IGPReplicaDataset), 'GPReplicaDataset' )),
]
################################################################
## code template for IGPReplicaDatasets implementation
##class IGPReplicaDatasets_Impl(object):
##    @property
##    def Count(self):
##        u'The dataset count.'
##        #return Count
##
##    def Insert(self, Index, GPReplicaDataset):
##        u'Adds dataset filtered property at the specified position.'
##        #return 
##
##    def Remove(self, Index):
##        u'Removes the replica dataset at the specified position.'
##        #return 
##
##    @property
##    def Element(self, Index):
##        u'Returns the replica dataset at the specified position.'
##        #return GPReplicaDataset
##
##    def RemoveAll(self):
##        u'Removes all replica dataset objects.'
##        #return 
##
##    def Add(self, GPReplicaDataset):
##        u'Adds replica dataset object.'
##        #return 
##

class IReplicaEdit2(IReplicaEdit):
    _case_insensitive_ = True
    u'Provides access to members that modify information for a replica.'
    _iid_ = GUID('{E4F414D0-398A-47B8-8176-DAA6860CDD77}')
    _idlflags_ = ['oleautomation']
IReplicaEdit2._methods_ = [
    COMMETHOD(['propput', helpstring(u'The generation number that the sibling thinks is my generation number.')], HRESULT, 'SibMyGenNumber',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The replica datasets for this replica.')], HRESULT, 'AllReplicaDatasets',
              ( ['in'], POINTER(IEnumReplicaDataset), 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Replica access type.')], HRESULT, 'AccessType',
              ( ['in'], esriReplicaAccessType, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Replica reconcile policy.')], HRESULT, 'ReconcilePolicyType',
              ( ['in'], esriReplicaReconcilePolicyType, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The sib connection string for a replica.')], HRESULT, 'SibConnectionString',
              ( ['in'], BSTR, 'rhs' )),
]
################################################################
## code template for IReplicaEdit2 implementation
##class IReplicaEdit2_Impl(object):
##    def _set(self, rhs):
##        u'Replica reconcile policy.'
##    ReconcilePolicyType = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The sib connection string for a replica.'
##    SibConnectionString = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The generation number that the sibling thinks is my generation number.'
##    SibMyGenNumber = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Replica access type.'
##    AccessType = property(fset = _set, doc = _set.__doc__)
##
##    def AllReplicaDatasets(self, rhs):
##        u'The replica datasets for this replica.'
##        #return 
##

class IOwnershipBasedAccessControl(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Ownership-based feature-level access control value object'
    _iid_ = GUID('{406812AD-189B-439D-A186-323E2B6E3CF5}')
    _idlflags_ = ['oleautomation']
IOwnershipBasedAccessControl._methods_ = [
    COMMETHOD(['propget'], HRESULT, 'AllowOthersToDelete',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'allow' )),
    COMMETHOD(['propget'], HRESULT, 'AllowOthersToUpdate',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'allow' )),
    COMMETHOD(['propget'], HRESULT, 'Enabled',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Enabled' )),
]
################################################################
## code template for IOwnershipBasedAccessControl implementation
##class IOwnershipBasedAccessControl_Impl(object):
##    @property
##    def AllowOthersToDelete(self):
##        '-no docstring-'
##        #return allow
##
##    @property
##    def Enabled(self):
##        '-no docstring-'
##        #return Enabled
##
##    @property
##    def AllowOthersToUpdate(self):
##        '-no docstring-'
##        #return allow
##

class IReplicaDatasetEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that set the properties of a check-out dataset.'
    _iid_ = GUID('{79DB3598-6E18-4921-B4F7-2CC03AD52C47}')
    _idlflags_ = ['oleautomation']
IReplicaDatasetEdit._methods_ = [
    COMMETHOD(['propput', helpstring(u'The name of the dataset.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The type of the dataset.')], HRESULT, 'Type',
              ( ['in'], esriDatasetType, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The ID of the dataset.')], HRESULT, 'DatasetID',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The owner of the dataset in the master geodatabase.')], HRESULT, 'ParentOwner',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The name of the master geodatabase the dataset was checked out from.')], HRESULT, 'ParentDatabase',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The ID of the check-out associated with this dataset.')], HRESULT, 'ReplicaID',
              ( ['in'], c_int, 'rhs' )),
]
################################################################
## code template for IReplicaDatasetEdit implementation
##class IReplicaDatasetEdit_Impl(object):
##    def _set(self, rhs):
##        u'The name of the master geodatabase the dataset was checked out from.'
##    ParentDatabase = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The name of the dataset.'
##    Name = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The ID of the check-out associated with this dataset.'
##    ReplicaID = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The owner of the dataset in the master geodatabase.'
##    ParentOwner = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The type of the dataset.'
##    Type = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The ID of the dataset.'
##    DatasetID = property(fset = _set, doc = _set.__doc__)
##

class IAttachmentManager2(IAttachmentManager):
    _case_insensitive_ = True
    _iid_ = GUID('{52067577-796D-421A-8502-8F10D4EBD787}')
    _idlflags_ = ['oleautomation']
IAttachmentManager._methods_ = [
    COMMETHOD([helpstring(u'Adds an attachment to the object identified by the oid.')], HRESULT, 'AddAttachment',
              ( ['in'], c_int, 'parentObjectID' ),
              ( ['in'], POINTER(IAttachment), 'Attachment' ),
              ( ['retval', 'out'], POINTER(c_int), 'AttachmentID' )),
    COMMETHOD([helpstring(u'Returns the attachments for the objects with the object ids specified in the oids argument.')], HRESULT, 'GetAttachmentsByParentIDs',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'oids' ),
              ( [], VARIANT_BOOL, 'infosOnly' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumAttachment)), 'attachments' )),
    COMMETHOD([helpstring(u'Returns the attachments for the attachments with the attachment ids specified in the attIDs argument.')], HRESULT, 'GetAttachmentsByAttachmentIDs',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'attachmentIDs' ),
              ( [], VARIANT_BOOL, 'infosOnly' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumAttachment)), 'attachments' )),
    COMMETHOD([helpstring(u'Updates the attachment.')], HRESULT, 'UpdateAttachment',
              ( ['in'], POINTER(IAttachment), 'Attachment' )),
    COMMETHOD([helpstring(u'Deletes the attachment identified with attID.')], HRESULT, 'DeleteAttachment',
              ( ['in'], c_int, 'AttachmentID' )),
    COMMETHOD([helpstring(u'Deletes all attachments for the object with oid.')], HRESULT, 'DeleteAttachmentsForParent',
              ( ['in'], c_int, 'parentObjectID' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the attachments have a global object identity field.')], HRESULT, 'HasGlobalID',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasGlobalID' )),
]
################################################################
## code template for IAttachmentManager implementation
##class IAttachmentManager_Impl(object):
##    def GetAttachmentsByAttachmentIDs(self, attachmentIDs, infosOnly):
##        u'Returns the attachments for the attachments with the attachment ids specified in the attIDs argument.'
##        #return attachments
##
##    def AddAttachment(self, parentObjectID, Attachment):
##        u'Adds an attachment to the object identified by the oid.'
##        #return AttachmentID
##
##    def DeleteAttachmentsForParent(self, parentObjectID):
##        u'Deletes all attachments for the object with oid.'
##        #return 
##
##    def UpdateAttachment(self, Attachment):
##        u'Updates the attachment.'
##        #return 
##
##    @property
##    def HasGlobalID(self):
##        u'Indicates if the attachments have a global object identity field.'
##        #return HasGlobalID
##
##    def GetAttachmentsByParentIDs(self, oids, infosOnly):
##        u'Returns the attachments for the objects with the object ids specified in the oids argument.'
##        #return attachments
##
##    def DeleteAttachment(self, AttachmentID):
##        u'Deletes the attachment identified with attID.'
##        #return 
##

IAttachmentManager2._methods_ = [
    COMMETHOD([helpstring(u'Adds an attachment to the object identified by the oid.')], HRESULT, 'AddAttachmentByGlobalID',
              ( ['in'], BSTR, 'ParentGlobalID' ),
              ( ['in'], POINTER(IAttachment), 'Attachment' ),
              ( ['retval', 'out'], POINTER(c_int), 'AttachmentID' )),
    COMMETHOD([helpstring(u'Returns the attachments for the objects with the object ids specified in the oids argument.')], HRESULT, 'GetAttachmentsByParentGlobalIDs',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'parentGlobalIDs' ),
              ( [], VARIANT_BOOL, 'infosOnly' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumAttachment)), 'attachments' )),
    COMMETHOD([helpstring(u'Returns the attachments for the attachments with the attachment ids specified in the attIDs argument.')], HRESULT, 'GetAttachmentsByAttachmentGlobalIDs',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'attachmentGlobalIDs' ),
              ( [], VARIANT_BOOL, 'infosOnly' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumAttachment)), 'attachments' )),
    COMMETHOD([helpstring(u'Deletes the attachment identified with attID.')], HRESULT, 'DeleteAttachmentByGlobalID',
              ( ['in'], BSTR, 'GlobalID' )),
    COMMETHOD([helpstring(u'Deletes all attachments for the object with oid.')], HRESULT, 'DeleteAttachmentsForParentByGlobalID',
              ( ['in'], BSTR, 'ParentGlobalID' )),
]
################################################################
## code template for IAttachmentManager2 implementation
##class IAttachmentManager2_Impl(object):
##    def GetAttachmentsByAttachmentGlobalIDs(self, attachmentGlobalIDs, infosOnly):
##        u'Returns the attachments for the attachments with the attachment ids specified in the attIDs argument.'
##        #return attachments
##
##    def DeleteAttachmentByGlobalID(self, GlobalID):
##        u'Deletes the attachment identified with attID.'
##        #return 
##
##    def DeleteAttachmentsForParentByGlobalID(self, ParentGlobalID):
##        u'Deletes all attachments for the object with oid.'
##        #return 
##
##    def AddAttachmentByGlobalID(self, ParentGlobalID, Attachment):
##        u'Adds an attachment to the object identified by the oid.'
##        #return AttachmentID
##
##    def GetAttachmentsByParentGlobalIDs(self, parentGlobalIDs, infosOnly):
##        u'Returns the attachments for the objects with the object ids specified in the oids argument.'
##        #return attachments
##

IGPReplicaDataset._methods_ = [
    COMMETHOD(['propput', helpstring(u'The name of the dataset.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The name of the dataset.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The dataset type.')], HRESULT, 'DatasetType',
              ( ['in'], esriDatasetType, 'DatasetType' )),
    COMMETHOD(['propget', helpstring(u'The dataset type.')], HRESULT, 'DatasetType',
              ( ['retval', 'out'], POINTER(esriDatasetType), 'DatasetType' )),
    COMMETHOD(['propput', helpstring(u'Defines the replicated rows.')], HRESULT, 'RowsType',
              ( ['in'], esriRowsType, 'RowsType' )),
    COMMETHOD(['propget', helpstring(u'Defines the replicated rows.')], HRESULT, 'RowsType',
              ( ['retval', 'out'], POINTER(esriRowsType), 'RowsType' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the replica dataset is private.')], HRESULT, 'IsPrivate',
              ( ['in'], VARIANT_BOOL, 'IsPrivate' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the replica dataset is private.')], HRESULT, 'IsPrivate',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsPrivate' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the geometry defined in the replica description is applied to the replica dataset.')], HRESULT, 'UseGeometry',
              ( ['in'], VARIANT_BOOL, 'UseGeometry' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the geometry defined in the replica description is applied to the replica dataset.')], HRESULT, 'UseGeometry',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'UseGeometry' )),
    COMMETHOD(['propput', helpstring(u'Definition query for the replica dataset.')], HRESULT, 'DefQuery',
              ( ['in'], BSTR, 'DefQuery' )),
    COMMETHOD(['propget', helpstring(u'Definition query for the replica dataset.')], HRESULT, 'DefQuery',
              ( ['retval', 'out'], POINTER(BSTR), 'DefQuery' )),
    COMMETHOD(['propputref', helpstring(u'Array of selected IDs.')], HRESULT, 'SelectionIDs',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'LongArray' )),
    COMMETHOD(['propget', helpstring(u'Array of selected IDs.')], HRESULT, 'SelectionIDs',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray)), 'LongArray' )),
    COMMETHOD(['propput', helpstring(u'Defines the direction of the replicated relationship class.')], HRESULT, 'RelExtractDirection',
              ( ['in'], esriRelExtractDirection, 'RelExtractDir' )),
    COMMETHOD(['propget', helpstring(u'Defines the direction of the replicated relationship class.')], HRESULT, 'RelExtractDirection',
              ( ['retval', 'out'], POINTER(esriRelExtractDirection), 'RelExtractDir' )),
    COMMETHOD(['propput', helpstring(u'The origin class for the relationship class.')], HRESULT, 'RelOriginClass',
              ( ['in'], BSTR, 'OriginClass' )),
    COMMETHOD(['propget', helpstring(u'The origin class for the relationship class.')], HRESULT, 'RelOriginClass',
              ( ['retval', 'out'], POINTER(BSTR), 'OriginClass' )),
    COMMETHOD(['propput', helpstring(u'The destination class for the relationship class.')], HRESULT, 'RelDestinationClass',
              ( ['in'], BSTR, 'destClass' )),
    COMMETHOD(['propget', helpstring(u'The destination class for the relationship class.')], HRESULT, 'RelDestinationClass',
              ( ['retval', 'out'], POINTER(BSTR), 'destClass' )),
]
################################################################
## code template for IGPReplicaDataset implementation
##class IGPReplicaDataset_Impl(object):
##    def _get(self):
##        u'Indicates if the geometry defined in the replica description is applied to the replica dataset.'
##        #return UseGeometry
##    def _set(self, UseGeometry):
##        u'Indicates if the geometry defined in the replica description is applied to the replica dataset.'
##    UseGeometry = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the dataset.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the dataset.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The destination class for the relationship class.'
##        #return destClass
##    def _set(self, destClass):
##        u'The destination class for the relationship class.'
##    RelDestinationClass = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Defines the replicated rows.'
##        #return RowsType
##    def _set(self, RowsType):
##        u'Defines the replicated rows.'
##    RowsType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Defines the direction of the replicated relationship class.'
##        #return RelExtractDir
##    def _set(self, RelExtractDir):
##        u'Defines the direction of the replicated relationship class.'
##    RelExtractDirection = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The origin class for the relationship class.'
##        #return OriginClass
##    def _set(self, OriginClass):
##        u'The origin class for the relationship class.'
##    RelOriginClass = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Definition query for the replica dataset.'
##        #return DefQuery
##    def _set(self, DefQuery):
##        u'Definition query for the replica dataset.'
##    DefQuery = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the replica dataset is private.'
##        #return IsPrivate
##    def _set(self, IsPrivate):
##        u'Indicates if the replica dataset is private.'
##    IsPrivate = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The dataset type.'
##        #return DatasetType
##    def _set(self, DatasetType):
##        u'The dataset type.'
##    DatasetType = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def SelectionIDs(self, LongArray):
##        u'Array of selected IDs.'
##        #return 
##

class RepresentationRules(CoClass):
    u'A collection of representation rules object.'
    _reg_clsid_ = GUID('{FA485356-8FF1-4515-ADBD-1655BEB500C1}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
RepresentationRules._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRepresentationRules, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDocumentVersionSupportGEN]

class IReplicaDataset2(IReplicaDataset):
    _case_insensitive_ = True
    u'Provides access to members that return the properties of a replica dataset.'
    _iid_ = GUID('{829135B2-0BD4-4422-971C-19E27B8741AB}')
    _idlflags_ = ['oleautomation']
IReplicaDataset2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The target name of the dataset.')], HRESULT, 'TargetName',
              ( ['retval', 'out'], POINTER(BSTR), 'TargetName' )),
    COMMETHOD(['propput', helpstring(u'The target name of the dataset.')], HRESULT, 'TargetName',
              ( ['in'], BSTR, 'TargetName' )),
]
################################################################
## code template for IReplicaDataset2 implementation
##class IReplicaDataset2_Impl(object):
##    def _get(self):
##        u'The target name of the dataset.'
##        #return TargetName
##    def _set(self, TargetName):
##        u'The target name of the dataset.'
##    TargetName = property(_get, _set, doc = _set.__doc__)
##

class FeatureDataConverter(CoClass):
    u'Converts a featuredataset to a Personal Geodatabase/Geodatabase featuredataset.'
    _reg_clsid_ = GUID('{78B08005-7054-11D2-AAFE-00C04FA33C20}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IFeatureDataConverter2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that convert to one dataset to another, optionally using a selection set.'
    _iid_ = GUID('{5C37086D-EE25-11D3-A0A1-00C04F6BC626}')
    _idlflags_ = ['oleautomation']
FeatureDataConverter._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IFeatureDataConverter, IFeatureDataConverter2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IConnectionPointContainer]
FeatureDataConverter._outgoing_interfaces_ = [IFeatureProgress]

class IAttachmentInfoArray(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Array of AttachmentInfo objects.'
    _iid_ = GUID('{FC8174E2-F15E-4ABA-8C47-78CA3EBCB0B4}')
    _idlflags_ = ['oleautomation']
IAttachmentInfoArray._methods_ = [
    COMMETHOD(['propget', helpstring(u'The attachmentinfo count.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'Returns the attachmentinfo at the specified position.')], HRESULT, 'Element',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IAttachmentInfo)), 'Attachment' )),
    COMMETHOD([helpstring(u'Removes the attachmentinfo at the specified position.')], HRESULT, 'Remove',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD([helpstring(u'Removes all attachmentinfos.')], HRESULT, 'RemoveAll'),
    COMMETHOD([helpstring(u'Adds a attachmentinfo.')], HRESULT, 'Add',
              ( ['in'], POINTER(IAttachmentInfo), 'rec' )),
    COMMETHOD([helpstring(u'Adds a attachmentinfo at the specified position.')], HRESULT, 'Insert',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(IAttachmentInfo), 'Attachment' )),
]
################################################################
## code template for IAttachmentInfoArray implementation
##class IAttachmentInfoArray_Impl(object):
##    @property
##    def Count(self):
##        u'The attachmentinfo count.'
##        #return Count
##
##    def Insert(self, Index, Attachment):
##        u'Adds a attachmentinfo at the specified position.'
##        #return 
##
##    def Remove(self, Index):
##        u'Removes the attachmentinfo at the specified position.'
##        #return 
##
##    @property
##    def Element(self, Index):
##        u'Returns the attachmentinfo at the specified position.'
##        #return Attachment
##
##    def RemoveAll(self):
##        u'Removes all attachmentinfos.'
##        #return 
##
##    def Add(self, rec):
##        u'Adds a attachmentinfo.'
##        #return 
##

class tagesriTopologyParent(Structure):
    pass
esriTopologyParent = tagesriTopologyParent
IEnumTopologyParent._methods_ = [
    COMMETHOD([helpstring(u'Resets this eumerator.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Returns the next parent of this topology element.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(esriTopologyParent), 'parentInfo' )),
    COMMETHOD(['propget', helpstring(u'The count of parents of this topology element.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'parentCount' )),
]
################################################################
## code template for IEnumTopologyParent implementation
##class IEnumTopologyParent_Impl(object):
##    def Reset(self):
##        u'Resets this eumerator.'
##        #return 
##
##    @property
##    def Count(self):
##        u'The count of parents of this topology element.'
##        #return parentCount
##
##    def Next(self):
##        u'Returns the next parent of this topology element.'
##        #return parentInfo
##

tagesriTopologyParent._fields_ = [
    ('m_pFC', POINTER(IFeatureClass)),
    ('m_FID', c_int),
    ('m_bSelected', VARIANT_BOOL),
    ('m_AttributeAwareness', c_int),
]
assert sizeof(tagesriTopologyParent) == 16, sizeof(tagesriTopologyParent)
assert alignment(tagesriTopologyParent) == 4, alignment(tagesriTopologyParent)

# values for enumeration 'esriXMLIndexTagDataType'
esriXMLIndexTagDataTypeDouble = 0
esriXMLIndexTagDataTypeString = 1
esriXMLIndexTagDataTypeVarChar = 2
esriXMLIndexTagDataType = c_int # enum
IXMLIndexTag._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name formatted as the full locational path of the XML schema.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'indexName' )),
    COMMETHOD(['propput', helpstring(u'The name formatted as the full locational path of the XML schema.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'indexName' )),
    COMMETHOD(['propget', helpstring(u'The data type classification of the index tag.')], HRESULT, 'DataType',
              ( ['retval', 'out'], POINTER(esriXMLIndexTagDataType), 'DataType' )),
    COMMETHOD(['propput', helpstring(u'The data type classification of the index tag.')], HRESULT, 'DataType',
              ( ['in'], esriXMLIndexTagDataType, 'DataType' )),
    COMMETHOD(['propget', helpstring(u'An optional property which associates a number with the index tag.')], HRESULT, 'LocationAlias',
              ( ['retval', 'out'], POINTER(c_int), 'Alias' )),
    COMMETHOD(['propput', helpstring(u'An optional property which associates a number with the index tag.')], HRESULT, 'LocationAlias',
              ( ['in'], c_int, 'Alias' )),
    COMMETHOD(['propget', helpstring(u'A textual description of the index tag.')], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'tagDescription' )),
    COMMETHOD(['propput', helpstring(u'A textual description of the index tag.')], HRESULT, 'Description',
              ( ['in'], BSTR, 'tagDescription' )),
]
################################################################
## code template for IXMLIndexTag implementation
##class IXMLIndexTag_Impl(object):
##    def _get(self):
##        u'The data type classification of the index tag.'
##        #return DataType
##    def _set(self, DataType):
##        u'The data type classification of the index tag.'
##    DataType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name formatted as the full locational path of the XML schema.'
##        #return indexName
##    def _set(self, indexName):
##        u'The name formatted as the full locational path of the XML schema.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'An optional property which associates a number with the index tag.'
##        #return Alias
##    def _set(self, Alias):
##        u'An optional property which associates a number with the index tag.'
##    LocationAlias = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'A textual description of the index tag.'
##        #return tagDescription
##    def _set(self, tagDescription):
##        u'A textual description of the index tag.'
##    Description = property(_get, _set, doc = _set.__doc__)
##

class IAttachmentDataArray(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Array of AttachmentData objects.'
    _iid_ = GUID('{7D02063D-57A2-4607-9D78-753526030802}')
    _idlflags_ = ['oleautomation']
class IAttachmentData(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe an attachment.'
    _iid_ = GUID('{289E0BC8-26F4-4391-8A4B-87D6E133DFF4}')
    _idlflags_ = ['oleautomation']
IAttachmentDataArray._methods_ = [
    COMMETHOD(['propget', helpstring(u'The attachment data count.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'Returns the attachment data at the specified position.')], HRESULT, 'Element',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IAttachmentData)), 'Attachment' )),
    COMMETHOD([helpstring(u'Removes the attachment data at the specified position.')], HRESULT, 'Remove',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD([helpstring(u'Removes all attachment data.')], HRESULT, 'RemoveAll'),
    COMMETHOD([helpstring(u'Adds a attachment data.')], HRESULT, 'Add',
              ( ['in'], POINTER(IAttachmentData), 'Attachment' )),
    COMMETHOD([helpstring(u'Adds a attachment data at the specified position.')], HRESULT, 'Insert',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(IAttachmentData), 'Attachment' )),
]
################################################################
## code template for IAttachmentDataArray implementation
##class IAttachmentDataArray_Impl(object):
##    @property
##    def Count(self):
##        u'The attachment data count.'
##        #return Count
##
##    def Insert(self, Index, Attachment):
##        u'Adds a attachment data at the specified position.'
##        #return 
##
##    def Remove(self, Index):
##        u'Removes the attachment data at the specified position.'
##        #return 
##
##    @property
##    def Element(self, Index):
##        u'Returns the attachment data at the specified position.'
##        #return Attachment
##
##    def RemoveAll(self):
##        u'Removes all attachment data.'
##        #return 
##
##    def Add(self, Attachment):
##        u'Adds a attachment data.'
##        #return 
##

class IDatasetFileStat(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control Dataset file-based statistics.'
    _iid_ = GUID('{52D4A757-DF71-47E0-AAB8-EE302EB7ACAB}')
    _idlflags_ = ['oleautomation']
IDatasetFileStat._methods_ = [
    COMMETHOD(['propget', helpstring(u'The date modified/created/accessed.')], HRESULT, 'StatTime',
              ( ['in'], esriDatasetFileStatTimeMode, 'dateMode' ),
              ( ['retval', 'out'], POINTER(c_int), 'time' )),
    COMMETHOD(['propget', helpstring(u'The size.')], HRESULT, 'StatSize',
              ( ['retval', 'out'], POINTER(c_int), 'Size' )),
    COMMETHOD(['propget', helpstring(u'The access mode.')], HRESULT, 'StatMode',
              ( ['retval', 'out'], POINTER(esriDatasetFileStatAccessMode), 'accessMode' )),
]
################################################################
## code template for IDatasetFileStat implementation
##class IDatasetFileStat_Impl(object):
##    @property
##    def StatTime(self, dateMode):
##        u'The date modified/created/accessed.'
##        #return time
##
##    @property
##    def StatMode(self):
##        u'The access mode.'
##        #return accessMode
##
##    @property
##    def StatSize(self):
##        u'The size.'
##        #return Size
##

class ITinClock(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides timing utilities.'
    _iid_ = GUID('{75D08EF4-23AA-11D5-ABA6-0008C73FD50C}')
    _idlflags_ = ['oleautomation', 'hidden']
ITinClock._methods_ = [
    COMMETHOD([helpstring(u'Reset clock.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Suspends the execution of the current thread for the specified interval (in seconds).')], HRESULT, 'Sleep',
              ( ['in'], c_double, 'Seconds' )),
    COMMETHOD([helpstring(u'Return elapsed (since last Reset call) time in seconds.')], HRESULT, 'GetElapsedTime',
              ( ['retval', 'out'], POINTER(c_double), 'pElapsedTime' )),
]
################################################################
## code template for ITinClock implementation
##class ITinClock_Impl(object):
##    def Reset(self):
##        u'Reset clock.'
##        #return 
##
##    def GetElapsedTime(self):
##        u'Return elapsed (since last Reset call) time in seconds.'
##        #return pElapsedTime
##
##    def Sleep(self, Seconds):
##        u'Suspends the execution of the current thread for the specified interval (in seconds).'
##        #return 
##

class IEnumConfigurationKeyword(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members to enumerate configuration keywords.'
    _iid_ = GUID('{B055BBD8-DE08-49CD-A589-FFFD22112CD5}')
    _idlflags_ = ['oleautomation']
IWorkspaceConfiguration._methods_ = [
    COMMETHOD(['propget', helpstring(u'The available configuration keywords.')], HRESULT, 'ConfigurationKeywords',
              ( ['retval', 'out'], POINTER(POINTER(IEnumConfigurationKeyword)), 'keywords' )),
]
################################################################
## code template for IWorkspaceConfiguration implementation
##class IWorkspaceConfiguration_Impl(object):
##    @property
##    def ConfigurationKeywords(self):
##        u'The available configuration keywords.'
##        #return keywords
##

IEnumTGHitInfo._methods_ = [
    COMMETHOD([helpstring(u'Resets enumerator.')], HRESULT, 'Reset'),
    COMMETHOD(['propget', helpstring(u'Number of topology elements.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'hitElements' )),
    COMMETHOD([helpstring(u'Iterates to the next topology element.')], HRESULT, 'Next',
              ( ['out'], POINTER(POINTER(ITopologyElement)), 'hitElement' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint)), 'hitPoint' ),
              ( [], POINTER(c_double), 'hitDistance' )),
]
################################################################
## code template for IEnumTGHitInfo implementation
##class IEnumTGHitInfo_Impl(object):
##    def Reset(self):
##        u'Resets enumerator.'
##        #return 
##
##    @property
##    def Count(self):
##        u'Number of topology elements.'
##        #return hitElements
##
##    def Next(self, hitDistance):
##        u'Iterates to the next topology element.'
##        #return hitElement, hitPoint
##

class IXMLReplicaDescription(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members which set and return the properties of a ReplicaDescription object.'
    _iid_ = GUID('{D14BB518-5768-4B2E-995D-69190EF369ED}')
    _idlflags_ = ['oleautomation']
IXMLReplicaDescription._methods_ = [
    COMMETHOD([helpstring(u'Provides access to members that define the datasets to check-out or extract to am XML file.')], HRESULT, 'Init2',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IEnumName), 'enumNames' ),
              ( ['in'], BSTR, 'OutputXMLFile' ),
              ( ['in'], VARIANT_BOOL, 'BinaryGeometry' ),
              ( ['in'], VARIANT_BOOL, 'Compressed' ),
              ( ['in'], esriDataExtractionType, 'deType' )),
    COMMETHOD(['propget', helpstring(u'The name of the output XML file.')], HRESULT, 'OutputXMLFile',
              ( ['retval', 'out'], POINTER(BSTR), 'OutputXMLFile' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the geometry coordinates are stored in binary')], HRESULT, 'BinaryGeometry',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'BinaryGeometry' )),
    COMMETHOD(['propget', helpstring(u'indicates of the output XML file is to be compressed.')], HRESULT, 'Compressed',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Compressed' )),
]
################################################################
## code template for IXMLReplicaDescription implementation
##class IXMLReplicaDescription_Impl(object):
##    @property
##    def Compressed(self):
##        u'indicates of the output XML file is to be compressed.'
##        #return Compressed
##
##    @property
##    def BinaryGeometry(self):
##        u'Indicates if the geometry coordinates are stored in binary'
##        #return BinaryGeometry
##
##    def Init2(self, enumNames, OutputXMLFile, BinaryGeometry, Compressed, deType):
##        u'Provides access to members that define the datasets to check-out or extract to am XML file.'
##        #return 
##
##    @property
##    def OutputXMLFile(self):
##        u'The name of the output XML file.'
##        #return OutputXMLFile
##


# values for enumeration 'esriTopologyState'
esriTSUnanalyzed = 0
esriTSAnalyzedWithErrors = 1
esriTSAnalyzedWithoutErrors = 2
esriTSEmpty = 3
esriTopologyState = c_int # enum
class TopologyGraphEventsHelper(CoClass):
    u'Topology graph event helper.'
    _reg_clsid_ = GUID('{72D5F011-D7CC-4551-88BF-80BB7B7ACBDA}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ITopologyGraphEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that occur with a topology graph.'
    _iid_ = GUID('{49111212-C452-474E-B7F4-7669EF6C5762}')
    _idlflags_ = ['oleautomation']
TopologyGraphEventsHelper._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown]
TopologyGraphEventsHelper._outgoing_interfaces_ = [ITopologyGraphEvents]

ITableCapabilities._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the table supports selection.')], HRESULT, 'CanSelect',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanSelect' )),
]
################################################################
## code template for ITableCapabilities implementation
##class ITableCapabilities_Impl(object):
##    @property
##    def CanSelect(self):
##        u'Indicates if the table supports selection.'
##        #return CanSelect
##

IRelQueryTableManage._methods_ = [
    COMMETHOD([helpstring(u'Updates all children tables to use new version of the workspace.')], HRESULT, 'VersionChanged',
              ( ['in'], POINTER(IVersion), 'selectedWorkspace' ),
              ( ['in'], POINTER(IVersion), 'targetVersion' ),
              ( ['in'], POINTER(IEnumTableVersionChanges), 'tablesRequiringMapEventFiring' )),
]
################################################################
## code template for IRelQueryTableManage implementation
##class IRelQueryTableManage_Impl(object):
##    def VersionChanged(self, selectedWorkspace, targetVersion, tablesRequiringMapEventFiring):
##        u'Updates all children tables to use new version of the workspace.'
##        #return 
##

class IDifferenceCursorEx(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the difference cursor.'
    _iid_ = GUID('{810856CE-680B-443B-930D-CD26B1B0C412}')
    _idlflags_ = ['oleautomation']
IDataChangesEx._methods_ = [
    COMMETHOD(['propget', helpstring(u'The list of tables with edits.')], HRESULT, 'ModifiedClasses',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IEnumBSTR)), 'ModifiedClasses' )),
    COMMETHOD(['propget', helpstring(u'The IDs of rows that changed during the edit session.')], HRESULT, 'ChangedIDs',
              ( ['in'], BSTR, 'ClassName' ),
              ( ['in'], esriDifferenceType, 'DiffType' ),
              ( ['retval', 'out'], POINTER(POINTER(IFIDSet)), 'FIDSet' )),
    COMMETHOD([helpstring(u'Get changed rows for a specific class.')], HRESULT, 'Extract',
              ( ['in'], BSTR, 'ClassName' ),
              ( ['in'], esriDifferenceType, 'DiffType' ),
              ( ['retval', 'out'], POINTER(POINTER(IDifferenceCursor)), 'diffCursor' )),
    COMMETHOD([helpstring(u'Get changed rows for a specific class.')], HRESULT, 'ExtractEx',
              ( ['in'], BSTR, 'ClassName' ),
              ( ['in'], esriDifferenceType, 'DiffType' ),
              ( ['retval', 'out'], POINTER(POINTER(IDifferenceCursorEx)), 'diffCursor' )),
]
################################################################
## code template for IDataChangesEx implementation
##class IDataChangesEx_Impl(object):
##    @property
##    def ModifiedClasses(self):
##        u'The list of tables with edits.'
##        #return ModifiedClasses
##
##    @property
##    def ChangedIDs(self, ClassName, DiffType):
##        u'The IDs of rows that changed during the edit session.'
##        #return FIDSet
##
##    def Extract(self, ClassName, DiffType):
##        u'Get changed rows for a specific class.'
##        #return diffCursor
##
##    def ExtractEx(self, ClassName, DiffType):
##        u'Get changed rows for a specific class.'
##        #return diffCursor
##

IEnumTableVersionChanges._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next table whose version has been changed.')], HRESULT, 'Next',
              ( ['out'], POINTER(POINTER(ITable)), 'oldTable' ),
              ( ['out'], POINTER(POINTER(ITable)), 'newTable' )),
    COMMETHOD([helpstring(u'Resets enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumTableVersionChanges implementation
##class IEnumTableVersionChanges_Impl(object):
##    def Reset(self):
##        u'Resets enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next table whose version has been changed.'
##        #return oldTable, newTable
##

class IDatabaseConnectionInfo2(IDatabaseConnectionInfo):
    _case_insensitive_ = True
    u"Provides access to members that provide information about the Workspace's connected database."
    _iid_ = GUID('{6557F590-8A8E-4F2C-A910-4EAC2785F986}')
    _idlflags_ = ['oleautomation']
IDatabaseConnectionInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u"The name of the connected database. It may be different from the DATABASE property in the workspace's connection properties.")], HRESULT, 'ConnectedDatabase',
              ( ['retval', 'out'], POINTER(BSTR), 'db' )),
    COMMETHOD(['propget', helpstring(u"The name of the connected user. It may be different from the USER property in the workspace's connection properties.")], HRESULT, 'ConnectedUser',
              ( ['retval', 'out'], POINTER(BSTR), 'user' )),
]
################################################################
## code template for IDatabaseConnectionInfo implementation
##class IDatabaseConnectionInfo_Impl(object):
##    @property
##    def ConnectedUser(self):
##        u"The name of the connected user. It may be different from the USER property in the workspace's connection properties."
##        #return user
##
##    @property
##    def ConnectedDatabase(self):
##        u"The name of the connected database. It may be different from the DATABASE property in the workspace's connection properties."
##        #return db
##


# values for enumeration 'esriConnectionDBMS'
esriDBMS_Unknown = 0
esriDBMS_Oracle = 1
esriDBMS_Informix = 2
esriDBMS_SQLServer = 3
esriDBMS_DB2 = 4
esriDBMS_PostgreSQL = 5
esriDBMS_Netezza = 6
esriDBMS_Teradata = 7
esriDBMS_SQLite = 8
esriDBMS_Hana = 9
esriConnectionDBMS = c_int # enum
IDatabaseConnectionInfo2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The type of DBMS this workspace is connected to.')], HRESULT, 'ConnectionDBMS',
              ( ['retval', 'out'], POINTER(esriConnectionDBMS), 'dbms' )),
    COMMETHOD(['propget', helpstring(u'The current DBMS date/time.')], HRESULT, 'ConnectionCurrentDateTime',
              ( ['retval', 'out'], POINTER(VARIANT), 'datetime' )),
    COMMETHOD(['propget', helpstring(u'The ArcSDE server class.')], HRESULT, 'GeodatabaseServerClass',
              ( ['retval', 'out'], POINTER(esriGeodatabaseServerClassType), 'serverClass' )),
    COMMETHOD(['propget', helpstring(u'The server this workspace is connected to.')], HRESULT, 'ConnectionServer',
              ( ['retval', 'out'], POINTER(BSTR), 'server' )),
]
################################################################
## code template for IDatabaseConnectionInfo2 implementation
##class IDatabaseConnectionInfo2_Impl(object):
##    @property
##    def ConnectionDBMS(self):
##        u'The type of DBMS this workspace is connected to.'
##        #return dbms
##
##    @property
##    def ConnectionCurrentDateTime(self):
##        u'The current DBMS date/time.'
##        #return datetime
##
##    @property
##    def ConnectionServer(self):
##        u'The server this workspace is connected to.'
##        #return server
##
##    @property
##    def GeodatabaseServerClass(self):
##        u'The ArcSDE server class.'
##        #return serverClass
##

IMetadata._methods_ = [
    COMMETHOD(['propget', helpstring(u'The PropertySet containing metadata.')], HRESULT, 'Metadata',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'PropertySet' )),
    COMMETHOD(['propput', helpstring(u'The PropertySet containing metadata.')], HRESULT, 'Metadata',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'PropertySet' )),
    COMMETHOD([helpstring(u"Updates metadata with the current properties; may create metadata if it doesn't already exist.")], HRESULT, 'Synchronize',
              ( ['in'], esriMetadataSyncAction, 'action' ),
              ( ['in'], c_int, 'interval' )),
]
################################################################
## code template for IMetadata implementation
##class IMetadata_Impl(object):
##    def Synchronize(self, action, interval):
##        u"Updates metadata with the current properties; may create metadata if it doesn't already exist."
##        #return 
##
##    def _get(self):
##        u'The PropertySet containing metadata.'
##        #return PropertySet
##    def _set(self, PropertySet):
##        u'The PropertySet containing metadata.'
##    Metadata = property(_get, _set, doc = _set.__doc__)
##

ITopologyGraphEvents._methods_ = [
    COMMETHOD([helpstring(u'This event is fired when a new object is created in the object class.')], HRESULT, 'OnTopologyGraphModified'),
]
################################################################
## code template for ITopologyGraphEvents implementation
##class ITopologyGraphEvents_Impl(object):
##    def OnTopologyGraphModified(self):
##        u'This event is fired when a new object is created in the object class.'
##        #return 
##

class ISimpleRelationshipChanges(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control simple relationship changes.'
    _iid_ = GUID('{1438A5CC-BDEF-411A-A201-FE5E7C493A00}')
    _idlflags_ = ['oleautomation']
ISimpleRelationshipChanges._methods_ = [
    COMMETHOD(['propget', helpstring(u'The old origin key.')], HRESULT, 'OldOriginKey',
              ( ['retval', 'out'], POINTER(VARIANT), 'oldOrigKey' )),
]
################################################################
## code template for ISimpleRelationshipChanges implementation
##class ISimpleRelationshipChanges_Impl(object):
##    @property
##    def OldOriginKey(self):
##        u'The old origin key.'
##        #return oldOrigKey
##

class IUserInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members describing a user connected to a database.'
    _iid_ = GUID('{EB75FCDE-A676-4B77-A9A6-48F722B7087B}')
    _idlflags_ = ['oleautomation']
IUserInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'The unique ID of the connection.')], HRESULT, 'SessionID',
              ( ['retval', 'out'], POINTER(c_int), 'SessionID' )),
    COMMETHOD(['propget', helpstring(u'The name of the connected user.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The name of the connected computer')], HRESULT, 'ClientName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The time that the connection was made')], HRESULT, 'ConnectionTime',
              ( ['retval', 'out'], POINTER(VARIANT), 'ConnectionTime' )),
    COMMETHOD(['propget', helpstring(u'The type of connection.')], HRESULT, 'IsDirectConnection',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isDirectConnect' )),
    COMMETHOD(['propget', helpstring(u"Whether this connection is the current users' connection.")], HRESULT, 'IsOwnConnection',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsOwnConnection' )),
]
################################################################
## code template for IUserInfo implementation
##class IUserInfo_Impl(object):
##    @property
##    def Name(self):
##        u'The name of the connected user.'
##        #return Name
##
##    @property
##    def ConnectionTime(self):
##        u'The time that the connection was made'
##        #return ConnectionTime
##
##    @property
##    def SessionID(self):
##        u'The unique ID of the connection.'
##        #return SessionID
##
##    @property
##    def IsDirectConnection(self):
##        u'The type of connection.'
##        #return isDirectConnect
##
##    @property
##    def ClientName(self):
##        u'The name of the connected computer'
##        #return Name
##
##    @property
##    def IsOwnConnection(self):
##        u"Whether this connection is the current users' connection."
##        #return IsOwnConnection
##

class ITableWrite(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control Low level Table Write. For use only by custom feature implementations that override Store.'
    _iid_ = GUID('{D4C2BE91-C50C-11D1-8876-0000F877762D}')
    _idlflags_ = ['oleautomation']
class ITableWrite2(ITableWrite):
    _case_insensitive_ = True
    u'Provides access to members that control Low level Table Write. For use only by custom feature implementations that override Store.'
    _iid_ = GUID('{02E142C4-F7E9-4D67-AB25-7F88B839EE54}')
    _idlflags_ = ['oleautomation']
ITableWrite._methods_ = [
    COMMETHOD([helpstring(u'Deletes a set of rows.')], HRESULT, 'DeleteRows',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'Rows' )),
    COMMETHOD([helpstring(u'Sends OnDeleted messages, deletes relationships and part objects (if composite), then calls RemoveRows.')], HRESULT, 'RemoveDeletedRows',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'Rows' )),
    COMMETHOD([helpstring(u'Sends OnChanged messages, sends move notifications to related objects, then calls WriteRows.')], HRESULT, 'WriteMovedRows',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'Rows' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ILine), 'moveVector' )),
    COMMETHOD([helpstring(u'Sends OnChanged messages, sends rotate notifications to related objects, then calls WriteRows.')], HRESULT, 'WriteRotatedRows',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'Rows' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'Origin' ),
              ( [], c_double, 'Angle' )),
    COMMETHOD([helpstring(u'Sends OnChanged messages, Sends Changed Notifications to related objects, then calls WriteRows.')], HRESULT, 'WriteChangedRows',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'Rows' )),
    COMMETHOD([helpstring(u'Write a row to the database without polymorphic object update behavior.')], HRESULT, 'WriteRow',
              ( ['in'], POINTER(IRow), 'Row' )),
    COMMETHOD([helpstring(u'Write a set of rows to the database without polymorphic object update behavior.')], HRESULT, 'WriteRows',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'Rows' )),
    COMMETHOD([helpstring(u'Remove a row from the database without polymorphic object delete behavior.')], HRESULT, 'RemoveRow',
              ( ['in'], POINTER(IRow), 'Row' )),
    COMMETHOD([helpstring(u'Remove a set of rows from the database without polymorphic object delete behavior.')], HRESULT, 'RemoveRows',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'Rows' )),
    COMMETHOD([helpstring(u'A cursor that can be used to update rows selected by the specified query without polymorphic object update behavior.')], HRESULT, 'UpdateRows',
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' ),
              ( ['in'], VARIANT_BOOL, 'Recycling' ),
              ( ['retval', 'out'], POINTER(POINTER(ICursor)), 'Cursor' )),
    COMMETHOD([helpstring(u'A cursor that can be used to insert new rows without polymorphic object insert behavior.')], HRESULT, 'InsertRows',
              ( ['in'], VARIANT_BOOL, 'useBuffering' ),
              ( ['retval', 'out'], POINTER(POINTER(ICursor)), 'Cursor' )),
]
################################################################
## code template for ITableWrite implementation
##class ITableWrite_Impl(object):
##    def WriteChangedRows(self, Rows):
##        u'Sends OnChanged messages, Sends Changed Notifications to related objects, then calls WriteRows.'
##        #return 
##
##    def UpdateRows(self, QueryFilter, Recycling):
##        u'A cursor that can be used to update rows selected by the specified query without polymorphic object update behavior.'
##        #return Cursor
##
##    def WriteRow(self, Row):
##        u'Write a row to the database without polymorphic object update behavior.'
##        #return 
##
##    def DeleteRows(self, Rows):
##        u'Deletes a set of rows.'
##        #return 
##
##    def WriteMovedRows(self, Rows, moveVector):
##        u'Sends OnChanged messages, sends move notifications to related objects, then calls WriteRows.'
##        #return 
##
##    def RemoveRow(self, Row):
##        u'Remove a row from the database without polymorphic object delete behavior.'
##        #return 
##
##    def InsertRows(self, useBuffering):
##        u'A cursor that can be used to insert new rows without polymorphic object insert behavior.'
##        #return Cursor
##
##    def RemoveRows(self, Rows):
##        u'Remove a set of rows from the database without polymorphic object delete behavior.'
##        #return 
##
##    def WriteRows(self, Rows):
##        u'Write a set of rows to the database without polymorphic object update behavior.'
##        #return 
##
##    def RemoveDeletedRows(self, Rows):
##        u'Sends OnDeleted messages, deletes relationships and part objects (if composite), then calls RemoveRows.'
##        #return 
##
##    def WriteRotatedRows(self, Rows, Origin, Angle):
##        u'Sends OnChanged messages, sends rotate notifications to related objects, then calls WriteRows.'
##        #return 
##

ITableWrite2._methods_ = [
    COMMETHOD([helpstring(u'Truncates all rows in the table.')], HRESULT, 'Truncate'),
]
################################################################
## code template for ITableWrite2 implementation
##class ITableWrite2_Impl(object):
##    def Truncate(self):
##        u'Truncates all rows in the table.'
##        #return 
##

class TopologyName(CoClass):
    u'Esri Topology Name object.'
    _reg_clsid_ = GUID('{9FCA50EC-C413-440C-B453-49A591440096}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TopologyName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IDatasetName, ITopologyName, INativeTypeInfo, IMetadata, IMetadataEdit]

class ITableUtil(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return rows in the specified spatial reference.'
    _iid_ = GUID('{D3CB0FC1-8C02-11D3-9F91-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
ITableUtil._methods_ = [
    COMMETHOD([helpstring(u'The row from the database with the specified object ID, in the specified spatial reference.')], HRESULT, 'GetRow',
              ( ['in'], c_int, 'OID' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference' ),
              ( ['retval', 'out'], POINTER(POINTER(IRow)), 'Row' )),
    COMMETHOD([helpstring(u'A cursor of rows given a set of object ids, in the specified spatial reference.')], HRESULT, 'GetRows',
              ( ['in'], VARIANT, 'oids' ),
              ( ['in'], VARIANT_BOOL, 'Recycling' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference' ),
              ( ['retval', 'out'], POINTER(POINTER(ICursor)), 'Cursor' )),
]
################################################################
## code template for ITableUtil implementation
##class ITableUtil_Impl(object):
##    def GetRows(self, oids, Recycling, SpatialReference):
##        u'A cursor of rows given a set of object ids, in the specified spatial reference.'
##        #return Cursor
##
##    def GetRow(self, OID, SpatialReference):
##        u'The row from the database with the specified object ID, in the specified spatial reference.'
##        #return Row
##

IDifferenceCursor._methods_ = [
    COMMETHOD([helpstring(u'Returns the object identifier or difference row.')], HRESULT, 'Next',
              ( ['out'], POINTER(c_int), 'OID' ),
              ( ['out'], POINTER(POINTER(IRow)), 'differenceRow' )),
]
################################################################
## code template for IDifferenceCursor implementation
##class IDifferenceCursor_Impl(object):
##    def Next(self):
##        u'Returns the object identifier or difference row.'
##        #return OID, differenceRow
##

class IEnumUserInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Enumerates users connected to a database.'
    _iid_ = GUID('{20E7292D-152D-42FA-8766-A91E10A34D0E}')
    _idlflags_ = ['oleautomation']
IEnumUserInfo._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next user.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IUserInfo)), 'user' )),
    COMMETHOD([helpstring(u'Resets the enumeration of users to the beginning')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumUserInfo implementation
##class IEnumUserInfo_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration of users to the beginning'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next user.'
##        #return user
##

class RasterDatasetName(CoClass):
    u'A container for name information about a raster dataset.'
    _reg_clsid_ = GUID('{75BCE6E2-8AF5-478E-8892-FA45CA50AF4D}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IRasterDatasetName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that maintain name information about a raster dataset.'
    _iid_ = GUID('{BC25E11E-168B-11D2-8D25-0000F8780535}')
    _idlflags_ = ['oleautomation']
class IRasterDatasetContainerName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that maintain name information about a raster dataset container.'
    _iid_ = GUID('{EDB00D1E-1E4E-4B1F-BB48-E09499137088}')
    _idlflags_ = ['oleautomation']
RasterDatasetName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IRasterDatasetName, IMetadata, IMetadataEdit, INativeTypeInfo, IDatasetNameFileStat, IDatasetNameFileSize, IRasterDatasetContainerName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDocumentVersionSupportGEN]

class IEnumWorkspace(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate workspaces.'
    _iid_ = GUID('{8D39A5FF-BDC8-11D0-87F8-080009EC732A}')
    _idlflags_ = ['oleautomation']
    def __iter__(self):
        return self

    def next(self):
        item, fetched = self.Next(1)
        if fetched:
            return item
        raise StopIteration

    def __getitem__(self, index):
        self.Reset()
        self.Skip(index)
        item, fetched = self.Next(1)
        if fetched:
            return item
        raise IndexError(index)

IEnumWorkspace._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next Workspace in the enumeration sequence.')], HRESULT, 'Next',
              ( ['in'], c_int, 'numRequested' ),
              ( ['out'], POINTER(POINTER(IWorkspace)), 'workspaces' ),
              ( ['out'], POINTER(c_int), 'numFetched' )),
    COMMETHOD([helpstring(u'Skips the next Workspace in the enumeration.')], HRESULT, 'Skip',
              ( ['in'], c_int, 'numToSkip' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Creates a clone of the current enumeration.')], HRESULT, 'Clone',
              ( ['out'], POINTER(POINTER(IEnumWorkspace)), 'workspaces' )),
]
################################################################
## code template for IEnumWorkspace implementation
##class IEnumWorkspace_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Skip(self, numToSkip):
##        u'Skips the next Workspace in the enumeration.'
##        #return 
##
##    def Clone(self):
##        u'Creates a clone of the current enumeration.'
##        #return workspaces
##
##    def Next(self, numRequested):
##        u'Retrieves the next Workspace in the enumeration sequence.'
##        #return workspaces, numFetched
##

class IConfirmSendRelatedObjectEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that occur when related objects change, move or rotate and confirms that the event be sent.'
    _iid_ = GUID('{4A72E282-52BF-11D4-80DD-00C04F601565}')
    _idlflags_ = ['oleautomation']
IConfirmSendRelatedObjectEvents._methods_ = [
    COMMETHOD([helpstring(u'Notifies this object that a related object changed and asks if events should be sent.')], HRESULT, 'ConfirmSendRelatedObjectChanged',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(IObject), 'objectThatChanged' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'doSend' )),
    COMMETHOD([helpstring(u'Notifies this object that a related object moved and asks if events should be sent.')], HRESULT, 'ConfirmSendRelatedObjectMoved',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(IObject), 'objectThatChanged' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ILine), 'moveVector' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'doSend' )),
    COMMETHOD([helpstring(u'Notifies this object that a set of objects with relationships to the input set of objects moved and asks if events should be sent.')], HRESULT, 'ConfirmSendRelatedObjectSetMoved',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'objectsThatChanged' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ILine), 'moveVector' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'doSend' )),
    COMMETHOD([helpstring(u'Notifies this object that a related object rotated and asks if events should be sent.')], HRESULT, 'ConfirmSendRelatedObjectRotated',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(IObject), 'objectThatChanged' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'Origin' ),
              ( [], c_double, 'Angle' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'doSend' )),
    COMMETHOD([helpstring(u'Notifies this object that a set of objects with relationships to the input set of objects rotated and asks if events should be sent.')], HRESULT, 'ConfirmSendRelatedObjectSetRotated',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'objectsThatChanged' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'Origin' ),
              ( [], c_double, 'Angle' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'doSend' )),
]
################################################################
## code template for IConfirmSendRelatedObjectEvents implementation
##class IConfirmSendRelatedObjectEvents_Impl(object):
##    def ConfirmSendRelatedObjectChanged(self, RelationshipClass, objectThatChanged):
##        u'Notifies this object that a related object changed and asks if events should be sent.'
##        #return doSend
##
##    def ConfirmSendRelatedObjectMoved(self, RelationshipClass, objectThatChanged, moveVector):
##        u'Notifies this object that a related object moved and asks if events should be sent.'
##        #return doSend
##
##    def ConfirmSendRelatedObjectSetRotated(self, RelationshipClass, objectsThatChanged, Origin, Angle):
##        u'Notifies this object that a set of objects with relationships to the input set of objects rotated and asks if events should be sent.'
##        #return doSend
##
##    def ConfirmSendRelatedObjectRotated(self, RelationshipClass, objectThatChanged, Origin, Angle):
##        u'Notifies this object that a related object rotated and asks if events should be sent.'
##        #return doSend
##
##    def ConfirmSendRelatedObjectSetMoved(self, RelationshipClass, objectsThatChanged, moveVector):
##        u'Notifies this object that a set of objects with relationships to the input set of objects moved and asks if events should be sent.'
##        #return doSend
##

IObjectClassEvents._methods_ = [
    COMMETHOD([helpstring(u'This event is fired when a new object is created in the object class.')], HRESULT, 'OnCreate',
              ( ['in'], POINTER(IObject), 'obj' )),
    COMMETHOD([helpstring(u'This event is fired when an object is deleted from the object class.')], HRESULT, 'OnDelete',
              ( ['in'], POINTER(IObject), 'obj' )),
    COMMETHOD([helpstring(u"This event is fired when an object's attributes or geometry is updated.")], HRESULT, 'OnChange',
              ( ['in'], POINTER(IObject), 'obj' )),
]
################################################################
## code template for IObjectClassEvents implementation
##class IObjectClassEvents_Impl(object):
##    def OnDelete(self, obj):
##        u'This event is fired when an object is deleted from the object class.'
##        #return 
##
##    def OnCreate(self, obj):
##        u'This event is fired when a new object is created in the object class.'
##        #return 
##
##    def OnChange(self, obj):
##        u"This event is fired when an object's attributes or geometry is updated."
##        #return 
##


# values for enumeration 'esriMergePolicyType'
esriMPTSumValues = 1
esriMPTAreaWeighted = 2
esriMPTDefaultValue = 3
esriMergePolicyType = c_int # enum

# values for enumeration 'esriSplitPolicyType'
esriSPTGeometryRatio = 1
esriSPTDuplicate = 2
esriSPTDefaultValue = 3
esriSplitPolicyType = c_int # enum

# values for enumeration 'esriDomainType'
esriDTRange = 1
esriDTCodedValue = 2
esriDTString = 3
esriDomainType = c_int # enum
IDomain._methods_ = [
    COMMETHOD(['hidden', helpstring(u'The ID of the domain.'), 'propget'], HRESULT, 'DomainID',
              ( ['retval', 'out'], POINTER(c_int), 'ID' )),
    COMMETHOD(['hidden', helpstring(u'The ID of the domain.'), 'propput'], HRESULT, 'DomainID',
              ( ['in'], c_int, 'ID' )),
    COMMETHOD(['propget', helpstring(u'The description of the domain.')], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'Description' )),
    COMMETHOD(['propput', helpstring(u'The description of the domain.')], HRESULT, 'Description',
              ( ['in'], BSTR, 'Description' )),
    COMMETHOD(['propget', helpstring(u'The field type of the field.')], HRESULT, 'FieldType',
              ( ['retval', 'out'], POINTER(esriFieldType), 'FieldType' )),
    COMMETHOD(['hidden', helpstring(u'The field type of the field.'), 'propput'], HRESULT, 'FieldType',
              ( ['in'], esriFieldType, 'FieldType' )),
    COMMETHOD(['propget', helpstring(u'The merge policy.')], HRESULT, 'MergePolicy',
              ( ['retval', 'out'], POINTER(esriMergePolicyType), 'policy' )),
    COMMETHOD(['propput', helpstring(u'The merge policy.')], HRESULT, 'MergePolicy',
              ( ['in'], esriMergePolicyType, 'policy' )),
    COMMETHOD(['propget', helpstring(u'The split policy.')], HRESULT, 'SplitPolicy',
              ( ['retval', 'out'], POINTER(esriSplitPolicyType), 'policy' )),
    COMMETHOD(['propput', helpstring(u'The split policy.')], HRESULT, 'SplitPolicy',
              ( ['in'], esriSplitPolicyType, 'policy' )),
    COMMETHOD(['propget', helpstring(u'The name of the domain.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the domain.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['hidden', helpstring(u'The owner of the domain.'), 'propget'], HRESULT, 'Owner',
              ( ['retval', 'out'], POINTER(BSTR), 'Owner' )),
    COMMETHOD(['hidden', helpstring(u'The owner of the domain.'), 'propput'], HRESULT, 'Owner',
              ( ['in'], BSTR, 'Owner' )),
    COMMETHOD(['propget', helpstring(u'The domain type.')], HRESULT, 'Type',
              ( ['retval', 'out'], POINTER(esriDomainType), 'Type' )),
    COMMETHOD([helpstring(u'Indicates whether the value is a valid member of the domain.')], HRESULT, 'MemberOf',
              ( ['in'], VARIANT, 'Value' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isMember' )),
]
################################################################
## code template for IDomain implementation
##class IDomain_Impl(object):
##    def _get(self):
##        u'The ID of the domain.'
##        #return ID
##    def _set(self, ID):
##        u'The ID of the domain.'
##    DomainID = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the domain.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the domain.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The merge policy.'
##        #return policy
##    def _set(self, policy):
##        u'The merge policy.'
##    MergePolicy = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The field type of the field.'
##        #return FieldType
##    def _set(self, FieldType):
##        u'The field type of the field.'
##    FieldType = property(_get, _set, doc = _set.__doc__)
##
##    def MemberOf(self, Value):
##        u'Indicates whether the value is a valid member of the domain.'
##        #return isMember
##
##    def _get(self):
##        u'The owner of the domain.'
##        #return Owner
##    def _set(self, Owner):
##        u'The owner of the domain.'
##    Owner = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The description of the domain.'
##        #return Description
##    def _set(self, Description):
##        u'The description of the domain.'
##    Description = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def Type(self):
##        u'The domain type.'
##        #return Type
##
##    def _get(self):
##        u'The split policy.'
##        #return policy
##    def _set(self, policy):
##        u'The split policy.'
##    SplitPolicy = property(_get, _set, doc = _set.__doc__)
##

class IDatabaseConnectionInfo3(IDatabaseConnectionInfo2):
    _case_insensitive_ = True
    u"Provides access to members that provide information about the Workspace's connected database."
    _iid_ = GUID('{BB7BD22E-A5CB-44D8-9130-7C729D6E6FD1}')
    _idlflags_ = ['oleautomation']
IDatabaseConnectionInfo3._methods_ = [
    COMMETHOD(['propget', helpstring(u'The current connections to the database.')], HRESULT, 'ConnectedUsers',
              ( ['retval', 'out'], POINTER(POINTER(IEnumUserInfo)), 'ConnectedUsers' )),
    COMMETHOD([helpstring(u'Disconnect a user connection to the database.')], HRESULT, 'DisconnectUser',
              ( ['in'], c_int, 'SessionID' )),
    COMMETHOD(['propput', helpstring(u'Is the database accepting connections.')], HRESULT, 'IsAcceptingConnections',
              ( ['in'], VARIANT_BOOL, 'acceptingConnections' )),
    COMMETHOD(['propget', helpstring(u'Is the database accepting connections.')], HRESULT, 'IsAcceptingConnections',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'acceptingConnections' )),
    COMMETHOD(['propget', helpstring(u"The name of the connected database. It may be different from the DATABASE property in the workspace's connection properties. Works on Oracle.")], HRESULT, 'ConnectedDatabaseEx',
              ( ['retval', 'out'], POINTER(BSTR), 'ConnectedDatabase' )),
]
################################################################
## code template for IDatabaseConnectionInfo3 implementation
##class IDatabaseConnectionInfo3_Impl(object):
##    @property
##    def ConnectedUsers(self):
##        u'The current connections to the database.'
##        #return ConnectedUsers
##
##    def _get(self):
##        u'Is the database accepting connections.'
##        #return acceptingConnections
##    def _set(self, acceptingConnections):
##        u'Is the database accepting connections.'
##    IsAcceptingConnections = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def ConnectedDatabaseEx(self):
##        u"The name of the connected database. It may be different from the DATABASE property in the workspace's connection properties. Works on Oracle."
##        #return ConnectedDatabase
##
##    def DisconnectUser(self, SessionID):
##        u'Disconnect a user connection to the database.'
##        #return 
##

class IRemoteDatabaseWorkspaceFactory2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage remote geodatabase database connection information.'
    _iid_ = GUID('{02DDEFE3-468D-456D-A862-53296B590988}')
    _idlflags_ = ['oleautomation']
IRemoteDatabaseWorkspaceFactory2._methods_ = [
    COMMETHOD([helpstring(u'Edits the geodatabase connection properties of a remote database workspace connection file.')], HRESULT, 'EditGeodatabaseConnectionProperties',
              ( ['in'], BSTR, 'PathName' ),
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'hWnd' ),
              ( ['retval', 'out'], POINTER(POINTER(IWorkspaceName)), 'WorkspaceName' )),
]
################################################################
## code template for IRemoteDatabaseWorkspaceFactory2 implementation
##class IRemoteDatabaseWorkspaceFactory2_Impl(object):
##    def EditGeodatabaseConnectionProperties(self, PathName, hWnd):
##        u'Edits the geodatabase connection properties of a remote database workspace connection file.'
##        #return WorkspaceName
##

class IObjectClass2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about an object class.'
    _iid_ = GUID('{6A911226-CEF7-4D30-A24E-2A0A1385A36D}')
    _idlflags_ = ['oleautomation']
IObjectClass2._methods_ = [
    COMMETHOD([helpstring(u'Rebuild the spatial index of this object class.')], HRESULT, 'RebuildSpatialIndex',
              ( ['in'], POINTER(IIndex), 'Index' )),
]
################################################################
## code template for IObjectClass2 implementation
##class IObjectClass2_Impl(object):
##    def RebuildSpatialIndex(self, Index):
##        u'Rebuild the spatial index of this object class.'
##        #return 
##

IFields._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of fields in the fields collection.')], HRESULT, 'FieldCount',
              ( ['retval', 'out'], POINTER(c_int), 'numFields' )),
    COMMETHOD(['propget', helpstring(u'The field at the specified index in the fields collection.')], HRESULT, 'Field',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IField)), 'Field' )),
    COMMETHOD([helpstring(u'Finds the index of the named field in the fields collection.')], HRESULT, 'FindField',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(c_int), 'Index' )),
    COMMETHOD([helpstring(u'Finds the index of the field with the alias name in the fields collection.')], HRESULT, 'FindFieldByAliasName',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(c_int), 'Index' )),
]
################################################################
## code template for IFields implementation
##class IFields_Impl(object):
##    @property
##    def Field(self, Index):
##        u'The field at the specified index in the fields collection.'
##        #return Field
##
##    @property
##    def FieldCount(self):
##        u'The number of fields in the fields collection.'
##        #return numFields
##
##    def FindFieldByAliasName(self, Name):
##        u'Finds the index of the field with the alias name in the fields collection.'
##        #return Index
##
##    def FindField(self, Name):
##        u'Finds the index of the named field in the fields collection.'
##        #return Index
##

IObjectClassSchemaEvents._methods_ = [
    COMMETHOD([helpstring(u'This event is fired when a new field is added to the object class.')], HRESULT, 'OnAddField',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD([helpstring(u'This event is fired when a field is deleted from the object class.')], HRESULT, 'OnDeleteField',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD([helpstring(u'This event is fired when the behavior class for the object class changes.')], HRESULT, 'OnBehaviorChanged'),
]
################################################################
## code template for IObjectClassSchemaEvents implementation
##class IObjectClassSchemaEvents_Impl(object):
##    def OnBehaviorChanged(self):
##        u'This event is fired when the behavior class for the object class changes.'
##        #return 
##
##    def OnDeleteField(self, FieldName):
##        u'This event is fired when a field is deleted from the object class.'
##        #return 
##
##    def OnAddField(self, FieldName):
##        u'This event is fired when a new field is added to the object class.'
##        #return 
##

class IEnumWorkspaceEx(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate workspaces.'
    _iid_ = GUID('{10D42686-2F6E-4D6A-A27D-1823FFAD34EC}')
    _idlflags_ = ['oleautomation']
IEnumWorkspaceEx._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next workspace in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'ws' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumWorkspaceEx implementation
##class IEnumWorkspaceEx_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next workspace in the enumeration sequence.'
##        #return ws
##

IDatasetComponent._methods_ = [
    COMMETHOD(['propget', helpstring(u'The data element corresponding to the dataset component.')], HRESULT, 'DataElement',
              ( ['retval', 'out'], POINTER(POINTER(IDEDataset)), 'DataElement' )),
    COMMETHOD(['propget', helpstring(u'The containing parent dataset.')], HRESULT, 'Parent',
              ( ['retval', 'out'], POINTER(POINTER(IDataset)), 'Dataset' )),
]
################################################################
## code template for IDatasetComponent implementation
##class IDatasetComponent_Impl(object):
##    @property
##    def DataElement(self):
##        u'The data element corresponding to the dataset component.'
##        #return DataElement
##
##    @property
##    def Parent(self):
##        u'The containing parent dataset.'
##        #return Dataset
##

IRelationshipClassEvents._methods_ = [
    COMMETHOD([helpstring(u'This event is fired when a new relationship is created in the relationship class.')], HRESULT, 'OnCreate',
              ( ['in'], POINTER(IRelationship), 'rel' )),
    COMMETHOD([helpstring(u'This event is fired when an relationship is deleted from the relationship class.')], HRESULT, 'OnDelete',
              ( ['in'], POINTER(IRelationship), 'rel' )),
    COMMETHOD([helpstring(u"This event is fired when a relationship's attributes are updated.")], HRESULT, 'OnChange',
              ( ['in'], POINTER(IRelationship), 'rel' )),
]
################################################################
## code template for IRelationshipClassEvents implementation
##class IRelationshipClassEvents_Impl(object):
##    def OnDelete(self, rel):
##        u'This event is fired when an relationship is deleted from the relationship class.'
##        #return 
##
##    def OnCreate(self, rel):
##        u'This event is fired when a new relationship is created in the relationship class.'
##        #return 
##
##    def OnChange(self, rel):
##        u"This event is fired when a relationship's attributes are updated."
##        #return 
##

class IEnumEdgeFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate edge features and resets the enumeration.'
    _iid_ = GUID('{655E3F50-55FC-11D1-AE55-0000F80372B4}')
    _idlflags_ = ['oleautomation']
IEnumEdgeFeature._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next EdgeFeature in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IEdgeFeature)), 'Edge' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumEdgeFeature implementation
##class IEnumEdgeFeature_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next EdgeFeature in the enumeration sequence.'
##        #return Edge
##

class IEnterpriseWorkspaceFactory(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage enterprise workspace.'
    _iid_ = GUID('{B871B848-7B8F-4AEF-BD4D-EC3AEFE76EBF}')
    _idlflags_ = ['oleautomation']
IEnterpriseWorkspaceFactory._methods_ = [
    COMMETHOD([helpstring(u"Opens the workspace specified by the connection properties. Changes the connection password if it's expiring or expired.")], HRESULT, 'OpenWithNewPassword',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'ConnectionProperties' ),
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'hWnd' ),
              ( ['in'], BSTR, 'newPassword' ),
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'Workspace' )),
    COMMETHOD([helpstring(u'Open the enterprise database connection with new license file.')], HRESULT, 'OpenWithNewLicense',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'ConnectionProperties' ),
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'hWnd' ),
              ( ['in'], BSTR, 'newLicensePath' ),
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'Workspace' )),
]
################################################################
## code template for IEnterpriseWorkspaceFactory implementation
##class IEnterpriseWorkspaceFactory_Impl(object):
##    def OpenWithNewLicense(self, ConnectionProperties, hWnd, newLicensePath):
##        u'Open the enterprise database connection with new license file.'
##        #return Workspace
##
##    def OpenWithNewPassword(self, ConnectionProperties, hWnd, newPassword):
##        u"Opens the workspace specified by the connection properties. Changes the connection password if it's expiring or expired."
##        #return Workspace
##

IField._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the field.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The alias name of the field.')], HRESULT, 'AliasName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The type of the field.')], HRESULT, 'Type',
              ( ['retval', 'out'], POINTER(esriFieldType), 'Type' )),
    COMMETHOD(['propget', helpstring(u'The default domain of the field.')], HRESULT, 'Domain',
              ( ['retval', 'out'], POINTER(POINTER(IDomain)), 'Domain' )),
    COMMETHOD(['propget', helpstring(u'The default value of the field.')], HRESULT, 'DefaultValue',
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
    COMMETHOD(['propget', helpstring(u'The maximum length, in bytes, for values described by the field.')], HRESULT, 'Length',
              ( ['retval', 'out'], POINTER(c_int), 'Length' )),
    COMMETHOD(['propget', helpstring(u'The precision for field values.')], HRESULT, 'Precision',
              ( ['retval', 'out'], POINTER(c_int), 'Length' )),
    COMMETHOD(['propget', helpstring(u'The scale for field values.')], HRESULT, 'Scale',
              ( ['retval', 'out'], POINTER(c_int), 'Length' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the field can contain null values.')], HRESULT, 'IsNullable',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsNullable' )),
    COMMETHOD(['propget', helpstring(u'The geometry definition for the field if IsGeometry is TRUE.')], HRESULT, 'GeometryDef',
              ( ['retval', 'out'], POINTER(POINTER(IGeometryDef)), 'GeometryDef' )),
    COMMETHOD(['propget', helpstring(u'The VARTYPE of the field (e.g. VT_I4).')], HRESULT, 'VarType',
              ( ['retval', 'out'], POINTER(c_int), 'VarType' )),
    COMMETHOD(['propget', helpstring(u"Indicates if the field's domain is fixed.")], HRESULT, 'DomainFixed',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isFixed' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the field is required.')], HRESULT, 'Required',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsRequired' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the field is editable.')], HRESULT, 'Editable',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsEditable' )),
    COMMETHOD([helpstring(u'Indicates if the value is valid given the field definition.')], HRESULT, 'CheckValue',
              ( ['in'], VARIANT, 'Value' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isValidValue' )),
]
################################################################
## code template for IField implementation
##class IField_Impl(object):
##    @property
##    def Domain(self):
##        u'The default domain of the field.'
##        #return Domain
##
##    @property
##    def Scale(self):
##        u'The scale for field values.'
##        #return Length
##
##    @property
##    def Name(self):
##        u'The name of the field.'
##        #return Name
##
##    def CheckValue(self, Value):
##        u'Indicates if the value is valid given the field definition.'
##        #return isValidValue
##
##    @property
##    def DefaultValue(self):
##        u'The default value of the field.'
##        #return Value
##
##    @property
##    def Required(self):
##        u'Indicates if the field is required.'
##        #return IsRequired
##
##    @property
##    def Editable(self):
##        u'Indicates if the field is editable.'
##        #return IsEditable
##
##    @property
##    def Precision(self):
##        u'The precision for field values.'
##        #return Length
##
##    @property
##    def Length(self):
##        u'The maximum length, in bytes, for values described by the field.'
##        #return Length
##
##    @property
##    def AliasName(self):
##        u'The alias name of the field.'
##        #return Name
##
##    @property
##    def GeometryDef(self):
##        u'The geometry definition for the field if IsGeometry is TRUE.'
##        #return GeometryDef
##
##    @property
##    def DomainFixed(self):
##        u"Indicates if the field's domain is fixed."
##        #return isFixed
##
##    @property
##    def VarType(self):
##        u'The VARTYPE of the field (e.g. VT_I4).'
##        #return VarType
##
##    @property
##    def Type(self):
##        u'The type of the field.'
##        #return Type
##
##    @property
##    def IsNullable(self):
##        u'Indicates if the field can contain null values.'
##        #return IsNullable
##

IWorkspaceProperty._methods_ = [
    COMMETHOD(['propget', helpstring(u'The value of this property.')], HRESULT, 'PropertyValue',
              ( ['retval', 'out'], POINTER(VARIANT), 'PropertyValue' )),
    COMMETHOD(['propput', helpstring(u'The value of this property.')], HRESULT, 'PropertyValue',
              ( ['in'], VARIANT, 'PropertyValue' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this property is read only.')], HRESULT, 'IsReadOnly',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsReadOnly' )),
    COMMETHOD(['propput', helpstring(u'Indicates if this property is read only.')], HRESULT, 'IsReadOnly',
              ( ['in'], VARIANT_BOOL, 'IsReadOnly' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this property is supported.')], HRESULT, 'IsSupported',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsSupported' )),
    COMMETHOD(['propput', helpstring(u'Indicates if this property is supported.')], HRESULT, 'IsSupported',
              ( ['in'], VARIANT_BOOL, 'IsSupported' )),
]
################################################################
## code template for IWorkspaceProperty implementation
##class IWorkspaceProperty_Impl(object):
##    def _get(self):
##        u'Indicates if this property is read only.'
##        #return IsReadOnly
##    def _set(self, IsReadOnly):
##        u'Indicates if this property is read only.'
##    IsReadOnly = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if this property is supported.'
##        #return IsSupported
##    def _set(self, IsSupported):
##        u'Indicates if this property is supported.'
##    IsSupported = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The value of this property.'
##        #return PropertyValue
##    def _set(self, PropertyValue):
##        u'The value of this property.'
##    PropertyValue = property(_get, _set, doc = _set.__doc__)
##

class IRemoteDatabaseWorkspaceFactory(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage remote database connection information.'
    _iid_ = GUID('{AB4A2D7A-055B-11D2-AA97-00C04FA33A15}')
    _idlflags_ = ['oleautomation']
IRemoteDatabaseWorkspaceFactory._methods_ = [
    COMMETHOD([helpstring(u'Deletes the remote database workspace connection file.')], HRESULT, 'DeleteConnectionFile',
              ( ['in'], BSTR, 'PathName' )),
    COMMETHOD([helpstring(u'Renames the remote database workspace connection file.')], HRESULT, 'RenameConnectionFile',
              ( ['in'], BSTR, 'oldPathName' ),
              ( ['in'], BSTR, 'newName' ),
              ( ['retval', 'out'], POINTER(POINTER(IWorkspaceName)), 'WorkspaceName' )),
    COMMETHOD([helpstring(u'Edits the properties of a remote database workspace connection file.')], HRESULT, 'EditConnectionFile',
              ( ['in'], BSTR, 'PathName' ),
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'hWnd' ),
              ( ['retval', 'out'], POINTER(POINTER(IWorkspaceName)), 'WorkspaceName' )),
]
################################################################
## code template for IRemoteDatabaseWorkspaceFactory implementation
##class IRemoteDatabaseWorkspaceFactory_Impl(object):
##    def EditConnectionFile(self, PathName, hWnd):
##        u'Edits the properties of a remote database workspace connection file.'
##        #return WorkspaceName
##
##    def DeleteConnectionFile(self, PathName):
##        u'Deletes the remote database workspace connection file.'
##        #return 
##
##    def RenameConnectionFile(self, oldPathName, newName):
##        u'Renames the remote database workspace connection file.'
##        #return WorkspaceName
##

class TopologyWorkspaceExtension(CoClass):
    u'Esri Topology Workspace Extension object.'
    _reg_clsid_ = GUID('{8C690139-67BE-4B5F-86D7-B73474DB26D0}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TopologyWorkspaceExtension._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IWorkspaceExtension, IWorkspaceExtensionControl]

IWorkspaceProperties._methods_ = [
    COMMETHOD(['propget', helpstring(u'Information about this particular property.')], HRESULT, 'Property',
              ( ['in'], esriWorkspacePropertyGroupType, 'propertyGroup' ),
              ( ['in'], c_int, 'PropertyType' ),
              ( ['retval', 'out'], POINTER(POINTER(IWorkspaceProperty)), 'WorkspaceProperty' )),
    COMMETHOD(['propput', helpstring(u'Information about this particular property.')], HRESULT, 'Property',
              ( ['in'], esriWorkspacePropertyGroupType, 'propertyGroup' ),
              ( ['in'], c_int, 'PropertyType' ),
              ( ['in'], POINTER(IWorkspaceProperty), 'WorkspaceProperty' )),
]
################################################################
## code template for IWorkspaceProperties implementation
##class IWorkspaceProperties_Impl(object):
##    def _get(self, propertyGroup, PropertyType):
##        u'Information about this particular property.'
##        #return WorkspaceProperty
##    def _set(self, propertyGroup, PropertyType, WorkspaceProperty):
##        u'Information about this particular property.'
##    Property = property(_get, _set, doc = _set.__doc__)
##

class IGeodatabaseRelease2(IGeodatabaseRelease):
    _case_insensitive_ = True
    u'Provides access to members that provide information about the release version of a geodatabase.'
    _iid_ = GUID('{92CA80CA-081B-40C2-A444-9357C681E53C}')
    _idlflags_ = ['oleautomation']
class IGeodatabaseRelease3(IGeodatabaseRelease2):
    _case_insensitive_ = True
    u'Provides access to members that provide information about the release version of a geodatabase.'
    _iid_ = GUID('{3B4AAA9D-98F3-4D9D-B561-B58C75A4338C}')
    _idlflags_ = ['oleautomation']
class IGeodatabaseRelease4(IGeodatabaseRelease3):
    _case_insensitive_ = True
    u'Provides access to members that provide information about the release version of a geodatabase.'
    _iid_ = GUID('{8E602B66-BE7F-4D4E-9340-50DF434480AD}')
    _idlflags_ = ['oleautomation']
IGeodatabaseRelease._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the geodatabase can be upgraded with this interface. If not, then another utility must be used to upgrade it.')], HRESULT, 'CanUpgrade',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanUpgrade' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the geodatabase at the current release level.')], HRESULT, 'CurrentRelease',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isCurrent' )),
    COMMETHOD(['propget', helpstring(u'Geodatabase major version level.')], HRESULT, 'MajorVersion',
              ( ['retval', 'out'], POINTER(c_int), 'versionNumber' )),
    COMMETHOD(['propget', helpstring(u'Geodatabase minor version level.')], HRESULT, 'MinorVersion',
              ( ['retval', 'out'], POINTER(c_int), 'versionNumber' )),
    COMMETHOD(['propget', helpstring(u'Geodatabase bugfix version level.')], HRESULT, 'BugfixVersion',
              ( ['retval', 'out'], POINTER(c_int), 'versionNumber' )),
    COMMETHOD([helpstring(u'Upgrade the database to the current release level.')], HRESULT, 'Upgrade'),
]
################################################################
## code template for IGeodatabaseRelease implementation
##class IGeodatabaseRelease_Impl(object):
##    @property
##    def MajorVersion(self):
##        u'Geodatabase major version level.'
##        #return versionNumber
##
##    def Upgrade(self):
##        u'Upgrade the database to the current release level.'
##        #return 
##
##    @property
##    def MinorVersion(self):
##        u'Geodatabase minor version level.'
##        #return versionNumber
##
##    @property
##    def CurrentRelease(self):
##        u'Indicates if the geodatabase at the current release level.'
##        #return isCurrent
##
##    @property
##    def BugfixVersion(self):
##        u'Geodatabase bugfix version level.'
##        #return versionNumber
##
##    @property
##    def CanUpgrade(self):
##        u'Indicates if the geodatabase can be upgraded with this interface. If not, then another utility must be used to upgrade it.'
##        #return CanUpgrade
##

IGeodatabaseRelease2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates whether the workspace supports the specified dataset type.')], HRESULT, 'DatasetSupported',
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'canSupport' )),
]
################################################################
## code template for IGeodatabaseRelease2 implementation
##class IGeodatabaseRelease2_Impl(object):
##    @property
##    def DatasetSupported(self, Type):
##        u'Indicates whether the workspace supports the specified dataset type.'
##        #return canSupport
##

IGeodatabaseRelease3._methods_ = [
    COMMETHOD([helpstring(u'Upgrade the database to the current release level.')], HRESULT, 'Upgrade2',
              ( ['in'], VARIANT_BOOL, 'doPrerequisiteCheck' ),
              ( ['in'], VARIANT_BOOL, 'doUpgrade' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITrackCancel), 'cancelTrack' ),
              ( ['in'], POINTER(IGPMessages), 'Messages' )),
]
################################################################
## code template for IGeodatabaseRelease3 implementation
##class IGeodatabaseRelease3_Impl(object):
##    def Upgrade2(self, doPrerequisiteCheck, doUpgrade, cancelTrack, Messages):
##        u'Upgrade the database to the current release level.'
##        #return 
##

IGeodatabaseRelease4._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the geodatabase system tables are at the current release level.')], HRESULT, 'GeodatabaseCurrent',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isGeodatabaseCurrent' )),
]
################################################################
## code template for IGeodatabaseRelease4 implementation
##class IGeodatabaseRelease4_Impl(object):
##    @property
##    def GeodatabaseCurrent(self):
##        u'Indicates if the geodatabase system tables are at the current release level.'
##        #return isGeodatabaseCurrent
##

IVersionEvents2._methods_ = [
    COMMETHOD([helpstring(u'This event is fired after the historical archive has been updated with changes saved or posted to the DEFAULT version.')], HRESULT, 'OnArchiveUpdated',
              ( ['in'], VARIANT, 'archiveTransactionTime' )),
    COMMETHOD([helpstring(u'This event is fired before a version is reconciled.')], HRESULT, 'OnBeginReconcile',
              ( ['in'], BSTR, 'targetVersionName' )),
    COMMETHOD([helpstring(u'This event is fired after a version is posted.')], HRESULT, 'OnPost',
              ( ['in'], BSTR, 'targetVersionName' )),
    COMMETHOD([helpstring(u'This event is fired before a version is deleted.')], HRESULT, 'OnDeleteVersion',
              ( ['in'], BSTR, 'VersionName' )),
]
################################################################
## code template for IVersionEvents2 implementation
##class IVersionEvents2_Impl(object):
##    def OnDeleteVersion(self, VersionName):
##        u'This event is fired before a version is deleted.'
##        #return 
##
##    def OnBeginReconcile(self, targetVersionName):
##        u'This event is fired before a version is reconciled.'
##        #return 
##
##    def OnArchiveUpdated(self, archiveTransactionTime):
##        u'This event is fired after the historical archive has been updated with changes saved or posted to the DEFAULT version.'
##        #return 
##
##    def OnPost(self, targetVersionName):
##        u'This event is fired after a version is posted.'
##        #return 
##

class ISqlWorkspace(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Query layer workspace interface'
    _iid_ = GUID('{EED692F3-04E5-42D8-A232-4AAD0085E471}')
    _idlflags_ = ['oleautomation']
ISqlWorkspace._methods_ = [
    COMMETHOD([helpstring(u'Get query properties including spatial based on the first record of the query.')], HRESULT, 'GetQueryDescription',
              ( ['in'], BSTR, 'Query' ),
              ( ['retval', 'out'], POINTER(POINTER(IQueryDescription)), 'ppQueryDescription' )),
    COMMETHOD([helpstring(u'Returns a table or a feature class based on a query.')], HRESULT, 'OpenQueryClass',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IQueryDescription), 'pQueryDescription' ),
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'ppTable' )),
    COMMETHOD([helpstring(u'Returns a cursor based on a query.')], HRESULT, 'OpenQueryCursor',
              ( ['in'], BSTR, 'Query' ),
              ( ['retval', 'out'], POINTER(POINTER(ICursor)), 'ppCursor' )),
    COMMETHOD([helpstring(u'Returns names of all the table.')], HRESULT, 'GetTables',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'ppTableNames' )),
    COMMETHOD([helpstring(u'Returns column information for a table.')], HRESULT, 'GetColumns',
              ( ['in'], BSTR, 'TableName' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'ppColumnName' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'ppColumnType' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IVariantArray)), 'ppIsNullable' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray)), 'ppSize' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray)), 'ppPrecision' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray)), 'ppScale' )),
    COMMETHOD([helpstring(u'Returns unique name in the workspace.')], HRESULT, 'CheckDatasetName',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IQueryDescription), 'pQueryDescription' ),
              ( ['out'], POINTER(BSTR), 'pNewName' )),
]
################################################################
## code template for ISqlWorkspace implementation
##class ISqlWorkspace_Impl(object):
##    def CheckDatasetName(self, Name, pQueryDescription):
##        u'Returns unique name in the workspace.'
##        #return pNewName
##
##    def OpenQueryCursor(self, Query):
##        u'Returns a cursor based on a query.'
##        #return ppCursor
##
##    def GetColumns(self, TableName):
##        u'Returns column information for a table.'
##        #return ppColumnName, ppColumnType, ppIsNullable, ppSize, ppPrecision, ppScale
##
##    def GetTables(self):
##        u'Returns names of all the table.'
##        #return ppTableNames
##
##    def OpenQueryClass(self, Name, pQueryDescription):
##        u'Returns a table or a feature class based on a query.'
##        #return ppTable
##
##    def GetQueryDescription(self, Query):
##        u'Get query properties including spatial based on the first record of the query.'
##        #return ppQueryDescription
##

class IPlugInMetadata(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage property set metadata for a plug-in.'
    _iid_ = GUID('{A21946CE-11A9-4241-84F5-7B10C1D6D8B9}')
    _idlflags_ = ['oleautomation']
class IPlugInMetadata2(IPlugInMetadata):
    _case_insensitive_ = True
    u'Provides access to members that manage property set metadata for a plug-in.'
    _iid_ = GUID('{C8E04D84-6557-40C5-A30A-B564C4D00560}')
    _idlflags_ = ['oleautomation']
IPlugInMetadata._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the metadata for the indicated dataset currently writable.')], HRESULT, 'CanEditMetadata',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanEdit' )),
    COMMETHOD(['propget', helpstring(u'A property set containing the metadata for the indicated dataset.')], HRESULT, 'Metadata',
              ( ['in'], BSTR, 'localName' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'Metadata' )),
    COMMETHOD(['propput', helpstring(u'A property set containing the metadata for the indicated dataset.')], HRESULT, 'Metadata',
              ( ['in'], BSTR, 'localName' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'Metadata' )),
]
################################################################
## code template for IPlugInMetadata implementation
##class IPlugInMetadata_Impl(object):
##    @property
##    def CanEditMetadata(self):
##        u'Indicates if the metadata for the indicated dataset currently writable.'
##        #return CanEdit
##
##    def _get(self, localName):
##        u'A property set containing the metadata for the indicated dataset.'
##        #return Metadata
##    def _set(self, localName, Metadata):
##        u'A property set containing the metadata for the indicated dataset.'
##    Metadata = property(_get, _set, doc = _set.__doc__)
##

IPlugInMetadata2._methods_ = [
    COMMETHOD(['propget', helpstring(u'A property set containing the metadata for the indicated dataset.')], HRESULT, 'MetadataByType',
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['in'], BSTR, 'localName' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'Metadata' )),
    COMMETHOD(['propput', helpstring(u'A property set containing the metadata for the indicated dataset.')], HRESULT, 'MetadataByType',
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['in'], BSTR, 'localName' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'Metadata' )),
]
################################################################
## code template for IPlugInMetadata2 implementation
##class IPlugInMetadata2_Impl(object):
##    def _get(self, Type, localName):
##        u'A property set containing the metadata for the indicated dataset.'
##        #return Metadata
##    def _set(self, Type, localName, Metadata):
##        u'A property set containing the metadata for the indicated dataset.'
##    MetadataByType = property(_get, _set, doc = _set.__doc__)
##

class IPlugInMetadataPath(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage file metadata for a plug-in.'
    _iid_ = GUID('{62E8C42D-1B76-497E-8865-D53E2B65C98C}')
    _idlflags_ = ['oleautomation']
class IPlugInMetadataPath2(IPlugInMetadataPath):
    _case_insensitive_ = True
    u'Provides access to members that manage file metadata for a plug-in.'
    _iid_ = GUID('{E67BE0CA-2683-4508-BC43-4FE4D381A7DD}')
    _idlflags_ = ['oleautomation']
IPlugInMetadataPath._methods_ = [
    COMMETHOD(['propget', helpstring(u'The path to the metadata file for the dataset indentified by localName.')], HRESULT, 'MetadataPath',
              ( ['in'], BSTR, 'localName' ),
              ( ['retval', 'out'], POINTER(BSTR), 'MetadataPath' )),
]
################################################################
## code template for IPlugInMetadataPath implementation
##class IPlugInMetadataPath_Impl(object):
##    @property
##    def MetadataPath(self, localName):
##        u'The path to the metadata file for the dataset indentified by localName.'
##        #return MetadataPath
##

IPlugInMetadataPath2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The path to the metadata file for the dataset indentified by localName.')], HRESULT, 'MetadataPathByType',
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['in'], BSTR, 'localName' ),
              ( ['retval', 'out'], POINTER(BSTR), 'MetadataPath' )),
]
################################################################
## code template for IPlugInMetadataPath2 implementation
##class IPlugInMetadataPath2_Impl(object):
##    @property
##    def MetadataPathByType(self, Type, localName):
##        u'The path to the metadata file for the dataset indentified by localName.'
##        #return MetadataPath
##

IFeatureClassDescription._methods_ = [
    COMMETHOD(['propget', helpstring(u'The esriFeatureType for the instances of this class.')], HRESULT, 'FeatureType',
              ( ['retval', 'out'], POINTER(esriFeatureType), 'FeatureType' )),
    COMMETHOD(['propget', helpstring(u'The name of the field containing the shape.')], HRESULT, 'ShapeFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
]
################################################################
## code template for IFeatureClassDescription implementation
##class IFeatureClassDescription_Impl(object):
##    @property
##    def FeatureType(self):
##        u'The esriFeatureType for the instances of this class.'
##        #return FeatureType
##
##    @property
##    def ShapeFieldName(self):
##        u'The name of the field containing the shape.'
##        #return Name
##

class FeatureClass(CoClass):
    u'Esri Feature Class object.'
    _reg_clsid_ = GUID('{AF10D71B-A61B-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ITopologyClass(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to topology class members.'
    _iid_ = GUID('{FB93B289-790E-42B6-9DD3-8F0C0728DA9F}')
    _idlflags_ = ['oleautomation']
class IFeatureClassLoad(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the load mode of a GDB feature class.'
    _iid_ = GUID('{C3BFF943-E069-11D1-AA82-00C04FA37585}')
    _idlflags_ = ['oleautomation']
class INetworkClass(IFeatureClass):
    _case_insensitive_ = True
    u'Provides access to members that return information about geometric networks, field weighting and ancillary roles.'
    _iid_ = GUID('{EE2896B0-5ED8-11D2-AA8A-00C04FA37B82}')
    _idlflags_ = ['oleautomation']
FeatureClass._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDataset, IDatasetEdit, IDatasetEditInfo, IDatasetAnalyze, ISchemaLock, IClass, ITable, IObjectClass, IClassSchemaEdit, IClassSchemaEdit2, IModelInfo, ITopologyClass, ISubtypes, IValidation, IValidation2, IObjectClassInfo, IObjectClassInfo2, IFeatureClass, IGeoDataset, IFeatureClassWrite, IFeatureClassLoad, INetworkClass, ITableCapabilities, IFeatureClassManage]

class IPlugInNetworkDatasetContainer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that get network datasets from plug-in workspaces and feature datasets.'
    _iid_ = GUID('{BD7ACDDC-C32A-4068-925B-9C3EB1345F04}')
    _idlflags_ = ['oleautomation']
IPlugInNetworkDatasetContainer._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of NetworkDatasets in this container.')], HRESULT, 'NetworkDatasetCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The NetworkDataset specified by the index.')], HRESULT, 'NetworkDataset',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(INetworkDataset)), 'NetworkDataset' )),
    COMMETHOD(['propget', helpstring(u'The NetworkDataset with the specified name.')], HRESULT, 'NetworkDatasetByName',
              ( ['in'], BSTR, 'NetworkName' ),
              ( ['retval', 'out'], POINTER(POINTER(INetworkDataset)), 'NetworkDataset' )),
    COMMETHOD(['propget', helpstring(u'The NetworkDatasets in this container.')], HRESULT, 'NetworkDatasets',
              ( ['retval', 'out'], POINTER(POINTER(IEnumDataset)), 'NetworkDatasetNames' )),
    COMMETHOD(['propget', helpstring(u'The names of the NetworkDatasets in this container.')], HRESULT, 'NetworkDatasetNames',
              ( ['retval', 'out'], POINTER(POINTER(IEnumDatasetName)), 'NetworkDatasetNames' )),
]
################################################################
## code template for IPlugInNetworkDatasetContainer implementation
##class IPlugInNetworkDatasetContainer_Impl(object):
##    @property
##    def NetworkDatasetByName(self, NetworkName):
##        u'The NetworkDataset with the specified name.'
##        #return NetworkDataset
##
##    @property
##    def NetworkDataset(self, Index):
##        u'The NetworkDataset specified by the index.'
##        #return NetworkDataset
##
##    @property
##    def NetworkDatasets(self):
##        u'The NetworkDatasets in this container.'
##        #return NetworkDatasetNames
##
##    @property
##    def NetworkDatasetCount(self):
##        u'The number of NetworkDatasets in this container.'
##        #return Count
##
##    @property
##    def NetworkDatasetNames(self):
##        u'The names of the NetworkDatasets in this container.'
##        #return NetworkDatasetNames
##

IObjectClassDescription._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name for this class, e.g., Esri Simple Junction Feature.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The alias name of this class.')], HRESULT, 'AliasName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The model name of this class.')], HRESULT, 'ModelName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the model name of this class is unique.')], HRESULT, 'ModelNameUnique',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsUnique' )),
    COMMETHOD(['propget', helpstring(u'The CLSID of the COM class that implements instance level behavior.')], HRESULT, 'InstanceCLSID',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'InstanceCLSID' )),
    COMMETHOD(['propget', helpstring(u'The CLSID of the class extension COM class that implements class level behavior.')], HRESULT, 'ClassExtensionCLSID',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'ClassExtensionCLSID' )),
    COMMETHOD(['propget', helpstring(u'The descriptions of the set of required fields for this class.')], HRESULT, 'RequiredFields',
              ( ['retval', 'out'], POINTER(POINTER(IFields)), 'fieldDescription' )),
]
################################################################
## code template for IObjectClassDescription implementation
##class IObjectClassDescription_Impl(object):
##    @property
##    def ModelName(self):
##        u'The model name of this class.'
##        #return Name
##
##    @property
##    def Name(self):
##        u'The name for this class, e.g., Esri Simple Junction Feature.'
##        #return Name
##
##    @property
##    def ModelNameUnique(self):
##        u'Indicates if the model name of this class is unique.'
##        #return IsUnique
##
##    @property
##    def ClassExtensionCLSID(self):
##        u'The CLSID of the class extension COM class that implements class level behavior.'
##        #return ClassExtensionCLSID
##
##    @property
##    def AliasName(self):
##        u'The alias name of this class.'
##        #return Name
##
##    @property
##    def RequiredFields(self):
##        u'The descriptions of the set of required fields for this class.'
##        #return fieldDescription
##
##    @property
##    def InstanceCLSID(self):
##        u'The CLSID of the COM class that implements instance level behavior.'
##        #return InstanceCLSID
##

IDENetworkDatasetType._methods_ = [
]
################################################################
## code template for IDENetworkDatasetType implementation
##class IDENetworkDatasetType_Impl(object):


# values for enumeration 'esriNetworkJunctionConnectivityPolicy'
esriNJCPHonor = 0
esriNJCPOverride = 1
esriNetworkJunctionConnectivityPolicy = c_int # enum
class IEnumFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that hand out enumerated features and reset the enumeration.'
    _iid_ = GUID('{E373DB08-56FF-11D1-AE55-0000F80372B4}')
    _idlflags_ = ['oleautomation']
IGraph._methods_ = [
    COMMETHOD(['hidden', helpstring(u'Adds the preexisting Feature to the graph.')], HRESULT, 'Add',
              ( ['in'], POINTER(IFeature), 'NewFeature' )),
    COMMETHOD([helpstring(u'Add the FeatureClass to this graph.')], HRESULT, 'AddFeatureClass',
              ( ['in'], POINTER(IFeatureClass), 'FeatureClass' ),
              ( ['in'], BSTR, 'EnabledFieldName' ),
              ( ['in'], esriNetworkClassAncillaryRole, 'Role' ),
              ( ['in'], BSTR, 'AncillaryRoleFieldName' )),
    COMMETHOD([helpstring(u'Removes the set of Feature from the graph.')], HRESULT, 'DeleteSet',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'featuresToDelete' )),
    COMMETHOD(['propget', helpstring(u'The FeatureDataset associated with the graph.')], HRESULT, 'FeatureDataset',
              ( ['retval', 'out'], POINTER(POINTER(IFeatureDataset)), 'FeatureDataset' )),
    COMMETHOD(['hidden', helpstring(u'The DisplayFeedback.')], HRESULT, 'GetDisplayFeedback',
              ( ['in'], POINTER(IFeature), 'Feature' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'features' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'point' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IDisplayFeedback)), 'feedback' )),
    COMMETHOD([helpstring(u'Initializes the graph.')], HRESULT, 'Init',
              ( ['in'], POINTER(IFeatureDataset), 'Dataset' ),
              ( ['in'], c_int, 'graphID' ),
              ( ['in'], BSTR, 'graphName' ),
              ( ['in'], VARIANT_BOOL, 'buildNormalizedTables' ),
              ( ['in'], VARIANT_BOOL, 'createGraph' )),
    COMMETHOD([helpstring(u'Merges the Features together, returning the newly created Feature.')], HRESULT, 'Merge',
              ( ['in'], POINTER(IEnumFeature), 'mergingFeatures' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumFeature)), 'newFeatures' )),
    COMMETHOD([helpstring(u'Split the feature.')], HRESULT, 'Split',
              ( ['in'], POINTER(IEdgeFeature), 'splittingEdge' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'point' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet)), 'newFeatures' )),
    COMMETHOD([helpstring(u'Repositions all specified NetworkFeatures and any topologically connected NetworkFeatures.')], HRESULT, 'TransformSet',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'features' ),
              ( ['in'], esriTransformType, 'Type' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IAffineTransformation2D), 'tranformation' )),
    COMMETHOD(['hidden', helpstring(u'The stretching model to nearest vertex (true) or junction (false) based stretching.'), 'propget'], HRESULT, 'VertexBasedStretching',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'vertexBased' )),
    COMMETHOD(['hidden', helpstring(u'The stretching model to nearest vertex (true) or junction (false) based stretching.'), 'propput'], HRESULT, 'VertexBasedStretching',
              ( ['in'], VARIANT_BOOL, 'vertexBased' )),
]
################################################################
## code template for IGraph implementation
##class IGraph_Impl(object):
##    def GetDisplayFeedback(self, Feature, features, point):
##        u'The DisplayFeedback.'
##        #return feedback
##
##    def AddFeatureClass(self, FeatureClass, EnabledFieldName, Role, AncillaryRoleFieldName):
##        u'Add the FeatureClass to this graph.'
##        #return 
##
##    def Init(self, Dataset, graphID, graphName, buildNormalizedTables, createGraph):
##        u'Initializes the graph.'
##        #return 
##
##    def TransformSet(self, features, Type, tranformation):
##        u'Repositions all specified NetworkFeatures and any topologically connected NetworkFeatures.'
##        #return 
##
##    def Merge(self, mergingFeatures):
##        u'Merges the Features together, returning the newly created Feature.'
##        #return newFeatures
##
##    def Add(self, NewFeature):
##        u'Adds the preexisting Feature to the graph.'
##        #return 
##
##    def Split(self, splittingEdge, point):
##        u'Split the feature.'
##        #return newFeatures
##
##    def _get(self):
##        u'The stretching model to nearest vertex (true) or junction (false) based stretching.'
##        #return vertexBased
##    def _set(self, vertexBased):
##        u'The stretching model to nearest vertex (true) or junction (false) based stretching.'
##    VertexBasedStretching = property(_get, _set, doc = _set.__doc__)
##
##    def DeleteSet(self, featuresToDelete):
##        u'Removes the set of Feature from the graph.'
##        #return 
##
##    @property
##    def FeatureDataset(self):
##        u'The FeatureDataset associated with the graph.'
##        #return FeatureDataset
##

class ISimpleJunctionFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about simple junction features.'
    _iid_ = GUID('{F9B04A4A-557A-11D1-AE55-0000F80372B4}')
    _idlflags_ = ['oleautomation']
class IEnumRule(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate rules.'
    _iid_ = GUID('{76F9849E-84C3-11D2-AB61-000000000000}')
    _idlflags_ = ['oleautomation']
IGeometricNetwork._methods_ = [
    COMMETHOD(['propget', helpstring(u'The FeatureClasses with the specified ancillary role.')], HRESULT, 'ClassesByNetworkAncillaryRole',
              ( ['in'], esriNetworkClassAncillaryRole, 'Role' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumFeatureClass)), 'Classes' )),
    COMMETHOD([helpstring(u'Establish the flow direction in the LogicalNetwork.')], HRESULT, 'EstablishFlowDirection'),
    COMMETHOD(['propget', helpstring(u'Indicates whether the current flow directions are valid.')], HRESULT, 'ValidFlowDirection',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'ValidFlowDirection' )),
    COMMETHOD(['propget', helpstring(u'The FeatureClasses containing Features of the specified type.')], HRESULT, 'ClassesByType',
              ( ['in'], esriFeatureType, 'Type' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumFeatureClass)), 'featureClasses' )),
    COMMETHOD([helpstring(u'Create an orphan JunctionFeature.')], HRESULT, 'CreateOrphanFeature',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'Location' ),
              ( ['out'], POINTER(c_int), 'orphanEID' ),
              ( ['retval', 'out'], POINTER(POINTER(ISimpleJunctionFeature)), 'orphan' )),
    COMMETHOD(['propget', helpstring(u'The EdgeElement EID at the specified location.')], HRESULT, 'EdgeElement',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'Location' ),
              ( ['retval', 'out'], POINTER(c_int), 'edgeEID' )),
    COMMETHOD(['propget', helpstring(u'The area to be drawn.')], HRESULT, 'InvalidArea',
              ( ['retval', 'out'], POINTER(POINTER(IInvalidArea)), 'InvalidArea' )),
    COMMETHOD(['propputref', helpstring(u'The area to be drawn.')], HRESULT, 'InvalidArea',
              ( ['in'], POINTER(IInvalidArea), 'InvalidArea' )),
    COMMETHOD(['propget', helpstring(u'The JunctionElement EID at the specified location.')], HRESULT, 'JunctionElement',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'Location' ),
              ( ['retval', 'out'], POINTER(c_int), 'junctionEID' )),
    COMMETHOD(['propget', helpstring(u'The associated logical network.')], HRESULT, 'Network',
              ( ['retval', 'out'], POINTER(POINTER(INetwork)), 'Network' )),
    COMMETHOD(['propget', helpstring(u'The type of associated logical network.')], HRESULT, 'NetworkType',
              ( ['retval', 'out'], POINTER(esriNetworkType), 'Type' )),
    COMMETHOD(['propget', helpstring(u'The FeatureClass containing the OrphanJunctionFeatures.')], HRESULT, 'OrphanJunctionFeatureClass',
              ( ['retval', 'out'], POINTER(POINTER(IFeatureClass)), 'FeatureClass' )),
    COMMETHOD(['hidden', helpstring(u'Adds the constraint to the set of connectivity rules.')], HRESULT, 'AddRule',
              ( ['in'], POINTER(IConnectivityRule), 'Rule' )),
    COMMETHOD(['hidden', helpstring(u'Removes the rule from the set of rules.')], HRESULT, 'DeleteRule',
              ( ['in'], POINTER(IConnectivityRule), 'Rule' )),
    COMMETHOD(['propget', helpstring(u'All the connectivity rules associated with the network.')], HRESULT, 'Rules',
              ( ['retval', 'out'], POINTER(POINTER(IEnumRule)), 'Rules' )),
    COMMETHOD(['propget', helpstring(u'The connectivity rules associated with the class and subtype.')], HRESULT, 'RulesByClassAndSubtype',
              ( ['in'], c_int, 'ClassID' ),
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumRule)), 'Rules' )),
    COMMETHOD([helpstring(u'The NetworkFeatures found at the point.')], HRESULT, 'SearchForNetworkFeature',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'Location' ),
              ( ['in'], esriFeatureType, 'Type' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumFeature)), 'features' )),
    COMMETHOD(['propget', helpstring(u'The geometry of the EdgeElement.')], HRESULT, 'GeometryForEdgeEID',
              ( ['in'], c_int, 'edgeEID' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Geometry' )),
    COMMETHOD(['propget', helpstring(u'The geometry that corresponds to the JunctionElement (a point).')], HRESULT, 'GeometryForJunctionEID',
              ( ['in'], c_int, 'junctionEID' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Geometry' )),
    COMMETHOD(['propget', helpstring(u'The NetworkFeature that corresponds to the NetworkElement.')], HRESULT, 'NetworkFeature',
              ( ['in'], POINTER(INetElementDescription), 'networkElement' ),
              ( ['retval', 'out'], POINTER(POINTER(INetworkFeature)), 'Feature' )),
    COMMETHOD(['hidden', helpstring(u'Create network connectivity between the simple junction and any intersecting network feature.  For internal use only.')], HRESULT, 'SpliceSimpleJunction',
              ( ['in'], POINTER(ISimpleJunctionFeature), 'Junction' ),
              ( ['in'], c_int, 'junctionEID' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'Geometry' ),
              ( ['in'], VARIANT_BOOL, 'forceConnectivity' )),
    COMMETHOD(['hidden', helpstring(u'Add a new junction feature to the network by replacing existing junction.')], HRESULT, 'AddJunctionWithSubsumption',
              ( ['in'], POINTER(ISimpleJunctionFeature), 'Junction' ),
              ( ['in'], c_int, 'junctionEID' ),
              ( ['in'], POINTER(ISimpleJunctionFeature), 'subsumedJunction' )),
]
################################################################
## code template for IGeometricNetwork implementation
##class IGeometricNetwork_Impl(object):
##    def AddJunctionWithSubsumption(self, Junction, junctionEID, subsumedJunction):
##        u'Add a new junction feature to the network by replacing existing junction.'
##        #return 
##
##    @property
##    def ValidFlowDirection(self):
##        u'Indicates whether the current flow directions are valid.'
##        #return ValidFlowDirection
##
##    @property
##    def Network(self):
##        u'The associated logical network.'
##        #return Network
##
##    @property
##    def ClassesByType(self, Type):
##        u'The FeatureClasses containing Features of the specified type.'
##        #return featureClasses
##
##    @property
##    def Rules(self):
##        u'All the connectivity rules associated with the network.'
##        #return Rules
##
##    def AddRule(self, Rule):
##        u'Adds the constraint to the set of connectivity rules.'
##        #return 
##
##    @property
##    def GeometryForJunctionEID(self, junctionEID):
##        u'The geometry that corresponds to the JunctionElement (a point).'
##        #return Geometry
##
##    def EstablishFlowDirection(self):
##        u'Establish the flow direction in the LogicalNetwork.'
##        #return 
##
##    def DeleteRule(self, Rule):
##        u'Removes the rule from the set of rules.'
##        #return 
##
##    def CreateOrphanFeature(self, Location):
##        u'Create an orphan JunctionFeature.'
##        #return orphanEID, orphan
##
##    @property
##    def ClassesByNetworkAncillaryRole(self, Role):
##        u'The FeatureClasses with the specified ancillary role.'
##        #return Classes
##
##    def SearchForNetworkFeature(self, Location, Type):
##        u'The NetworkFeatures found at the point.'
##        #return features
##
##    @property
##    def RulesByClassAndSubtype(self, ClassID, SubtypeCode):
##        u'The connectivity rules associated with the class and subtype.'
##        #return Rules
##
##    def SpliceSimpleJunction(self, Junction, junctionEID, Geometry, forceConnectivity):
##        u'Create network connectivity between the simple junction and any intersecting network feature.  For internal use only.'
##        #return 
##
##    @property
##    def EdgeElement(self, Location):
##        u'The EdgeElement EID at the specified location.'
##        #return edgeEID
##
##    @property
##    def NetworkType(self):
##        u'The type of associated logical network.'
##        #return Type
##
##    def InvalidArea(self, InvalidArea):
##        u'The area to be drawn.'
##        #return 
##
##    @property
##    def OrphanJunctionFeatureClass(self):
##        u'The FeatureClass containing the OrphanJunctionFeatures.'
##        #return FeatureClass
##
##    @property
##    def JunctionElement(self, Location):
##        u'The JunctionElement EID at the specified location.'
##        #return junctionEID
##
##    @property
##    def GeometryForEdgeEID(self, edgeEID):
##        u'The geometry of the EdgeElement.'
##        #return Geometry
##
##    @property
##    def NetworkFeature(self, networkElement):
##        u'The NetworkFeature that corresponds to the NetworkElement.'
##        #return Feature
##

class INetworkClassDescription(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the Network Class Description.'
    _iid_ = GUID('{C9318830-2052-11D3-9F8A-00C04F6BDD84}')
    _idlflags_ = ['oleautomation']
INetworkClassDescription._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the Enabled field for the class described by this class description.')], HRESULT, 'EnabledFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The name of the Ancillary Role field for the junction feature class described by this class description.')], HRESULT, 'NetworkAncillaryRoleFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
]
################################################################
## code template for INetworkClassDescription implementation
##class INetworkClassDescription_Impl(object):
##    @property
##    def EnabledFieldName(self):
##        u'The name of the Enabled field for the class described by this class description.'
##        #return Name
##
##    @property
##    def NetworkAncillaryRoleFieldName(self):
##        u'The name of the Ancillary Role field for the junction feature class described by this class description.'
##        #return Name
##

class IRepresentationClassName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about the representation class.'
    _iid_ = GUID('{DDEC16BA-1C6F-46B4-9410-F09E9984B766}')
    _idlflags_ = ['oleautomation']
IRepresentationClassName._methods_ = [
    COMMETHOD(['propput', helpstring(u'RuleIDFieldName property.')], HRESULT, 'RuleIDFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'RuleIDFieldName property.')], HRESULT, 'RuleIDFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'OverrideFieldName property.')], HRESULT, 'OverrideFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'OverrideFieldName property.')], HRESULT, 'OverrideFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
]
################################################################
## code template for IRepresentationClassName implementation
##class IRepresentationClassName_Impl(object):
##    def _get(self):
##        u'OverrideFieldName property.'
##        #return Name
##    def _set(self, Name):
##        u'OverrideFieldName property.'
##    OverrideFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'RuleIDFieldName property.'
##        #return Name
##    def _set(self, Name):
##        u'RuleIDFieldName property.'
##    RuleIDFieldName = property(_get, _set, doc = _set.__doc__)
##

IItemInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'Name of the item.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'pName' )),
    COMMETHOD(['propput', helpstring(u'Name of the item.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'pName' )),
    COMMETHOD(['propget', helpstring(u'GUID of the item.')], HRESULT, 'GUID',
              ( ['retval', 'out'], POINTER(BSTR), 'pGuid' )),
    COMMETHOD(['propput', helpstring(u'GUID of the item.')], HRESULT, 'GUID',
              ( ['in'], BSTR, 'pGuid' )),
    COMMETHOD(['propget', helpstring(u'Type of the item.')], HRESULT, 'Type',
              ( ['retval', 'out'], POINTER(BSTR), 'pType' )),
    COMMETHOD(['propput', helpstring(u'Type of the item.')], HRESULT, 'Type',
              ( ['in'], BSTR, 'pType' )),
    COMMETHOD(['propget', helpstring(u'The keywords of a type of the item.')], HRESULT, 'TypeKeywords',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'ppKeywords' )),
    COMMETHOD(['propput', helpstring(u'The keywords of a type of the item.')], HRESULT, 'TypeKeywords',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'ppKeywords' )),
    COMMETHOD(['propget', helpstring(u'The additional info of a type of the item.')], HRESULT, 'TypeInfo',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'ppInfo' )),
    COMMETHOD(['propput', helpstring(u'The additional info of a type of the item.')], HRESULT, 'TypeInfo',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'ppInfo' )),
    COMMETHOD(['propget', helpstring(u'Catalog path of the item.')], HRESULT, 'CatalogPath',
              ( ['retval', 'out'], POINTER(BSTR), 'pCatalogPath' )),
    COMMETHOD(['propput', helpstring(u'Catalog path of the item.')], HRESULT, 'CatalogPath',
              ( ['in'], BSTR, 'pCatalogPath' )),
    COMMETHOD(['propget', helpstring(u'Title of the item.')], HRESULT, 'Title',
              ( ['retval', 'out'], POINTER(BSTR), 'pTitle' )),
    COMMETHOD(['propput', helpstring(u'Title of the item.')], HRESULT, 'Title',
              ( ['in'], BSTR, 'pTitle' )),
    COMMETHOD(['propget', helpstring(u'Description of the item.')], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'pDescription' )),
    COMMETHOD(['propput', helpstring(u'Description of the item.')], HRESULT, 'Description',
              ( ['in'], BSTR, 'pDescription' )),
    COMMETHOD(['propget', helpstring(u'Tags of the item.')], HRESULT, 'Tags',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'ppTags' )),
    COMMETHOD(['propput', helpstring(u'Tags of the item.')], HRESULT, 'Tags',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'ppTags' )),
    COMMETHOD(['propget', helpstring(u'Snippet of the item.')], HRESULT, 'Snippet',
              ( ['retval', 'out'], POINTER(BSTR), 'pSnippet' )),
    COMMETHOD(['propput', helpstring(u'Snippet of the item.')], HRESULT, 'Snippet',
              ( ['in'], BSTR, 'pSnippet' )),
    COMMETHOD(['propget', helpstring(u'Url of the item.')], HRESULT, 'URL',
              ( ['retval', 'out'], POINTER(BSTR), 'pUrl' )),
    COMMETHOD(['propput', helpstring(u'Url of the item.')], HRESULT, 'URL',
              ( ['in'], BSTR, 'pUrl' )),
    COMMETHOD(['propget', helpstring(u'The last modified time of the data.')], HRESULT, 'LastModifiedTime',
              ( ['retval', 'out'], POINTER(VARIANT), 'pDateT' )),
    COMMETHOD(['propput', helpstring(u'The last modified time of the data.')], HRESULT, 'LastModifiedTime',
              ( ['in'], VARIANT, 'pDateT' )),
    COMMETHOD(['propget', helpstring(u'Extent of the item.')], HRESULT, 'Extent',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'ppExtent' )),
    COMMETHOD(['propputref', helpstring(u'Extent of the item.')], HRESULT, 'Extent',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'ppExtent' )),
    COMMETHOD(['propget', helpstring(u'The spatial reference of the data.')], HRESULT, 'SpatialReference',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference)), 'ppSpatialRef' )),
    COMMETHOD(['propputref', helpstring(u'The spatial reference of the data.')], HRESULT, 'SpatialReference',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'ppSpatialRef' )),
    COMMETHOD(['propget', helpstring(u'Thumbnail info of the item.')], HRESULT, 'ThumbnailInfo',
              ( ['retval', 'out'], POINTER(POINTER(IThumbnailInfo)), 'ppThumbnailInfo' )),
    COMMETHOD(['propputref', helpstring(u'Thumbnail info of the item.')], HRESULT, 'ThumbnailInfo',
              ( ['in'], POINTER(IThumbnailInfo), 'ppThumbnailInfo' )),
    COMMETHOD(['propget', helpstring(u'Documentation info of the item.')], HRESULT, 'DocumentationInfo',
              ( ['retval', 'out'], POINTER(POINTER(IDocumentationInfo)), 'ppDocInfo' )),
    COMMETHOD(['propputref', helpstring(u'Documentation info of the item.')], HRESULT, 'DocumentationInfo',
              ( ['in'], POINTER(IDocumentationInfo), 'ppDocInfo' )),
    COMMETHOD(['propget', helpstring(u'Access constraints to this data.')], HRESULT, 'AccessConstraints',
              ( ['retval', 'out'], POINTER(BSTR), 'pConstraints' )),
    COMMETHOD(['propput', helpstring(u'Access constraints to this data.')], HRESULT, 'AccessConstraints',
              ( ['in'], BSTR, 'pConstraints' )),
    COMMETHOD(['propget', helpstring(u'Additional properties of this item.')], HRESULT, 'ItemProperties',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'ppProps' )),
    COMMETHOD(['propput', helpstring(u'Additional properties of this item.')], HRESULT, 'ItemProperties',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'ppProps' )),
]
################################################################
## code template for IItemInfo implementation
##class IItemInfo_Impl(object):
##    def _get(self):
##        u'Access constraints to this data.'
##        #return pConstraints
##    def _set(self, pConstraints):
##        u'Access constraints to this data.'
##    AccessConstraints = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The additional info of a type of the item.'
##        #return ppInfo
##    def _set(self, ppInfo):
##        u'The additional info of a type of the item.'
##    TypeInfo = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Name of the item.'
##        #return pName
##    def _set(self, pName):
##        u'Name of the item.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Title of the item.'
##        #return pTitle
##    def _set(self, pTitle):
##        u'Title of the item.'
##    Title = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Url of the item.'
##        #return pUrl
##    def _set(self, pUrl):
##        u'Url of the item.'
##    URL = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Additional properties of this item.'
##        #return ppProps
##    def _set(self, ppProps):
##        u'Additional properties of this item.'
##    ItemProperties = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Tags of the item.'
##        #return ppTags
##    def _set(self, ppTags):
##        u'Tags of the item.'
##    Tags = property(_get, _set, doc = _set.__doc__)
##
##    def SpatialReference(self, ppSpatialRef):
##        u'The spatial reference of the data.'
##        #return 
##
##    def _get(self):
##        u'Snippet of the item.'
##        #return pSnippet
##    def _set(self, pSnippet):
##        u'Snippet of the item.'
##    Snippet = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Catalog path of the item.'
##        #return pCatalogPath
##    def _set(self, pCatalogPath):
##        u'Catalog path of the item.'
##    CatalogPath = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The keywords of a type of the item.'
##        #return ppKeywords
##    def _set(self, ppKeywords):
##        u'The keywords of a type of the item.'
##    TypeKeywords = property(_get, _set, doc = _set.__doc__)
##
##    def Extent(self, ppExtent):
##        u'Extent of the item.'
##        #return 
##
##    def DocumentationInfo(self, ppDocInfo):
##        u'Documentation info of the item.'
##        #return 
##
##    def _get(self):
##        u'The last modified time of the data.'
##        #return pDateT
##    def _set(self, pDateT):
##        u'The last modified time of the data.'
##    LastModifiedTime = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'GUID of the item.'
##        #return pGuid
##    def _set(self, pGuid):
##        u'GUID of the item.'
##    GUID = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Type of the item.'
##        #return pType
##    def _set(self, pType):
##        u'Type of the item.'
##    Type = property(_get, _set, doc = _set.__doc__)
##
##    def ThumbnailInfo(self, ppThumbnailInfo):
##        u'Thumbnail info of the item.'
##        #return 
##
##    def _get(self):
##        u'Description of the item.'
##        #return pDescription
##    def _set(self, pDescription):
##        u'Description of the item.'
##    Description = property(_get, _set, doc = _set.__doc__)
##

class IPlugInFastRowCount(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for getting a fast count of rows in the dataset.'
    _iid_ = GUID('{C3DD33FE-6447-4472-8898-693AB4ACFCFC}')
    _idlflags_ = ['oleautomation']
IPlugInFastRowCount._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of rows in the dataset.')], HRESULT, 'RowCount',
              ( ['retval', 'out'], POINTER(c_int), 'numRows' )),
]
################################################################
## code template for IPlugInFastRowCount implementation
##class IPlugInFastRowCount_Impl(object):
##    @property
##    def RowCount(self):
##        u'The number of rows in the dataset.'
##        #return numRows
##

ITrafficData._methods_ = [
    COMMETHOD(['propget', helpstring(u'The time interval of the traffic data.')], HRESULT, 'TimeInterval',
              ( ['retval', 'out'], POINTER(c_double), 'TimeInterval' )),
    COMMETHOD(['propget', helpstring(u'The units of the time interval of the traffic data.')], HRESULT, 'TimeIntervalUnits',
              ( ['retval', 'out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.esriTimeUnits), 'TimeIntervalUnits' )),
]
################################################################
## code template for ITrafficData implementation
##class ITrafficData_Impl(object):
##    @property
##    def TimeInterval(self):
##        u'The time interval of the traffic data.'
##        #return TimeInterval
##
##    @property
##    def TimeIntervalUnits(self):
##        u'The units of the time interval of the traffic data.'
##        #return TimeIntervalUnits
##

ITrafficData2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The field name for the length attribute.')], HRESULT, 'LengthAttributeName',
              ( ['retval', 'out'], POINTER(BSTR), 'LengthAttributeName' )),
    COMMETHOD(['propput', helpstring(u'The field name for the length attribute.')], HRESULT, 'LengthAttributeName',
              ( ['in'], BSTR, 'LengthAttributeName' )),
]
################################################################
## code template for ITrafficData2 implementation
##class ITrafficData2_Impl(object):
##    def _get(self):
##        u'The field name for the length attribute.'
##        #return LengthAttributeName
##    def _set(self, LengthAttributeName):
##        u'The field name for the length attribute.'
##    LengthAttributeName = property(_get, _set, doc = _set.__doc__)
##

class MosaicDatasetName(CoClass):
    u'The mosaic dataset name object.'
    _reg_clsid_ = GUID('{5CD5BB6D-6549-429E-80F4-0DD4731198D1}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IMosaicDatasetName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control a mosaic dataset name.'
    _iid_ = GUID('{8911E302-D22B-42CB-B994-D3774B276460}')
    _idlflags_ = ['oleautomation']
class IMosaicDatasetName2(IMosaicDatasetName):
    _case_insensitive_ = True
    u'Provides access to members that control a mosaic dataset name.'
    _iid_ = GUID('{0B6F5156-2E59-41C8-9817-48D6D27FFA07}')
    _idlflags_ = ['oleautomation']
MosaicDatasetName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IMosaicDatasetName, IMosaicDatasetName2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName]

IHistoricalTrafficData._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the table containing profiles.')], HRESULT, 'ProfilesTableName',
              ( ['retval', 'out'], POINTER(BSTR), 'ProfilesTableName' )),
    COMMETHOD(['propput', helpstring(u'The name of the table containing profiles.')], HRESULT, 'ProfilesTableName',
              ( ['in'], BSTR, 'ProfilesTableName' )),
    COMMETHOD(['propget', helpstring(u'The duration of time slice in minutes.')], HRESULT, 'TimeSliceDurationInMinutes',
              ( ['retval', 'out'], POINTER(c_int), 'TimeSliceDurationInMinutes' )),
    COMMETHOD(['propput', helpstring(u'The duration of time slice in minutes.')], HRESULT, 'TimeSliceDurationInMinutes',
              ( ['in'], c_int, 'TimeSliceDurationInMinutes' )),
    COMMETHOD(['propget', helpstring(u'The start time of valid period of a day for traffic data.')], HRESULT, 'FirstTimeSliceStartTime',
              ( ['retval', 'out'], POINTER(c_double), 'FirstTimeSliceStartTime' )),
    COMMETHOD(['propput', helpstring(u'The start time of valid period of a day for traffic data.')], HRESULT, 'FirstTimeSliceStartTime',
              ( ['in'], c_double, 'FirstTimeSliceStartTime' )),
    COMMETHOD(['propget', helpstring(u'The field name of the first time slice of the given period in the profile table.')], HRESULT, 'FirstTimeSliceFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FirstTimeSliceFieldName' )),
    COMMETHOD(['propput', helpstring(u'The field name of the first time slice of the given period in the profile table.')], HRESULT, 'FirstTimeSliceFieldName',
              ( ['in'], BSTR, 'FirstTimeSliceFieldName' )),
    COMMETHOD(['propget', helpstring(u'The field name of the last time slice of the given period in the profile table.')], HRESULT, 'LastTimeSliceFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'LastTimeSliceFieldName' )),
    COMMETHOD(['propput', helpstring(u'The field name of the last time slice of the given period in the profile table.')], HRESULT, 'LastTimeSliceFieldName',
              ( ['in'], BSTR, 'LastTimeSliceFieldName' )),
    COMMETHOD(['propget', helpstring(u'The name of the join table between edges and profiles.')], HRESULT, 'JoinTableName',
              ( ['retval', 'out'], POINTER(BSTR), 'JoinTableName' )),
    COMMETHOD(['propput', helpstring(u'The name of the join table between edges and profiles.')], HRESULT, 'JoinTableName',
              ( ['in'], BSTR, 'JoinTableName' )),
    COMMETHOD(['propget', helpstring(u'The field name for base travel time in the join table.')], HRESULT, 'JoinTableBaseTravelTimeFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propput', helpstring(u'The field name for base travel time in the join table.')], HRESULT, 'JoinTableBaseTravelTimeFieldName',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'Base travel time units.')], HRESULT, 'JoinTableBaseTravelTimeUnits',
              ( ['retval', 'out'], POINTER(esriNetworkAttributeUnits), 'Units' )),
    COMMETHOD(['propput', helpstring(u'Base travel time units.')], HRESULT, 'JoinTableBaseTravelTimeUnits',
              ( ['in'], esriNetworkAttributeUnits, 'Units' )),
    COMMETHOD(['propget', helpstring(u'The field names of the historic join table pointing to speed profiles.')], HRESULT, 'JoinTableProfileIDFieldNames',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'profileIDFields' )),
    COMMETHOD(['propputref', helpstring(u'The field names of the historic join table pointing to speed profiles.')], HRESULT, 'JoinTableProfileIDFieldNames',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'profileIDFields' )),
]
################################################################
## code template for IHistoricalTrafficData implementation
##class IHistoricalTrafficData_Impl(object):
##    def _get(self):
##        u'The field name of the first time slice of the given period in the profile table.'
##        #return FirstTimeSliceFieldName
##    def _set(self, FirstTimeSliceFieldName):
##        u'The field name of the first time slice of the given period in the profile table.'
##    FirstTimeSliceFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The duration of time slice in minutes.'
##        #return TimeSliceDurationInMinutes
##    def _set(self, TimeSliceDurationInMinutes):
##        u'The duration of time slice in minutes.'
##    TimeSliceDurationInMinutes = property(_get, _set, doc = _set.__doc__)
##
##    def JoinTableProfileIDFieldNames(self, profileIDFields):
##        u'The field names of the historic join table pointing to speed profiles.'
##        #return 
##
##    def _get(self):
##        u'Base travel time units.'
##        #return Units
##    def _set(self, Units):
##        u'Base travel time units.'
##    JoinTableBaseTravelTimeUnits = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the join table between edges and profiles.'
##        #return JoinTableName
##    def _set(self, JoinTableName):
##        u'The name of the join table between edges and profiles.'
##    JoinTableName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The field name of the last time slice of the given period in the profile table.'
##        #return LastTimeSliceFieldName
##    def _set(self, LastTimeSliceFieldName):
##        u'The field name of the last time slice of the given period in the profile table.'
##    LastTimeSliceFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The start time of valid period of a day for traffic data.'
##        #return FirstTimeSliceStartTime
##    def _set(self, FirstTimeSliceStartTime):
##        u'The start time of valid period of a day for traffic data.'
##    FirstTimeSliceStartTime = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the table containing profiles.'
##        #return ProfilesTableName
##    def _set(self, ProfilesTableName):
##        u'The name of the table containing profiles.'
##    ProfilesTableName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The field name for base travel time in the join table.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The field name for base travel time in the join table.'
##    JoinTableBaseTravelTimeFieldName = property(_get, _set, doc = _set.__doc__)
##

class IPlugInRowCount(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for getting a fast count of rows in the dataset.'
    _iid_ = GUID('{A860DD65-A3B4-4CFE-BE56-47E8AFDB7CBD}')
    _idlflags_ = ['oleautomation']
IPlugInRowCount._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of rows in the indicated dataset.')], HRESULT, 'RowCount',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(c_int), 'numRows' )),
]
################################################################
## code template for IPlugInRowCount implementation
##class IPlugInRowCount_Impl(object):
##    @property
##    def RowCount(self, Index):
##        u'The number of rows in the indicated dataset.'
##        #return numRows
##

class IPlugInIndexManager(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for managing indexes for the dataset.'
    _iid_ = GUID('{9BD2FEE7-BEEC-4B70-9F18-AD16B6E7D2D5}')
    _idlflags_ = ['oleautomation']
IPlugInIndexManager._methods_ = [
    COMMETHOD([helpstring(u'Adds an index to the dataset.')], HRESULT, 'AddIndex',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['in'], POINTER(IIndex), 'Index' )),
    COMMETHOD([helpstring(u'Deletes an index from the dataset.')], HRESULT, 'DeleteIndex',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['in'], POINTER(IIndex), 'Index' )),
]
################################################################
## code template for IPlugInIndexManager implementation
##class IPlugInIndexManager_Impl(object):
##    def DeleteIndex(self, ClassIndex, Index):
##        u'Deletes an index from the dataset.'
##        #return 
##
##    def AddIndex(self, ClassIndex, Index):
##        u'Adds an index to the dataset.'
##        #return 
##


# values for enumeration 'esriTableNameErrorType'
esriIsSQLReservedWord = 1
esriHasInvalidCharacter = 2
esriHasInvalidStartingCharacter = 4
esriTableNameErrorType = c_int # enum
ISynchronizationHelper._methods_ = [
    COMMETHOD([helpstring(u'Call this before synchronizing.')], HRESULT, 'StartSynchronization',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'PropertySet' ),
              ( ['in'], esriMetadataSyncAction, 'action' ),
              ( ['in'], c_int, 'interval' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'Ok' )),
    COMMETHOD([helpstring(u'Call this after synchronizing.')], HRESULT, 'FinishSynchronization',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'PropertySet' )),
    COMMETHOD([helpstring(u'Fills in required properties.')], HRESULT, 'PopulateStaticProperties',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'PropertySet' )),
    COMMETHOD([helpstring(u'Extracts spatial properties from a GeoDataset.')], HRESULT, 'ExtractSpatialProperties',
              ( ['in'], POINTER(IGeoDataset), 'geoDataset' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'PropertySet' )),
    COMMETHOD([helpstring(u'Extracts properties from a Feature Class.')], HRESULT, 'ExtractFeatureClassProperties',
              ( ['in'], POINTER(IFeatureClass), 'geoDataset' ),
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'PropertySet' )),
    COMMETHOD([helpstring(u'Extracts entity attribute properties from a Feature Class.')], HRESULT, 'ExtractEntityAttrProperties',
              ( ['in'], POINTER(IClass), 'geoDataset' ),
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'PropertySet' )),
    COMMETHOD([helpstring(u'Extracts entity attribute properties from a Relationship Class.')], HRESULT, 'ExtractRelationshipProperties',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'PropertySet' )),
    COMMETHOD([helpstring(u'Populates distribution properties given a filename.')], HRESULT, 'PopulateDistributionProperties',
              ( ['in'], BSTR, 'fileName' ),
              ( ['in'], BSTR, 'fileType' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'PropertySet' )),
    COMMETHOD([helpstring(u'Populates distribution properties given a filename.')], HRESULT, 'PopulateDistributionPropertiesForDatabase',
              ( ['in'], POINTER(IDataset), 'Dataset' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'PropertySet' )),
    COMMETHOD([helpstring(u'Extracts brief entity attribute properties from a Feature Class.')], HRESULT, 'ExtractBriefEntityAttrProperties',
              ( ['in'], POINTER(IClass), 'geoDataset' ),
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'PropertySet' )),
    COMMETHOD([helpstring(u'Extracts brief entity attribute properties from a Relationship Class.')], HRESULT, 'ExtractBriefRelationshipProperties',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'PropertySet' )),
]
################################################################
## code template for ISynchronizationHelper implementation
##class ISynchronizationHelper_Impl(object):
##    def FinishSynchronization(self, PropertySet):
##        u'Call this after synchronizing.'
##        #return 
##
##    def ExtractSpatialProperties(self, geoDataset, PropertySet):
##        u'Extracts spatial properties from a GeoDataset.'
##        #return 
##
##    def ExtractRelationshipProperties(self, RelationshipClass, Index, PropertySet):
##        u'Extracts entity attribute properties from a Relationship Class.'
##        #return 
##
##    def ExtractBriefEntityAttrProperties(self, geoDataset, Index, PropertySet):
##        u'Extracts brief entity attribute properties from a Feature Class.'
##        #return 
##
##    def ExtractFeatureClassProperties(self, geoDataset, Index, PropertySet):
##        u'Extracts properties from a Feature Class.'
##        #return 
##
##    def PopulateDistributionPropertiesForDatabase(self, Dataset, PropertySet):
##        u'Populates distribution properties given a filename.'
##        #return 
##
##    def PopulateStaticProperties(self, PropertySet):
##        u'Fills in required properties.'
##        #return 
##
##    def PopulateDistributionProperties(self, fileName, fileType, PropertySet):
##        u'Populates distribution properties given a filename.'
##        #return 
##
##    def ExtractBriefRelationshipProperties(self, RelationshipClass, Index, PropertySet):
##        u'Extracts brief entity attribute properties from a Relationship Class.'
##        #return 
##
##    def StartSynchronization(self, PropertySet, action, interval):
##        u'Call this before synchronizing.'
##        #return Ok
##
##    def ExtractEntityAttrProperties(self, geoDataset, Index, PropertySet):
##        u'Extracts entity attribute properties from a Feature Class.'
##        #return 
##

class IEnumTopologyErrorFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through the topology errors.'
    _iid_ = GUID('{C18BEC52-C376-469B-899F-4DEA0CE3CB61}')
    _idlflags_ = ['oleautomation']
IEnumTopologyErrorFeature._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next topology error.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(ITopologyErrorFeature)), 'error' )),
]
################################################################
## code template for IEnumTopologyErrorFeature implementation
##class IEnumTopologyErrorFeature_Impl(object):
##    def Next(self):
##        u'Retrieves the next topology error.'
##        #return error
##

class FieldError(CoClass):
    u'Esri Field Error object.'
    _reg_clsid_ = GUID('{23A73299-AB83-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
FieldError._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IFieldError]

class IEnumDataElement(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through DataElements.'
    _iid_ = GUID('{27CD2023-223C-4942-9DB0-4E4E83BCF906}')
    _idlflags_ = ['oleautomation']
IEnumDataElement._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next DataElement in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IDataElement)), 'DataElement' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumDataElement implementation
##class IEnumDataElement_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next DataElement in the enumeration sequence.'
##        #return DataElement
##

IEnumFeature._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next Feature in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IFeature)), 'Feature' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumFeature implementation
##class IEnumFeature_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next Feature in the enumeration sequence.'
##        #return Feature
##

class IPlugInIndexInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members describing indexes for the dataset.'
    _iid_ = GUID('{32F25F5B-A97C-489F-90D9-E93DC84494C0}')
    _idlflags_ = ['oleautomation']
IPlugInIndexInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'The indexes for the dataset.')], HRESULT, 'Indexes',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['retval', 'out'], POINTER(POINTER(IIndexes)), 'Indexes' )),
]
################################################################
## code template for IPlugInIndexInfo implementation
##class IPlugInIndexInfo_Impl(object):
##    @property
##    def Indexes(self, ClassIndex):
##        u'The indexes for the dataset.'
##        #return Indexes
##

IOverride._methods_ = [
    COMMETHOD([helpstring(u'Removes a given override from the blob.')], HRESULT, 'RemoveOverride',
              ( ['in'], POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IGraphicAttributes), 'attrs' ),
              ( ['in'], c_int, 'idx' )),
    COMMETHOD([helpstring(u'Checks if the value of a graphical attribute comes from a feature field.')], HRESULT, 'IsOverridenWithField',
              ( ['in'], POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IGraphicAttributes), 'attrs' ),
              ( ['in'], c_int, 'idx' ),
              ( ['retval', 'out'], POINTER(c_int), 'fldIdx' )),
    COMMETHOD([helpstring(u'Removes all attributes overrides from the representation.')], HRESULT, 'RemoveOverrides'),
    COMMETHOD(['propget', helpstring(u'Indicates if a graphical attribute is overriden.')], HRESULT, 'HasAttributeOverride',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasAttributeOverride' )),
]
################################################################
## code template for IOverride implementation
##class IOverride_Impl(object):
##    @property
##    def HasAttributeOverride(self):
##        u'Indicates if a graphical attribute is overriden.'
##        #return HasAttributeOverride
##
##    def IsOverridenWithField(self, attrs, idx):
##        u'Checks if the value of a graphical attribute comes from a feature field.'
##        #return fldIdx
##
##    def RemoveOverrides(self):
##        u'Removes all attributes overrides from the representation.'
##        #return 
##
##    def RemoveOverride(self, attrs, idx):
##        u'Removes a given override from the blob.'
##        #return 
##

class IUtilityNetwork(INetwork):
    _case_insensitive_ = True
    u'Provides access to members that get and set flow direction in a utility network.'
    _iid_ = GUID('{19F99C84-A089-11D0-9CC9-00805F74D243}')
    _idlflags_ = []
class IUtilityNetwork2(IUtilityNetwork):
    _case_insensitive_ = True
    u'Provides access to members that get and set flow direction in a utility network.'
    _iid_ = GUID('{FA8BC670-D572-11D5-A134-00508BA0C977}')
    _idlflags_ = []

# values for enumeration 'esriNetworkStatus'
esriNSInvalidConnection = 0
esriNSNetworkAlreadyExist = 1
esriNSReadOnlyNetwork = 2
esriNSCannotOpenTables = 3
esriNSCannotCreateTables = 4
esriNSInvalidElementClasses = 5
esriNSInvalidWeights = 6
esriNSUnknownStatus = 7
esriNSValidNetwork = 8
esriNSInvalidName = 9
esriNetworkStatus = c_int # enum
INetwork._methods_ = [
    COMMETHOD(['propget', helpstring(u'Status of the network.')], HRESULT, 'Status',
              ( ['retval', 'out'], POINTER(esriNetworkStatus), 'networkStatus' )),
    COMMETHOD(['propget', helpstring(u'Number of junctions in the network.')], HRESULT, 'JunctionCount',
              ( ['retval', 'out'], POINTER(c_int), 'JunctionCount' )),
    COMMETHOD(['propget', helpstring(u'Number of edges in the network.')], HRESULT, 'EdgeCount',
              ( ['retval', 'out'], POINTER(c_int), 'EdgeCount' )),
    COMMETHOD(['propget', helpstring(u'Number of turns in the network.')], HRESULT, 'TurnCount',
              ( ['retval', 'out'], POINTER(c_int), 'TurnCount' )),
    COMMETHOD(['propget', helpstring(u'Maximum degree of a junction.')], HRESULT, 'MaxDegree',
              ( ['retval', 'out'], POINTER(c_int), 'MaxDegree' )),
    COMMETHOD(['propget', helpstring(u'Maximum number of turns associated with a junction.')], HRESULT, 'MaxTurn',
              ( ['retval', 'out'], POINTER(c_int), 'MaxTurn' )),
    COMMETHOD([helpstring(u'Creates a forward star cursor on the network index.')], HRESULT, 'CreateForwardStar',
              ( ['in'], VARIANT_BOOL, 'honorState' ),
              ( ['in'], POINTER(INetWeight), 'JunctionWeight' ),
              ( ['in'], POINTER(INetWeight), 'FromToEdgeWeight' ),
              ( ['in'], POINTER(INetWeight), 'ToFromEdgeWeight' ),
              ( ['in'], POINTER(INetWeight), 'turnWeight' ),
              ( ['retval', 'out'], POINTER(POINTER(IForwardStar)), 'ForwardStar' )),
    COMMETHOD([helpstring(u'Creates a network index element browser.')], HRESULT, 'CreateNetBrowser',
              ( ['in'], esriElementType, 'ElementType' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumNetEID)), 'netBrowser' )),
]
################################################################
## code template for INetwork implementation
##class INetwork_Impl(object):
##    @property
##    def Status(self):
##        u'Status of the network.'
##        #return networkStatus
##
##    @property
##    def MaxDegree(self):
##        u'Maximum degree of a junction.'
##        #return MaxDegree
##
##    @property
##    def JunctionCount(self):
##        u'Number of junctions in the network.'
##        #return JunctionCount
##
##    @property
##    def EdgeCount(self):
##        u'Number of edges in the network.'
##        #return EdgeCount
##
##    def CreateNetBrowser(self, ElementType):
##        u'Creates a network index element browser.'
##        #return netBrowser
##
##    @property
##    def MaxTurn(self):
##        u'Maximum number of turns associated with a junction.'
##        #return MaxTurn
##
##    @property
##    def TurnCount(self):
##        u'Number of turns in the network.'
##        #return TurnCount
##
##    def CreateForwardStar(self, honorState, JunctionWeight, FromToEdgeWeight, ToFromEdgeWeight, turnWeight):
##        u'Creates a forward star cursor on the network index.'
##        #return ForwardStar
##


# values for enumeration 'esriFlowDirection'
esriFDIndeterminate = 3
esriFDWithFlow = 1
esriFDAgainstFlow = 2
esriFDUninitialized = 0
esriFlowDirection = c_int # enum
IUtilityNetwork._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the flow direction is valid for this utility network.')], HRESULT, 'ValidFlowDirection',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'ValidFlowDirection' )),
    COMMETHOD([helpstring(u'Returns the flow direction of the specified edge element.')], HRESULT, 'GetFlowDirection',
              ( ['in'], c_int, 'edgeEID' ),
              ( ['retval', 'out'], POINTER(esriFlowDirection), 'flowDirection' )),
    COMMETHOD([helpstring(u'Sets the flow direction for the specified edge element.')], HRESULT, 'SetFlowDirection',
              ( ['in'], c_int, 'edgeEID' ),
              ( ['in'], esriFlowDirection, 'flowDirection' )),
    COMMETHOD(['hidden', helpstring(u'Sets the flow direction of all edge elements based on the placement of sources and sinks.')], HRESULT, 'EstablishFlowDirection',
              ( ['in'], c_int, 'SourceCount' ),
              ( ['in'], POINTER(c_int), 'sourceEIDs' ),
              ( ['in'], c_int, 'sinkCount' ),
              ( ['in'], POINTER(c_int), 'sinkEIDs' )),
]
################################################################
## code template for IUtilityNetwork implementation
##class IUtilityNetwork_Impl(object):
##    def SetFlowDirection(self, edgeEID, flowDirection):
##        u'Sets the flow direction for the specified edge element.'
##        #return 
##
##    @property
##    def ValidFlowDirection(self):
##        u'Indicates if the flow direction is valid for this utility network.'
##        #return ValidFlowDirection
##
##    def EstablishFlowDirection(self, SourceCount, sourceEIDs, sinkCount, sinkEIDs):
##        u'Sets the flow direction of all edge elements based on the placement of sources and sinks.'
##        #return 
##
##    def GetFlowDirection(self, edgeEID):
##        u'Returns the flow direction of the specified edge element.'
##        #return flowDirection
##

IUtilityNetwork2._methods_ = [
    COMMETHOD(['hidden', helpstring(u'Sets the flow direction of all reachable edge elements based on the placement of sources and sinks.')], HRESULT, 'PartialEstablishFlowDirection',
              ( ['in'], c_int, 'SourceCount' ),
              ( ['in'], POINTER(c_int), 'sourceEIDs' ),
              ( ['in'], c_int, 'sinkCount' ),
              ( ['in'], POINTER(c_int), 'sinkEIDs' )),
]
################################################################
## code template for IUtilityNetwork2 implementation
##class IUtilityNetwork2_Impl(object):
##    def PartialEstablishFlowDirection(self, SourceCount, sourceEIDs, sinkCount, sinkEIDs):
##        u'Sets the flow direction of all reachable edge elements based on the placement of sources and sinks.'
##        #return 
##

class IPlugInDatasetHelper(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that help Plug-In datasets.'
    _iid_ = GUID('{D22B5232-EB1B-44A1-B2CA-B0D085059CFB}')
    _idlflags_ = ['oleautomation']
class IPlugInDatasetHelper2(IPlugInDatasetHelper):
    _case_insensitive_ = True
    u'Provides access to members that help Plug-In datasets.'
    _iid_ = GUID('{09362A67-F8F6-4DAE-8DF0-A32A6F0F38A6}')
    _idlflags_ = ['oleautomation']
class IPlugInDatasetHelper3(IPlugInDatasetHelper2):
    _case_insensitive_ = True
    u'Provides access to members that help Plug-In datasets.'
    _iid_ = GUID('{344F6114-E98D-4645-AF83-3E155FA83627}')
    _idlflags_ = ['oleautomation']
IPlugInDatasetHelper._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of classes in the dataset.')], HRESULT, 'ClassCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The name of the indicated class.')], HRESULT, 'ClassName',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The index of the named class.')], HRESULT, 'ClassIndex',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(c_int), 'Index' )),
    COMMETHOD(['propget', helpstring(u'The extent of the dataset.')], HRESULT, 'Bounds',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'Bounds' )),
    COMMETHOD(['propget', helpstring(u'The field set of the indicated class.')], HRESULT, 'Fields',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['retval', 'out'], POINTER(POINTER(IFields)), 'FieldSet' )),
    COMMETHOD(['propget', helpstring(u'The index of the oid field in the field set of the indicated dataset.')], HRESULT, 'OIDFieldIndex',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['retval', 'out'], POINTER(c_int), 'OIDFieldIndex' )),
    COMMETHOD(['propget', helpstring(u'The index of the shape field in the field set of the indicated dataset.')], HRESULT, 'ShapeFieldIndex',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['retval', 'out'], POINTER(c_int), 'ShapeFieldIndex' )),
    COMMETHOD([helpstring(u'Gets a record by object id.')], HRESULT, 'FetchByID',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['in'], c_int, 'ID' ),
              ( ['in'], VARIANT, 'FieldMap' ),
              ( ['retval', 'out'], POINTER(POINTER(IPlugInCursorHelper)), 'cursorHelper' )),
    COMMETHOD([helpstring(u'Gets all the records in the database.')], HRESULT, 'FetchAll',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['in'], BSTR, 'WhereClause' ),
              ( ['in'], VARIANT, 'FieldMap' ),
              ( ['retval', 'out'], POINTER(POINTER(IPlugInCursorHelper)), 'cursorHelper' )),
    COMMETHOD([helpstring(u'Gets the records within the envelope (or the full extent if the envelope is null).')], HRESULT, 'FetchByEnvelope',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'env' ),
              ( ['in'], VARIANT_BOOL, 'strictSearch' ),
              ( ['in'], BSTR, 'WhereClause' ),
              ( ['in'], VARIANT, 'FieldMap' ),
              ( ['retval', 'out'], POINTER(POINTER(IPlugInCursorHelper)), 'cursorHelper' )),
]
################################################################
## code template for IPlugInDatasetHelper implementation
##class IPlugInDatasetHelper_Impl(object):
##    @property
##    def ShapeFieldIndex(self, ClassIndex):
##        u'The index of the shape field in the field set of the indicated dataset.'
##        #return ShapeFieldIndex
##
##    def FetchAll(self, ClassIndex, WhereClause, FieldMap):
##        u'Gets all the records in the database.'
##        #return cursorHelper
##
##    @property
##    def ClassCount(self):
##        u'The number of classes in the dataset.'
##        #return Count
##
##    def FetchByEnvelope(self, ClassIndex, env, strictSearch, WhereClause, FieldMap):
##        u'Gets the records within the envelope (or the full extent if the envelope is null).'
##        #return cursorHelper
##
##    @property
##    def Fields(self, ClassIndex):
##        u'The field set of the indicated class.'
##        #return FieldSet
##
##    @property
##    def Bounds(self):
##        u'The extent of the dataset.'
##        #return Bounds
##
##    @property
##    def ClassName(self, Index):
##        u'The name of the indicated class.'
##        #return Name
##
##    @property
##    def ClassIndex(self, Name):
##        u'The index of the named class.'
##        #return Index
##
##    def FetchByID(self, ClassIndex, ID, FieldMap):
##        u'Gets a record by object id.'
##        #return cursorHelper
##
##    @property
##    def OIDFieldIndex(self, ClassIndex):
##        u'The index of the oid field in the field set of the indicated dataset.'
##        #return OIDFieldIndex
##

IPlugInDatasetHelper2._methods_ = [
    COMMETHOD([helpstring(u'Gets the records according to the envelope, where clause or FIDSet.')], HRESULT, 'FetchWithFilter',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'env' ),
              ( ['in'], VARIANT_BOOL, 'strictSearch' ),
              ( ['in'], BSTR, 'WhereClause' ),
              ( ['in'], POINTER(IFIDSet), 'FIDSet' ),
              ( ['in'], VARIANT, 'FieldMap' ),
              ( ['retval', 'out'], POINTER(POINTER(IPlugInCursorHelper)), 'cursorHelper' )),
]
################################################################
## code template for IPlugInDatasetHelper2 implementation
##class IPlugInDatasetHelper2_Impl(object):
##    def FetchWithFilter(self, ClassIndex, env, strictSearch, WhereClause, FIDSet, FieldMap):
##        u'Gets the records according to the envelope, where clause or FIDSet.'
##        #return cursorHelper
##

IPlugInDatasetHelper3._methods_ = [
    COMMETHOD([helpstring(u'Gets the records according to the envelope, where clause, FIDSet or time extent.')], HRESULT, 'FetchWithFilterWithTime',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'envelope' ),
              ( ['in'], VARIANT_BOOL, 'strictSearch' ),
              ( ['in'], BSTR, 'WhereClause' ),
              ( ['in'], POINTER(IFIDSet), 'FIDSet' ),
              ( ['in'], VARIANT, 'FieldMap' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITimeValue), 'TimeValue' ),
              ( ['in'], c_double, 'SpatialResolution' ),
              ( ['retval', 'out'], POINTER(POINTER(IPlugInCursorHelper)), 'cursorHelper' )),
]
################################################################
## code template for IPlugInDatasetHelper3 implementation
##class IPlugInDatasetHelper3_Impl(object):
##    def FetchWithFilterWithTime(self, ClassIndex, envelope, strictSearch, WhereClause, FIDSet, FieldMap, TimeValue, SpatialResolution):
##        u'Gets the records according to the envelope, where clause, FIDSet or time extent.'
##        #return cursorHelper
##

IDERepresentationClass._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the attached feature class.')], HRESULT, 'FeatureClassName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the attached feature class.')], HRESULT, 'FeatureClassName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The name of the RuleID field.')], HRESULT, 'RuleIDFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the RuleID field.')], HRESULT, 'RuleIDFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The name of the Override field.')], HRESULT, 'OverrideFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the Override field.')], HRESULT, 'OverrideFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'RepresentationRules Property.')], HRESULT, 'RepresentationRules',
              ( ['retval', 'out'], POINTER(POINTER(IRepresentationRules)), 'repRules' )),
    COMMETHOD(['propputref', helpstring(u'RepresentationRules Property.')], HRESULT, 'RepresentationRules',
              ( ['in'], POINTER(IRepresentationRules), 'repRules' )),
    COMMETHOD(['propget', helpstring(u'General attributes defined at the representation class level.')], HRESULT, 'Attributes',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IGraphicAttributes)), 'Attributes' )),
    COMMETHOD(['propputref', helpstring(u'General attributes defined at the representation class level.')], HRESULT, 'Attributes',
              ( ['in'], POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IGraphicAttributes), 'Attributes' )),
    COMMETHOD(['propget', helpstring(u'Indicates if a shape override is required for feature representations.')], HRESULT, 'RequireShapeOverride',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'RequireShapeOverride' )),
    COMMETHOD(['propput', helpstring(u'Indicates if a shape override is required for feature representations.')], HRESULT, 'RequireShapeOverride',
              ( ['in'], VARIANT_BOOL, 'RequireShapeOverride' )),
]
################################################################
## code template for IDERepresentationClass implementation
##class IDERepresentationClass_Impl(object):
##    def _get(self):
##        u'The name of the RuleID field.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the RuleID field.'
##    RuleIDFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def RepresentationRules(self, repRules):
##        u'RepresentationRules Property.'
##        #return 
##
##    def _get(self):
##        u'Indicates if a shape override is required for feature representations.'
##        #return RequireShapeOverride
##    def _set(self, RequireShapeOverride):
##        u'Indicates if a shape override is required for feature representations.'
##    RequireShapeOverride = property(_get, _set, doc = _set.__doc__)
##
##    def Attributes(self, Attributes):
##        u'General attributes defined at the representation class level.'
##        #return 
##
##    def _get(self):
##        u'The name of the Override field.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the Override field.'
##    OverrideFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the attached feature class.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the attached feature class.'
##    FeatureClassName = property(_get, _set, doc = _set.__doc__)
##

class ISetDefaultConnectionInfo3(ISetDefaultConnectionInfo2):
    _case_insensitive_ = True
    u'Provides access to default connection information for a remote database (ArcSDE).'
    _iid_ = GUID('{FC5B76D5-5CA4-4A0E-A998-FE383E73D6C0}')
    _idlflags_ = ['oleautomation']
ISetDefaultConnectionInfo3._methods_ = [
    COMMETHOD([helpstring(u'Sets ArcSDE connection property parameters.')], HRESULT, 'SetParameters3',
              ( ['in'], BSTR, 'server' ),
              ( ['in'], BSTR, 'instance' ),
              ( ['in'], BSTR, 'authenticationMode' ),
              ( ['in'], BSTR, 'UserName' ),
              ( ['in'], BSTR, 'password' ),
              ( ['in'], BSTR, 'VersionName' ),
              ( ['in'], VARIANT, 'historicalInfo' )),
    COMMETHOD([helpstring(u'Clears ArcSDE connection property parameters.')], HRESULT, 'ClearParameters3',
              ( ['in'], BSTR, 'server' ),
              ( ['in'], BSTR, 'instance' ),
              ( ['in'], BSTR, 'authenticationMode' )),
]
################################################################
## code template for ISetDefaultConnectionInfo3 implementation
##class ISetDefaultConnectionInfo3_Impl(object):
##    def SetParameters3(self, server, instance, authenticationMode, UserName, password, VersionName, historicalInfo):
##        u'Sets ArcSDE connection property parameters.'
##        #return 
##
##    def ClearParameters3(self, server, instance, authenticationMode):
##        u'Clears ArcSDE connection property parameters.'
##        #return 
##

ISimpleEdgeFeature._methods_ = [
    COMMETHOD(['propget', helpstring(u'The logical network element ID of this edge.')], HRESULT, 'EID',
              ( ['retval', 'out'], POINTER(c_int), 'ElementID' )),
]
################################################################
## code template for ISimpleEdgeFeature implementation
##class ISimpleEdgeFeature_Impl(object):
##    @property
##    def EID(self):
##        u'The logical network element ID of this edge.'
##        #return ElementID
##

class GPTopologyMembership(CoClass):
    u'The Topology Membership object.'
    _reg_clsid_ = GUID('{5DA78FF6-546B-4AF0-84B8-50B68484D9D5}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
GPTopologyMembership._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPControllerMembership, IGPTopologyMembership, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

class ISqlDefaultConnectionInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to default connection information for a remote database (QueryLayers).'
    _iid_ = GUID('{177A8E41-D923-4996-99FE-D87D7E1833CD}')
    _idlflags_ = ['oleautomation']
ISqlDefaultConnectionInfo._methods_ = [
    COMMETHOD([helpstring(u'Sets connection property parameters.')], HRESULT, 'SetParameters',
              ( ['in'], BSTR, 'dbclient' ),
              ( ['in'], BSTR, 'instance' ),
              ( ['in'], BSTR, 'authenticationMode' ),
              ( ['in'], BSTR, 'user' ),
              ( ['in'], BSTR, 'password' )),
    COMMETHOD([helpstring(u'Clears connection property parameters.')], HRESULT, 'ClearParameters',
              ( ['in'], BSTR, 'dbclient' ),
              ( ['in'], BSTR, 'instance' ),
              ( ['in'], BSTR, 'authenticationMode' )),
]
################################################################
## code template for ISqlDefaultConnectionInfo implementation
##class ISqlDefaultConnectionInfo_Impl(object):
##    def SetParameters(self, dbclient, instance, authenticationMode, user, password):
##        u'Sets connection property parameters.'
##        #return 
##
##    def ClearParameters(self, dbclient, instance, authenticationMode):
##        u'Clears connection property parameters.'
##        #return 
##

class IEnumFeatureSetup(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that define behavior of IEnumFeature.'
    _iid_ = GUID('{6EA26548-CD08-47F3-93CA-BD8D8AB5D30A}')
    _idlflags_ = ['oleautomation']
IEnumFeatureSetup._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if returned features recycle.')], HRESULT, 'Recycling',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'recyling' )),
    COMMETHOD(['propput', helpstring(u'Indicates if returned features recycle.')], HRESULT, 'Recycling',
              ( [], VARIANT_BOOL, 'recyling' )),
    COMMETHOD(['propget', helpstring(u'Indicates if returned features will contain all fields.')], HRESULT, 'AllFields',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'AllFields' )),
    COMMETHOD(['propput', helpstring(u'Indicates if returned features will contain all fields.')], HRESULT, 'AllFields',
              ( [], VARIANT_BOOL, 'AllFields' )),
]
################################################################
## code template for IEnumFeatureSetup implementation
##class IEnumFeatureSetup_Impl(object):
##    def _get(self):
##        u'Indicates if returned features recycle.'
##        #return recyling
##    def _set(self, recyling):
##        u'Indicates if returned features recycle.'
##    Recycling = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if returned features will contain all fields.'
##        #return AllFields
##    def _set(self, AllFields):
##        u'Indicates if returned features will contain all fields.'
##    AllFields = property(_get, _set, doc = _set.__doc__)
##


# values for enumeration 'esriTopoConfiguration'
esriTCChain = 0
esriTCLoop = 1
esriTCStar = 2
esriTCMesh = 3
esriTopoConfiguration = c_int # enum
IComplexJunctionFeature._methods_ = [
    COMMETHOD(['propget', helpstring(u'The geometry corresponding to the element with the given subID.')], HRESULT, 'GeometryForEdgeElement',
              ( ['in'], c_int, 'subID' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Geometry' )),
    COMMETHOD(['propget', helpstring(u'The number of EdgeFeatures associated with the indexed connection point.')], HRESULT, 'EdgeFeatureCount',
              ( ['in'], c_int, 'connectionPointIndex' ),
              ( ['retval', 'out'], POINTER(c_int), 'numFeatures' )),
    COMMETHOD(['propget', helpstring(u'The EdgeFeature associated with the specified index value and the indexed connection point.')], HRESULT, 'EdgeFeature',
              ( ['in'], c_int, 'connectionPointIndex' ),
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IEdgeFeature)), 'EdgeFeature' )),
    COMMETHOD(['propget', helpstring(u'The configuration of this Feature.')], HRESULT, 'TopologicalConfiguration',
              ( ['retval', 'out'], POINTER(esriTopoConfiguration), 'configuration' )),
    COMMETHOD(['propput', helpstring(u'The configuration of this Feature.')], HRESULT, 'TopologicalConfiguration',
              ( ['in'], esriTopoConfiguration, 'configuration' )),
    COMMETHOD(['propput', helpstring(u'The rotation angle of this Feature.')], HRESULT, 'RotationAngle',
              ( ['in'], c_double, 'rhs' )),
    COMMETHOD(['propget', helpstring(u'The EID associated with the specified field index.')], HRESULT, 'FieldToEIDMapping',
              ( ['in'], c_int, 'FieldIndex' ),
              ( ['retval', 'out'], POINTER(c_int), 'EID' )),
    COMMETHOD(['propget', helpstring(u'The number of junctions associated with this Feature.')], HRESULT, 'JunctionElementCount',
              ( ['retval', 'out'], POINTER(c_int), 'numJunctions' )),
    COMMETHOD(['hidden', helpstring(u'The number of junctions associated with this Feature.'), 'propput'], HRESULT, 'JunctionElementCount',
              ( ['in'], c_int, 'numJunctions' )),
    COMMETHOD([helpstring(u'The EID associated with the JunctionElement at the specified point.')], HRESULT, 'FindJunctionEID',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'point' ),
              ( ['retval', 'out'], POINTER(c_int), 'junctionEID' )),
]
################################################################
## code template for IComplexJunctionFeature implementation
##class IComplexJunctionFeature_Impl(object):
##    @property
##    def GeometryForEdgeElement(self, subID):
##        u'The geometry corresponding to the element with the given subID.'
##        #return Geometry
##
##    @property
##    def FieldToEIDMapping(self, FieldIndex):
##        u'The EID associated with the specified field index.'
##        #return EID
##
##    def _set(self, rhs):
##        u'The rotation angle of this Feature.'
##    RotationAngle = property(fset = _set, doc = _set.__doc__)
##
##    @property
##    def EdgeFeature(self, connectionPointIndex, Index):
##        u'The EdgeFeature associated with the specified index value and the indexed connection point.'
##        #return EdgeFeature
##
##    def _get(self):
##        u'The number of junctions associated with this Feature.'
##        #return numJunctions
##    def _set(self, numJunctions):
##        u'The number of junctions associated with this Feature.'
##    JunctionElementCount = property(_get, _set, doc = _set.__doc__)
##
##    def FindJunctionEID(self, point):
##        u'The EID associated with the JunctionElement at the specified point.'
##        #return junctionEID
##
##    @property
##    def EdgeFeatureCount(self, connectionPointIndex):
##        u'The number of EdgeFeatures associated with the indexed connection point.'
##        #return numFeatures
##
##    def _get(self):
##        u'The configuration of this Feature.'
##        #return configuration
##    def _set(self, configuration):
##        u'The configuration of this Feature.'
##    TopologicalConfiguration = property(_get, _set, doc = _set.__doc__)
##

class INativeTypeSearch(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to member that defines search of children.'
    _iid_ = GUID('{12B123E8-895D-4D2F-A7B0-C7C07CF195E0}')
    _idlflags_ = ['oleautomation']
INativeTypeSearch._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates whether the children of this native type should be searched.')], HRESULT, 'ExcludeChildren',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'ExcludeChildren' )),
]
################################################################
## code template for INativeTypeSearch implementation
##class INativeTypeSearch_Impl(object):
##    @property
##    def ExcludeChildren(self):
##        u'Indicates whether the children of this native type should be searched.'
##        #return ExcludeChildren
##

IObjects._methods_ = [
    COMMETHOD([helpstring(u'The number of objects in the array that belong to a specific class.')], HRESULT, 'Count',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'classFilter' ),
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD([helpstring(u'Insert object into the array at the given index.')], HRESULT, 'Insert',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(IUnknown), 'Object' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'CLSID' )),
    COMMETHOD([helpstring(u"Removes 'count' number of objects from the array starting at the given index.")], HRESULT, 'Remove',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], c_int, 'Count' )),
    COMMETHOD([helpstring(u'Retrieves an object from the array by index.')], HRESULT, 'Get',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IUnknown)), 'Object' )),
    COMMETHOD([helpstring(u'Add an object at the given index replacing the existing object, which is returned.')], HRESULT, 'Set',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(IUnknown), 'Object' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'CLSID' ),
              ( ['retval', 'out'], POINTER(POINTER(IUnknown)), 'previousObject' )),
]
################################################################
## code template for IObjects implementation
##class IObjects_Impl(object):
##    def Count(self, classFilter):
##        u'The number of objects in the array that belong to a specific class.'
##        #return Count
##
##    def Insert(self, Index, Object, CLSID):
##        u'Insert object into the array at the given index.'
##        #return 
##
##    def Set(self, Index, Object, CLSID):
##        u'Add an object at the given index replacing the existing object, which is returned.'
##        #return previousObject
##
##    def Remove(self, Index, Count):
##        u"Removes 'count' number of objects from the array starting at the given index."
##        #return 
##
##    def Get(self, Index):
##        u'Retrieves an object from the array by index.'
##        #return Object
##

class IXMLIndexTemplate(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'A standardized set of tags managed through a Geodatabase workspace.'
    _iid_ = GUID('{5C2B7178-119E-4D2D-BAD6-57769F9A2EEC}')
    _idlflags_ = ['oleautomation']
IEnumXMLIndexTemplate._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next XML Index Template in the enumerator.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IXMLIndexTemplate)), 'nextTemplate' )),
    COMMETHOD([helpstring(u'Resets the enumerator to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumXMLIndexTemplate implementation
##class IEnumXMLIndexTemplate_Impl(object):
##    def Reset(self):
##        u'Resets the enumerator to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next XML Index Template in the enumerator.'
##        #return nextTemplate
##

class JunctionConnectivityRule(CoClass):
    u'Esri Junction-Edge NetworkConnectivity rule object.'
    _reg_clsid_ = GUID('{F290D9E1-58E5-11D2-AB26-000000000000}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IJunctionConnectivityRule2(IJunctionConnectivityRule):
    _case_insensitive_ = True
    u'Provides access to members that supply information about, modify and manage junction-edge connectivity rules.'
    _iid_ = GUID('{B93B7600-0FEB-11D4-A063-00C04F6BDD84}')
    _idlflags_ = ['oleautomation']
JunctionConnectivityRule._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRule, IConnectivityRule, IJunctionConnectivityRule, IJunctionConnectivityRule2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

INativeTypeInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'The native type.')], HRESULT, 'NativeType',
              ( ['retval', 'out'], POINTER(POINTER(INativeType)), 'NativeType' )),
]
################################################################
## code template for INativeTypeInfo implementation
##class INativeTypeInfo_Impl(object):
##    @property
##    def NativeType(self):
##        u'The native type.'
##        #return NativeType
##

class NetWeightAssociation(CoClass):
    u'A container for defining an association between a network weight and a field in a table.'
    _reg_clsid_ = GUID('{19BDC491-6201-11D1-B255-0000F878229E}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class INetWeightAssociation(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that get information about the network weight association described by this NetWeightAssociation object.'
    _iid_ = GUID('{19BDC490-6201-11D1-B255-0000F878229E}')
    _idlflags_ = ['oleautomation']
class INetWeightAssociationEdit(INetWeightAssociation):
    _case_insensitive_ = True
    u'Provides access to members that set information for this NetWeightAssociation object.'
    _iid_ = GUID('{13D15D40-1119-11D2-B284-0000F878229E}')
    _idlflags_ = ['oleautomation']
NetWeightAssociation._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetWeightAssociation, INetWeightAssociationEdit, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

IComplexEdgeFeature._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of connected JunctionFeatures.')], HRESULT, 'JunctionFeatureCount',
              ( ['retval', 'out'], POINTER(c_int), 'numFeatures' )),
    COMMETHOD(['propget', helpstring(u'The JunctionFeature associated with the index.')], HRESULT, 'JunctionFeature',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IJunctionFeature)), 'JunctionFeature' )),
    COMMETHOD([helpstring(u'Inserts the specified JunctionElement into an edge at the point.')], HRESULT, 'SplitEdgeElement',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'point' ),
              ( ['in'], c_int, 'newJunctionEID' )),
    COMMETHOD(['propget', helpstring(u'The geometry associated with the two points.')], HRESULT, 'GeometryByPoints',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'fromPoint' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'toPoint' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Geometry' )),
    COMMETHOD(['propget', helpstring(u'The geometry (polyline) corresponding to the edge EID.')], HRESULT, 'GeometryForEID',
              ( ['in'], c_int, 'edgeEID' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Geometry' )),
    COMMETHOD([helpstring(u'Attempt to connect at the locations corresponding to intermediate vertices.')], HRESULT, 'ConnectAtIntermediateVertices'),
]
################################################################
## code template for IComplexEdgeFeature implementation
##class IComplexEdgeFeature_Impl(object):
##    @property
##    def JunctionFeatureCount(self):
##        u'The number of connected JunctionFeatures.'
##        #return numFeatures
##
##    @property
##    def JunctionFeature(self, Index):
##        u'The JunctionFeature associated with the index.'
##        #return JunctionFeature
##
##    @property
##    def GeometryByPoints(self, fromPoint, toPoint):
##        u'The geometry associated with the two points.'
##        #return Geometry
##
##    def ConnectAtIntermediateVertices(self):
##        u'Attempt to connect at the locations corresponding to intermediate vertices.'
##        #return 
##
##    @property
##    def GeometryForEID(self, edgeEID):
##        u'The geometry (polyline) corresponding to the edge EID.'
##        #return Geometry
##
##    def SplitEdgeElement(self, point, newJunctionEID):
##        u'Inserts the specified JunctionElement into an edge at the point.'
##        #return 
##

class UtilityNetwork(CoClass):
    u'A container for describing a utility network.'
    _reg_clsid_ = GUID('{91DD8AB5-E33D-11D4-9FEA-00C04F68E627}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IUtilityNetworkGEN(INetwork):
    _case_insensitive_ = True
    u'Provides access to members that get and set flow direction in a utility network.'
    _iid_ = GUID('{32012812-0631-4D1E-B92F-13CAD1502EDF}')
    _idlflags_ = ['oleautomation']
class INetworkUpdate(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that start and end sessions for updating the attributes, schema, and topology of the network.'
    _iid_ = GUID('{051C9860-1880-11D2-B289-0000F878229E}')
    _idlflags_ = ['oleautomation']
class INetSchema(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that get information about the schema of the network.'
    _iid_ = GUID('{5DB91DBB-AFB4-11D0-9CCD-00805F74D243}')
    _idlflags_ = ['oleautomation']
class INetSchemaEdit(INetSchema):
    _case_insensitive_ = True
    u'Provides access to members that modify the schema of the network.'
    _iid_ = GUID('{5DB91DB1-AFB4-11D0-9CCD-00805F74D243}')
    _idlflags_ = ['oleautomation']
class INetAttributes(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that get the disabled state and weight values of individual elements in the network.'
    _iid_ = GUID('{027E7417-981B-11D1-B264-0000F878229E}')
    _idlflags_ = ['oleautomation']
class INetAttributesEdit(INetAttributes):
    _case_insensitive_ = True
    u'Provides access to members that modify the disabled state and weight values of individual elements in the network.'
    _iid_ = GUID('{DA7FD2C0-0794-11D1-9CD6-00805F74D243}')
    _idlflags_ = ['oleautomation']
UtilityNetwork._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IUtilityNetworkGEN, INetwork, INetworkUpdate, INetElements, INetSchema, INetSchemaEdit, INetTopology, INetTopologyEdit, INetAttributes, INetAttributesEdit, IDataset, IDatasetEdit, IDatasetEditInfo, ISchemaLock, IVersionedObject2, IDatasetAnalyze]

IRowEdit._methods_ = [
    COMMETHOD([helpstring(u'Deletes the set of rows.')], HRESULT, 'DeleteSet',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'Rows' )),
]
################################################################
## code template for IRowEdit implementation
##class IRowEdit_Impl(object):
##    def DeleteSet(self, Rows):
##        u'Deletes the set of rows.'
##        #return 
##

IFeatureEdit._methods_ = [
    COMMETHOD([helpstring(u'Prepares the set of features for a move operation.')], HRESULT, 'BeginMoveSet',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'features' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'start' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IDisplayFeedback)), 'feedback' )),
    COMMETHOD([helpstring(u'Moves the set of features through a distance and direction specified by moveVector.')], HRESULT, 'MoveSet',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'features' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ILine), 'moveVector' )),
    COMMETHOD([helpstring(u'Rotates the set of features according to the specified origin and angle.')], HRESULT, 'RotateSet',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'features' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'Origin' ),
              ( ['in'], c_double, 'Angle' )),
    COMMETHOD([helpstring(u'Split the feature.')], HRESULT, 'Split',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'point' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet)), 'newFeatures' )),
    COMMETHOD([helpstring(u'Split the feature attributes.')], HRESULT, 'SplitAttributes',
              ( [], POINTER(IFeature), 'baseFeature' )),
]
################################################################
## code template for IFeatureEdit implementation
##class IFeatureEdit_Impl(object):
##    def BeginMoveSet(self, features, start):
##        u'Prepares the set of features for a move operation.'
##        #return feedback
##
##    def SplitAttributes(self, baseFeature):
##        u'Split the feature attributes.'
##        #return 
##
##    def RotateSet(self, features, Origin, Angle):
##        u'Rotates the set of features according to the specified origin and angle.'
##        #return 
##
##    def MoveSet(self, features, moveVector):
##        u'Moves the set of features through a distance and direction specified by moveVector.'
##        #return 
##
##    def Split(self, point):
##        u'Split the feature.'
##        #return newFeatures
##

IFeatureEdit2._methods_ = [
    COMMETHOD([helpstring(u'Split the feature by updating the split feature and creating new feature(s) for the smaller portion.')], HRESULT, 'SplitWithUpdate',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'Geometry' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet)), 'newFeatures' )),
]
################################################################
## code template for IFeatureEdit2 implementation
##class IFeatureEdit2_Impl(object):
##    def SplitWithUpdate(self, Geometry):
##        u'Split the feature by updating the split feature and creating new feature(s) for the smaller portion.'
##        #return newFeatures
##

IFeatureSnap._methods_ = [
    COMMETHOD([helpstring(u'Snap the feature based on the arguments.')], HRESULT, 'Snap',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'point' ),
              ( ['in'], c_double, 'tolerance' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'snapped' )),
]
################################################################
## code template for IFeatureSnap implementation
##class IFeatureSnap_Impl(object):
##    def Snap(self, point, tolerance):
##        u'Snap the feature based on the arguments.'
##        #return snapped
##

ISimpleNetworkFeature._methods_ = [
]
################################################################
## code template for ISimpleNetworkFeature implementation
##class ISimpleNetworkFeature_Impl(object):

class NetworkWorkspace(CoClass):
    u'A container for creating and maintaining information about the logical networks in this workspace.'
    _reg_clsid_ = GUID('{1F07A0B0-2E14-11D1-B24E-0000F878229E}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class INetworkWorkspace(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that create and maintain information about logical networks.'
    _iid_ = GUID('{4700C2E0-2E11-11D1-B24E-0000F878229E}')
    _idlflags_ = ['oleautomation']
class INetworkWorkspace2(INetworkWorkspace):
    _case_insensitive_ = True
    u'Provides access to members that create and maintain information about logical networks.'
    _iid_ = GUID('{33978FFF-118D-11D4-A0E7-00C04F6BDF0E}')
    _idlflags_ = ['oleautomation']
NetworkWorkspace._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkWorkspace, INetworkWorkspace2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class NetElementClass(CoClass):
    u'A container for describing a class in the network.'
    _reg_clsid_ = GUID('{91DD8AB7-E33D-11D4-9FEA-00C04F68E627}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class INetElementClass(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a member that gets the user class ID of an element class in the logical network.'
    _iid_ = GUID('{23A799E2-CCBC-11D0-9CCF-00805F74D243}')
    _idlflags_ = ['oleautomation']
NetElementClass._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetElementClass]

class WorkspaceHelper(CoClass):
    u'Esri Workspace Helper.'
    _reg_clsid_ = GUID('{DA10C1C6-09A3-11D4-9FAA-00C04F6BDF0C}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IWorkspaceHelper(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that allow you to get a reference to a Workspace from a Workspace Extension.'
    _iid_ = GUID('{DA10C1BD-09A3-11D4-9FAA-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
WorkspaceHelper._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IWorkspaceHelper]

class IFeatureElementEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for setting feature element properties.'
    _iid_ = GUID('{78773728-E142-11D1-AEC3-0000F80372B4}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriFeatureElementType'
esriFETWholeFeature = 1
esriFETVertex = 2
esriFETEdge = 4
esriFETPart = 8
esriFETAnnotation = 16
esriFETConnectionPoint = 32
esriFETConnectorPoint = 64
esriFeatureElementType = c_int # enum
class IFeatureElement(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members to return feature element properties.'
    _iid_ = GUID('{B617FB50-C4FD-11D1-AEA9-0000F80372B4}')
    _idlflags_ = ['oleautomation']
IFeatureElementEdit._methods_ = [
    COMMETHOD(['propputref', helpstring(u'The Feature that owns the Feature Element.')], HRESULT, 'Owner',
              ( ['in'], POINTER(IFeature), 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The Type of Feature Element.')], HRESULT, 'ElementType',
              ( ['in'], esriFeatureElementType, 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The Geometry of the Feature Element.')], HRESULT, 'Geometry',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The Parent of the Feature Element.')], HRESULT, 'Parent',
              ( ['in'], POINTER(IFeatureElement), 'rhs' )),
]
################################################################
## code template for IFeatureElementEdit implementation
##class IFeatureElementEdit_Impl(object):
##    def Owner(self, rhs):
##        u'The Feature that owns the Feature Element.'
##        #return 
##
##    def Geometry(self, rhs):
##        u'The Geometry of the Feature Element.'
##        #return 
##
##    def _set(self, rhs):
##        u'The Type of Feature Element.'
##    ElementType = property(fset = _set, doc = _set.__doc__)
##
##    def Parent(self, rhs):
##        u'The Parent of the Feature Element.'
##        #return 
##

class StreetNetwork(CoClass):
    u'A container for describing a street network.'
    _reg_clsid_ = GUID('{91DD8AB6-E33D-11D4-9FEA-00C04F68E627}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IStreetNetwork(INetwork):
    _case_insensitive_ = True
    u'Indicator interface for a street network.'
    _iid_ = GUID('{19F99C8B-A089-11D0-9CC9-00805F74D243}')
    _idlflags_ = ['oleautomation']
StreetNetwork._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetwork, IStreetNetwork, INetworkUpdate, INetElements, INetSchema, INetSchemaEdit, INetTopology, INetTopologyEdit, INetAttributes, INetAttributesEdit, IDataset, IDatasetEdit, IDatasetEditInfo, ISchemaLock, IVersionedObject2, IDatasetAnalyze]

IWorkspace._methods_ = [
    COMMETHOD(['propget', helpstring(u'The connection properties of the workspace.')], HRESULT, 'ConnectionProperties',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'ConnectionProperties' )),
    COMMETHOD(['propget', helpstring(u'The factory that created the workspace.')], HRESULT, 'WorkspaceFactory',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspaceFactory)), 'Factory' )),
    COMMETHOD(['propget', helpstring(u'The datasets in the workspace.')], HRESULT, 'Datasets',
              ( ['in'], esriDatasetType, 'DatasetType' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumDataset)), 'Datasets' )),
    COMMETHOD(['propget', helpstring(u'The DatasetNames in the workspace.')], HRESULT, 'DatasetNames',
              ( ['in'], esriDatasetType, 'DatasetType' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumDatasetName)), 'DatasetNames' )),
    COMMETHOD(['propget', helpstring(u'The file system full path of the workspace.')], HRESULT, 'PathName',
              ( ['retval', 'out'], POINTER(BSTR), 'PathName' )),
    COMMETHOD(['propget', helpstring(u'The Type of the Workspace.')], HRESULT, 'Type',
              ( ['retval', 'out'], POINTER(esriWorkspaceType), 'Type' )),
    COMMETHOD([helpstring(u'TRUE if the workspace is a file system directory.')], HRESULT, 'IsDirectory',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isDir' )),
    COMMETHOD([helpstring(u'Checks if the workspace exists.')], HRESULT, 'Exists',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Exists' )),
    COMMETHOD([helpstring(u'Executes the specified SQL statement.')], HRESULT, 'ExecuteSQL',
              ( ['in'], BSTR, 'sqlStmt' )),
]
################################################################
## code template for IWorkspace implementation
##class IWorkspace_Impl(object):
##    @property
##    def Datasets(self, DatasetType):
##        u'The datasets in the workspace.'
##        #return Datasets
##
##    @property
##    def DatasetNames(self, DatasetType):
##        u'The DatasetNames in the workspace.'
##        #return DatasetNames
##
##    def Exists(self):
##        u'Checks if the workspace exists.'
##        #return Exists
##
##    def ExecuteSQL(self, sqlStmt):
##        u'Executes the specified SQL statement.'
##        #return 
##
##    def IsDirectory(self):
##        u'TRUE if the workspace is a file system directory.'
##        #return isDir
##
##    @property
##    def PathName(self):
##        u'The file system full path of the workspace.'
##        #return PathName
##
##    @property
##    def WorkspaceFactory(self):
##        u'The factory that created the workspace.'
##        #return Factory
##
##    @property
##    def ConnectionProperties(self):
##        u'The connection properties of the workspace.'
##        #return ConnectionProperties
##
##    @property
##    def Type(self):
##        u'The Type of the Workspace.'
##        #return Type
##

IDatasetAnalyze._methods_ = [
    COMMETHOD([helpstring(u'Analyze the data to update/generate DBMS statistics.')], HRESULT, 'Analyze',
              ( ['in'], c_int, 'tableComponents' )),
    COMMETHOD(['propget', helpstring(u'The allowable components to be analyzed.')], HRESULT, 'AllowableComponents',
              ( ['retval', 'out'], POINTER(c_int), 'AllowableComponents' )),
]
################################################################
## code template for IDatasetAnalyze implementation
##class IDatasetAnalyze_Impl(object):
##    def Analyze(self, tableComponents):
##        u'Analyze the data to update/generate DBMS statistics.'
##        #return 
##
##    @property
##    def AllowableComponents(self):
##        u'The allowable components to be analyzed.'
##        #return AllowableComponents
##

IFeatureClassLoad._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the featureclass is in load only mode.')], HRESULT, 'LoadOnlyMode',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isInLoadMode' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the featureclass is in load only mode.')], HRESULT, 'LoadOnlyMode',
              ( ['in'], VARIANT_BOOL, 'isInLoadMode' )),
]
################################################################
## code template for IFeatureClassLoad implementation
##class IFeatureClassLoad_Impl(object):
##    def _get(self):
##        u'Indicates if the featureclass is in load only mode.'
##        #return isInLoadMode
##    def _set(self, isInLoadMode):
##        u'Indicates if the featureclass is in load only mode.'
##    LoadOnlyMode = property(_get, _set, doc = _set.__doc__)
##

IComplexNetworkFeature._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of edge elements associated with this Feature.')], HRESULT, 'EdgeElementCount',
              ( ['retval', 'out'], POINTER(c_int), 'numEdges' )),
    COMMETHOD([helpstring(u'The EID associated with the EdgeElement at the specified point.')], HRESULT, 'FindEdgeEID',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'point' ),
              ( ['retval', 'out'], POINTER(c_int), 'edgeEID' )),
    COMMETHOD(['propget', helpstring(u'Indicates whether the NetworkFeature is open or not (i.e., closed).')], HRESULT, 'EnabledByIndex',
              ( ['in'], c_int, 'edgeIndex' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isEnabled' )),
    COMMETHOD(['propput', helpstring(u'Indicates whether the NetworkFeature is open or not (i.e., closed).')], HRESULT, 'EnabledByIndex',
              ( ['in'], c_int, 'edgeIndex' ),
              ( ['in'], VARIANT_BOOL, 'isEnabled' )),
]
################################################################
## code template for IComplexNetworkFeature implementation
##class IComplexNetworkFeature_Impl(object):
##    @property
##    def EdgeElementCount(self):
##        u'The number of edge elements associated with this Feature.'
##        #return numEdges
##
##    def _get(self, edgeIndex):
##        u'Indicates whether the NetworkFeature is open or not (i.e., closed).'
##        #return isEnabled
##    def _set(self, edgeIndex, isEnabled):
##        u'Indicates whether the NetworkFeature is open or not (i.e., closed).'
##    EnabledByIndex = property(_get, _set, doc = _set.__doc__)
##
##    def FindEdgeEID(self, point):
##        u'The EID associated with the EdgeElement at the specified point.'
##        #return edgeEID
##

class ITimeQueryFilter(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Query filter that gives access to members that allow queries using time.'
    _iid_ = GUID('{20E1C9A6-FF1E-489F-BB59-B03BED3A8660}')
    _idlflags_ = ['oleautomation']
ITimeQueryFilter._methods_ = [
    COMMETHOD(['propget', helpstring(u'Time value.')], HRESULT, 'TimeValue',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITimeValue)), 'TimeValue' )),
    COMMETHOD(['propputref', helpstring(u'Time value.')], HRESULT, 'TimeValue',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITimeValue), 'TimeValue' )),
    COMMETHOD(['propget', helpstring(u'Output time reference.')], HRESULT, 'OutputTimeReference',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITimeReference)), 'TimeReference' )),
    COMMETHOD(['propputref', helpstring(u'Output time reference.')], HRESULT, 'OutputTimeReference',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITimeReference), 'TimeReference' )),
    COMMETHOD(['propget', helpstring(u'Time relation for the time query.')], HRESULT, 'TimeRelation',
              ( ['retval', 'out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.esriTimeRelation), 'relation' )),
    COMMETHOD(['propput', helpstring(u'Time relation for the time query.')], HRESULT, 'TimeRelation',
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.esriTimeRelation, 'relation' )),
]
################################################################
## code template for ITimeQueryFilter implementation
##class ITimeQueryFilter_Impl(object):
##    def OutputTimeReference(self, TimeReference):
##        u'Output time reference.'
##        #return 
##
##    def TimeValue(self, TimeValue):
##        u'Time value.'
##        #return 
##
##    def _get(self):
##        u'Time relation for the time query.'
##        #return relation
##    def _set(self, relation):
##        u'Time relation for the time query.'
##    TimeRelation = property(_get, _set, doc = _set.__doc__)
##

class EnumNetWeightAssociation(CoClass):
    u'A container for defining a network weight association enumeration.'
    _reg_clsid_ = GUID('{E3D2B732-E652-11D4-9FEB-00C04F68E627}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IEnumNetWeightAssociation(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that iterate through an enumeration of weight associations.'
    _iid_ = GUID('{13D15D41-1119-11D2-B284-0000F878229E}')
    _idlflags_ = ['oleautomation']
EnumNetWeightAssociation._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumNetWeightAssociation]

IQueryDescription._methods_ = [
    COMMETHOD(['propput', helpstring(u'Srid of the resultset.')], HRESULT, 'Srid',
              ( ['in'], BSTR, 'pSrid' )),
    COMMETHOD(['propget', helpstring(u'Srid of the resultset.')], HRESULT, 'Srid',
              ( ['retval', 'out'], POINTER(BSTR), 'pSrid' )),
    COMMETHOD(['propput', helpstring(u'Spatial reference.')], HRESULT, 'SpatialReference',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'ppSpatialReference' )),
    COMMETHOD(['propget', helpstring(u'Spatial reference.')], HRESULT, 'SpatialReference',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference)), 'ppSpatialReference' )),
    COMMETHOD(['propput', helpstring(u'Unique key field(s).')], HRESULT, 'OIDFields',
              ( ['in'], BSTR, 'ppOidMap' )),
    COMMETHOD(['propget', helpstring(u'Unique key field(s).')], HRESULT, 'OIDFields',
              ( ['retval', 'out'], POINTER(BSTR), 'ppOidMap' )),
    COMMETHOD(['propput', helpstring(u'Geometry type on the spatial column if present.')], HRESULT, 'GeometryType',
              ( ['in'], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType, 'pGeomType' )),
    COMMETHOD(['propget', helpstring(u'Geometry type on the spatial column if present.')], HRESULT, 'GeometryType',
              ( ['retval', 'out'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType), 'pGeomType' )),
    COMMETHOD(['propget', helpstring(u'Geometry column if present.')], HRESULT, 'ShapeColumnName',
              ( ['retval', 'out'], POINTER(BSTR), 'pShapeColumnName' )),
    COMMETHOD(['propget', helpstring(u'Name of OID field.')], HRESULT, 'OIDColumnName',
              ( ['retval', 'out'], POINTER(BSTR), 'pOIDColumnName' )),
    COMMETHOD(['propget', helpstring(u'The resultset fields.')], HRESULT, 'Fields',
              ( ['retval', 'out'], POINTER(POINTER(IFields)), 'ppFields' )),
    COMMETHOD(['propget', helpstring(u'Query statemaent.')], HRESULT, 'Query',
              ( ['retval', 'out'], POINTER(BSTR), 'pQuery' )),
    COMMETHOD(['propget', helpstring(u'Indicates if a virtual OID column is required.')], HRESULT, 'IsOIDMappedColumn',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pIsOIDMappedColumn' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the query resultset is spatial.')], HRESULT, 'IsSpatialQuery',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pIsSpatialQuery' )),
]
################################################################
## code template for IQueryDescription implementation
##class IQueryDescription_Impl(object):
##    @property
##    def IsOIDMappedColumn(self):
##        u'Indicates if a virtual OID column is required.'
##        #return pIsOIDMappedColumn
##
##    @property
##    def ShapeColumnName(self):
##        u'Geometry column if present.'
##        #return pShapeColumnName
##
##    @property
##    def Fields(self):
##        u'The resultset fields.'
##        #return ppFields
##
##    @property
##    def IsSpatialQuery(self):
##        u'Indicates if the query resultset is spatial.'
##        #return pIsSpatialQuery
##
##    @property
##    def OIDColumnName(self):
##        u'Name of OID field.'
##        #return pOIDColumnName
##
##    def _get(self):
##        u'Spatial reference.'
##        #return ppSpatialReference
##    def _set(self, ppSpatialReference):
##        u'Spatial reference.'
##    SpatialReference = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Geometry type on the spatial column if present.'
##        #return pGeomType
##    def _set(self, pGeomType):
##        u'Geometry type on the spatial column if present.'
##    GeometryType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Srid of the resultset.'
##        #return pSrid
##    def _set(self, pSrid):
##        u'Srid of the resultset.'
##    Srid = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def Query(self):
##        u'Query statemaent.'
##        #return pQuery
##
##    def _get(self):
##        u'Unique key field(s).'
##        #return ppOidMap
##    def _set(self, ppOidMap):
##        u'Unique key field(s).'
##    OIDFields = property(_get, _set, doc = _set.__doc__)
##

IFeatureWorkspaceSchemaEdit._methods_ = [
    COMMETHOD([helpstring(u'Changes the instance COM class associated with this database class.')], HRESULT, 'AlterInstanceCLSID',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'InstanceCLSID' )),
    COMMETHOD([helpstring(u'Changes the class extension COM class associated with this database class.')], HRESULT, 'AlterClassExtensionCLSID',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'ClassExtensionCLSID' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'classExtensionProperties' )),
]
################################################################
## code template for IFeatureWorkspaceSchemaEdit implementation
##class IFeatureWorkspaceSchemaEdit_Impl(object):
##    def AlterInstanceCLSID(self, Name, InstanceCLSID):
##        u'Changes the instance COM class associated with this database class.'
##        #return 
##
##    def AlterClassExtensionCLSID(self, Name, ClassExtensionCLSID, classExtensionProperties):
##        u'Changes the class extension COM class associated with this database class.'
##        #return 
##

class NetElementDescription(CoClass):
    u'A container for describing an element in the network.'
    _reg_clsid_ = GUID('{B1EB90E2-0CFA-11D1-9CD7-00805F74D243}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
NetElementDescription._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetElementDescription, INetElementDescriptionEdit]

class IGPMessagesCallback(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to Geoprocessor message callbacks.'
    _iid_ = GUID('{1264C9A8-0AFE-4903-87BA-A39B1F72779D}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriGPMessageSeverity'
esriGPMessageSeverityInformative = 0
esriGPMessageSeverityWarning = 1
esriGPMessageSeverityError = 2
esriGPMessageSeverityAbort = 3
esriGPMessageSeverity = c_int # enum
IGPMessages._methods_ = [
    COMMETHOD(['propputref', helpstring(u'The callback object associated with the GPMessages object.')], HRESULT, 'Callback',
              ( ['in'], POINTER(IGPMessagesCallback), 'messagesCallback' )),
    COMMETHOD(['propget', helpstring(u'The callback object associated with the GPMessages object.')], HRESULT, 'Callback',
              ( ['retval', 'out'], POINTER(POINTER(IGPMessagesCallback)), 'messagesCallback' )),
    COMMETHOD([helpstring(u'Clears the message objects from messages object.')], HRESULT, 'Clear'),
    COMMETHOD([helpstring(u'Adds a message object to the messages.')], HRESULT, 'Add',
              ( ['in'], POINTER(IGPMessage), 'msg' )),
    COMMETHOD([helpstring(u'Adds a warning message to the messages.')], HRESULT, 'AddWarning',
              ( ['in'], BSTR, 'Message' )),
    COMMETHOD([helpstring(u'Adds an abort message to the messages.')], HRESULT, 'AddAbort',
              ( ['in'], BSTR, 'Message' )),
    COMMETHOD([helpstring(u'Adds an error message to the messages.')], HRESULT, 'AddError',
              ( ['in'], c_int, 'ErrorCode' ),
              ( ['in'], BSTR, 'Message' )),
    COMMETHOD([helpstring(u'Adds an informative message to the messages.')], HRESULT, 'AddMessage',
              ( ['in'], BSTR, 'Message' )),
    COMMETHOD([helpstring(u'Adds all messages from an existing messages object to this messages object.')], HRESULT, 'AddMessages',
              ( ['in'], POINTER(IGPMessages), 'Messages' )),
    COMMETHOD([helpstring(u'Creates a number of empty messages and adds them to this messages object.')], HRESULT, 'InitializeMessages',
              ( ['in'], c_int, 'nMessages' )),
    COMMETHOD([helpstring(u'Replace an existing message in a specified location with a new message object.')], HRESULT, 'Replace',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(IGPMessage), 'msg' )),
    COMMETHOD([helpstring(u'Creates message of type esriGPMessageTypeError and replaces it into a specified position.')], HRESULT, 'ReplaceError',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], c_int, 'ErrorCode' ),
              ( ['in'], BSTR, 'Message' )),
    COMMETHOD([helpstring(u'Creates message of type esriGPMessageTypeWarning and replaces it into a specified position.')], HRESULT, 'ReplaceWarning',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], BSTR, 'Message' )),
    COMMETHOD([helpstring(u'Creates message of type esriGPMessageTypeAbort and replaces it into a specified position.')], HRESULT, 'ReplaceAbort',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], BSTR, 'Message' )),
    COMMETHOD([helpstring(u'Creates message and replaces it into a specified position.')], HRESULT, 'ReplaceMessage',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], BSTR, 'Message' )),
    COMMETHOD(['propget', helpstring(u'The message count.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD([helpstring(u'Provides a message object from the specified location.')], HRESULT, 'GetMessage',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IGPMessage)), 'msg' )),
    COMMETHOD(['propget', helpstring(u'The array of message objects.')], HRESULT, 'Messages',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'msgs' )),
    COMMETHOD(['propget', helpstring(u'The maximum message severity.')], HRESULT, 'MaxSeverity',
              ( ['retval', 'out'], POINTER(esriGPMessageSeverity), 'severity' )),
]
################################################################
## code template for IGPMessages implementation
##class IGPMessages_Impl(object):
##    @property
##    def Count(self):
##        u'The message count.'
##        #return Count
##
##    def AddError(self, ErrorCode, Message):
##        u'Adds an error message to the messages.'
##        #return 
##
##    def ReplaceWarning(self, Index, Message):
##        u'Creates message of type esriGPMessageTypeWarning and replaces it into a specified position.'
##        #return 
##
##    def AddMessage(self, Message):
##        u'Adds an informative message to the messages.'
##        #return 
##
##    @property
##    def MaxSeverity(self):
##        u'The maximum message severity.'
##        #return severity
##
##    @property
##    def Messages(self):
##        u'The array of message objects.'
##        #return msgs
##
##    def Clear(self):
##        u'Clears the message objects from messages object.'
##        #return 
##
##    def ReplaceMessage(self, Index, Message):
##        u'Creates message and replaces it into a specified position.'
##        #return 
##
##    def AddMessages(self, Messages):
##        u'Adds all messages from an existing messages object to this messages object.'
##        #return 
##
##    def AddWarning(self, Message):
##        u'Adds a warning message to the messages.'
##        #return 
##
##    def Replace(self, Index, msg):
##        u'Replace an existing message in a specified location with a new message object.'
##        #return 
##
##    @property
##    def Callback(self, messagesCallback):
##        u'The callback object associated with the GPMessages object.'
##        #return 
##
##    def Add(self, msg):
##        u'Adds a message object to the messages.'
##        #return 
##
##    def GetMessage(self, Index):
##        u'Provides a message object from the specified location.'
##        #return msg
##
##    def InitializeMessages(self, nMessages):
##        u'Creates a number of empty messages and adds them to this messages object.'
##        #return 
##
##    def ReplaceAbort(self, Index, Message):
##        u'Creates message of type esriGPMessageTypeAbort and replaces it into a specified position.'
##        #return 
##
##    def ReplaceError(self, Index, ErrorCode, Message):
##        u'Creates message of type esriGPMessageTypeError and replaces it into a specified position.'
##        #return 
##
##    def AddAbort(self, Message):
##        u'Adds an abort message to the messages.'
##        #return 
##

IItemInfo2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Credits of the item.')], HRESULT, 'Credits',
              ( ['retval', 'out'], POINTER(BSTR), 'pCredits' )),
    COMMETHOD(['propput', helpstring(u'Credits of the item.')], HRESULT, 'Credits',
              ( ['in'], BSTR, 'pCredits' )),
    COMMETHOD(['propget', helpstring(u'Minimum scale of the item.')], HRESULT, 'MinScale',
              ( ['retval', 'out'], POINTER(c_double), 'pScale' )),
    COMMETHOD(['propput', helpstring(u'Minimum scale of the item.')], HRESULT, 'MinScale',
              ( ['in'], c_double, 'pScale' )),
    COMMETHOD(['propget', helpstring(u'Maximum scale of the item.')], HRESULT, 'MaxScale',
              ( ['retval', 'out'], POINTER(c_double), 'pScale' )),
    COMMETHOD(['propput', helpstring(u'Maximum scale of the item.')], HRESULT, 'MaxScale',
              ( ['in'], c_double, 'pScale' )),
    COMMETHOD(['propget', helpstring(u'The name of the spatial reference.')], HRESULT, 'SpatialReferenceName',
              ( ['retval', 'out'], POINTER(BSTR), 'srName' )),
]
################################################################
## code template for IItemInfo2 implementation
##class IItemInfo2_Impl(object):
##    def _get(self):
##        u'Credits of the item.'
##        #return pCredits
##    def _set(self, pCredits):
##        u'Credits of the item.'
##    Credits = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Minimum scale of the item.'
##        #return pScale
##    def _set(self, pScale):
##        u'Minimum scale of the item.'
##    MinScale = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Maximum scale of the item.'
##        #return pScale
##    def _set(self, pScale):
##        u'Maximum scale of the item.'
##    MaxScale = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def SpatialReferenceName(self):
##        u'The name of the spatial reference.'
##        #return srName
##

class EnumNetEIDArray(CoClass):
    u'A container for defining a network element ID (EID) enumeration.'
    _reg_clsid_ = GUID('{4D2236DE-1525-11D3-9F4A-00C04F68E627}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IEnumNetEIDBuilderGEN(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that build an enumeration of network element IDs (EIDs).'
    _iid_ = GUID('{17582DDF-C06D-4C81-B32A-F23B74B1546E}')
    _idlflags_ = ['oleautomation']
class IEnumNetEIDBuilder(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that build an enumeration of network element IDs (EIDs).'
    _iid_ = GUID('{697ADA1E-A05C-4FFB-BD41-EB47B1773310}')
    _idlflags_ = []
EnumNetEIDArray._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumNetEID, IEnumNetEIDBuilderGEN, IEnumNetEIDBuilder]

class IEnumNetworkFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate network features and resets the enumeration.'
    _iid_ = GUID('{E75E9906-55FB-11D1-AE55-0000F80372B4}')
    _idlflags_ = ['oleautomation']
IEnumNetworkFeature._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next NetworkFeature in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(INetworkFeature)), 'Feature' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumNetworkFeature implementation
##class IEnumNetworkFeature_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next NetworkFeature in the enumeration sequence.'
##        #return Feature
##

IFilterDef._methods_ = [
]
################################################################
## code template for IFilterDef implementation
##class IFilterDef_Impl(object):

class IPlugInDatasetInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe a dataset.'
    _iid_ = GUID('{EE190B37-11B4-414A-BD25-43C49CAA6433}')
    _idlflags_ = ['oleautomation']
IPlugInDatasetInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the dataset within the workspace.')], HRESULT, 'LocalDatasetName',
              ( ['retval', 'out'], POINTER(BSTR), 'localName' )),
    COMMETHOD(['propget', helpstring(u'The type of the dataset.')], HRESULT, 'DatasetType',
              ( ['retval', 'out'], POINTER(esriDatasetType), 'DatasetType' )),
    COMMETHOD(['propget', helpstring(u'The geometry type of the dataset.')], HRESULT, 'GeometryType',
              ( ['retval', 'out'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType), 'GeometryType' )),
    COMMETHOD(['propget', helpstring(u"The name of the dataset's shape field.")], HRESULT, 'ShapeFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'ShapeFieldName' )),
]
################################################################
## code template for IPlugInDatasetInfo implementation
##class IPlugInDatasetInfo_Impl(object):
##    @property
##    def ShapeFieldName(self):
##        u"The name of the dataset's shape field."
##        #return ShapeFieldName
##
##    @property
##    def DatasetType(self):
##        u'The type of the dataset.'
##        #return DatasetType
##
##    @property
##    def GeometryType(self):
##        u'The geometry type of the dataset.'
##        #return GeometryType
##
##    @property
##    def LocalDatasetName(self):
##        u'The name of the dataset within the workspace.'
##        #return localName
##

class INameMapping2(INameMapping):
    _case_insensitive_ = True
    u'Provides access to members that manage name mapping and conflicts between two locations.'
    _iid_ = GUID('{D4E6BADF-3EB9-4F4E-9103-C7D0CBC119A2}')
    _idlflags_ = ['oleautomation']
INameMapping._methods_ = [
    COMMETHOD(['propget', helpstring(u'The Source Object.')], HRESULT, 'SourceObject',
              ( ['retval', 'out'], POINTER(POINTER(IUnknown)), 'sObject' )),
    COMMETHOD(['propput', helpstring(u'The name of the copied object.')], HRESULT, 'TargetName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The name of the copied object.')], HRESULT, 'TargetName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'Indicates if target name conflicts with source name.')], HRESULT, 'NameConflicts',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'conflicts' )),
    COMMETHOD([helpstring(u'Checks whether target name conflicts or not.')], HRESULT, 'ValidateTargetName',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'toName' )),
    COMMETHOD([helpstring(u'Gets the suggested name of the copied object (if conflict).')], HRESULT, 'GetSuggestedName',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'toName' ),
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'Children objects (if any).')], HRESULT, 'Children',
              ( ['retval', 'out'], POINTER(POINTER(IEnumNameMapping)), 'Objects' )),
    COMMETHOD(['propput', helpstring(u'The configuration keyword (for the data transfer).')], HRESULT, 'ConfigKeyword',
              ( ['in'], BSTR, 'rhs' )),
]
################################################################
## code template for INameMapping implementation
##class INameMapping_Impl(object):
##    @property
##    def SourceObject(self):
##        u'The Source Object.'
##        #return sObject
##
##    def _get(self):
##        u'The name of the copied object.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the copied object.'
##    TargetName = property(_get, _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The configuration keyword (for the data transfer).'
##    ConfigKeyword = property(fset = _set, doc = _set.__doc__)
##
##    @property
##    def NameConflicts(self):
##        u'Indicates if target name conflicts with source name.'
##        #return conflicts
##
##    def GetSuggestedName(self, toName):
##        u'Gets the suggested name of the copied object (if conflict).'
##        #return Name
##
##    @property
##    def Children(self):
##        u'Children objects (if any).'
##        #return Objects
##
##    def ValidateTargetName(self, toName):
##        u'Checks whether target name conflicts or not.'
##        #return 
##

INameMapping2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The configuration keyword for the data transfer.')], HRESULT, 'ConfigKeyword',
              ( ['retval', 'out'], POINTER(BSTR), 'keyword' )),
    COMMETHOD(['propget', helpstring(u'Indicates whether the object was created.')], HRESULT, 'Created',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Created' )),
]
################################################################
## code template for INameMapping2 implementation
##class INameMapping2_Impl(object):
##    @property
##    def ConfigKeyword(self):
##        u'The configuration keyword for the data transfer.'
##        #return keyword
##
##    @property
##    def Created(self):
##        u'Indicates whether the object was created.'
##        #return Created
##

IQueryFilterDefinition2._methods_ = [
    COMMETHOD(['propget', helpstring(u'A clause that will be inserted between the SELECT keyword and the SELECT COLUMN LIST.  Most commonly used for clauses like DISTINCT or ALL.')], HRESULT, 'PrefixClause',
              ( ['retval', 'out'], POINTER(BSTR), 'clause' )),
    COMMETHOD(['propput', helpstring(u'A clause that will be inserted between the SELECT keyword and the SELECT COLUMN LIST.  Most commonly used for clauses like DISTINCT or ALL.')], HRESULT, 'PrefixClause',
              ( ['in'], BSTR, 'clause' )),
]
################################################################
## code template for IQueryFilterDefinition2 implementation
##class IQueryFilterDefinition2_Impl(object):
##    def _get(self):
##        u'A clause that will be inserted between the SELECT keyword and the SELECT COLUMN LIST.  Most commonly used for clauses like DISTINCT or ALL.'
##        #return clause
##    def _set(self, clause):
##        u'A clause that will be inserted between the SELECT keyword and the SELECT COLUMN LIST.  Most commonly used for clauses like DISTINCT or ALL.'
##    PrefixClause = property(_get, _set, doc = _set.__doc__)
##

IEnumSpatialReferenceInfo._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next spatial reference object.')], HRESULT, 'Next',
              ( ['out'], POINTER(c_int), 'Srid' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference)), 'info' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumSpatialReferenceInfo implementation
##class IEnumSpatialReferenceInfo_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next spatial reference object.'
##        #return Srid, info
##

IFilterDefs._methods_ = [
    COMMETHOD(['propget', helpstring(u'The filter definition count.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The filter definition at the specified position.')], HRESULT, 'Element',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IFilterDef)), 'filterDef' )),
    COMMETHOD([helpstring(u'Removes the filter definition at the specified position.')], HRESULT, 'Remove',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD([helpstring(u'Removes all filter definition objects.')], HRESULT, 'RemoveAll'),
    COMMETHOD([helpstring(u'Adds a filter definition object.')], HRESULT, 'Add',
              ( ['in'], POINTER(IFilterDef), 'filterDef' )),
    COMMETHOD([helpstring(u'Adds a filter definition property at the specified position.')], HRESULT, 'Insert',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(IFilterDef), 'filterDef' )),
]
################################################################
## code template for IFilterDefs implementation
##class IFilterDefs_Impl(object):
##    @property
##    def Count(self):
##        u'The filter definition count.'
##        #return Count
##
##    def Insert(self, Index, filterDef):
##        u'Adds a filter definition property at the specified position.'
##        #return 
##
##    def Remove(self, Index):
##        u'Removes the filter definition at the specified position.'
##        #return 
##
##    @property
##    def Element(self, Index):
##        u'The filter definition at the specified position.'
##        #return filterDef
##
##    def RemoveAll(self):
##        u'Removes all filter definition objects.'
##        #return 
##
##    def Add(self, filterDef):
##        u'Adds a filter definition object.'
##        #return 
##

class DEGeometricNetwork(CoClass):
    u'GeometricNetwork Data Element object.'
    _reg_clsid_ = GUID('{FE68BA8C-935D-4F6F-80D5-7957F8DBEFDF}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DEGeometricNetwork._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEGeometricNetwork2, IDEGeoDataset, IDEDataset2, IDataElement, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe]

class DETopology(CoClass):
    u'Topology Data Element object.'
    _reg_clsid_ = GUID('{ACC4637D-D5E0-47D5-ABCD-9F25AB326E6F}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDETopology(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about topology data elements.'
    _iid_ = GUID('{2F5817AB-5C2F-4250-B515-D2BDCDB5FA84}')
    _idlflags_ = ['oleautomation']
DETopology._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDETopology, IDEGeoDataset, IDEDataset2, IDataElement, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe]

class IDatabaseConnectionInfo4(IDatabaseConnectionInfo3):
    _case_insensitive_ = True
    u"Provides access to members that provide information about the Workspace's connected database."
    _iid_ = GUID('{7461E679-FD70-4655-B5F5-BCF5FF97064A}')
    _idlflags_ = ['oleautomation']
IDatabaseConnectionInfo4._methods_ = [
    COMMETHOD(['propput', helpstring(u'The realm used to create fully qualified names for Editor Tracking.')], HRESULT, 'Realm',
              ( ['in'], BSTR, 'Realm' )),
    COMMETHOD(['propget', helpstring(u'The realm used to create fully qualified names for Editor Tracking.')], HRESULT, 'Realm',
              ( ['retval', 'out'], POINTER(BSTR), 'Realm' )),
    COMMETHOD([helpstring(u'The default qualifier used to create fully qualified names for Editor Tracking.')], HRESULT, 'GenerateDefaultRealm',
              ( ['retval', 'out'], POINTER(BSTR), 'defaultRealm' )),
    COMMETHOD(['propget', helpstring(u'The current UTC date/time.')], HRESULT, 'ConnectionCurrentDateTimeInUTC',
              ( ['retval', 'out'], POINTER(VARIANT), 'datetime' )),
]
################################################################
## code template for IDatabaseConnectionInfo4 implementation
##class IDatabaseConnectionInfo4_Impl(object):
##    @property
##    def ConnectionCurrentDateTimeInUTC(self):
##        u'The current UTC date/time.'
##        #return datetime
##
##    def _get(self):
##        u'The realm used to create fully qualified names for Editor Tracking.'
##        #return Realm
##    def _set(self, Realm):
##        u'The realm used to create fully qualified names for Editor Tracking.'
##    Realm = property(_get, _set, doc = _set.__doc__)
##
##    def GenerateDefaultRealm(self):
##        u'The default qualifier used to create fully qualified names for Editor Tracking.'
##        #return defaultRealm
##

class IRasterCursor(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that provide optimized raster access.'
    _iid_ = GUID('{3A625C22-A707-11D2-8E30-00A0249480F0}')
    _idlflags_ = ['oleautomation']
IRaster._methods_ = [
    COMMETHOD([helpstring(u'Read a block of pixels starting from the top left corner.')], HRESULT, 'Read',
              ( ['in'], POINTER(IPnt), 'tlc' ),
              ( ['in'], POINTER(IPixelBlock), 'block' )),
    COMMETHOD([helpstring(u'Allocates a PixelBlock of requested size.')], HRESULT, 'CreatePixelBlock',
              ( ['in'], POINTER(IPnt), 'Size' ),
              ( ['retval', 'out'], POINTER(POINTER(IPixelBlock)), 'pxlblk' )),
    COMMETHOD([helpstring(u'Allocates a Raster Cursor for fast raster scanning.')], HRESULT, 'CreateCursor',
              ( ['retval', 'out'], POINTER(POINTER(IRasterCursor)), 'Cursor' )),
    COMMETHOD(['propget', helpstring(u'Interpolation method used when reading pixels.')], HRESULT, 'ResampleMethod',
              ( ['retval', 'out'], POINTER(rstResamplingTypes), 'val' )),
    COMMETHOD(['propput', helpstring(u'Interpolation method used when reading pixels.')], HRESULT, 'ResampleMethod',
              ( ['in'], rstResamplingTypes, 'val' )),
]
################################################################
## code template for IRaster implementation
##class IRaster_Impl(object):
##    def Read(self, tlc, block):
##        u'Read a block of pixels starting from the top left corner.'
##        #return 
##
##    def _get(self):
##        u'Interpolation method used when reading pixels.'
##        #return val
##    def _set(self, val):
##        u'Interpolation method used when reading pixels.'
##    ResampleMethod = property(_get, _set, doc = _set.__doc__)
##
##    def CreateCursor(self):
##        u'Allocates a Raster Cursor for fast raster scanning.'
##        #return Cursor
##
##    def CreatePixelBlock(self, Size):
##        u'Allocates a PixelBlock of requested size.'
##        #return pxlblk
##

IGPMessage2._methods_ = [
    COMMETHOD([helpstring(u'Creates the error or warning message with code ID.')], HRESULT, 'CreateIDMessage',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ErrorCode' )),
    COMMETHOD([helpstring(u'Creates the error or warning message with code ID, one argument.')], HRESULT, 'CreateIDMessage1Args',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ErrorCode' ),
              ( ['in'], BSTR, 'arg' )),
    COMMETHOD([helpstring(u'Creates the error or warning message with code ID, two arguments.')], HRESULT, 'CreateIDMessage2Args',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ErrorCode' ),
              ( ['in'], BSTR, 'arg1' ),
              ( ['in'], BSTR, 'arg2' )),
]
################################################################
## code template for IGPMessage2 implementation
##class IGPMessage2_Impl(object):
##    def CreateIDMessage2Args(self, Type, ErrorCode, arg1, arg2):
##        u'Creates the error or warning message with code ID, two arguments.'
##        #return 
##
##    def CreateIDMessage1Args(self, Type, ErrorCode, arg):
##        u'Creates the error or warning message with code ID, one argument.'
##        #return 
##
##    def CreateIDMessage(self, Type, ErrorCode):
##        u'Creates the error or warning message with code ID.'
##        #return 
##

class DEGeometricNetworkType(CoClass):
    u'GeometricNetwork Data Type object.'
    _reg_clsid_ = GUID('{D2BA94EF-A424-4FCF-A6D2-5015A1B2080E}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DEGeometricNetworkType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEGeometricNetworkType, IDEGeoDatasetType, IDEDatasetType, IGxFilterInfo, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, IDataElementType]

IPixelBlock._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of pixel arrays contained in the PixelBlock.')], HRESULT, 'Planes',
              ( ['retval', 'out'], POINTER(c_int), 'val' )),
    COMMETHOD(['propget', helpstring(u'The width of the PixelBlock in pixels.')], HRESULT, 'Width',
              ( ['retval', 'out'], POINTER(c_int), 'val' )),
    COMMETHOD(['propget', helpstring(u'The height of the PixelBlock in pixels.')], HRESULT, 'Height',
              ( ['retval', 'out'], POINTER(c_int), 'val' )),
    COMMETHOD(['propget', helpstring(u'The pixel type of the PixelBlock.')], HRESULT, 'PixelType',
              ( ['in'], c_int, 'plane' ),
              ( ['retval', 'out'], POINTER(rstPixelType), 'val' )),
    COMMETHOD(['propput', helpstring(u'The pixel type of the PixelBlock.')], HRESULT, 'PixelType',
              ( ['in'], c_int, 'plane' ),
              ( ['in'], rstPixelType, 'val' )),
    COMMETHOD(['propget', helpstring(u'The number of bytes per pixel for the PixelBlock.')], HRESULT, 'BytesPerPixel',
              ( ['retval', 'out'], POINTER(c_int), 'val' )),
    COMMETHOD(['propget', helpstring(u'A variant SafeArray of pixels for a specified plane.')], HRESULT, 'SafeArray',
              ( ['in'], c_int, 'plane' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'val' )),
    COMMETHOD(['propput', helpstring(u'A variant SafeArray of pixels for a specified plane.')], HRESULT, 'SafeArray',
              ( ['in'], c_int, 'plane' ),
              ( ['in'], VARIANT, 'val' )),
    COMMETHOD([helpstring(u'The value for a specified pixel.')], HRESULT, 'GetVal',
              ( ['in'], c_int, 'plane' ),
              ( ['in'], c_int, 'X' ),
              ( ['in'], c_int, 'Y' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'val' )),
]
################################################################
## code template for IPixelBlock implementation
##class IPixelBlock_Impl(object):
##    def _get(self, plane):
##        u'A variant SafeArray of pixels for a specified plane.'
##        #return val
##    def _set(self, plane, val):
##        u'A variant SafeArray of pixels for a specified plane.'
##    SafeArray = property(_get, _set, doc = _set.__doc__)
##
##    def GetVal(self, plane, X, Y):
##        u'The value for a specified pixel.'
##        #return val
##
##    def _get(self, plane):
##        u'The pixel type of the PixelBlock.'
##        #return val
##    def _set(self, plane, val):
##        u'The pixel type of the PixelBlock.'
##    PixelType = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def Planes(self):
##        u'The number of pixel arrays contained in the PixelBlock.'
##        #return val
##
##    @property
##    def Height(self):
##        u'The height of the PixelBlock in pixels.'
##        #return val
##
##    @property
##    def Width(self):
##        u'The width of the PixelBlock in pixels.'
##        #return val
##
##    @property
##    def BytesPerPixel(self):
##        u'The number of bytes per pixel for the PixelBlock.'
##        #return val
##

class DETopologyType(CoClass):
    _reg_clsid_ = GUID('{4C008436-C283-408F-B5F9-F6804C7E3635}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDETopologyType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the Topology Data Element type.'
    _iid_ = GUID('{924FD381-F8F0-45C5-AAEA-34F2959770E6}')
    _idlflags_ = ['oleautomation']
DETopologyType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDETopologyType, IDEGeoDatasetType, IDEDatasetType, IDataElementType, IGxFilterInfo, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class Table(CoClass):
    u'Esri Table object.'
    _reg_clsid_ = GUID('{AF10D71C-A61B-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Table._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITable, IClass, ITableCapabilities, IDataset, IDatasetEdit, IDatasetEditInfo, IDatasetAnalyze, ISchemaLock]

ITableSortCallBack._methods_ = [
    COMMETHOD([helpstring(u'Compare fields. Return result as 0 = match, -1 = field1 < field2, 1 = field1 > field2, 2 = force caller to calculate.')], HRESULT, 'Compare',
              ( ['in'], VARIANT, 'value1' ),
              ( ['in'], VARIANT, 'value2' ),
              ( ['in'], c_int, 'FieldIndex' ),
              ( ['in'], c_int, 'fieldSortIndex' ),
              ( ['retval', 'out'], POINTER(c_int), 'result' )),
]
################################################################
## code template for ITableSortCallBack implementation
##class ITableSortCallBack_Impl(object):
##    def Compare(self, value1, value2, FieldIndex, fieldSortIndex):
##        u'Compare fields. Return result as 0 = match, -1 = field1 < field2, 1 = field1 > field2, 2 = force caller to calculate.'
##        #return result
##

IClass._methods_ = [
    COMMETHOD([helpstring(u'The index of the field with the specified name.')], HRESULT, 'FindField',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(c_int), 'FieldIndex' )),
    COMMETHOD(['propget', helpstring(u'The fields collection for this object class.')], HRESULT, 'Fields',
              ( ['retval', 'out'], POINTER(POINTER(IFields)), 'Fields' )),
    COMMETHOD(['propget', helpstring(u'The indexes collection for this object class.')], HRESULT, 'Indexes',
              ( ['retval', 'out'], POINTER(POINTER(IIndexes)), 'Indexes' )),
    COMMETHOD([helpstring(u'Adds a field to this object class.')], HRESULT, 'AddField',
              ( ['in'], POINTER(IField), 'Field' )),
    COMMETHOD([helpstring(u'Deletes a field from this object class.')], HRESULT, 'DeleteField',
              ( ['in'], POINTER(IField), 'Field' )),
    COMMETHOD([helpstring(u'Adds an index to this object class.')], HRESULT, 'AddIndex',
              ( ['in'], POINTER(IIndex), 'Index' )),
    COMMETHOD([helpstring(u'Deletes an index from this  object class.')], HRESULT, 'DeleteIndex',
              ( ['in'], POINTER(IIndex), 'Index' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the class has an object identity (OID) field.')], HRESULT, 'HasOID',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasOID' )),
    COMMETHOD(['propget', helpstring(u'The name of the field corresponding to the OID.')], HRESULT, 'OIDFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The GUID for the COM Class (CoClass) corresponding to instances of this object class.')], HRESULT, 'CLSID',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'InstanceCLSID' )),
    COMMETHOD(['propget', helpstring(u'The GUID for the COM Class (CoClass) corresponding to the class extension for this object class.')], HRESULT, 'EXTCLSID',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'ClassExtensionCLSID' )),
    COMMETHOD(['propget', helpstring(u'The extension for this object class.')], HRESULT, 'Extension',
              ( ['retval', 'out'], POINTER(POINTER(IUnknown)), 'Extension' )),
    COMMETHOD(['propget', helpstring(u'The extension properties for this object class.')], HRESULT, 'ExtensionProperties',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'extProps' )),
]
################################################################
## code template for IClass implementation
##class IClass_Impl(object):
##    def DeleteIndex(self, Index):
##        u'Deletes an index from this  object class.'
##        #return 
##
##    @property
##    def CLSID(self):
##        u'The GUID for the COM Class (CoClass) corresponding to instances of this object class.'
##        #return InstanceCLSID
##
##    @property
##    def Extension(self):
##        u'The extension for this object class.'
##        #return Extension
##
##    def AddField(self, Field):
##        u'Adds a field to this object class.'
##        #return 
##
##    @property
##    def Fields(self):
##        u'The fields collection for this object class.'
##        #return Fields
##
##    def AddIndex(self, Index):
##        u'Adds an index to this object class.'
##        #return 
##
##    def DeleteField(self, Field):
##        u'Deletes a field from this object class.'
##        #return 
##
##    def FindField(self, Name):
##        u'The index of the field with the specified name.'
##        #return FieldIndex
##
##    @property
##    def Indexes(self):
##        u'The indexes collection for this object class.'
##        #return Indexes
##
##    @property
##    def HasOID(self):
##        u'Indicates if the class has an object identity (OID) field.'
##        #return HasOID
##
##    @property
##    def EXTCLSID(self):
##        u'The GUID for the COM Class (CoClass) corresponding to the class extension for this object class.'
##        #return ClassExtensionCLSID
##
##    @property
##    def OIDFieldName(self):
##        u'The name of the field corresponding to the OID.'
##        #return Name
##
##    @property
##    def ExtensionProperties(self):
##        u'The extension properties for this object class.'
##        #return extProps
##


# values for enumeration 'esriRelRole'
esriRelRoleAny = 1
esriRelRoleOrigin = 2
esriRelRoleDestination = 3
esriRelRole = c_int # enum
IObjectClass._methods_ = [
    COMMETHOD(['propget', helpstring(u'The unique ID for the object class.')], HRESULT, 'ObjectClassID',
              ( ['retval', 'out'], POINTER(c_int), 'ObjectClassID' )),
    COMMETHOD(['propget', helpstring(u'The relationship classes in which this object class participates in for the specified role.')], HRESULT, 'RelationshipClasses',
              ( ['in'], esriRelRole, 'Role' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumRelationshipClass)), 'RelationshipClasses' )),
    COMMETHOD(['propget', helpstring(u'The alias name of the object class.')], HRESULT, 'AliasName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
]
################################################################
## code template for IObjectClass implementation
##class IObjectClass_Impl(object):
##    @property
##    def ObjectClassID(self):
##        u'The unique ID for the object class.'
##        #return ObjectClassID
##
##    @property
##    def AliasName(self):
##        u'The alias name of the object class.'
##        #return Name
##
##    @property
##    def RelationshipClasses(self, Role):
##        u'The relationship classes in which this object class participates in for the specified role.'
##        #return RelationshipClasses
##

IFeatureClass._methods_ = [
    COMMETHOD(['propget', helpstring(u'The type of the default Shape for the features in this feature class.')], HRESULT, 'ShapeType',
              ( ['retval', 'out'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType), 'Type' )),
    COMMETHOD(['propget', helpstring(u'The type of features in this feature class.')], HRESULT, 'FeatureType',
              ( ['retval', 'out'], POINTER(esriFeatureType), 'Type' )),
    COMMETHOD(['propget', helpstring(u'The name of the default sShape field.')], HRESULT, 'ShapeFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The geometry area field.')], HRESULT, 'AreaField',
              ( ['retval', 'out'], POINTER(POINTER(IField)), 'Field' )),
    COMMETHOD(['propget', helpstring(u'The geometry length field.')], HRESULT, 'LengthField',
              ( ['retval', 'out'], POINTER(POINTER(IField)), 'Field' )),
    COMMETHOD(['propget', helpstring(u'The feature dataset that contains the feature class.')], HRESULT, 'FeatureDataset',
              ( ['retval', 'out'], POINTER(POINTER(IFeatureDataset)), 'Dataset' )),
    COMMETHOD([helpstring(u'Create a new feature, with a system assigned object ID and null property values.')], HRESULT, 'CreateFeature',
              ( ['retval', 'out'], POINTER(POINTER(IFeature)), 'Feature' )),
    COMMETHOD([helpstring(u'Get the feature with the specified object ID.')], HRESULT, 'GetFeature',
              ( ['in'], c_int, 'ID' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeature)), 'Feature' )),
    COMMETHOD([helpstring(u'Get a cursor of Rows given a set of object ids.')], HRESULT, 'GetFeatures',
              ( ['in'], VARIANT, 'fids' ),
              ( ['in'], VARIANT_BOOL, 'Recycling' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureCursor)), 'Cursor' )),
    COMMETHOD(['propget', helpstring(u'The unique ID for the Feature Class.')], HRESULT, 'FeatureClassID',
              ( ['retval', 'out'], POINTER(c_int), 'fID' )),
    COMMETHOD([helpstring(u'Create a feature buffer that can be used with an insert cursor.')], HRESULT, 'CreateFeatureBuffer',
              ( ['retval', 'out'], POINTER(POINTER(IFeatureBuffer)), 'buffer' )),
    COMMETHOD([helpstring(u'The number of features selected by the specified query.')], HRESULT, 'FeatureCount',
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' ),
              ( ['retval', 'out'], POINTER(c_int), 'numFeatures' )),
    COMMETHOD([helpstring(u'Returns an object cursor that can be used to fetch feature objects selected by the specified query.')], HRESULT, 'Search',
              ( ['in'], POINTER(IQueryFilter), 'filter' ),
              ( ['in'], VARIANT_BOOL, 'Recycling' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureCursor)), 'Cursor' )),
    COMMETHOD([helpstring(u'Returns a cursor that can be used to update  features selected by the specified query.')], HRESULT, 'Update',
              ( ['in'], POINTER(IQueryFilter), 'filter' ),
              ( ['in'], VARIANT_BOOL, 'Recycling' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureCursor)), 'Cursor' )),
    COMMETHOD([helpstring(u'Returns a cursor that can be used to insert new features.')], HRESULT, 'Insert',
              ( ['in'], VARIANT_BOOL, 'useBuffering' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureCursor)), 'Cursor' )),
    COMMETHOD([helpstring(u'Returns a selection That contains the object ids selected by the specified query.')], HRESULT, 'Select',
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' ),
              ( ['in'], esriSelectionType, 'selType' ),
              ( ['in'], esriSelectionOption, 'selOption' ),
              ( ['in'], POINTER(IWorkspace), 'selectionContainer' ),
              ( ['retval', 'out'], POINTER(POINTER(ISelectionSet)), 'SelectionSet' )),
]
################################################################
## code template for IFeatureClass implementation
##class IFeatureClass_Impl(object):
##    @property
##    def FeatureType(self):
##        u'The type of features in this feature class.'
##        #return Type
##
##    @property
##    def ShapeFieldName(self):
##        u'The name of the default sShape field.'
##        #return Name
##
##    def GetFeature(self, ID):
##        u'Get the feature with the specified object ID.'
##        #return Feature
##
##    @property
##    def ShapeType(self):
##        u'The type of the default Shape for the features in this feature class.'
##        #return Type
##
##    def Insert(self, useBuffering):
##        u'Returns a cursor that can be used to insert new features.'
##        #return Cursor
##
##    @property
##    def AreaField(self):
##        u'The geometry area field.'
##        #return Field
##
##    def CreateFeature(self):
##        u'Create a new feature, with a system assigned object ID and null property values.'
##        #return Feature
##
##    def Search(self, filter, Recycling):
##        u'Returns an object cursor that can be used to fetch feature objects selected by the specified query.'
##        #return Cursor
##
##    def Update(self, filter, Recycling):
##        u'Returns a cursor that can be used to update  features selected by the specified query.'
##        #return Cursor
##
##    def GetFeatures(self, fids, Recycling):
##        u'Get a cursor of Rows given a set of object ids.'
##        #return Cursor
##
##    def FeatureCount(self, QueryFilter):
##        u'The number of features selected by the specified query.'
##        #return numFeatures
##
##    def CreateFeatureBuffer(self):
##        u'Create a feature buffer that can be used with an insert cursor.'
##        #return buffer
##
##    @property
##    def LengthField(self):
##        u'The geometry length field.'
##        #return Field
##
##    @property
##    def FeatureDataset(self):
##        u'The feature dataset that contains the feature class.'
##        #return Dataset
##
##    def Select(self, QueryFilter, selType, selOption, selectionContainer):
##        u'Returns a selection That contains the object ids selected by the specified query.'
##        #return SelectionSet
##
##    @property
##    def FeatureClassID(self):
##        u'The unique ID for the Feature Class.'
##        #return fID
##

class DERasterCatalog(CoClass):
    u'Raster Catalog Data Element object.'
    _reg_clsid_ = GUID('{80207192-7CE8-4D06-9542-763E78518FFB}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDERasterCatalog(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about raster catalog data elements.'
    _iid_ = GUID('{8F9C9DC8-9AB1-49ED-B1CC-C6FBFDE09567}')
    _idlflags_ = ['oleautomation']
DERasterCatalog._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDERasterCatalog, IDEFeatureClass, IDETable, IDEGdbFeatureClass, IDEGdbTable, IDEEditorTracking, IDEGeoDataset, IDEDataset2, IDataElement, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe]


# values for enumeration 'esriLocatorWorkspaceType'
esriLocalSystemLocatorWorkspace = 0
esriFileSystemLocatorWorkspace = 1
esriRemoteDatabaseLocatorWorkspace = 2
esriExtensionLocatorWorkspace = 3
esriArcGISServerLocatorWorkspace = 4
esriLocalDatabaseLocatorWorkspace = 5
esriLocatorWorkspaceType = c_int # enum
class DERasterCatalogType(CoClass):
    u'Raster Catalog Data Element Type object.'
    _reg_clsid_ = GUID('{46EE5B40-1292-4C56-B27C-A1F6DFBC0287}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDERasterCatalogType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the RasterCatalog Data Element Type.'
    _iid_ = GUID('{D3A432E3-8922-4835-9D23-400ABE0D36F6}')
    _idlflags_ = ['oleautomation']
DERasterCatalogType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDERasterCatalogType, IDEFeatureClassType, IDETableType, IDEGeoDatasetType, IDEDatasetType, IGxFilterInfo, IDataElementType, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

IObjectClassInfo._methods_ = [
    COMMETHOD([helpstring(u'Indicates if updates to objects can bypass the Store method and OnChange notifications for efficiency.')], HRESULT, 'CanBypassStoreMethod',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'canBypassStore' )),
]
################################################################
## code template for IObjectClassInfo implementation
##class IObjectClassInfo_Impl(object):
##    def CanBypassStoreMethod(self):
##        u'Indicates if updates to objects can bypass the Store method and OnChange notifications for efficiency.'
##        #return canBypassStore
##

IRasterCursor._methods_ = [
    COMMETHOD(['propget', helpstring(u'The offset of the current PixelBlock.')], HRESULT, 'TopLeft',
              ( ['retval', 'out'], POINTER(POINTER(IPnt)), 'val' )),
    COMMETHOD(['propget', helpstring(u'The current PixelBlock.')], HRESULT, 'PixelBlock',
              ( ['retval', 'out'], POINTER(POINTER(IPixelBlock)), 'val' )),
    COMMETHOD([helpstring(u'Iterates to the next PixelBlock.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'not_finished' )),
    COMMETHOD([helpstring(u'Return to state when first created.')], HRESULT, 'Reset'),
]
################################################################
## code template for IRasterCursor implementation
##class IRasterCursor_Impl(object):
##    def Reset(self):
##        u'Return to state when first created.'
##        #return 
##
##    @property
##    def TopLeft(self):
##        u'The offset of the current PixelBlock.'
##        #return val
##
##    def Next(self):
##        u'Iterates to the next PixelBlock.'
##        #return not_finished
##
##    @property
##    def PixelBlock(self):
##        u'The current PixelBlock.'
##        #return val
##

IEnumRelationshipClass._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next relationship class in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IRelationshipClass)), 'FeatureClass' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumRelationshipClass implementation
##class IEnumRelationshipClass_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next relationship class in the enumeration sequence.'
##        #return FeatureClass
##

class IEnumGPValue(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members of a GPValue Enumeration.'
    _iid_ = GUID('{06414895-D64D-46B0-856C-F7B7ECE73D36}')
    _idlflags_ = ['oleautomation']
IEnumGPValue._methods_ = [
    COMMETHOD([helpstring(u'Provides the next value object in the enumeration.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IGPValue)), 'Value' )),
    COMMETHOD([helpstring(u'Resets the enumerator such that a subsequent next returns the first value object.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumGPValue implementation
##class IEnumGPValue_Impl(object):
##    def Reset(self):
##        u'Resets the enumerator such that a subsequent next returns the first value object.'
##        #return 
##
##    def Next(self):
##        u'Provides the next value object in the enumeration.'
##        #return Value
##

class IGPDataTypeFactory(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members of a Data Type Factory.'
    _iid_ = GUID('{1AFF0D88-E9B8-4571-8DF1-217DCAF48A50}')
    _idlflags_ = ['oleautomation']
class IEnumGPName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a GPName Enumeration.'
    _iid_ = GUID('{4DAA55F1-B959-4C53-990B-A871B19BA3D6}')
    _idlflags_ = ['oleautomation']
IGPDataTypeFactory._methods_ = [
    COMMETHOD(['propget', helpstring(u'The COM class ID of the data type factory.')], HRESULT, 'CLSID',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'CLSID' )),
    COMMETHOD([helpstring(u'Provides the data type object given the name.')], HRESULT, 'GetDataType',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IGPDataType)), 'Type' )),
    COMMETHOD([helpstring(u'Provides the data type name object given the name.')], HRESULT, 'GetDataTypeName',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IGPName)), 'datatypename' )),
    COMMETHOD([helpstring(u'Provides the enumeration of data type name objects.')], HRESULT, 'GetDataTypeNames',
              ( ['retval', 'out'], POINTER(POINTER(IEnumGPName)), 'datatypenames' )),
]
################################################################
## code template for IGPDataTypeFactory implementation
##class IGPDataTypeFactory_Impl(object):
##    def GetDataTypeName(self, Name):
##        u'Provides the data type name object given the name.'
##        #return datatypename
##
##    def GetDataTypeNames(self):
##        u'Provides the enumeration of data type name objects.'
##        #return datatypenames
##
##    @property
##    def CLSID(self):
##        u'The COM class ID of the data type factory.'
##        #return CLSID
##
##    def GetDataType(self, Name):
##        u'Provides the data type object given the name.'
##        #return Type
##


# values for enumeration 'esriDEExpandType'
esriDEExpandNone = 0
esriDEExpandChildren = 1
esriDEExpandDescendants = 2
esriDEExpandType = c_int # enum
IDEGdbUtilities._methods_ = [
    COMMETHOD([helpstring(u'Get dataset type from string.')], HRESULT, 'GetDatasetTypeFromString',
              ( ['in'], BSTR, 'desc' ),
              ( ['retval', 'out'], POINTER(esriDatasetType), 'Type' )),
    COMMETHOD([helpstring(u'Get dataset type description.')], HRESULT, 'GetDatasetTypeDescription',
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['retval', 'out'], POINTER(BSTR), 'desc' )),
    COMMETHOD([helpstring(u'Get geometry type from string.')], HRESULT, 'GetGeometryTypeFromString',
              ( ['in'], BSTR, 'desc' ),
              ( ['retval', 'out'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType), 'Type' )),
    COMMETHOD([helpstring(u'Get geometry type description.')], HRESULT, 'GetGeometryTypeDescription',
              ( ['in'], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType, 'Type' ),
              ( ['retval', 'out'], POINTER(BSTR), 'desc' )),
    COMMETHOD([helpstring(u'Get feature type from string.')], HRESULT, 'GetFeatureTypeFromString',
              ( ['in'], BSTR, 'desc' ),
              ( ['retval', 'out'], POINTER(esriFeatureType), 'Type' )),
    COMMETHOD([helpstring(u'Get feature type description.')], HRESULT, 'GetFeatureTypeDescription',
              ( ['in'], esriFeatureType, 'Type' ),
              ( ['retval', 'out'], POINTER(BSTR), 'desc' )),
    COMMETHOD([helpstring(u'Get expand type from string.')], HRESULT, 'GetExpandTypeFromString',
              ( ['in'], BSTR, 'desc' ),
              ( ['retval', 'out'], POINTER(esriDEExpandType), 'Type' )),
    COMMETHOD([helpstring(u'Get expand type description.')], HRESULT, 'GetExpandTypeDescription',
              ( ['in'], esriDEExpandType, 'Type' ),
              ( ['retval', 'out'], POINTER(BSTR), 'desc' )),
    COMMETHOD([helpstring(u'Get field type from string.')], HRESULT, 'GetFieldTypeFromString',
              ( ['in'], BSTR, 'desc' ),
              ( ['retval', 'out'], POINTER(esriFieldType), 'Type' )),
    COMMETHOD([helpstring(u'Get field type description.')], HRESULT, 'GetFieldTypeDescription',
              ( ['in'], esriFieldType, 'Type' ),
              ( ['retval', 'out'], POINTER(BSTR), 'desc' )),
    COMMETHOD([helpstring(u'Get worspace type from string.')], HRESULT, 'GetWorkspaceTypeFromString',
              ( ['in'], BSTR, 'desc' ),
              ( ['retval', 'out'], POINTER(esriWorkspaceType), 'Type' )),
    COMMETHOD([helpstring(u'Get workspace type description.')], HRESULT, 'GetWorkspaceTypeDescription',
              ( ['in'], esriWorkspaceType, 'Type' ),
              ( ['retval', 'out'], POINTER(BSTR), 'desc' )),
    COMMETHOD([helpstring(u'Get network class ancillary role type from string.')], HRESULT, 'GetNetworkClassAncillaryRoleFromString',
              ( ['in'], BSTR, 'desc' ),
              ( ['retval', 'out'], POINTER(esriNetworkClassAncillaryRole), 'Role' )),
    COMMETHOD([helpstring(u'Get network class ancillary role type description.')], HRESULT, 'GetNetworkClassAncillaryRoleDescription',
              ( ['in'], esriNetworkClassAncillaryRole, 'Role' ),
              ( ['retval', 'out'], POINTER(BSTR), 'desc' )),
    COMMETHOD([helpstring(u'Get relationship key type from string.')], HRESULT, 'GetRelationshipKeyTypeFromString',
              ( ['in'], BSTR, 'desc' ),
              ( ['retval', 'out'], POINTER(esriRelKeyType), 'KeyType' )),
    COMMETHOD([helpstring(u'Get relationship key type description.')], HRESULT, 'GetRelationshipKeyTypeDescription',
              ( ['in'], esriRelKeyType, 'KeyType' ),
              ( ['retval', 'out'], POINTER(BSTR), 'desc' )),
    COMMETHOD([helpstring(u'Get relationship class key type from string.')], HRESULT, 'GetRelationshipClassKeyFromString',
              ( ['in'], BSTR, 'desc' ),
              ( ['retval', 'out'], POINTER(esriRelClassKey), 'ClassKey' )),
    COMMETHOD([helpstring(u'Get relationship class key type description.')], HRESULT, 'GetRelationshipClassKeyDescription',
              ( ['in'], esriRelClassKey, 'ClassKey' ),
              ( ['retval', 'out'], POINTER(BSTR), 'desc' )),
    COMMETHOD([helpstring(u'Get relationship key role from string.')], HRESULT, 'GetRelationshipKeyRoleFromString',
              ( ['in'], BSTR, 'desc' ),
              ( ['retval', 'out'], POINTER(esriRelKeyRole), 'KeyRole' )),
    COMMETHOD([helpstring(u'Get relationship key role description.')], HRESULT, 'GetRelationshipKeyRoleDescription',
              ( ['in'], esriRelKeyRole, 'KeyRole' ),
              ( ['retval', 'out'], POINTER(BSTR), 'desc' )),
    COMMETHOD([helpstring(u'Get relationship cardinality from string.')], HRESULT, 'GetRelationshipCardinalityFromString',
              ( ['in'], BSTR, 'desc' ),
              ( ['retval', 'out'], POINTER(esriRelCardinality), 'card' )),
    COMMETHOD([helpstring(u'Get relationship cardinality description.')], HRESULT, 'GetRelationshipCardinalityDescription',
              ( ['in'], esriRelCardinality, 'card' ),
              ( ['retval', 'out'], POINTER(BSTR), 'desc' )),
    COMMETHOD([helpstring(u'Get relationship notification from string.')], HRESULT, 'GetRelationshipNotificationFromString',
              ( ['in'], BSTR, 'desc' ),
              ( ['retval', 'out'], POINTER(esriRelNotification), 'Notification' )),
    COMMETHOD([helpstring(u'Get relationship notification description.')], HRESULT, 'GetRelationshipNotificationDescription',
              ( ['in'], esriRelNotification, 'Notification' ),
              ( ['retval', 'out'], POINTER(BSTR), 'desc' )),
    COMMETHOD([helpstring(u'Get network type from string.')], HRESULT, 'GetNetworkTypeFromString',
              ( ['in'], BSTR, 'desc' ),
              ( ['retval', 'out'], POINTER(esriNetworkType), 'netType' )),
    COMMETHOD([helpstring(u'Get network type description.')], HRESULT, 'GetNetworkTypeDescription',
              ( ['in'], esriNetworkType, 'netType' ),
              ( ['retval', 'out'], POINTER(BSTR), 'desc' )),
    COMMETHOD([helpstring(u'Check if DEGeoDataset properties are equal.')], HRESULT, 'IsEqualDEGeoDataset',
              ( ['in'], POINTER(IDEGeoDataset), 'DEGeoDataset1' ),
              ( ['in'], POINTER(IDEGeoDataset), 'DEGeoDataset2' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'equal' )),
]
################################################################
## code template for IDEGdbUtilities implementation
##class IDEGdbUtilities_Impl(object):
##    def GetFieldTypeDescription(self, Type):
##        u'Get field type description.'
##        #return desc
##
##    def GetDatasetTypeDescription(self, Type):
##        u'Get dataset type description.'
##        #return desc
##
##    def GetRelationshipCardinalityFromString(self, desc):
##        u'Get relationship cardinality from string.'
##        #return card
##
##    def GetRelationshipKeyRoleFromString(self, desc):
##        u'Get relationship key role from string.'
##        #return KeyRole
##
##    def GetRelationshipNotificationFromString(self, desc):
##        u'Get relationship notification from string.'
##        #return Notification
##
##    def IsEqualDEGeoDataset(self, DEGeoDataset1, DEGeoDataset2):
##        u'Check if DEGeoDataset properties are equal.'
##        #return equal
##
##    def GetNetworkTypeDescription(self, netType):
##        u'Get network type description.'
##        #return desc
##
##    def GetExpandTypeFromString(self, desc):
##        u'Get expand type from string.'
##        #return Type
##
##    def GetWorkspaceTypeDescription(self, Type):
##        u'Get workspace type description.'
##        #return desc
##
##    def GetNetworkTypeFromString(self, desc):
##        u'Get network type from string.'
##        #return netType
##
##    def GetDatasetTypeFromString(self, desc):
##        u'Get dataset type from string.'
##        #return Type
##
##    def GetNetworkClassAncillaryRoleFromString(self, desc):
##        u'Get network class ancillary role type from string.'
##        #return Role
##
##    def GetRelationshipClassKeyFromString(self, desc):
##        u'Get relationship class key type from string.'
##        #return ClassKey
##
##    def GetNetworkClassAncillaryRoleDescription(self, Role):
##        u'Get network class ancillary role type description.'
##        #return desc
##
##    def GetRelationshipClassKeyDescription(self, ClassKey):
##        u'Get relationship class key type description.'
##        #return desc
##
##    def GetGeometryTypeDescription(self, Type):
##        u'Get geometry type description.'
##        #return desc
##
##    def GetWorkspaceTypeFromString(self, desc):
##        u'Get worspace type from string.'
##        #return Type
##
##    def GetRelationshipNotificationDescription(self, Notification):
##        u'Get relationship notification description.'
##        #return desc
##
##    def GetFieldTypeFromString(self, desc):
##        u'Get field type from string.'
##        #return Type
##
##    def GetExpandTypeDescription(self, Type):
##        u'Get expand type description.'
##        #return desc
##
##    def GetFeatureTypeFromString(self, desc):
##        u'Get feature type from string.'
##        #return Type
##
##    def GetRelationshipCardinalityDescription(self, card):
##        u'Get relationship cardinality description.'
##        #return desc
##
##    def GetGeometryTypeFromString(self, desc):
##        u'Get geometry type from string.'
##        #return Type
##
##    def GetRelationshipKeyTypeFromString(self, desc):
##        u'Get relationship key type from string.'
##        #return KeyType
##
##    def GetFeatureTypeDescription(self, Type):
##        u'Get feature type description.'
##        #return desc
##
##    def GetRelationshipKeyRoleDescription(self, KeyRole):
##        u'Get relationship key role description.'
##        #return desc
##
##    def GetRelationshipKeyTypeDescription(self, KeyType):
##        u'Get relationship key type description.'
##        #return desc
##

IEnumGPName._methods_ = [
    COMMETHOD([helpstring(u'Provides the next name object in the enumeration.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IGPName)), 'Name' )),
    COMMETHOD([helpstring(u'Resets the enumerator such that a subsequent next returns the first name object.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumGPName implementation
##class IEnumGPName_Impl(object):
##    def Reset(self):
##        u'Resets the enumerator such that a subsequent next returns the first name object.'
##        #return 
##
##    def Next(self):
##        u'Provides the next name object in the enumeration.'
##        #return Name
##


# values for enumeration 'esriGeodatabaseVersion'
esriGeodatabaseVersion10 = 0
esriGeodatabaseVersion101 = 1
esriGeodatabaseVersion102 = 2
esriGeodatabaseVersion = c_int # enum
IDEGdbUtilities2._methods_ = [
    COMMETHOD([helpstring(u'Get required geodatabase client version from string.')], HRESULT, 'GetRequiredGdbClientVersionFromString',
              ( ['in'], BSTR, 'desc' ),
              ( ['retval', 'out'], POINTER(esriGeodatabaseVersion), 'gdbVersion' )),
    COMMETHOD([helpstring(u'Get required geodatabase client version description.')], HRESULT, 'GetRequiredGdbClientVersionDescription',
              ( ['in'], esriGeodatabaseVersion, 'gdbVersion' ),
              ( ['retval', 'out'], POINTER(BSTR), 'desc' )),
]
################################################################
## code template for IDEGdbUtilities2 implementation
##class IDEGdbUtilities2_Impl(object):
##    def GetRequiredGdbClientVersionFromString(self, desc):
##        u'Get required geodatabase client version from string.'
##        #return gdbVersion
##
##    def GetRequiredGdbClientVersionDescription(self, gdbVersion):
##        u'Get required geodatabase client version description.'
##        #return desc
##

ITinDynamicFilter._methods_ = [
    COMMETHOD([helpstring(u'Re/establishes the filter; determines and returns an ID for the subset of elements represented by the index.')], HRESULT, 'Init',
              ( ['in'], POINTER(ITinElement), 'pElement' ),
              ( ['retval', 'out'], POINTER(c_int), 'pID' )),
]
################################################################
## code template for ITinDynamicFilter implementation
##class ITinDynamicFilter_Impl(object):
##    def Init(self, pElement):
##        u'Re/establishes the filter; determines and returns an ID for the subset of elements represented by the index.'
##        #return pID
##

IRasterValue._methods_ = [
    COMMETHOD(['propget', helpstring(u'The raster storage properties.')], HRESULT, 'RasterStorageDef',
              ( ['retval', 'out'], POINTER(POINTER(IRasterStorageDef)), 'StorageDef' )),
    COMMETHOD(['propputref', helpstring(u'The raster storage properties.')], HRESULT, 'RasterStorageDef',
              ( ['in'], POINTER(IRasterStorageDef), 'StorageDef' )),
    COMMETHOD(['propget', helpstring(u'The extent of the raster value.')], HRESULT, 'Extent',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'Extent' )),
    COMMETHOD(['propputref', helpstring(u'The extent of the raster value.')], HRESULT, 'Extent',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'Extent' )),
    COMMETHOD(['propget', helpstring(u'The raster dataset of the raster value.')], HRESULT, 'RasterDataset',
              ( ['retval', 'out'], POINTER(POINTER(IRasterDataset)), 'Dataset' )),
    COMMETHOD(['propputref', helpstring(u'The raster dataset of the raster value.')], HRESULT, 'RasterDataset',
              ( ['in'], POINTER(IRasterDataset), 'Dataset' )),
    COMMETHOD(['propget', helpstring(u'The raster dataset name of the raster value.')], HRESULT, 'RasterDatasetName',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'DatasetName' )),
    COMMETHOD(['propputref', helpstring(u'The raster dataset name of the raster value.')], HRESULT, 'RasterDatasetName',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'DatasetName' )),
    COMMETHOD(['propget', helpstring(u'The raster of the raster value.')], HRESULT, 'Raster',
              ( ['retval', 'out'], POINTER(POINTER(IRaster)), 'Raster' )),
    COMMETHOD(['propputref', helpstring(u'The raster of the raster value.')], HRESULT, 'Raster',
              ( ['in'], POINTER(IRaster), 'Raster' )),
    COMMETHOD([helpstring(u'Sets up the empty raster dataset.')], HRESULT, 'SetEmptyRasterDataset',
              ( ['in'], c_int, 'nBands' ),
              ( ['in'], rstPixelType, 'PixelType' )),
]
################################################################
## code template for IRasterValue implementation
##class IRasterValue_Impl(object):
##    def Raster(self, Raster):
##        u'The raster of the raster value.'
##        #return 
##
##    def Extent(self, Extent):
##        u'The extent of the raster value.'
##        #return 
##
##    def SetEmptyRasterDataset(self, nBands, PixelType):
##        u'Sets up the empty raster dataset.'
##        #return 
##
##    def RasterDatasetName(self, DatasetName):
##        u'The raster dataset name of the raster value.'
##        #return 
##
##    def RasterDataset(self, Dataset):
##        u'The raster dataset of the raster value.'
##        #return 
##
##    def RasterStorageDef(self, StorageDef):
##        u'The raster storage properties.'
##        #return 
##

class IGeodataXform(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control geodata transformation.'
    _iid_ = GUID('{5E6CF525-4E74-419B-946F-7DA9BFDF815D}')
    _idlflags_ = ['oleautomation']
IRasterValue2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The geodata transformation to be persisted.')], HRESULT, 'PersistXform',
              ( ['retval', 'out'], POINTER(POINTER(IGeodataXform)), 'xform' )),
    COMMETHOD(['propputref', helpstring(u'The geodata transformation to be persisted.')], HRESULT, 'PersistXform',
              ( ['in'], POINTER(IGeodataXform), 'xform' )),
]
################################################################
## code template for IRasterValue2 implementation
##class IRasterValue2_Impl(object):
##    def PersistXform(self, xform):
##        u'The geodata transformation to be persisted.'
##        #return 
##

class ITableFields(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about a table.'
    _iid_ = GUID('{E5966B0A-E3D9-11D3-A096-00C04F6BC626}')
    _idlflags_ = ['oleautomation']
ITableFields._methods_ = [
    COMMETHOD(['propget', helpstring(u'The field count.')], HRESULT, 'FieldCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The field at the given index.')], HRESULT, 'Field',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IField)), 'Field' )),
    COMMETHOD(['propget', helpstring(u'The extended field information for the field at the given index.')], HRESULT, 'FieldInfo',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IFieldInfo)), 'FieldInfo' )),
    COMMETHOD([helpstring(u'The index of the field with the given name.')], HRESULT, 'FindField',
              ( ['in'], BSTR, 'FieldName' ),
              ( ['retval', 'out'], POINTER(c_int), 'Index' )),
]
################################################################
## code template for ITableFields implementation
##class ITableFields_Impl(object):
##    @property
##    def Field(self, Index):
##        u'The field at the given index.'
##        #return Field
##
##    @property
##    def FieldCount(self):
##        u'The field count.'
##        #return Count
##
##    def FindField(self, FieldName):
##        u'The index of the field with the given name.'
##        #return Index
##
##    @property
##    def FieldInfo(self, Index):
##        u'The extended field information for the field at the given index.'
##        #return FieldInfo
##

IGPDataTypeName._methods_ = [
]
################################################################
## code template for IGPDataTypeName implementation
##class IGPDataTypeName_Impl(object):

IEnumTinNode._methods_ = [
    COMMETHOD([helpstring(u'Resets the enumerator.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Gets next node element.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(ITinNode)), 'ppNode' )),
    COMMETHOD([helpstring(u'Queries next node element.')], HRESULT, 'QueryNext',
              ( [], POINTER(ITinNode), 'pNode' )),
    COMMETHOD([helpstring(u'Queries next node element as a WKS point with z values.')], HRESULT, 'QueryNextAsWKSPointZ',
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPoint' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'pbIsEnd' )),
    COMMETHOD(['restricted', helpstring(u'Queries next node element as a WKS point with z values.')], HRESULT, 'QueryNextAsWKSPointZ2',
              ( ['out'], POINTER(c_int), 'pTriangleIndex' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPoint' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'pbIsEnd' )),
]
################################################################
## code template for IEnumTinNode implementation
##class IEnumTinNode_Impl(object):
##    def Reset(self):
##        u'Resets the enumerator.'
##        #return 
##
##    def QueryNextAsWKSPointZ2(self):
##        u'Queries next node element as a WKS point with z values.'
##        #return pTriangleIndex, pPoint, pbIsEnd
##
##    def QueryNextAsWKSPointZ(self):
##        u'Queries next node element as a WKS point with z values.'
##        #return pPoint, pbIsEnd
##
##    def QueryNext(self, pNode):
##        u'Queries next node element.'
##        #return 
##
##    def Next(self):
##        u'Gets next node element.'
##        #return ppNode
##

IRasterCatalogHelper._methods_ = [
    COMMETHOD([helpstring(u'Updates RasterCatalog footprint.')], HRESULT, 'UpdateFootprint',
              ( ['in'], POINTER(IRasterCatalog), 'Catalog' )),
    COMMETHOD([helpstring(u'Updates RasterCatalog footprint spatial reference.')], HRESULT, 'UpdateFootprintSpatialReference',
              ( ['in'], POINTER(IRasterCatalog), 'Catalog' )),
]
################################################################
## code template for IRasterCatalogHelper implementation
##class IRasterCatalogHelper_Impl(object):
##    def UpdateFootprintSpatialReference(self, Catalog):
##        u'Updates RasterCatalog footprint spatial reference.'
##        #return 
##
##    def UpdateFootprint(self, Catalog):
##        u'Updates RasterCatalog footprint.'
##        #return 
##

IFeatureDataset._methods_ = [
    COMMETHOD([helpstring(u'Creates a new FeatureClass in this FeatureDataset.')], HRESULT, 'CreateFeatureClass',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IFields), 'Fields' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'CLSID' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'EXTCLSID' ),
              ( ['in'], esriFeatureType, 'FeatureType' ),
              ( ['in'], BSTR, 'ShapeFieldName' ),
              ( ['in'], BSTR, 'ConfigKeyword' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureClass)), 'FeatureClass' )),
]
################################################################
## code template for IFeatureDataset implementation
##class IFeatureDataset_Impl(object):
##    def CreateFeatureClass(self, Name, Fields, CLSID, EXTCLSID, FeatureType, ShapeFieldName, ConfigKeyword):
##        u'Creates a new FeatureClass in this FeatureDataset.'
##        #return FeatureClass
##

class IRasterLODInfos2(IRasterLODInfos):
    _case_insensitive_ = True
    u'Provides access to additional members that control custom Level of Details.'
    _iid_ = GUID('{85BC9BC4-A306-45CF-A2EF-2C9603D7B13D}')
    _idlflags_ = ['oleautomation']
IRasterLODInfos._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of levels of details.')], HRESULT, 'NumLevels',
              ( ['retval', 'out'], POINTER(c_int), 'NumLevels' )),
    COMMETHOD([helpstring(u'Snaps a given cellsize to a proper Level Of Details.')], HRESULT, 'Snap',
              ( ['in'], c_double, 'dx' ),
              ( ['in'], c_double, 'dy' ),
              ( ['retval', 'out'], POINTER(c_int), 'level' )),
    COMMETHOD([helpstring(u'Gets X and Y resolution (cellsize) at a given level.')], HRESULT, 'GetResolution',
              ( ['in'], c_int, 'level' ),
              ( ['out'], POINTER(c_double), 'XResolution' ),
              ( ['out'], POINTER(c_double), 'YResolution' )),
]
################################################################
## code template for IRasterLODInfos implementation
##class IRasterLODInfos_Impl(object):
##    def Snap(self, dx, dy):
##        u'Snaps a given cellsize to a proper Level Of Details.'
##        #return level
##
##    @property
##    def NumLevels(self):
##        u'The number of levels of details.'
##        #return NumLevels
##
##    def GetResolution(self, level):
##        u'Gets X and Y resolution (cellsize) at a given level.'
##        #return XResolution, YResolution
##


# values for enumeration 'esriRasterResamplingHint'
esriRasterResamplingClosest = 1
esriRasterResamplingUpsampling = 2
esriRasterResamplingDownsampling = 3
esriRasterResamplingFinest = 4
esriRasterResamplingHint = c_int # enum
IRasterLODInfos2._methods_ = [
    COMMETHOD([helpstring(u'Snaps a given cellsize to a proper Level Of Details.')], HRESULT, 'Snap2',
              ( ['in'], c_double, 'dx' ),
              ( ['in'], c_double, 'dy' ),
              ( ['in'], esriRasterResamplingHint, 'hint' ),
              ( ['retval', 'out'], POINTER(c_int), 'level' )),
]
################################################################
## code template for IRasterLODInfos2 implementation
##class IRasterLODInfos2_Impl(object):
##    def Snap2(self, dx, dy, hint):
##        u'Snaps a given cellsize to a proper Level Of Details.'
##        #return level
##

class ITinTriangleFilter(ITinFilter):
    _case_insensitive_ = True
    u'Provides access to members that control TIN triangle filters.'
    _iid_ = GUID('{4EEE3279-FA94-11D2-AE10-000000000000}')
    _idlflags_ = ['oleautomation']
ITinTriangleFilter._methods_ = [
    COMMETHOD(['propput', helpstring(u'The property that the filter classifies on.')], HRESULT, 'PropertyType',
              ( ['in'], esriTinTrianglePropertyType, 'pType' )),
    COMMETHOD(['propget', helpstring(u'The property that the filter classifies on.')], HRESULT, 'PropertyType',
              ( ['retval', 'out'], POINTER(esriTinTrianglePropertyType), 'pType' )),
    COMMETHOD(['propput', helpstring(u'The lower bound of the filter.')], HRESULT, 'LowerBound',
              ( ['in'], c_double, 'pBound' )),
    COMMETHOD(['propget', helpstring(u'The lower bound of the filter.')], HRESULT, 'LowerBound',
              ( ['retval', 'out'], POINTER(c_double), 'pBound' )),
    COMMETHOD(['propput', helpstring(u'The upper bound of the filter.')], HRESULT, 'UpperBound',
              ( ['in'], c_double, 'pBound' )),
    COMMETHOD(['propget', helpstring(u'The upper bound of the filter.')], HRESULT, 'UpperBound',
              ( ['retval', 'out'], POINTER(c_double), 'pBound' )),
    COMMETHOD(['propputref', helpstring(u'The classification categories of the filter.')], HRESULT, 'ClassBreaks',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDoubleArray), 'ppBreaks' )),
    COMMETHOD(['propget', helpstring(u'The classification categories of the filter.')], HRESULT, 'ClassBreaks',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDoubleArray)), 'ppBreaks' )),
    COMMETHOD(['propputref', helpstring(u"The filter's numeric values used to represent each class.")], HRESULT, 'ClassBreakCodes',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'ppCodes' )),
    COMMETHOD(['propget', helpstring(u"The filter's numeric values used to represent each class.")], HRESULT, 'ClassBreakCodes',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray)), 'ppCodes' )),
    COMMETHOD(['propput', helpstring(u'The unique value of the filter.')], HRESULT, 'UniqueValue',
              ( ['in'], c_double, 'pValue' )),
    COMMETHOD(['propget', helpstring(u'The unique value of the filter.')], HRESULT, 'UniqueValue',
              ( ['retval', 'out'], POINTER(c_double), 'pValue' )),
    COMMETHOD(['propput', helpstring(u'The active boundaries of the filter.')], HRESULT, 'ActiveBound',
              ( ['in'], esriTinBoundType, 'pType' )),
    COMMETHOD(['propget', helpstring(u'The active boundaries of the filter.')], HRESULT, 'ActiveBound',
              ( ['retval', 'out'], POINTER(esriTinBoundType), 'pType' )),
]
################################################################
## code template for ITinTriangleFilter implementation
##class ITinTriangleFilter_Impl(object):
##    def _get(self):
##        u'The lower bound of the filter.'
##        #return pBound
##    def _set(self, pBound):
##        u'The lower bound of the filter.'
##    LowerBound = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The active boundaries of the filter.'
##        #return pType
##    def _set(self, pType):
##        u'The active boundaries of the filter.'
##    ActiveBound = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The upper bound of the filter.'
##        #return pBound
##    def _set(self, pBound):
##        u'The upper bound of the filter.'
##    UpperBound = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The unique value of the filter.'
##        #return pValue
##    def _set(self, pValue):
##        u'The unique value of the filter.'
##    UniqueValue = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The property that the filter classifies on.'
##        #return pType
##    def _set(self, pType):
##        u'The property that the filter classifies on.'
##    PropertyType = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def ClassBreakCodes(self, ppCodes):
##        u"The filter's numeric values used to represent each class."
##        #return 
##
##    @property
##    def ClassBreaks(self, ppBreaks):
##        u'The classification categories of the filter.'
##        #return 
##

class IGPVariable(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to properties of a geoprocessing variable.'
    _iid_ = GUID('{91290E84-B518-43E3-8E7A-9EE8E0CEF5C9}')
    _idlflags_ = ['oleautomation']
IGPVariable._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the geoprocessing variable.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the geoprocessing variable.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The value object associated with the variable.')], HRESULT, 'Value',
              ( ['retval', 'out'], POINTER(POINTER(IGPValue)), 'Value' )),
    COMMETHOD(['propputref', helpstring(u'The value object associated with the variable.')], HRESULT, 'Value',
              ( ['in'], POINTER(IGPValue), 'Value' )),
    COMMETHOD(['propget', helpstring(u'The data type of the variable.')], HRESULT, 'DataType',
              ( ['retval', 'out'], POINTER(POINTER(IGPDataType)), 'DataType' )),
    COMMETHOD(['propputref', helpstring(u'The data type of the variable.')], HRESULT, 'DataType',
              ( ['in'], POINTER(IGPDataType), 'DataType' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the variable is type derived.')], HRESULT, 'Derived',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Derived' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the variable is type derived.')], HRESULT, 'Derived',
              ( ['in'], VARIANT_BOOL, 'Derived' )),
]
################################################################
## code template for IGPVariable implementation
##class IGPVariable_Impl(object):
##    def DataType(self, DataType):
##        u'The data type of the variable.'
##        #return 
##
##    def _get(self):
##        u'Indicates if the variable is type derived.'
##        #return Derived
##    def _set(self, Derived):
##        u'Indicates if the variable is type derived.'
##    Derived = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the geoprocessing variable.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the geoprocessing variable.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def Value(self, Value):
##        u'The value object associated with the variable.'
##        #return 
##

IRasterCatalogHelper2._methods_ = [
    COMMETHOD([helpstring(u'Updates RasterCatalog footprint.')], HRESULT, 'UpdateFootprintEx',
              ( ['in'], POINTER(IRasterCatalog), 'Catalog' ),
              ( ['in'], BSTR, 'where' ),
              ( ['in'], VARIANT_BOOL, 'onlyIfEmpty' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITrackCancel), 'cancel' )),
]
################################################################
## code template for IRasterCatalogHelper2 implementation
##class IRasterCatalogHelper2_Impl(object):
##    def UpdateFootprintEx(self, Catalog, where, onlyIfEmpty, cancel):
##        u'Updates RasterCatalog footprint.'
##        #return 
##

IEnumTinEdge._methods_ = [
    COMMETHOD([helpstring(u'Resets the enumerator.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Gets next edge element.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(ITinEdge)), 'ppEdge' )),
    COMMETHOD([helpstring(u'Queries next edge element.')], HRESULT, 'QueryNext',
              ( [], POINTER(ITinEdge), 'pEdge' )),
    COMMETHOD([helpstring(u'Queries next edge element as a WKS point with z values.')], HRESULT, 'QueryNextAsWKSPointZs',
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pFrom' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pTo' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'pbIsEnd' )),
    COMMETHOD(['restricted', helpstring(u'Queries next edge element as a WKS point with z values.')], HRESULT, 'QueryNextAsWKSPointZs2',
              ( ['out'], POINTER(c_int), 'pTriangleIndex' ),
              ( ['out'], POINTER(c_int), 'pEdgeIndex' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pFrom' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pTo' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'pbIsEnd' )),
]
################################################################
## code template for IEnumTinEdge implementation
##class IEnumTinEdge_Impl(object):
##    def Reset(self):
##        u'Resets the enumerator.'
##        #return 
##
##    def QueryNextAsWKSPointZs2(self):
##        u'Queries next edge element as a WKS point with z values.'
##        #return pTriangleIndex, pEdgeIndex, pFrom, pTo, pbIsEnd
##
##    def QueryNextAsWKSPointZs(self):
##        u'Queries next edge element as a WKS point with z values.'
##        #return pFrom, pTo, pbIsEnd
##
##    def QueryNext(self, pEdge):
##        u'Queries next edge element.'
##        #return 
##
##    def Next(self):
##        u'Gets next edge element.'
##        #return ppEdge
##

class IWorkspaceDataElements(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return data element objects for workspace datatasets.'
    _iid_ = GUID('{94DDE7CE-AA25-4682-8290-F7DDFFEE5D98}')
    _idlflags_ = ['oleautomation']
class IDEBrowseOptions(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the data element browsing options interface.'
    _iid_ = GUID('{25E52C75-56A2-4631-9CA3-2DE46103EBFB}')
    _idlflags_ = ['oleautomation']
IWorkspaceDataElements._methods_ = [
    COMMETHOD([helpstring(u'The data element for the workspace.')], HRESULT, 'GetWorkspaceDataElement',
              ( ['in'], POINTER(IDEBrowseOptions), 'browseOptions' ),
              ( ['retval', 'out'], POINTER(POINTER(IDataElement)), 'workspaceDataElement' )),
    COMMETHOD([helpstring(u'Returns the data element for the in-bound dataset name or dataset object.')], HRESULT, 'GetDatasetDataElement',
              ( ['in'], POINTER(IUnknown), 'datasetSpec' ),
              ( ['in'], POINTER(IDEBrowseOptions), 'browseOptions' ),
              ( ['retval', 'out'], POINTER(POINTER(IDataElement)), 'DataElement' )),
]
################################################################
## code template for IWorkspaceDataElements implementation
##class IWorkspaceDataElements_Impl(object):
##    def GetDatasetDataElement(self, datasetSpec, browseOptions):
##        u'Returns the data element for the in-bound dataset name or dataset object.'
##        #return DataElement
##
##    def GetWorkspaceDataElement(self, browseOptions):
##        u'The data element for the workspace.'
##        #return workspaceDataElement
##

class ISaveAs(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to methods for saving as a new Dataset.'
    _iid_ = GUID('{C7A92E97-597E-4A69-A872-29CB60B5E0DB}')
    _idlflags_ = ['oleautomation']
ISaveAs._methods_ = [
    COMMETHOD([helpstring(u'Creates a new persistent Dataset of a given format.')], HRESULT, 'SaveAs',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IWorkspace), 'Workspace' ),
              ( ['in'], BSTR, 'Format' ),
              ( ['retval', 'out'], POINTER(POINTER(IDataset)), 'Dataset' )),
    COMMETHOD([helpstring(u"Checks if it's can be saved as a new persistent Dataset of a given format.")], HRESULT, 'CanSaveAs',
              ( ['in'], BSTR, 'Format' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanSaveAs' )),
]
################################################################
## code template for ISaveAs implementation
##class ISaveAs_Impl(object):
##    def CanSaveAs(self, Format):
##        u"Checks if it's can be saved as a new persistent Dataset of a given format."
##        #return CanSaveAs
##
##    def SaveAs(self, Name, Workspace, Format):
##        u'Creates a new persistent Dataset of a given format.'
##        #return Dataset
##

IGPValue._methods_ = [
    COMMETHOD(['propget', helpstring(u'The data type of the value object.')], HRESULT, 'DataType',
              ( ['retval', 'out'], POINTER(POINTER(IGPDataType)), 'DataType' )),
    COMMETHOD([helpstring(u'Indicates if the value object is empty.')], HRESULT, 'IsEmpty',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsEmpty' )),
    COMMETHOD([helpstring(u'Clears the value object.')], HRESULT, 'Empty'),
    COMMETHOD([helpstring(u'Provides the value of the value object.')], HRESULT, 'GetAsText',
              ( ['retval', 'out'], POINTER(BSTR), 'text' )),
    COMMETHOD([helpstring(u'Provides the value of the value object with the given string value.')], HRESULT, 'SetAsText',
              ( ['in'], BSTR, 'text' ),
              ( ['retval', 'out'], POINTER(POINTER(IGPMessage)), 'Message' )),
]
################################################################
## code template for IGPValue implementation
##class IGPValue_Impl(object):
##    @property
##    def DataType(self):
##        u'The data type of the value object.'
##        #return DataType
##
##    def GetAsText(self):
##        u'Provides the value of the value object.'
##        #return text
##
##    def SetAsText(self, text):
##        u'Provides the value of the value object with the given string value.'
##        #return Message
##
##    def IsEmpty(self):
##        u'Indicates if the value object is empty.'
##        #return IsEmpty
##
##    def Empty(self):
##        u'Clears the value object.'
##        #return 
##

class IDEMapServer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe MapServer objects.'
    _iid_ = GUID('{1EA10704-31F3-4106-B8CA-CD30773FBD13}')
    _idlflags_ = ['oleautomation']
IDEMapServer._methods_ = [
]
################################################################
## code template for IDEMapServer implementation
##class IDEMapServer_Impl(object):


# values for enumeration 'esriNetworkRoadCategory'
esriNRCNone = 0
esriNRCLocal = 1
esriNRCSecondary = 2
esriNRCPrimary = 4
esriNRCMajor = 6
esriNRCAny = 7
esriNetworkRoadCategory = c_int # enum
class IDEGlobeServerType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the GlobeServer Data Element Type.'
    _iid_ = GUID('{DC951E00-7D11-4BCF-8D9B-B9B861354DAB}')
    _idlflags_ = ['oleautomation']
IDEGlobeServerType._methods_ = [
]
################################################################
## code template for IDEGlobeServerType implementation
##class IDEGlobeServerType_Impl(object):

IDEGlobeServer._methods_ = [
]
################################################################
## code template for IDEGlobeServer implementation
##class IDEGlobeServer_Impl(object):

class XMLIndexTags(CoClass):
    u'XML Index Tags Collection Object.'
    _reg_clsid_ = GUID('{78D0F170-0F98-41CF-8768-D7C8887C1935}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
XMLIndexTags._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IXMLIndexTags, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe]

class IEnumAttributedRelationship(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate through the attributed relationships.'
    _iid_ = GUID('{D245D158-E17E-4412-B894-934DEA6193B6}')
    _idlflags_ = ['oleautomation']
IEnumAttributedRelationship._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next attributed relationship.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IRelationship)), 'Relationship' )),
    COMMETHOD([helpstring(u'Resets enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumAttributedRelationship implementation
##class IEnumAttributedRelationship_Impl(object):
##    def Reset(self):
##        u'Resets enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next attributed relationship.'
##        #return Relationship
##

class INetworkDirections2(INetworkDirections):
    _case_insensitive_ = True
    u'Provides access to the properties for setting up driving directions.'
    _iid_ = GUID('{85301471-ABAD-49EE-AA65-FC498D75F362}')
    _idlflags_ = ['oleautomation']
INetworkDirections2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The collection of directions attribute mapping.')], HRESULT, 'AttributeMappings',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'AttributeMappings' )),
    COMMETHOD(['propputref', helpstring(u'The collection of directions attribute mapping.')], HRESULT, 'AttributeMappings',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'AttributeMappings' )),
]
################################################################
## code template for INetworkDirections2 implementation
##class INetworkDirections2_Impl(object):
##    def AttributeMappings(self, AttributeMappings):
##        u'The collection of directions attribute mapping.'
##        #return 
##

IDETableType._methods_ = [
]
################################################################
## code template for IDETableType implementation
##class IDETableType_Impl(object):

IDEGPServerType._methods_ = [
]
################################################################
## code template for IDEGPServerType implementation
##class IDEGPServerType_Impl(object):

class IGPDomain(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members of a Geoprocessing Domain.'
    _iid_ = GUID('{0948F56F-9A99-4672-959E-3519F5676ADD}')
    _idlflags_ = ['oleautomation']
IGPDataType._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the data type.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The descriptive, user-friendly name.')], HRESULT, 'DisplayName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The COM class id of the data type.')], HRESULT, 'ControlCLSID',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'CLSID' )),
    COMMETHOD(['propget', helpstring(u'The associated Name object.')], HRESULT, 'FullName',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The name of the (CHM) file containing help information.')], HRESULT, 'HelpFile',
              ( ['retval', 'out'], POINTER(BSTR), 'file' )),
    COMMETHOD(['propget', helpstring(u'The context identifier of the topic within the help file.')], HRESULT, 'HelpContext',
              ( ['retval', 'out'], POINTER(c_int), 'context' )),
    COMMETHOD(['propget', helpstring(u'The name of the (XML) file containing the default metadata for this data type.')], HRESULT, 'MetadataFile',
              ( ['retval', 'out'], POINTER(BSTR), 'file' )),
    COMMETHOD([helpstring(u'Creates a geoprocessing value object from the given string.')], HRESULT, 'CreateValue',
              ( ['in'], BSTR, 'text' ),
              ( ['retval', 'out'], POINTER(POINTER(IGPValue)), 'Value' )),
    COMMETHOD([helpstring(u'Validates if a given geoprocessing data type object is valid.')], HRESULT, 'ValidateDataType',
              ( ['in'], POINTER(IGPDataType), 'Type' ),
              ( ['retval', 'out'], POINTER(POINTER(IGPMessage)), 'Message' )),
    COMMETHOD([helpstring(u'Validates if a given geoprocessing value object is the correct data type.')], HRESULT, 'ValidateValue',
              ( ['in'], POINTER(IGPValue), 'Value' ),
              ( ['in'], POINTER(IGPDomain), 'Domain' ),
              ( ['retval', 'out'], POINTER(POINTER(IGPMessage)), 'Message' )),
]
################################################################
## code template for IGPDataType implementation
##class IGPDataType_Impl(object):
##    def ValidateValue(self, Value, Domain):
##        u'Validates if a given geoprocessing value object is the correct data type.'
##        #return Message
##
##    @property
##    def DisplayName(self):
##        u'The descriptive, user-friendly name.'
##        #return Name
##
##    @property
##    def Name(self):
##        u'The name of the data type.'
##        #return Name
##
##    @property
##    def MetadataFile(self):
##        u'The name of the (XML) file containing the default metadata for this data type.'
##        #return file
##
##    @property
##    def ControlCLSID(self):
##        u'The COM class id of the data type.'
##        #return CLSID
##
##    def ValidateDataType(self, Type):
##        u'Validates if a given geoprocessing data type object is valid.'
##        #return Message
##
##    @property
##    def HelpContext(self):
##        u'The context identifier of the topic within the help file.'
##        #return context
##
##    @property
##    def HelpFile(self):
##        u'The name of the (CHM) file containing help information.'
##        #return file
##
##    def CreateValue(self, text):
##        u'Creates a geoprocessing value object from the given string.'
##        #return Value
##
##    @property
##    def FullName(self):
##        u'The associated Name object.'
##        #return Name
##

IDEGPServer._methods_ = [
]
################################################################
## code template for IDEGPServer implementation
##class IDEGPServer_Impl(object):

IDEGeometryServerType._methods_ = [
]
################################################################
## code template for IDEGeometryServerType implementation
##class IDEGeometryServerType_Impl(object):

INetElementClass._methods_ = [
    COMMETHOD(['propget', helpstring(u'UserClassID of an element class in the logical network.')], HRESULT, 'UserClassID',
              ( ['retval', 'out'], POINTER(c_int), 'UserClassID' )),
]
################################################################
## code template for INetElementClass implementation
##class INetElementClass_Impl(object):
##    @property
##    def UserClassID(self):
##        u'UserClassID of an element class in the logical network.'
##        #return UserClassID
##

IDEGeometryServer._methods_ = [
]
################################################################
## code template for IDEGeometryServer implementation
##class IDEGeometryServer_Impl(object):

IDataElementType._methods_ = [
    COMMETHOD([helpstring(u'Creates a data element given a catalog path and an optional workspace.')], HRESULT, 'CreateOutputDataElement',
              ( ['in'], BSTR, 'CatalogPath' ),
              ( ['in'], BSTR, 'optionalWorkspace' ),
              ( ['retval', 'out'], POINTER(POINTER(IDataElement)), 'DataElement' )),
]
################################################################
## code template for IDataElementType implementation
##class IDataElementType_Impl(object):
##    def CreateOutputDataElement(self, CatalogPath, optionalWorkspace):
##        u'Creates a data element given a catalog path and an optional workspace.'
##        #return DataElement
##

IDEServerConnectionType._methods_ = [
]
################################################################
## code template for IDEServerConnectionType implementation
##class IDEServerConnectionType_Impl(object):

class ITopology2(ITopology):
    _case_insensitive_ = True
    u'Provides access to members that control a topology.'
    _iid_ = GUID('{FF9B929C-9726-4F60-AC10-E798999BCE71}')
    _idlflags_ = ['oleautomation']
ITopology._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates whether the topology is clean or not.')], HRESULT, 'State',
              ( ['retval', 'out'], POINTER(esriTopologyState), 'State' )),
    COMMETHOD([helpstring(u'Validate the specified area in the topology.')], HRESULT, 'ValidateTopology',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'areaToValidate' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'affectedArea' )),
    COMMETHOD(['propget', helpstring(u'The cluster tolerance of the topology.')], HRESULT, 'ClusterTolerance',
              ( ['retval', 'out'], POINTER(c_double), 'tolerance' )),
    COMMETHOD(['propget', helpstring(u'The topology graph of the topology.')], HRESULT, 'Cache',
              ( ['retval', 'out'], POINTER(POINTER(ITopologyGraph)), 'graph' )),
    COMMETHOD(['propget', helpstring(u'The feature dataset that contains the topology.')], HRESULT, 'FeatureDataset',
              ( ['retval', 'out'], POINTER(POINTER(IFeatureDataset)), 'Dataset' )),
    COMMETHOD([helpstring(u'Add an object, feature, or attributed relationship class to the topology.')], HRESULT, 'AddClass',
              ( ['in'], POINTER(IClass), 'classToAdd' ),
              ( ['in'], c_double, 'Weight' ),
              ( ['in'], c_int, 'XYRank' ),
              ( ['in'], c_int, 'ZRank' ),
              ( ['in'], VARIANT_BOOL, 'EventNotificationOnValidate' )),
    COMMETHOD([helpstring(u'Remove an object, feature, or attributed relationship class to the topology.')], HRESULT, 'RemoveClass',
              ( ['in'], POINTER(IClass), 'classToRemove' )),
    COMMETHOD(['propget', helpstring(u'The maximum number of errors to generate when validating a topology.')], HRESULT, 'MaximumGeneratedErrorCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The ID of the topology.')], HRESULT, 'TopologyID',
              ( ['retval', 'out'], POINTER(c_int), 'ID' )),
    COMMETHOD(['propget', helpstring(u'The dirty area polygon of the topology.')], HRESULT, 'DirtyArea',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon), 'Location' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon)), 'dirtyAreaPolygon' )),
]
################################################################
## code template for ITopology implementation
##class ITopology_Impl(object):
##    def RemoveClass(self, classToRemove):
##        u'Remove an object, feature, or attributed relationship class to the topology.'
##        #return 
##
##    @property
##    def MaximumGeneratedErrorCount(self):
##        u'The maximum number of errors to generate when validating a topology.'
##        #return Count
##
##    @property
##    def TopologyID(self):
##        u'The ID of the topology.'
##        #return ID
##
##    @property
##    def Cache(self):
##        u'The topology graph of the topology.'
##        #return graph
##
##    @property
##    def ClusterTolerance(self):
##        u'The cluster tolerance of the topology.'
##        #return tolerance
##
##    @property
##    def State(self):
##        u'Indicates whether the topology is clean or not.'
##        #return State
##
##    def ValidateTopology(self, areaToValidate):
##        u'Validate the specified area in the topology.'
##        #return affectedArea
##
##    @property
##    def DirtyArea(self, Location):
##        u'The dirty area polygon of the topology.'
##        #return dirtyAreaPolygon
##
##    @property
##    def FeatureDataset(self):
##        u'The feature dataset that contains the topology.'
##        #return Dataset
##
##    def AddClass(self, classToAdd, Weight, XYRank, ZRank, EventNotificationOnValidate):
##        u'Add an object, feature, or attributed relationship class to the topology.'
##        #return 
##

ITopology2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The z cluster tolerance of the topology.')], HRESULT, 'ZClusterTolerance',
              ( ['retval', 'out'], POINTER(c_double), 'tolerance' )),
]
################################################################
## code template for ITopology2 implementation
##class ITopology2_Impl(object):
##    @property
##    def ZClusterTolerance(self):
##        u'The z cluster tolerance of the topology.'
##        #return tolerance
##

IDEServerConnection._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the connection.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'pName' )),
    COMMETHOD(['propput', helpstring(u'The name of the connection.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'pName' )),
    COMMETHOD(['propget', helpstring(u'The URL of the connection.')], HRESULT, 'URL',
              ( ['retval', 'out'], POINTER(BSTR), 'pUrl' )),
    COMMETHOD(['propput', helpstring(u'The URL of the connection.')], HRESULT, 'URL',
              ( ['in'], BSTR, 'pUrl' )),
]
################################################################
## code template for IDEServerConnection implementation
##class IDEServerConnection_Impl(object):
##    def _get(self):
##        u'The URL of the connection.'
##        #return pUrl
##    def _set(self, pUrl):
##        u'The URL of the connection.'
##    URL = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the connection.'
##        #return pName
##    def _set(self, pName):
##        u'The name of the connection.'
##    Name = property(_get, _set, doc = _set.__doc__)
##

INetWeightAssociation._methods_ = [
    COMMETHOD(['propget', helpstring(u'Name of the table to which this weight is associated.')], HRESULT, 'TableName',
              ( ['retval', 'out'], POINTER(BSTR), 'TableName' )),
    COMMETHOD(['propget', helpstring(u'Name of the field that contains the values for this weight.')], HRESULT, 'FieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'Weight internal ID of the weight to which this table is associated.')], HRESULT, 'WeightID',
              ( ['retval', 'out'], POINTER(c_int), 'WeightID' )),
]
################################################################
## code template for INetWeightAssociation implementation
##class INetWeightAssociation_Impl(object):
##    @property
##    def FieldName(self):
##        u'Name of the field that contains the values for this weight.'
##        #return FieldName
##
##    @property
##    def TableName(self):
##        u'Name of the table to which this weight is associated.'
##        #return TableName
##
##    @property
##    def WeightID(self):
##        u'Weight internal ID of the weight to which this table is associated.'
##        #return WeightID
##

class ITopologyProperties(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return properties of a topology.'
    _iid_ = GUID('{40658B10-2C65-4B38-B00F-4D40AB551E27}')
    _idlflags_ = ['oleautomation']
ITopologyProperties._methods_ = [
    COMMETHOD(['propget', helpstring(u'The cluster tolerance of the topology.')], HRESULT, 'ClusterTolerance',
              ( ['retval', 'out'], POINTER(c_double), 'tolerance' )),
    COMMETHOD(['propget', helpstring(u'An enumerator over the FeatureClasses.')], HRESULT, 'Classes',
              ( ['retval', 'out'], POINTER(POINTER(IEnumFeatureClass)), 'Classes' )),
    COMMETHOD(['propget', helpstring(u'The spatial reference for the dataset.')], HRESULT, 'SpatialReference',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference)), 'SpatialReference' )),
]
################################################################
## code template for ITopologyProperties implementation
##class ITopologyProperties_Impl(object):
##    @property
##    def SpatialReference(self):
##        u'The spatial reference for the dataset.'
##        #return SpatialReference
##
##    @property
##    def Classes(self):
##        u'An enumerator over the FeatureClasses.'
##        #return Classes
##
##    @property
##    def ClusterTolerance(self):
##        u'The cluster tolerance of the topology.'
##        #return tolerance
##

class Tin(CoClass):
    u'The Esri TIN component.'
    _reg_clsid_ = GUID('{73B80FC3-FF33-11D1-A549-0000F8774F0F}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ITinAdvanced3(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control advanced TIN functions.'
    _iid_ = GUID('{911FDE18-ABB0-4F7B-B960-F40DCD527B46}')
    _idlflags_ = ['oleautomation']
class ITinNodeCollection(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control TIN nodes.'
    _iid_ = GUID('{9A2A4B72-11CF-11D2-A556-0000F8774F0F}')
    _idlflags_ = []
class ITinEdit2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control TIN editing.'
    _iid_ = GUID('{21C49CC8-3C46-454E-9115-57490FB6BA4F}')
    _idlflags_ = ['oleautomation']
class ITinSelection(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control TIN selction methods.'
    _iid_ = GUID('{B0DBC8E2-B4B1-11D3-AB4D-0008C73FD50C}')
    _idlflags_ = ['oleautomation']
class ITinNodeInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to TIN node's properties."
    _iid_ = GUID('{11F2C1AC-188B-4A4F-B221-573C1A0C753D}')
    _idlflags_ = ['oleautomation']
class ITinEditErrorLog(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to TIN's internal edit errors."
    _iid_ = GUID('{0F7F5A1E-5588-40AB-B7F0-777A4B0C8958}')
    _idlflags_ = ['oleautomation']
class ISurfaceIntersectionEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that occur with a surface intersection process.'
    _iid_ = GUID('{63CE4874-B31C-48D3-BA60-5D1B74A63CEB}')
    _idlflags_ = ['oleautomation']
Tin._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDataset, IGeoDataset, IGeoDatasetSchemaEdit, IMetadata, IMetadataEdit, ITin, INativeTypeInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, ITinAdvanced, ITinAdvanced2, ITinAdvanced3, ITinNodeCollection, comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IFunctionalSurface, comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IFunctionalSurface3, ISurface, ITinSurface, ITinSurface2, ITinSurface3, ITinEdit, ITinEdit2, ITinSelection, ITinFeatureEdit, ITinClock, ITinNodeInfo, ITinEditErrorLog]
Tin._outgoing_interfaces_ = [ISurfaceIntersectionEvents]

class IDEWorkspaceType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the Workspace Data Element Type.'
    _iid_ = GUID('{D23FDD2B-1986-4359-AC2B-D7BF7D582C5E}')
    _idlflags_ = ['oleautomation']
IDEWorkspaceType._methods_ = [
]
################################################################
## code template for IDEWorkspaceType implementation
##class IDEWorkspaceType_Impl(object):

IResultPortionInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'The unique ID of a result.')], HRESULT, 'ResultID',
              ( ['retval', 'out'], POINTER(BSTR), 'queryID' )),
    COMMETHOD(['propput', helpstring(u'The unique ID of a result.')], HRESULT, 'ResultID',
              ( ['in'], BSTR, 'queryID' )),
    COMMETHOD(['propget', helpstring(u'The zero-based index of the first element to return or being returned.')], HRESULT, 'StartIndex',
              ( ['retval', 'out'], POINTER(c_int), 'StartIndex' )),
    COMMETHOD(['propput', helpstring(u'The zero-based index of the first element to return or being returned.')], HRESULT, 'StartIndex',
              ( ['in'], c_int, 'StartIndex' )),
    COMMETHOD(['propget', helpstring(u'The number of elements to return or being returned.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propput', helpstring(u'The number of elements to return or being returned.')], HRESULT, 'Count',
              ( ['in'], c_int, 'Count' )),
]
################################################################
## code template for IResultPortionInfo implementation
##class IResultPortionInfo_Impl(object):
##    def _get(self):
##        u'The number of elements to return or being returned.'
##        #return Count
##    def _set(self, Count):
##        u'The number of elements to return or being returned.'
##    Count = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The zero-based index of the first element to return or being returned.'
##        #return StartIndex
##    def _set(self, StartIndex):
##        u'The zero-based index of the first element to return or being returned.'
##    StartIndex = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The unique ID of a result.'
##        #return queryID
##    def _set(self, queryID):
##        u'The unique ID of a result.'
##    ResultID = property(_get, _set, doc = _set.__doc__)
##

IEnumNetWeightAssociation._methods_ = [
    COMMETHOD(['propget', helpstring(u'Number of weight associations in this enumeration.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD([helpstring(u'Forces the enumerator pointing to the first weight association in this enumeration.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Returns the next weight association in this enumeration.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(INetWeightAssociation)), 'NetWeightAssociation' )),
]
################################################################
## code template for IEnumNetWeightAssociation implementation
##class IEnumNetWeightAssociation_Impl(object):
##    @property
##    def Count(self):
##        u'Number of weight associations in this enumeration.'
##        #return Count
##
##    def Reset(self):
##        u'Forces the enumerator pointing to the first weight association in this enumeration.'
##        #return 
##
##    def Next(self):
##        u'Returns the next weight association in this enumeration.'
##        #return NetWeightAssociation
##

class IErrorFeatureContainer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return error features.'
    _iid_ = GUID('{27C444DC-25EE-41FF-A2BD-C69B6343A6C3}')
    _idlflags_ = ['oleautomation']
class ITopologyRule(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to memebers that return information about topology rules.'
    _iid_ = GUID('{A53B59A5-2EFC-41C4-9769-C0FAA13E62E9}')
    _idlflags_ = ['oleautomation']
IErrorFeatureContainer._methods_ = [
    COMMETHOD(['propget', helpstring(u'An error feature with that matches the passed in parameters.')], HRESULT, 'ErrorFeature',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference' ),
              ( ['in'], esriTopologyRuleType, 'errorType' ),
              ( ['in'], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType, 'GeometryType' ),
              ( ['in'], c_int, 'OriginClassID' ),
              ( ['in'], c_int, 'OriginOID' ),
              ( ['in'], c_int, 'DestinationClassID' ),
              ( ['in'], c_int, 'DestinationOID' ),
              ( ['retval', 'out'], POINTER(POINTER(ITopologyErrorFeature)), 'ErrorFeature' )),
    COMMETHOD(['propget', helpstring(u'An enumeration of error features that match the passed in parameters.')], HRESULT, 'ErrorFeatures',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference' ),
              ( ['in'], POINTER(ITopologyRule), 'Rule' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'Extent' ),
              ( ['in'], VARIANT_BOOL, 'Errors' ),
              ( ['in'], VARIANT_BOOL, 'Exceptions' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumTopologyErrorFeature)), 'ErrorFeatures' )),
    COMMETHOD(['propget', helpstring(u'An enumeration of error features that match the passed in parameters.')], HRESULT, 'ErrorFeaturesByGeometryType',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference' ),
              ( ['in'], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType, 'GeometryType' ),
              ( ['in'], VARIANT_BOOL, 'Exceptions' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumTopologyErrorFeature)), 'ErrorFeatures' )),
    COMMETHOD(['propget', helpstring(u'An enumeration of error features that match the passed in parameters.')], HRESULT, 'ErrorFeaturesByRuleType',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference' ),
              ( ['in'], esriTopologyRuleType, 'TopologyRuleType' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'Extent' ),
              ( ['in'], VARIANT_BOOL, 'Errors' ),
              ( ['in'], VARIANT_BOOL, 'Exceptions' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumTopologyErrorFeature)), 'ErrorFeatures' )),
]
################################################################
## code template for IErrorFeatureContainer implementation
##class IErrorFeatureContainer_Impl(object):
##    @property
##    def ErrorFeaturesByGeometryType(self, SpatialReference, GeometryType, Exceptions):
##        u'An enumeration of error features that match the passed in parameters.'
##        #return ErrorFeatures
##
##    @property
##    def ErrorFeature(self, SpatialReference, errorType, GeometryType, OriginClassID, OriginOID, DestinationClassID, DestinationOID):
##        u'An error feature with that matches the passed in parameters.'
##        #return ErrorFeature
##
##    @property
##    def ErrorFeaturesByRuleType(self, SpatialReference, TopologyRuleType, Extent, Errors, Exceptions):
##        u'An enumeration of error features that match the passed in parameters.'
##        #return ErrorFeatures
##
##    @property
##    def ErrorFeatures(self, SpatialReference, Rule, Extent, Errors, Exceptions):
##        u'An enumeration of error features that match the passed in parameters.'
##        #return ErrorFeatures
##

class IFieldType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the Field Data Element Type.'
    _iid_ = GUID('{A60642F3-A6CC-472C-AAED-1BD5C0248E1F}')
    _idlflags_ = ['oleautomation']
IFieldType._methods_ = [
]
################################################################
## code template for IFieldType implementation
##class IFieldType_Impl(object):

class IIndexType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the Index Data Element Type.'
    _iid_ = GUID('{D8D57CE0-A6F3-11D5-931E-0080C71A3226}')
    _idlflags_ = ['oleautomation']
IIndexType._methods_ = [
]
################################################################
## code template for IIndexType implementation
##class IIndexType_Impl(object):

class ISimpleDataConverter(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members used for data conversions.'
    _iid_ = GUID('{0446469D-FAFA-11D1-AAB1-00C04FA33C20}')
    _idlflags_ = ['oleautomation']
ISimpleDataConverter._methods_ = [
    COMMETHOD([helpstring(u'Convert the input FeatureClass to another FeatureClass in the output FeatureDataset.')], HRESULT, 'Convert',
              ( ['retval', 'out'], POINTER(POINTER(IEnumInvalidObject)), 'EnumInvalidObject' )),
    COMMETHOD([helpstring(u'Reset all the properties associated with the simple data converter.')], HRESULT, 'Reset'),
    COMMETHOD(['propput', helpstring(u'The property to preserve the inputFeatureType in the output.')], HRESULT, 'IsFeatureTypeSimple',
              ( ['in'], VARIANT_BOOL, 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The input DatasetName, FeatureClass or table.')], HRESULT, 'InputDatasetName',
              ( ['in'], POINTER(IDatasetName), 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The input QueryFilter.')], HRESULT, 'InputQueryFilter',
              ( ['in'], POINTER(IQueryFilter), 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The GeometryDef (optional) for the output FeatureDatasetName.')], HRESULT, 'OutputGeometryDef',
              ( ['in'], POINTER(IGeometryDef), 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The output fields for the input FeatureClass.')], HRESULT, 'OutputFields',
              ( ['in'], POINTER(IFields), 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The output FeatureDatasetName.')], HRESULT, 'OutputFeatureDatasetName',
              ( ['in'], POINTER(IFeatureDatasetName), 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The output object class Name (optional).')], HRESULT, 'OutputDatasetName',
              ( ['in'], POINTER(IDatasetName), 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The configuration keyword for the new FeatureClass.')], HRESULT, 'ConfigurationKeyword',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The flushing interval for sde FeatureClass.')], HRESULT, 'FlushInterval',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The parent hWnd.')], HRESULT, 'ParentWindowHandle',
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'rhs' )),
]
################################################################
## code template for ISimpleDataConverter implementation
##class ISimpleDataConverter_Impl(object):
##    def Reset(self):
##        u'Reset all the properties associated with the simple data converter.'
##        #return 
##
##    def OutputFeatureDatasetName(self, rhs):
##        u'The output FeatureDatasetName.'
##        #return 
##
##    def Convert(self):
##        u'Convert the input FeatureClass to another FeatureClass in the output FeatureDataset.'
##        #return EnumInvalidObject
##
##    def InputDatasetName(self, rhs):
##        u'The input DatasetName, FeatureClass or table.'
##        #return 
##
##    def InputQueryFilter(self, rhs):
##        u'The input QueryFilter.'
##        #return 
##
##    def OutputDatasetName(self, rhs):
##        u'The output object class Name (optional).'
##        #return 
##
##    def _set(self, rhs):
##        u'The configuration keyword for the new FeatureClass.'
##    ConfigurationKeyword = property(fset = _set, doc = _set.__doc__)
##
##    def OutputFields(self, rhs):
##        u'The output fields for the input FeatureClass.'
##        #return 
##
##    def OutputGeometryDef(self, rhs):
##        u'The GeometryDef (optional) for the output FeatureDatasetName.'
##        #return 
##
##    def _set(self, rhs):
##        u'The parent hWnd.'
##    ParentWindowHandle = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The property to preserve the inputFeatureType in the output.'
##    IsFeatureTypeSimple = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The flushing interval for sde FeatureClass.'
##    FlushInterval = property(fset = _set, doc = _set.__doc__)
##


# values for enumeration 'esriNetworkAttributeParameterUsageType'
esriNAPUTGeneral = 0
esriNAPUTRestriction = 1
esriNetworkAttributeParameterUsageType = c_int # enum
IDEDatasetType._methods_ = [
]
################################################################
## code template for IDEDatasetType implementation
##class IDEDatasetType_Impl(object):

IGxFilterInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'The filters used to open a dataset of this type.')], HRESULT, 'OpenGxObjectFilters',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'filters' )),
    COMMETHOD(['propget', helpstring(u'The filters used to save a dataset of this type.')], HRESULT, 'SaveGxObjectFilters',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'filters' )),
]
################################################################
## code template for IGxFilterInfo implementation
##class IGxFilterInfo_Impl(object):
##    @property
##    def SaveGxObjectFilters(self):
##        u'The filters used to save a dataset of this type.'
##        #return filters
##
##    @property
##    def OpenGxObjectFilters(self):
##        u'The filters used to open a dataset of this type.'
##        #return filters
##


# values for enumeration 'esriNetworkElevationModel'
esriNEMNone = 0
esriNEMElevationFields = 1
esriNEMZCoordinates = 2
esriNetworkElevationModel = c_int # enum
IGPMessageManager._methods_ = [
    COMMETHOD([helpstring(u'Get a given message.')], HRESULT, 'GetMessage',
              ( ['in'], c_int, 'ID' ),
              ( ['retval', 'out'], POINTER(BSTR), 'msg' )),
    COMMETHOD([helpstring(u'Generate a given message from the message id.')], HRESULT, 'GenerateMessage',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ID' ),
              ( ['retval', 'out'], POINTER(BSTR), 'msg' )),
    COMMETHOD([helpstring(u'Add a given message from the message id to the messages object.')], HRESULT, 'AddMessage',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ID' ),
              ( ['in'], POINTER(IGPMessages), 'msgs' )),
    COMMETHOD([helpstring(u'Add a given message from the message id to the messages object.')], HRESULT, 'AddMessage1Args',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ID' ),
              ( ['in'], BSTR, 'arg1' ),
              ( ['in'], POINTER(IGPMessages), 'msgs' )),
    COMMETHOD([helpstring(u'Add a given message from the message id to the messages object.')], HRESULT, 'AddMessage2Args',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ID' ),
              ( ['in'], BSTR, 'arg1' ),
              ( ['in'], BSTR, 'arg2' ),
              ( ['in'], POINTER(IGPMessages), 'msgs' )),
    COMMETHOD([helpstring(u'Add a given message from the message text to the messages object.')], HRESULT, 'AddMessageText',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ID' ),
              ( ['in'], BSTR, 'msg' ),
              ( ['in'], POINTER(IGPMessages), 'msgs' )),
    COMMETHOD([helpstring(u'Set a given message from the message id to the messages object.')], HRESULT, 'SetMessage',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ID' ),
              ( ['in'], c_int, 'pos' ),
              ( ['in'], POINTER(IGPMessages), 'msgs' )),
    COMMETHOD([helpstring(u'Set a given message from the message id to the messages object.')], HRESULT, 'SetMessage1Args',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ID' ),
              ( ['in'], BSTR, 'arg1' ),
              ( ['in'], c_int, 'pos' ),
              ( ['in'], POINTER(IGPMessages), 'msgs' )),
    COMMETHOD([helpstring(u'Set a given message from the message id to the messages object.')], HRESULT, 'SetMessage2Args',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ID' ),
              ( ['in'], BSTR, 'arg1' ),
              ( ['in'], BSTR, 'arg2' ),
              ( ['in'], c_int, 'pos' ),
              ( ['in'], POINTER(IGPMessages), 'msgs' )),
    COMMETHOD([helpstring(u'Set a given message from the message text to the messages object.')], HRESULT, 'SetMessageText',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ID' ),
              ( ['in'], BSTR, 'msg' ),
              ( ['in'], c_int, 'pos' ),
              ( ['in'], POINTER(IGPMessages), 'msgs' )),
    COMMETHOD([helpstring(u'Chain a given message from the message id.')], HRESULT, 'ChainMessage',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ID' )),
    COMMETHOD([helpstring(u'Chain a given message from the message id.')], HRESULT, 'ChainMessage1Args',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ID' ),
              ( ['in'], BSTR, 'arg1' )),
    COMMETHOD([helpstring(u'Chain a given message from the message id.')], HRESULT, 'ChainMessage2Args',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ID' ),
              ( ['in'], BSTR, 'arg1' ),
              ( ['in'], BSTR, 'arg2' )),
    COMMETHOD([helpstring(u'Chain a given message from the message text.')], HRESULT, 'ChainMessageText',
              ( ['in'], esriGPMessageType, 'Type' ),
              ( ['in'], c_int, 'ID' ),
              ( ['in'], BSTR, 'msg' )),
    COMMETHOD([helpstring(u'Check for any errors in the IErrorInfo structure.')], HRESULT, 'CheckForErrors',
              ( ['in'], HRESULT, 'fdoError' ),
              ( ['in'], POINTER(IGPMessages), 'Messages' ),
              ( ['in'], VARIANT_BOOL, 'keepAllErrors' )),
    COMMETHOD([helpstring(u'Transfer any GP errors or warnings to the messages object.')], HRESULT, 'LookForGPChainedErrors',
              ( ['in'], POINTER(IGPMessages), 'Messages' )),
]
################################################################
## code template for IGPMessageManager implementation
##class IGPMessageManager_Impl(object):
##    def ChainMessage1Args(self, Type, ID, arg1):
##        u'Chain a given message from the message id.'
##        #return 
##
##    def AddMessage(self, Type, ID, msgs):
##        u'Add a given message from the message id to the messages object.'
##        #return 
##
##    def LookForGPChainedErrors(self, Messages):
##        u'Transfer any GP errors or warnings to the messages object.'
##        #return 
##
##    def AddMessage2Args(self, Type, ID, arg1, arg2, msgs):
##        u'Add a given message from the message id to the messages object.'
##        #return 
##
##    def ChainMessageText(self, Type, ID, msg):
##        u'Chain a given message from the message text.'
##        #return 
##
##    def SetMessage1Args(self, Type, ID, arg1, pos, msgs):
##        u'Set a given message from the message id to the messages object.'
##        #return 
##
##    def SetMessage2Args(self, Type, ID, arg1, arg2, pos, msgs):
##        u'Set a given message from the message id to the messages object.'
##        #return 
##
##    def GetMessage(self, ID):
##        u'Get a given message.'
##        #return msg
##
##    def SetMessageText(self, Type, ID, msg, pos, msgs):
##        u'Set a given message from the message text to the messages object.'
##        #return 
##
##    def GenerateMessage(self, Type, ID):
##        u'Generate a given message from the message id.'
##        #return msg
##
##    def SetMessage(self, Type, ID, pos, msgs):
##        u'Set a given message from the message id to the messages object.'
##        #return 
##
##    def ChainMessage2Args(self, Type, ID, arg1, arg2):
##        u'Chain a given message from the message id.'
##        #return 
##
##    def CheckForErrors(self, fdoError, Messages, keepAllErrors):
##        u'Check for any errors in the IErrorInfo structure.'
##        #return 
##
##    def AddMessage1Args(self, Type, ID, arg1, msgs):
##        u'Add a given message from the message id to the messages object.'
##        #return 
##
##    def ChainMessage(self, Type, ID):
##        u'Chain a given message from the message id.'
##        #return 
##
##    def AddMessageText(self, Type, ID, msg, msgs):
##        u'Add a given message from the message text to the messages object.'
##        #return 
##

IDEDataset._methods_ = [
    COMMETHOD(['propget', helpstring(u'Dataset type.')], HRESULT, 'DatasetType',
              ( ['retval', 'out'], POINTER(esriDatasetType), 'Type' )),
    COMMETHOD(['propput', helpstring(u'Dataset type.')], HRESULT, 'DatasetType',
              ( ['in'], esriDatasetType, 'Type' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this dataset is versioned.')], HRESULT, 'Versioned',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Versioned' )),
    COMMETHOD(['propput', helpstring(u'Indicates if this dataset is versioned.')], HRESULT, 'Versioned',
              ( ['in'], VARIANT_BOOL, 'Versioned' )),
    COMMETHOD(['propget', helpstring(u'The id of the dataset.')], HRESULT, 'DSID',
              ( ['retval', 'out'], POINTER(c_int), 'DSID' )),
    COMMETHOD(['propput', helpstring(u'The id of the dataset.')], HRESULT, 'DSID',
              ( ['in'], c_int, 'DSID' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this dataset can be versioned.')], HRESULT, 'CanVersion',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanVersion' )),
    COMMETHOD(['propput', helpstring(u'Indicates if this dataset can be versioned.')], HRESULT, 'CanVersion',
              ( ['in'], VARIANT_BOOL, 'CanVersion' )),
]
################################################################
## code template for IDEDataset implementation
##class IDEDataset_Impl(object):
##    def _get(self):
##        u'Indicates if this dataset can be versioned.'
##        #return CanVersion
##    def _set(self, CanVersion):
##        u'Indicates if this dataset can be versioned.'
##    CanVersion = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Dataset type.'
##        #return Type
##    def _set(self, Type):
##        u'Dataset type.'
##    DatasetType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The id of the dataset.'
##        #return DSID
##    def _set(self, DSID):
##        u'The id of the dataset.'
##    DSID = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if this dataset is versioned.'
##        #return Versioned
##    def _set(self, Versioned):
##        u'Indicates if this dataset is versioned.'
##    Versioned = property(_get, _set, doc = _set.__doc__)
##

IDEDataset2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Configuration keyword.')], HRESULT, 'ConfigurationKeyword',
              ( ['retval', 'out'], POINTER(BSTR), 'keyword' )),
    COMMETHOD(['propput', helpstring(u'Configuration keyword.')], HRESULT, 'ConfigurationKeyword',
              ( ['in'], BSTR, 'keyword' )),
]
################################################################
## code template for IDEDataset2 implementation
##class IDEDataset2_Impl(object):
##    def _get(self):
##        u'Configuration keyword.'
##        #return keyword
##    def _set(self, keyword):
##        u'Configuration keyword.'
##    ConfigurationKeyword = property(_get, _set, doc = _set.__doc__)
##


# values for enumeration 'esriRoadClass'
esriRCUnknown = 0
esriRCStreet = 1
esriRCHighway = 2
esriRCRamp = 3
esriRCFerry = 4
esriRCRoundabout = 5
esriRCMajorRoad = 6
esriRoadClass = c_int # enum
IDEGeoDatasetType._methods_ = [
]
################################################################
## code template for IDEGeoDatasetType implementation
##class IDEGeoDatasetType_Impl(object):

IDERasterCatalog._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the raster field.')], HRESULT, 'RasterFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propput', helpstring(u'The name of the raster field.')], HRESULT, 'RasterFieldName',
              ( ['in'], BSTR, 'FieldName' )),
]
################################################################
## code template for IDERasterCatalog implementation
##class IDERasterCatalog_Impl(object):
##    def _get(self):
##        u'The name of the raster field.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The name of the raster field.'
##    RasterFieldName = property(_get, _set, doc = _set.__doc__)
##

IDERasterBandType._methods_ = [
]
################################################################
## code template for IDERasterBandType implementation
##class IDERasterBandType_Impl(object):

IInvalidObjectInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'The object ID that did not get convert.')], HRESULT, 'InvalidObjectID',
              ( ['retval', 'out'], POINTER(c_int), 'featureID' )),
    COMMETHOD(['propget', helpstring(u'The description of the error in converting the feature/row.')], HRESULT, 'ErrorDescription',
              ( ['retval', 'out'], POINTER(BSTR), 'invalidFeatureErrorDescription' )),
]
################################################################
## code template for IInvalidObjectInfo implementation
##class IInvalidObjectInfo_Impl(object):
##    @property
##    def InvalidObjectID(self):
##        u'The object ID that did not get convert.'
##        #return featureID
##
##    @property
##    def ErrorDescription(self):
##        u'The description of the error in converting the feature/row.'
##        #return invalidFeatureErrorDescription
##


# values for enumeration 'esriNetworkTurnAngleCategory'
esriNTACStraight = 0
esriNTACReverse = 1
esriNTACRight = 2
esriNTACLeft = 3
esriNetworkTurnAngleCategory = c_int # enum
IDERasterDatasetType._methods_ = [
]
################################################################
## code template for IDERasterDatasetType implementation
##class IDERasterDatasetType_Impl(object):

IDERasterBand._methods_ = [
    COMMETHOD(['propget', helpstring(u'Number of Columns.')], HRESULT, 'Width',
              ( ['retval', 'out'], POINTER(c_int), 'pVal' )),
    COMMETHOD(['propput', helpstring(u'Number of Columns.')], HRESULT, 'Width',
              ( ['in'], c_int, 'pVal' )),
    COMMETHOD(['propget', helpstring(u'Number of Rows.')], HRESULT, 'Height',
              ( ['retval', 'out'], POINTER(c_int), 'pVal' )),
    COMMETHOD(['propput', helpstring(u'Number of Rows.')], HRESULT, 'Height',
              ( ['in'], c_int, 'pVal' )),
    COMMETHOD(['propget', helpstring(u'Data type of the pixels.')], HRESULT, 'PixelType',
              ( ['retval', 'out'], POINTER(rstPixelType), 'pVal' )),
    COMMETHOD(['propput', helpstring(u'Data type of the pixels.')], HRESULT, 'PixelType',
              ( ['in'], rstPixelType, 'pVal' )),
    COMMETHOD(['propget', helpstring(u'Data value used to indicate invalid or excluded data.')], HRESULT, 'NoDataValue',
              ( ['retval', 'out'], POINTER(VARIANT), 'pVal' )),
    COMMETHOD(['propput', helpstring(u'Data value used to indicate invalid or excluded data.')], HRESULT, 'NoDataValue',
              ( ['in'], VARIANT, 'pVal' )),
    COMMETHOD(['propget', helpstring(u'The approximate cell height of the raster.')], HRESULT, 'MeanCellHeight',
              ( ['retval', 'out'], POINTER(c_double), 'cellHeight' )),
    COMMETHOD(['propget', helpstring(u'The approximate cell width of the raster.')], HRESULT, 'MeanCellWidth',
              ( ['retval', 'out'], POINTER(c_double), 'cellWidth' )),
    COMMETHOD(['propput', helpstring(u'The approximate cell height of the raster.')], HRESULT, 'MeanCellHeight',
              ( ['in'], c_double, 'cellHeight' )),
    COMMETHOD(['propput', helpstring(u'The approximate cell width of the raster.')], HRESULT, 'MeanCellWidth',
              ( ['in'], c_double, 'cellWidth' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the data is integer.')], HRESULT, 'IsInteger',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsInteger' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the data is integer.')], HRESULT, 'IsInteger',
              ( ['in'], VARIANT_BOOL, 'IsInteger' )),
    COMMETHOD(['propget', helpstring(u'The class names of the table.')], HRESULT, 'TableType',
              ( ['retval', 'out'], POINTER(esriRasterTableTypeEnum), 'Type' )),
    COMMETHOD(['propput', helpstring(u'The class names of the table.')], HRESULT, 'TableType',
              ( ['in'], esriRasterTableTypeEnum, 'Type' )),
    COMMETHOD(['propget', helpstring(u'The primary field of the table.')], HRESULT, 'PrimaryField',
              ( ['retval', 'out'], POINTER(c_int), 'FieldIndex' )),
    COMMETHOD(['propput', helpstring(u'The primary field of the table.')], HRESULT, 'PrimaryField',
              ( ['in'], c_int, 'FieldIndex' )),
]
################################################################
## code template for IDERasterBand implementation
##class IDERasterBand_Impl(object):
##    def _get(self):
##        u'Data type of the pixels.'
##        #return pVal
##    def _set(self, pVal):
##        u'Data type of the pixels.'
##    PixelType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Data value used to indicate invalid or excluded data.'
##        #return pVal
##    def _set(self, pVal):
##        u'Data value used to indicate invalid or excluded data.'
##    NoDataValue = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Number of Columns.'
##        #return pVal
##    def _set(self, pVal):
##        u'Number of Columns.'
##    Width = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The primary field of the table.'
##        #return FieldIndex
##    def _set(self, FieldIndex):
##        u'The primary field of the table.'
##    PrimaryField = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The approximate cell height of the raster.'
##        #return cellHeight
##    def _set(self, cellHeight):
##        u'The approximate cell height of the raster.'
##    MeanCellHeight = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Number of Rows.'
##        #return pVal
##    def _set(self, pVal):
##        u'Number of Rows.'
##    Height = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The approximate cell width of the raster.'
##        #return cellWidth
##    def _set(self, cellWidth):
##        u'The approximate cell width of the raster.'
##    MeanCellWidth = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The class names of the table.'
##        #return Type
##    def _set(self, Type):
##        u'The class names of the table.'
##    TableType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the data is integer.'
##        #return IsInteger
##    def _set(self, IsInteger):
##        u'Indicates if the data is integer.'
##    IsInteger = property(_get, _set, doc = _set.__doc__)
##

class IDEFeatureDatasetType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the FeatureDataset Data Element Type.'
    _iid_ = GUID('{BA97439E-9387-49F7-A43B-88ABB81CE0C0}')
    _idlflags_ = ['oleautomation']
IDEFeatureDatasetType._methods_ = [
]
################################################################
## code template for IDEFeatureDatasetType implementation
##class IDEFeatureDatasetType_Impl(object):

IGPDomain._methods_ = [
    COMMETHOD([helpstring(u'Indicates if the value object is a member of the geoprocessing domain type.')], HRESULT, 'MemberOf',
              ( ['in'], POINTER(IGPValue), 'Value' ),
              ( ['retval', 'out'], POINTER(POINTER(IGPMessage)), 'Message' )),
]
################################################################
## code template for IGPDomain implementation
##class IGPDomain_Impl(object):
##    def MemberOf(self, Value):
##        u'Indicates if the value object is a member of the geoprocessing domain type.'
##        #return Message
##

IDEFeatureClassType._methods_ = [
]
################################################################
## code template for IDEFeatureClassType implementation
##class IDEFeatureClassType_Impl(object):

IEnumTinTriangle._methods_ = [
    COMMETHOD([helpstring(u'Resets the enumerators.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Gets next triangle elements.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(ITinTriangle)), 'ppTriangle' )),
    COMMETHOD([helpstring(u'Queries next triangle elements.')], HRESULT, 'QueryNext',
              ( [], POINTER(ITinTriangle), 'pTriangle' )),
    COMMETHOD([helpstring(u'Queries next triangle element as a WKS point with z values.')], HRESULT, 'QueryNextAsWKSPointZs',
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPi' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPj' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPk' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'pbIsEnd' )),
    COMMETHOD(['restricted', helpstring(u'Queries next triangle element as a WKS point with z values.')], HRESULT, 'QueryNextAsWKSPointZs2',
              ( ['out'], POINTER(c_int), 'pTriangleIndex' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPi' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPj' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPk' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'pbIsEnd' )),
    COMMETHOD([helpstring(u'Gets next triangle strip.')], HRESULT, 'NextTriangleStrip',
              ( ['in'], c_int, 'maxSize' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinNodeArray)), 'ppNodes' )),
    COMMETHOD([helpstring(u'Gets next triangle strip indices.')], HRESULT, 'NextTriangleStripIndices',
              ( ['in'], c_int, 'maxSize' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray)), 'ppNodes' )),
]
################################################################
## code template for IEnumTinTriangle implementation
##class IEnumTinTriangle_Impl(object):
##    def Reset(self):
##        u'Resets the enumerators.'
##        #return 
##
##    def NextTriangleStrip(self, maxSize):
##        u'Gets next triangle strip.'
##        #return ppNodes
##
##    def QueryNextAsWKSPointZs(self):
##        u'Queries next triangle element as a WKS point with z values.'
##        #return pPi, pPj, pPk, pbIsEnd
##
##    def Next(self):
##        u'Gets next triangle elements.'
##        #return ppTriangle
##
##    def QueryNextAsWKSPointZs2(self):
##        u'Queries next triangle element as a WKS point with z values.'
##        #return pTriangleIndex, pPi, pPj, pPk, pbIsEnd
##
##    def QueryNext(self, pTriangle):
##        u'Queries next triangle elements.'
##        #return 
##
##    def NextTriangleStripIndices(self, maxSize):
##        u'Gets next triangle strip indices.'
##        #return ppNodes
##

class IDERelationshipClassType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the RelationshipClass Data Element Type.'
    _iid_ = GUID('{294E86C0-B012-4C11-9BD7-2DB0C2BBE637}')
    _idlflags_ = ['oleautomation']
IDERelationshipClassType._methods_ = [
]
################################################################
## code template for IDERelationshipClassType implementation
##class IDERelationshipClassType_Impl(object):

IGPDescribe._methods_ = [
    COMMETHOD([helpstring(u'The description of the named object.')], HRESULT, 'Describe',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
]
################################################################
## code template for IGPDescribe implementation
##class IGPDescribe_Impl(object):
##    def Describe(self, Name):
##        u'The description of the named object.'
##        #return Value
##


# values for enumeration 'esriNetworkAccess'
esriNAReadOnly = 0
esriNAReadWrite = 1
esriNACreate = 2
esriNetworkAccess = c_int # enum
INetworkWorkspace._methods_ = [
    COMMETHOD([helpstring(u'Creates a logical network.')], HRESULT, 'CreateNetwork',
              ( ['in'], BSTR, 'NetworkName' ),
              ( ['in'], esriNetworkType, 'NetworkType' ),
              ( ['in'], VARIANT_BOOL, 'buildNormalizedTables' ),
              ( ['retval', 'out'], POINTER(POINTER(INetwork)), 'Network' )),
    COMMETHOD([helpstring(u'Opens a logical network.')], HRESULT, 'OpenNetwork',
              ( ['in'], BSTR, 'NetworkName' ),
              ( ['in'], esriNetworkType, 'NetworkType' ),
              ( ['in'], esriNetworkAccess, 'networkAccess' ),
              ( ['retval', 'out'], POINTER(POINTER(INetwork)), 'Network' )),
    COMMETHOD([helpstring(u'Returns an enumeration of the names of the logical networks within the current workspace.')], HRESULT, 'GetNetworkNames',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IEnumBSTR)), 'networkNames' )),
]
################################################################
## code template for INetworkWorkspace implementation
##class INetworkWorkspace_Impl(object):
##    def OpenNetwork(self, NetworkName, NetworkType, networkAccess):
##        u'Opens a logical network.'
##        #return Network
##
##    def CreateNetwork(self, NetworkName, NetworkType, buildNormalizedTables):
##        u'Creates a logical network.'
##        #return Network
##
##    def GetNetworkNames(self):
##        u'Returns an enumeration of the names of the logical networks within the current workspace.'
##        #return networkNames
##

IFeatureDatasetName._methods_ = [
    COMMETHOD(['propget', helpstring(u'An enumerator over the feature class names in this FeatureDataset.')], HRESULT, 'FeatureClassNames',
              ( ['retval', 'out'], POINTER(POINTER(IEnumDatasetName)), 'FeatureClassNames' )),
    COMMETHOD(['propget', helpstring(u'An enumerator over the geometric network names in this FeatureDataset.')], HRESULT, 'GeometricNetworkNames',
              ( ['retval', 'out'], POINTER(POINTER(IEnumDatasetName)), 'GeometricNetworkNames' )),
    COMMETHOD(['propget', helpstring(u'An enumerator over the table (non spatial object class) names in this FeatureDataset.')], HRESULT, 'TableNames',
              ( ['retval', 'out'], POINTER(POINTER(IEnumDatasetName)), 'FeatureClassNames' )),
    COMMETHOD(['propget', helpstring(u'An enumerator over the relationship class names in this FeatureDataset.')], HRESULT, 'RelationshipClassNames',
              ( ['retval', 'out'], POINTER(POINTER(IEnumDatasetName)), 'RelationshipClassNames' )),
]
################################################################
## code template for IFeatureDatasetName implementation
##class IFeatureDatasetName_Impl(object):
##    @property
##    def RelationshipClassNames(self):
##        u'An enumerator over the relationship class names in this FeatureDataset.'
##        #return RelationshipClassNames
##
##    @property
##    def GeometricNetworkNames(self):
##        u'An enumerator over the geometric network names in this FeatureDataset.'
##        #return GeometricNetworkNames
##
##    @property
##    def TableNames(self):
##        u'An enumerator over the table (non spatial object class) names in this FeatureDataset.'
##        #return FeatureClassNames
##
##    @property
##    def FeatureClassNames(self):
##        u'An enumerator over the feature class names in this FeatureDataset.'
##        #return FeatureClassNames
##

class ISignposts(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the properties for setting up signposts used in driving directions.'
    _iid_ = GUID('{E44759D6-D13B-4E36-93CE-1E755F3177D5}')
    _idlflags_ = ['oleautomation']
ISignposts._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the feature class containing the signposts.')], HRESULT, 'SignpostFeatureClassName',
              ( ['retval', 'out'], POINTER(BSTR), 'ClassName' )),
    COMMETHOD(['propput', helpstring(u'The name of the feature class containing the signposts.')], HRESULT, 'SignpostFeatureClassName',
              ( ['in'], BSTR, 'ClassName' )),
    COMMETHOD(['propget', helpstring(u'The name of the indexed table of signpost street references.')], HRESULT, 'SignpostStreetsTableName',
              ( ['retval', 'out'], POINTER(BSTR), 'TableName' )),
    COMMETHOD(['propput', helpstring(u'The name of the indexed table of signpost street references.')], HRESULT, 'SignpostStreetsTableName',
              ( ['in'], BSTR, 'TableName' )),
]
################################################################
## code template for ISignposts implementation
##class ISignposts_Impl(object):
##    def _get(self):
##        u'The name of the indexed table of signpost street references.'
##        #return TableName
##    def _set(self, TableName):
##        u'The name of the indexed table of signpost street references.'
##    SignpostStreetsTableName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the feature class containing the signposts.'
##        #return ClassName
##    def _set(self, ClassName):
##        u'The name of the feature class containing the signposts.'
##    SignpostFeatureClassName = property(_get, _set, doc = _set.__doc__)
##

class ITopologyRuleContainer(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return and set topology rules.'
    _iid_ = GUID('{B65D9FEE-6D67-47FD-AC13-06BDE90A1B34}')
    _idlflags_ = ['oleautomation']
ITopologyRuleContainer._methods_ = [
    COMMETHOD(['propget', helpstring(u'The topology rule with the corresponding ID.')], HRESULT, 'Rule',
              ( ['in'], c_int, 'RuleID' ),
              ( ['retval', 'out'], POINTER(POINTER(IRule)), 'Rule' )),
    COMMETHOD(['propget', helpstring(u'An enumeration of all the topology rules.')], HRESULT, 'Rules',
              ( ['retval', 'out'], POINTER(POINTER(IEnumRule)), 'Rules' )),
    COMMETHOD(['propget', helpstring(u'The rule with the globally unique ID.')], HRESULT, 'RuleByGUID',
              ( ['in'], BSTR, 'GUID' ),
              ( ['retval', 'out'], POINTER(POINTER(IRule)), 'Rule' )),
    COMMETHOD(['propget', helpstring(u'An enumeration of all the rules for a given class.')], HRESULT, 'RulesByClass',
              ( ['in'], c_int, 'ClassID' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumRule)), 'Rules' )),
    COMMETHOD(['propget', helpstring(u'An enumeration of all the rules for a given class and subtype.')], HRESULT, 'RulesByClassAndSubtype',
              ( ['in'], c_int, 'ClassID' ),
              ( ['in'], c_int, 'SubType' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumRule)), 'Rules' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the topology rule can be added to the topology.')], HRESULT, 'CanAddRule',
              ( ['in'], POINTER(ITopologyRule), 'Rule' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanAddRule' )),
    COMMETHOD([helpstring(u'Adds a topology rule.')], HRESULT, 'AddRule',
              ( ['in'], POINTER(ITopologyRule), 'Rule' )),
    COMMETHOD([helpstring(u'Deletes a topology rule.')], HRESULT, 'DeleteRule',
              ( ['in'], POINTER(ITopologyRule), 'Rule' )),
    COMMETHOD([helpstring(u'Promotes a topology error to an exception.')], HRESULT, 'PromoteToRuleException',
              ( ['in'], POINTER(ITopologyErrorFeature), 'errorException' )),
    COMMETHOD([helpstring(u'Demotes a topology error from an exception to an error.')], HRESULT, 'DemoteFromRuleException',
              ( ['in'], POINTER(ITopologyErrorFeature), 'errorException' )),
]
################################################################
## code template for ITopologyRuleContainer implementation
##class ITopologyRuleContainer_Impl(object):
##    @property
##    def Rules(self):
##        u'An enumeration of all the topology rules.'
##        #return Rules
##
##    def PromoteToRuleException(self, errorException):
##        u'Promotes a topology error to an exception.'
##        #return 
##
##    @property
##    def RuleByGUID(self, GUID):
##        u'The rule with the globally unique ID.'
##        #return Rule
##
##    def DeleteRule(self, Rule):
##        u'Deletes a topology rule.'
##        #return 
##
##    @property
##    def Rule(self, RuleID):
##        u'The topology rule with the corresponding ID.'
##        #return Rule
##
##    @property
##    def CanAddRule(self, Rule):
##        u'Indicates if the topology rule can be added to the topology.'
##        #return CanAddRule
##
##    def AddRule(self, Rule):
##        u'Adds a topology rule.'
##        #return 
##
##    @property
##    def RulesByClassAndSubtype(self, ClassID, SubType):
##        u'An enumeration of all the rules for a given class and subtype.'
##        #return Rules
##
##    def DemoteFromRuleException(self, errorException):
##        u'Demotes a topology error from an exception to an error.'
##        #return 
##
##    @property
##    def RulesByClass(self, ClassID):
##        u'An enumeration of all the rules for a given class.'
##        #return Rules
##

IGPDomain2._methods_ = [
    COMMETHOD(['hidden', helpstring(u'The ID of the domain.'), 'propget'], HRESULT, 'DomainID',
              ( ['retval', 'out'], POINTER(c_int), 'ID' )),
    COMMETHOD(['hidden', helpstring(u'The ID of the domain.'), 'propput'], HRESULT, 'DomainID',
              ( ['in'], c_int, 'ID' )),
    COMMETHOD(['propget', helpstring(u'The description of the domain.')], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'Description' )),
    COMMETHOD(['propput', helpstring(u'The description of the domain.')], HRESULT, 'Description',
              ( ['in'], BSTR, 'Description' )),
    COMMETHOD(['propget', helpstring(u'The field type of the field.')], HRESULT, 'FieldType',
              ( ['retval', 'out'], POINTER(esriFieldType), 'FieldType' )),
    COMMETHOD(['hidden', helpstring(u'The field type of the field.'), 'propput'], HRESULT, 'FieldType',
              ( ['in'], esriFieldType, 'FieldType' )),
    COMMETHOD(['propget', helpstring(u'The merge policy.')], HRESULT, 'MergePolicy',
              ( ['retval', 'out'], POINTER(esriMergePolicyType), 'policy' )),
    COMMETHOD(['propput', helpstring(u'The merge policy.')], HRESULT, 'MergePolicy',
              ( ['in'], esriMergePolicyType, 'policy' )),
    COMMETHOD(['propget', helpstring(u'The split policy.')], HRESULT, 'SplitPolicy',
              ( ['retval', 'out'], POINTER(esriSplitPolicyType), 'policy' )),
    COMMETHOD(['propput', helpstring(u'The split policy.')], HRESULT, 'SplitPolicy',
              ( ['in'], esriSplitPolicyType, 'policy' )),
    COMMETHOD(['propget', helpstring(u'The name of the domain.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the domain.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['hidden', helpstring(u'The owner of the domain.'), 'propget'], HRESULT, 'Owner',
              ( ['retval', 'out'], POINTER(BSTR), 'Owner' )),
    COMMETHOD(['hidden', helpstring(u'The owner of the domain.'), 'propput'], HRESULT, 'Owner',
              ( ['in'], BSTR, 'Owner' )),
    COMMETHOD(['propget', helpstring(u'The domain type.')], HRESULT, 'Type',
              ( ['retval', 'out'], POINTER(esriDomainType), 'Type' )),
]
################################################################
## code template for IGPDomain2 implementation
##class IGPDomain2_Impl(object):
##    def _get(self):
##        u'The ID of the domain.'
##        #return ID
##    def _set(self, ID):
##        u'The ID of the domain.'
##    DomainID = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the domain.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the domain.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The merge policy.'
##        #return policy
##    def _set(self, policy):
##        u'The merge policy.'
##    MergePolicy = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The field type of the field.'
##        #return FieldType
##    def _set(self, FieldType):
##        u'The field type of the field.'
##    FieldType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The owner of the domain.'
##        #return Owner
##    def _set(self, Owner):
##        u'The owner of the domain.'
##    Owner = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The description of the domain.'
##        #return Description
##    def _set(self, Description):
##        u'The description of the domain.'
##    Description = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def Type(self):
##        u'The domain type.'
##        #return Type
##
##    def _get(self):
##        u'The split policy.'
##        #return policy
##    def _set(self, policy):
##        u'The split policy.'
##    SplitPolicy = property(_get, _set, doc = _set.__doc__)
##

class IStreetNameFields(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a container for describing the street name fields used in generating driving directions.'
    _iid_ = GUID('{A69522DA-5C7E-439D-BB91-60CC70FF7FC0}')
    _idlflags_ = ['oleautomation']
class IStreetNameFields2(IStreetNameFields):
    _case_insensitive_ = True
    u'Provides access to a container for describing the street name fields used in generating driving directions.'
    _iid_ = GUID('{195DEE8D-4025-49AE-A76B-3A198D110FDB}')
    _idlflags_ = ['oleautomation']
IStreetNameFields._methods_ = [
    COMMETHOD(['propget', helpstring(u'The field name used for prefix direction.')], HRESULT, 'PrefixDirectionFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The field name used for prefix direction.')], HRESULT, 'PrefixDirectionFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The field name used for prefix type.')], HRESULT, 'PrefixTypeFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The field name used for prefix type.')], HRESULT, 'PrefixTypeFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The field name used for street name.')], HRESULT, 'StreetNameFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The field name used for street name.')], HRESULT, 'StreetNameFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The field name used for suffix type.')], HRESULT, 'SuffixTypeFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The field name used for suffix type.')], HRESULT, 'SuffixTypeFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The field name used for suffix direction.')], HRESULT, 'SuffixDirectionFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The field name used for suffix direction.')], HRESULT, 'SuffixDirectionFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The priority for when these street name fields are used.')], HRESULT, 'Priority',
              ( ['retval', 'out'], POINTER(c_int), 'Priority' )),
    COMMETHOD(['propput', helpstring(u'The priority for when these street name fields are used.')], HRESULT, 'Priority',
              ( ['in'], c_int, 'Priority' )),
]
################################################################
## code template for IStreetNameFields implementation
##class IStreetNameFields_Impl(object):
##    def _get(self):
##        u'The field name used for street name.'
##        #return Name
##    def _set(self, Name):
##        u'The field name used for street name.'
##    StreetNameFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The field name used for suffix type.'
##        #return Name
##    def _set(self, Name):
##        u'The field name used for suffix type.'
##    SuffixTypeFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The field name used for prefix direction.'
##        #return Name
##    def _set(self, Name):
##        u'The field name used for prefix direction.'
##    PrefixDirectionFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The priority for when these street name fields are used.'
##        #return Priority
##    def _set(self, Priority):
##        u'The priority for when these street name fields are used.'
##    Priority = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The field name used for suffix direction.'
##        #return Name
##    def _set(self, Name):
##        u'The field name used for suffix direction.'
##    SuffixDirectionFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The field name used for prefix type.'
##        #return Name
##    def _set(self, Name):
##        u'The field name used for prefix type.'
##    PrefixTypeFieldName = property(_get, _set, doc = _set.__doc__)
##

IStreetNameFields2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The field name used for highway direction.')], HRESULT, 'HighwayDirectionFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The field name used for highway direction.')], HRESULT, 'HighwayDirectionFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The field name used for the language of the street.')], HRESULT, 'LanguageFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The field name used for the language of the street.')], HRESULT, 'LanguageFieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The field name used to store the full street name.')], HRESULT, 'FullNameFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The field name used to store the full street name.')], HRESULT, 'FullNameFieldName',
              ( ['in'], BSTR, 'Name' )),
]
################################################################
## code template for IStreetNameFields2 implementation
##class IStreetNameFields2_Impl(object):
##    def _get(self):
##        u'The field name used for highway direction.'
##        #return Name
##    def _set(self, Name):
##        u'The field name used for highway direction.'
##    HighwayDirectionFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The field name used to store the full street name.'
##        #return Name
##    def _set(self, Name):
##        u'The field name used to store the full street name.'
##    FullNameFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The field name used for the language of the street.'
##        #return Name
##    def _set(self, Name):
##        u'The field name used for the language of the street.'
##    LanguageFieldName = property(_get, _set, doc = _set.__doc__)
##

class IIndexesEdit(IIndexes):
    _case_insensitive_ = True
    u'Provides access to members that modify the indexes collection.'
    _iid_ = GUID('{2063FD04-4CE0-11D1-89DB-006097AFF44E}')
    _idlflags_ = ['oleautomation']
class IEnumIndex(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate over a set of indexes.'
    _iid_ = GUID('{23BD2B49-BF8B-11D2-AADD-00C04FA37849}')
    _idlflags_ = ['oleautomation']
IIndexes._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of indexes in the indexes collection.')], HRESULT, 'IndexCount',
              ( ['retval', 'out'], POINTER(c_int), 'numIndexes' )),
    COMMETHOD(['propget', helpstring(u'The index at the specified position in the indexes collection.')], HRESULT, 'Index',
              ( ['in'], c_int, 'pos' ),
              ( ['retval', 'out'], POINTER(POINTER(IIndex)), 'Index' )),
    COMMETHOD([helpstring(u'Finds the position of the named index in the indexes collection.')], HRESULT, 'FindIndex',
              ( ['in'], BSTR, 'Name' ),
              ( ['out'], POINTER(c_int), 'pos' )),
    COMMETHOD([helpstring(u'The set of indexes for a given field name (if any).')], HRESULT, 'FindIndexesByFieldName',
              ( ['in'], BSTR, 'FieldName' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumIndex)), 'enumIndex' )),
]
################################################################
## code template for IIndexes implementation
##class IIndexes_Impl(object):
##    @property
##    def Index(self, pos):
##        u'The index at the specified position in the indexes collection.'
##        #return Index
##
##    def FindIndex(self, Name):
##        u'Finds the position of the named index in the indexes collection.'
##        #return pos
##
##    @property
##    def IndexCount(self):
##        u'The number of indexes in the indexes collection.'
##        #return numIndexes
##
##    def FindIndexesByFieldName(self, FieldName):
##        u'The set of indexes for a given field name (if any).'
##        #return enumIndex
##

IIndexesEdit._methods_ = [
    COMMETHOD(['hidden', helpstring(u'The number of indexes in this indexes collection.'), 'propput'], HRESULT, 'IndexCount',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['hidden', helpstring(u'The index at the specified position.'), 'propputref'], HRESULT, 'Index',
              ( ['in'], c_int, 'pos' ),
              ( ['in'], POINTER(IIndex), 'rhs' )),
    COMMETHOD(['hidden', helpstring(u'Add an index to the indexes collection.')], HRESULT, 'AddIndex',
              ( ['in'], POINTER(IIndex), 'Index' )),
    COMMETHOD(['hidden', helpstring(u'Delete an index from the indexes collection.')], HRESULT, 'DeleteIndex',
              ( ['in'], POINTER(IIndex), 'Index' )),
    COMMETHOD(['hidden', helpstring(u'Delete all the indexes from the indexes collection.')], HRESULT, 'DeleteAllIndexes'),
]
################################################################
## code template for IIndexesEdit implementation
##class IIndexesEdit_Impl(object):
##    def DeleteIndex(self, Index):
##        u'Delete an index from the indexes collection.'
##        #return 
##
##    def Index(self, pos, rhs):
##        u'The index at the specified position.'
##        #return 
##
##    def _set(self, rhs):
##        u'The number of indexes in this indexes collection.'
##    IndexCount = property(fset = _set, doc = _set.__doc__)
##
##    def AddIndex(self, Index):
##        u'Add an index to the indexes collection.'
##        #return 
##
##    def DeleteAllIndexes(self):
##        u'Delete all the indexes from the indexes collection.'
##        #return 
##

class IEnumTinElement(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to TIN element options.'
    _iid_ = GUID('{4EEE3271-FA94-11D2-AE10-000000000000}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriTinSelectionType'
esriTinSelectionNew = 0
esriTinSelectionAdd = 1
esriTinSelectionSubtract = 2
esriTinSelectionFlip = 3
esriTinSelectionType = c_int # enum
ITinSelection._methods_ = [
    COMMETHOD([helpstring(u'Indicates if element(s) is/are selected.')], HRESULT, 'HasSelection',
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbHasSelection' )),
    COMMETHOD([helpstring(u'Clears selected element(s).')], HRESULT, 'ClearSelection',
              ( ['in'], esriTinElementType, 'Type' )),
    COMMETHOD([helpstring(u'Selects elements returned by the enumerator.')], HRESULT, 'SetSelection',
              ( ['in'], POINTER(IEnumTinElement), 'pElements' ),
              ( ['in'], esriTinSelectionType, 'action' )),
    COMMETHOD([helpstring(u'Returns an enumerator containing selected elements.')], HRESULT, 'GetSelection',
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumTinElement)), 'ppElements' )),
    COMMETHOD([helpstring(u'Selects all elements of the specified element type in the TIN.')], HRESULT, 'SelectAll',
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['in'], VARIANT_BOOL, 'bDataElementsOnly' )),
    COMMETHOD([helpstring(u'Flips current selection of the specified element type in the TIN.')], HRESULT, 'FlipSelection',
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['in'], VARIANT_BOOL, 'bDataElementsOnly' )),
    COMMETHOD([helpstring(u'Selects all elements of the specified element type in a specified polygonal area.')], HRESULT, 'SelectByArea',
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon), 'pArea' ),
              ( ['in'], VARIANT_BOOL, 'bPassThrough' ),
              ( ['in'], VARIANT_BOOL, 'bDataElementsOnly' ),
              ( ['in'], esriTinSelectionType, 'action' )),
    COMMETHOD([helpstring(u'Selects all elements of the specified element type in a specified rectangular envelope.')], HRESULT, 'SelectByEnvelope',
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'pEnvelope' ),
              ( ['in'], VARIANT_BOOL, 'bPassThrough' ),
              ( ['in'], VARIANT_BOOL, 'bDataElementsOnly' ),
              ( ['in'], esriTinSelectionType, 'action' )),
    COMMETHOD([helpstring(u'Selects the element referenced by the index.')], HRESULT, 'SetSelected',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['in'], esriTinSelectionType, 'action' )),
    COMMETHOD([helpstring(u'Returns TRUE if the element referenced by the index is selected.')], HRESULT, 'IsSelected',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsSelected' )),
    COMMETHOD([helpstring(u'Returns the extent of the selected elements.')], HRESULT, 'QuerySelectionExtent',
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'pExtent' )),
    COMMETHOD(['propget', helpstring(u'The number of selected elements.')], HRESULT, 'SelectedElementCount',
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['retval', 'out'], POINTER(c_int), 'pCount' )),
]
################################################################
## code template for ITinSelection implementation
##class ITinSelection_Impl(object):
##    def SelectAll(self, Type, bDataElementsOnly):
##        u'Selects all elements of the specified element type in the TIN.'
##        #return 
##
##    def ClearSelection(self, Type):
##        u'Clears selected element(s).'
##        #return 
##
##    def QuerySelectionExtent(self, Type, pExtent):
##        u'Returns the extent of the selected elements.'
##        #return 
##
##    def SetSelection(self, pElements, action):
##        u'Selects elements returned by the enumerator.'
##        #return 
##
##    def IsSelected(self, Index, Type):
##        u'Returns TRUE if the element referenced by the index is selected.'
##        #return pbIsSelected
##
##    def FlipSelection(self, Type, bDataElementsOnly):
##        u'Flips current selection of the specified element type in the TIN.'
##        #return 
##
##    def GetSelection(self, Type):
##        u'Returns an enumerator containing selected elements.'
##        #return ppElements
##
##    def SetSelected(self, Index, Type, action):
##        u'Selects the element referenced by the index.'
##        #return 
##
##    def SelectByArea(self, Type, pArea, bPassThrough, bDataElementsOnly, action):
##        u'Selects all elements of the specified element type in a specified polygonal area.'
##        #return 
##
##    def SelectByEnvelope(self, Type, pEnvelope, bPassThrough, bDataElementsOnly, action):
##        u'Selects all elements of the specified element type in a specified rectangular envelope.'
##        #return 
##
##    @property
##    def SelectedElementCount(self, Type):
##        u'The number of selected elements.'
##        #return pCount
##
##    def HasSelection(self, Type):
##        u'Indicates if element(s) is/are selected.'
##        #return pbHasSelection
##

class IPersistCustomFeaturesExtension(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that allow extra feature information to be persisted.'
    _iid_ = GUID('{600811E1-2C1D-11D4-8303-0080C7E20671}')
    _idlflags_ = ['oleautomation']
IPersistCustomFeaturesExtension._methods_ = [
    COMMETHOD([helpstring(u'Writes out to the stream, class information used to aid loading.')], HRESULT, 'SaveClass',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStream), 'stream' )),
    COMMETHOD([helpstring(u'Looks at the class information and determines if it can load the features.')], HRESULT, 'LoadClass',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStream), 'stream' ),
              ( [], POINTER(VARIANT_BOOL), 'canLoad' )),
    COMMETHOD([helpstring(u'Writes out to the stream, feature infomation used to aid loading.')], HRESULT, 'SaveFeature',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStream), 'stream' ),
              ( ['in'], POINTER(IFeature), 'Feature' )),
    COMMETHOD([helpstring(u'Loads the feature information and updates the feature.')], HRESULT, 'LoadFeature',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStream), 'stream' ),
              ( ['in'], POINTER(IFeature), 'Feature' )),
]
################################################################
## code template for IPersistCustomFeaturesExtension implementation
##class IPersistCustomFeaturesExtension_Impl(object):
##    def SaveFeature(self, stream, Feature):
##        u'Writes out to the stream, feature infomation used to aid loading.'
##        #return 
##
##    def SaveClass(self, stream):
##        u'Writes out to the stream, class information used to aid loading.'
##        #return 
##
##    def LoadClass(self, stream, canLoad):
##        u'Looks at the class information and determines if it can load the features.'
##        #return 
##
##    def LoadFeature(self, stream, Feature):
##        u'Loads the feature information and updates the feature.'
##        #return 
##

INetworkEvaluator._methods_ = [
    COMMETHOD(['propget', helpstring(u'Unique name of this network evaluator.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'pName' )),
    COMMETHOD(['propget', helpstring(u'Name displayed in the user interface for this network evaluator.')], HRESULT, 'DisplayName',
              ( ['retval', 'out'], POINTER(BSTR), 'pDisplayName' )),
    COMMETHOD(['propget', helpstring(u"Indicates if this evaluator's values should be computed and stored when the network is built or computed at run time and never stored.")], HRESULT, 'CacheAttribute',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Cache' )),
]
################################################################
## code template for INetworkEvaluator implementation
##class INetworkEvaluator_Impl(object):
##    @property
##    def CacheAttribute(self):
##        u"Indicates if this evaluator's values should be computed and stored when the network is built or computed at run time and never stored."
##        #return Cache
##
##    @property
##    def DisplayName(self):
##        u'Name displayed in the user interface for this network evaluator.'
##        #return pDisplayName
##
##    @property
##    def Name(self):
##        u'Unique name of this network evaluator.'
##        #return pName
##

INetworkEvaluator2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Required fields of this network evaluator.')], HRESULT, 'RequiredFieldNames',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'fieldNames' )),
    COMMETHOD([helpstring(u'Refresh custom data for this network evaluator to synchronize with updated attribute parameter values or other external data.')], HRESULT, 'Refresh'),
]
################################################################
## code template for INetworkEvaluator2 implementation
##class INetworkEvaluator2_Impl(object):
##    @property
##    def RequiredFieldNames(self):
##        u'Required fields of this network evaluator.'
##        #return fieldNames
##
##    def Refresh(self):
##        u'Refresh custom data for this network evaluator to synchronize with updated attribute parameter values or other external data.'
##        #return 
##

IEvaluatedNetworkAttribute2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Evaluator used to derive values from the given network source for this network attribute.')], HRESULT, 'DENetworkDataset',
              ( ['retval', 'out'], POINTER(POINTER(IDENetworkDataset)), 'DataElement' )),
]
################################################################
## code template for IEvaluatedNetworkAttribute2 implementation
##class IEvaluatedNetworkAttribute2_Impl(object):
##    @property
##    def DENetworkDataset(self):
##        u'Evaluator used to derive values from the given network source for this network attribute.'
##        #return DataElement
##

INetworkEvaluatorSetup._methods_ = [
    COMMETHOD([helpstring(u'Initializes the network evaluator in preparation to evaluate the attribute value of a network element.')], HRESULT, 'Initialize',
              ( ['in'], POINTER(INetworkDataset), 'NetworkDataset' ),
              ( ['in'], POINTER(IDENetworkDataset), 'DataElement' ),
              ( ['in'], POINTER(INetworkSource), 'Source' ),
              ( ['in'], POINTER(IEvaluatedNetworkAttribute), 'Attribute' )),
    COMMETHOD(['propput', helpstring(u'The data used by this network evaluator for custom properties.')], HRESULT, 'Data',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'Data' )),
    COMMETHOD(['propget', helpstring(u'The data used by this network evaluator for custom properties.')], HRESULT, 'Data',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'Data' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the data for this evaluator has been edited.')], HRESULT, 'DataHasEdits',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasEdits' )),
    COMMETHOD(['propget', helpstring(u'Unique CLSID identifier for this network evaluator.')], HRESULT, 'CLSID',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'CLSID' )),
    COMMETHOD([helpstring(u'Indicates if this network evaluator can be used as the evaluator for the given network source and network attribute.')], HRESULT, 'SupportsSource',
              ( ['in'], POINTER(INetworkSource), 'Source' ),
              ( ['in'], POINTER(IEvaluatedNetworkAttribute), 'Attribute' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsSupported' )),
    COMMETHOD([helpstring(u'Indicates if this network evaluator can be used as the default evaluator for the given network element type and network attribute.')], HRESULT, 'SupportsDefault',
              ( ['in'], esriNetworkElementType, 'ElementType' ),
              ( ['in'], POINTER(IEvaluatedNetworkAttribute), 'Attribute' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsSupported' )),
    COMMETHOD([helpstring(u'Indicates if the network evaluator is in a valid state for use as the evaluator for the given network source and network attribute.')], HRESULT, 'ValidateSource',
              ( ['in'], POINTER(IDatasetContainer2), 'datasetContainer' ),
              ( ['in'], POINTER(INetworkSource), 'NetworkSource' ),
              ( ['in'], POINTER(IEvaluatedNetworkAttribute), 'Attribute' ),
              ( ['in', 'out'], POINTER(c_int), 'ErrorCode' ),
              ( ['in', 'out'], POINTER(BSTR), 'ErrorDescription' ),
              ( ['in', 'out'], POINTER(BSTR), 'errorAppendInfo' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isValid' )),
    COMMETHOD([helpstring(u'Indicates if the network evaluator is in a valid state for use as the default evaluator for the given element type and network attribute.')], HRESULT, 'ValidateDefault',
              ( ['in'], esriNetworkElementType, 'ElementType' ),
              ( ['in'], POINTER(IEvaluatedNetworkAttribute), 'Attribute' ),
              ( ['in', 'out'], POINTER(c_int), 'ErrorCode' ),
              ( ['in', 'out'], POINTER(BSTR), 'ErrorDescription' ),
              ( ['in', 'out'], POINTER(BSTR), 'errorAppendInfo' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isValid' )),
    COMMETHOD([helpstring(u'Evaluates the attribute value of a network element.')], HRESULT, 'QueryValue',
              ( ['in'], POINTER(INetworkElement), 'Element' ),
              ( ['in'], POINTER(IRow), 'Row' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'resultValue' )),
]
################################################################
## code template for INetworkEvaluatorSetup implementation
##class INetworkEvaluatorSetup_Impl(object):
##    def SupportsDefault(self, ElementType, Attribute):
##        u'Indicates if this network evaluator can be used as the default evaluator for the given network element type and network attribute.'
##        #return IsSupported
##
##    def ValidateDefault(self, ElementType, Attribute):
##        u'Indicates if the network evaluator is in a valid state for use as the default evaluator for the given element type and network attribute.'
##        #return ErrorCode, ErrorDescription, errorAppendInfo, isValid
##
##    def ValidateSource(self, datasetContainer, NetworkSource, Attribute):
##        u'Indicates if the network evaluator is in a valid state for use as the evaluator for the given network source and network attribute.'
##        #return ErrorCode, ErrorDescription, errorAppendInfo, isValid
##
##    @property
##    def DataHasEdits(self):
##        u'Indicates if the data for this evaluator has been edited.'
##        #return HasEdits
##
##    def SupportsSource(self, Source, Attribute):
##        u'Indicates if this network evaluator can be used as the evaluator for the given network source and network attribute.'
##        #return IsSupported
##
##    def QueryValue(self, Element, Row):
##        u'Evaluates the attribute value of a network element.'
##        #return resultValue
##
##    @property
##    def CLSID(self):
##        u'Unique CLSID identifier for this network evaluator.'
##        #return CLSID
##
##    def Initialize(self, NetworkDataset, DataElement, Source, Attribute):
##        u'Initializes the network evaluator in preparation to evaluate the attribute value of a network element.'
##        #return 
##
##    def _get(self):
##        u'The data used by this network evaluator for custom properties.'
##        #return Data
##    def _set(self, Data):
##        u'The data used by this network evaluator for custom properties.'
##    Data = property(_get, _set, doc = _set.__doc__)
##


# values for enumeration 'esriTinNodeEditInfo'
esriTinNodeUnknown = 1
esriTinNodeSuperNode = 2
esriTinNodeOriginal = 4
esriTinNodeDensified = 8
esriTinNodeLineEnforce = 16
esriTinNodeIntersection = 32
esriTinNodeLineTouch = 64
esriTinNodeCoincident = 128
esriTinNodeSnap = 256
esriTinNodeModified = 512
esriTinNodeEditInfo = c_int # enum
IEnumHistoricalMarker._methods_ = [
    COMMETHOD([helpstring(u'Retrieve the next historical marker in this enumerator.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IHistoricalMarker)), 'marker' )),
    COMMETHOD([helpstring(u'Reset the enumerator to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumHistoricalMarker implementation
##class IEnumHistoricalMarker_Impl(object):
##    def Reset(self):
##        u'Reset the enumerator to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieve the next historical marker in this enumerator.'
##        #return marker
##

class IEnumEventError(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to an enumeration of event source errors.'
    _iid_ = GUID('{A9EB56E2-7452-11D4-9FE4-00C04F6BDF06}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriLocatingError'
LOCATING_OK = 0
LOCATING_E_INVALIDRID = 1
LOCATING_E_INVALIDMEASURE = 2
LOCATING_E_CANT_FIND_ROUTE = 3
LOCATING_E_ROUTE_SHAPE_EMPTY = 4
LOCATING_E_CANT_FIND_LOCATION = 5
LOCATING_E_CANT_FIND_EXTENT = 6
LOCATING_E_FROM_PARTIAL_MATCH = 7
LOCATING_E_TO_PARTIAL_MATCH = 8
LOCATING_E_ROUTE_MS_NULL = 9
LOCATING_E_ROUTE_NOT_MAWARE = 10
LOCATING_E_FROM_TO_PARTIAL_MATCH = 11
LOCATING_E_MULTIPLE_LOCATION = 12
LOCATING_E_NULL_EXTENT = 13
esriLocatingError = c_int # enum
IEnumEventError._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next event error in the enumeration sequence.')], HRESULT, 'Next',
              ( ['out'], POINTER(POINTER(IRow)), 'eventRow' ),
              ( ['out'], POINTER(esriLocatingError), 'locatingError' )),
]
################################################################
## code template for IEnumEventError implementation
##class IEnumEventError_Impl(object):
##    def Next(self):
##        u'Retrieves the next event error in the enumeration sequence.'
##        #return eventRow, locatingError
##

class ILocatorUI2(ILocatorUI):
    _case_insensitive_ = True
    u"Provides access to members that control the locator's user interface."
    _iid_ = GUID('{46E6AB9D-C09E-4482-9CC5-871274C83785}')
    _idlflags_ = ['oleautomation']
ILocatorUI2._methods_ = [
    COMMETHOD([helpstring(u'Opens the user interface to repair a locator.')], HRESULT, 'RepairLocator',
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'parentWindow' ),
              ( ['in'], POINTER(ILocator), 'locator' ),
              ( ['in'], BSTR, 'Title' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Ok' )),
]
################################################################
## code template for ILocatorUI2 implementation
##class ILocatorUI2_Impl(object):
##    def RepairLocator(self, parentWindow, locator, Title):
##        u'Opens the user interface to repair a locator.'
##        #return Ok
##

IRelationshipRule._methods_ = [
    COMMETHOD(['propget', helpstring(u'The ID of the destination ObjectClass.')], HRESULT, 'DestinationClassID',
              ( ['retval', 'out'], POINTER(c_int), 'ClassID' )),
    COMMETHOD(['propput', helpstring(u'The ID of the destination ObjectClass.')], HRESULT, 'DestinationClassID',
              ( ['in'], c_int, 'ClassID' )),
    COMMETHOD(['propget', helpstring(u'The subtype value of the destination ObjectClass.')], HRESULT, 'DestinationSubtypeCode',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The subtype value of the destination ObjectClass.')], HRESULT, 'DestinationSubtypeCode',
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The minimum cardinality value of the destination ObjectClass.')], HRESULT, 'DestinationMinimumCardinality',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The minimum cardinality value of the destination ObjectClass.')], HRESULT, 'DestinationMinimumCardinality',
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The maximum cardinality value of the destination ObjectClass.')], HRESULT, 'DestinationMaximumCardinality',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The maximum cardinality value of the destination ObjectClass.')], HRESULT, 'DestinationMaximumCardinality',
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The ID of the origin ObjectClass.')], HRESULT, 'OriginClassID',
              ( ['retval', 'out'], POINTER(c_int), 'ClassID' )),
    COMMETHOD(['propput', helpstring(u'The ID of the origin ObjectClass.')], HRESULT, 'OriginClassID',
              ( ['in'], c_int, 'ClassID' )),
    COMMETHOD(['propget', helpstring(u'The subtype value of the origin ObjectClass.')], HRESULT, 'OriginSubtypeCode',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The subtype value of the origin ObjectClass.')], HRESULT, 'OriginSubtypeCode',
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The minimum cardinality value of the origin ObjectClass.')], HRESULT, 'OriginMinimumCardinality',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The minimum cardinality value of the origin ObjectClass.')], HRESULT, 'OriginMinimumCardinality',
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The maximum cardinality value of the origin ObjectClass.')], HRESULT, 'OriginMaximumCardinality',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The maximum cardinality value of the origin ObjectClass.')], HRESULT, 'OriginMaximumCardinality',
              ( ['in'], c_int, 'Value' )),
]
################################################################
## code template for IRelationshipRule implementation
##class IRelationshipRule_Impl(object):
##    def _get(self):
##        u'The maximum cardinality value of the destination ObjectClass.'
##        #return Value
##    def _set(self, Value):
##        u'The maximum cardinality value of the destination ObjectClass.'
##    DestinationMaximumCardinality = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The minimum cardinality value of the origin ObjectClass.'
##        #return Value
##    def _set(self, Value):
##        u'The minimum cardinality value of the origin ObjectClass.'
##    OriginMinimumCardinality = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The minimum cardinality value of the destination ObjectClass.'
##        #return Value
##    def _set(self, Value):
##        u'The minimum cardinality value of the destination ObjectClass.'
##    DestinationMinimumCardinality = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The subtype value of the destination ObjectClass.'
##        #return Value
##    def _set(self, Value):
##        u'The subtype value of the destination ObjectClass.'
##    DestinationSubtypeCode = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The ID of the destination ObjectClass.'
##        #return ClassID
##    def _set(self, ClassID):
##        u'The ID of the destination ObjectClass.'
##    DestinationClassID = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The ID of the origin ObjectClass.'
##        #return ClassID
##    def _set(self, ClassID):
##        u'The ID of the origin ObjectClass.'
##    OriginClassID = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The maximum cardinality value of the origin ObjectClass.'
##        #return Value
##    def _set(self, Value):
##        u'The maximum cardinality value of the origin ObjectClass.'
##    OriginMaximumCardinality = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The subtype value of the origin ObjectClass.'
##        #return Value
##    def _set(self, Value):
##        u'The subtype value of the origin ObjectClass.'
##    OriginSubtypeCode = property(_get, _set, doc = _set.__doc__)
##

class IFeatureClassExtension(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Indicator interface for feature class extensions.'
    _iid_ = GUID('{0432CCA2-4E79-11D2-88E5-0000F877762D}')
    _idlflags_ = ['oleautomation']
IFeatureClassExtension._methods_ = [
]
################################################################
## code template for IFeatureClassExtension implementation
##class IFeatureClassExtension_Impl(object):

class IFeatureClassUtil(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return features in the specified spatial reference.'
    _iid_ = GUID('{D3CB0FC2-8C02-11D3-9F91-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
IFeatureClassUtil._methods_ = [
    COMMETHOD([helpstring(u'Gets the feature from the database with the specified object ID, in the specified  spatial reference.')], HRESULT, 'GetFeature',
              ( ['in'], c_int, 'OID' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeature)), 'Feature' )),
    COMMETHOD([helpstring(u'Get a cursor of features given a set of object ids, in the specified  spatial reference.')], HRESULT, 'GetFeatures',
              ( ['in'], VARIANT, 'oids' ),
              ( ['in'], VARIANT_BOOL, 'Recycling' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureCursor)), 'Cursor' )),
]
################################################################
## code template for IFeatureClassUtil implementation
##class IFeatureClassUtil_Impl(object):
##    def GetFeatures(self, oids, Recycling, SpatialReference):
##        u'Get a cursor of features given a set of object ids, in the specified  spatial reference.'
##        #return Cursor
##
##    def GetFeature(self, OID, SpatialReference):
##        u'Gets the feature from the database with the specified object ID, in the specified  spatial reference.'
##        #return Feature
##

class EnumFieldError(CoClass):
    u'Esri EnumFieldError object.'
    _reg_clsid_ = GUID('{23A73297-AB83-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
EnumFieldError._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumFieldError]

ILocatorStyle._methods_ = [
]
################################################################
## code template for ILocatorStyle implementation
##class ILocatorStyle_Impl(object):

class ILocatorWorkspaceName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe a locator workspace.'
    _iid_ = GUID('{FC747401-39C0-4842-8635-6DB6F96717E5}')
    _idlflags_ = ['oleautomation']

# values for enumeration 'esriLocatorQuery'
esriLocatorStyle = 0
esriLocator = 1
esriAllTypes = 2
esriLocatorQuery = c_int # enum
class IEnumLocatorName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members to retrieving a set of Name objects for locators.'
    _iid_ = GUID('{8DDAEEE6-8B07-11D3-9F69-00C04F6BDF06}')
    _idlflags_ = ['oleautomation']
class IEnumLocator(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for retrieving a set of locators.'
    _iid_ = GUID('{E0F10B78-EB7C-11D2-9F47-00C04F8ED1C4}')
    _idlflags_ = ['oleautomation']
class ILocatorName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe a locator.'
    _iid_ = GUID('{837A9CF2-88C9-11D3-9F66-00C04F6BDF06}')
    _idlflags_ = ['oleautomation']
ILocatorWorkspace._methods_ = [
    COMMETHOD(['propget', helpstring(u'The Name object for the locator workspace.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(POINTER(ILocatorWorkspaceName)), 'LocatorWorkspaceName' )),
    COMMETHOD(['propget', helpstring(u'LocatorName objects in the locator workspace.')], HRESULT, 'LocatorNames',
              ( ['in'], esriLocatorQuery, 'queryType' ),
              ( ['in'], BSTR, 'Category' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumLocatorName)), 'enumLocatorNames' )),
    COMMETHOD(['propget', helpstring(u'Locators in the locator workspace.')], HRESULT, 'Locators',
              ( ['in'], esriLocatorQuery, 'queryType' ),
              ( ['in'], BSTR, 'Category' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumLocator)), 'enumLocators' )),
    COMMETHOD([helpstring(u'Gets a LocatorName object.')], HRESULT, 'GetLocatorName',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(ILocatorName)), 'outLocatorName' )),
    COMMETHOD([helpstring(u'Gets a locator.')], HRESULT, 'GetLocator',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(ILocator)), 'locator' )),
    COMMETHOD([helpstring(u'Gets a locator style.')], HRESULT, 'GetLocatorStyle',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(ILocatorStyle)), 'aLocatorStyle' )),
    COMMETHOD([helpstring(u'Adds a locator to the locator workspace.')], HRESULT, 'AddLocator',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(ILocator), 'locator' ),
              ( ['in'], BSTR, 'ConfigKeyword' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITrackCancel), 'CancelTracker' ),
              ( ['retval', 'out'], POINTER(POINTER(ILocator)), 'newLocator' )),
    COMMETHOD([helpstring(u'Adds a locator style.')], HRESULT, 'AddLocatorStyle',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], BSTR, 'Category' ),
              ( ['in'], POINTER(ILocatorStyle), 'locatorStyle' )),
    COMMETHOD([helpstring(u'Modifies the properties of a locator.')], HRESULT, 'UpdateLocator',
              ( ['in'], POINTER(ILocator), 'locator' )),
    COMMETHOD([helpstring(u'Deletes a locator.')], HRESULT, 'DeleteLocator',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD([helpstring(u'Renames a locator.')], HRESULT, 'RenameLocator',
              ( ['in'], BSTR, 'oldName' ),
              ( ['in'], BSTR, 'newName' )),
    COMMETHOD([helpstring(u'Copies a locator.')], HRESULT, 'CopyLocator',
              ( ['in'], BSTR, 'srcName' ),
              ( ['in'], BSTR, 'dstName' )),
]
################################################################
## code template for ILocatorWorkspace implementation
##class ILocatorWorkspace_Impl(object):
##    def AddLocatorStyle(self, Name, Category, locatorStyle):
##        u'Adds a locator style.'
##        #return 
##
##    @property
##    def Name(self):
##        u'The Name object for the locator workspace.'
##        #return LocatorWorkspaceName
##
##    def GetLocatorStyle(self, Name):
##        u'Gets a locator style.'
##        #return aLocatorStyle
##
##    def GetLocator(self, Name):
##        u'Gets a locator.'
##        #return locator
##
##    def AddLocator(self, Name, locator, ConfigKeyword, CancelTracker):
##        u'Adds a locator to the locator workspace.'
##        #return newLocator
##
##    def CopyLocator(self, srcName, dstName):
##        u'Copies a locator.'
##        #return 
##
##    def DeleteLocator(self, Name):
##        u'Deletes a locator.'
##        #return 
##
##    def UpdateLocator(self, locator):
##        u'Modifies the properties of a locator.'
##        #return 
##
##    def RenameLocator(self, oldName, newName):
##        u'Renames a locator.'
##        #return 
##
##    @property
##    def LocatorNames(self, queryType, Category):
##        u'LocatorName objects in the locator workspace.'
##        #return enumLocatorNames
##
##    def GetLocatorName(self, Name):
##        u'Gets a LocatorName object.'
##        #return outLocatorName
##
##    @property
##    def Locators(self, queryType, Category):
##        u'Locators in the locator workspace.'
##        #return enumLocators
##

class FieldChecker(CoClass):
    u'Checks for errors in Field Name.'
    _reg_clsid_ = GUID('{84CF806B-3E95-11D2-AAE0-00C04FA33C20}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
FieldChecker._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IFieldChecker]

IGeometricNetworkConnectivity._methods_ = [
    COMMETHOD([helpstring(u'Incrementally rebuilds connectivity for features within and intersecting the specified envelope.')], HRESULT, 'RebuildConnectivity',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'incrementalRebuildArea' )),
]
################################################################
## code template for IGeometricNetworkConnectivity implementation
##class IGeometricNetworkConnectivity_Impl(object):
##    def RebuildConnectivity(self, incrementalRebuildArea):
##        u'Incrementally rebuilds connectivity for features within and intersecting the specified envelope.'
##        #return 
##

IJunctionFeatureSource._methods_ = [
    COMMETHOD(['propget', helpstring(u'Connectivity groups in which this junction feature source participates.')], HRESULT, 'ClassConnectivityGroups',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray)), 'groups' )),
    COMMETHOD([helpstring(u'Adds a connectivity group in which this junction feature source participates.')], HRESULT, 'AddClassConnectivityGroup',
              ( ['in'], c_int, 'group' )),
    COMMETHOD([helpstring(u'Removes all connectivity groups in which this junction feature source participates.')], HRESULT, 'RemoveAllClassConnectivityGroups'),
    COMMETHOD(['propget', helpstring(u'Connectivity groups in which the specified subtype of this junction feature source participates.')], HRESULT, 'SubtypeConnectivityGroups',
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray)), 'groups' )),
    COMMETHOD([helpstring(u'Adds a connectivity group in which the specified subtype of this junction feature source participates.')], HRESULT, 'AddSubtypeConnectivityGroup',
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['in'], c_int, 'group' )),
    COMMETHOD([helpstring(u'Removes all connectivity groups in which the specified subtype of this junction feature source participates.')], HRESULT, 'RemoveAllSubtypeConnectivityGroups',
              ( ['in'], c_int, 'SubtypeCode' )),
    COMMETHOD(['propget', helpstring(u'Policy determining how all junction elements in this source connect to other edge elements.')], HRESULT, 'ClassConnectivityPolicy',
              ( ['retval', 'out'], POINTER(esriNetworkJunctionConnectivityPolicy), 'policy' )),
    COMMETHOD(['propput', helpstring(u'Policy determining how all junction elements in this source connect to other edge elements.')], HRESULT, 'ClassConnectivityPolicy',
              ( ['in'], esriNetworkJunctionConnectivityPolicy, 'policy' )),
    COMMETHOD(['propget', helpstring(u'Policy determining how the junction elements in the specified subtype of this source connect to other edge elements.')], HRESULT, 'SubtypeConnectivityPolicy',
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['retval', 'out'], POINTER(esriNetworkJunctionConnectivityPolicy), 'policy' )),
    COMMETHOD(['propput', helpstring(u'Policy determining how the junction elements in the specified subtype of this source connect to other edge elements.')], HRESULT, 'SubtypeConnectivityPolicy',
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['in'], esriNetworkJunctionConnectivityPolicy, 'policy' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this junction feature source determines connectivity groups and policies by subtypes.')], HRESULT, 'UsesSubtypes',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'bySubtype' )),
    COMMETHOD(['propput', helpstring(u'Indicates if this junction feature source determines connectivity groups and policies by subtypes.')], HRESULT, 'UsesSubtypes',
              ( ['in'], VARIANT_BOOL, 'bySubtype' )),
    COMMETHOD(['propget', helpstring(u'The field name on the feature source to be used as the elevation field when determining connectivity at coincident vertices.')], HRESULT, 'ElevationFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The field name on the feature source to be used as the elevation field when determining connectivity at coincident vertices.')], HRESULT, 'ElevationFieldName',
              ( ['in'], BSTR, 'Name' )),
]
################################################################
## code template for IJunctionFeatureSource implementation
##class IJunctionFeatureSource_Impl(object):
##    def AddSubtypeConnectivityGroup(self, SubtypeCode, group):
##        u'Adds a connectivity group in which the specified subtype of this junction feature source participates.'
##        #return 
##
##    def _get(self, SubtypeCode):
##        u'Policy determining how the junction elements in the specified subtype of this source connect to other edge elements.'
##        #return policy
##    def _set(self, SubtypeCode, policy):
##        u'Policy determining how the junction elements in the specified subtype of this source connect to other edge elements.'
##    SubtypeConnectivityPolicy = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if this junction feature source determines connectivity groups and policies by subtypes.'
##        #return bySubtype
##    def _set(self, bySubtype):
##        u'Indicates if this junction feature source determines connectivity groups and policies by subtypes.'
##    UsesSubtypes = property(_get, _set, doc = _set.__doc__)
##
##    def RemoveAllClassConnectivityGroups(self):
##        u'Removes all connectivity groups in which this junction feature source participates.'
##        #return 
##
##    @property
##    def ClassConnectivityGroups(self):
##        u'Connectivity groups in which this junction feature source participates.'
##        #return groups
##
##    def _get(self):
##        u'The field name on the feature source to be used as the elevation field when determining connectivity at coincident vertices.'
##        #return Name
##    def _set(self, Name):
##        u'The field name on the feature source to be used as the elevation field when determining connectivity at coincident vertices.'
##    ElevationFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def AddClassConnectivityGroup(self, group):
##        u'Adds a connectivity group in which this junction feature source participates.'
##        #return 
##
##    @property
##    def SubtypeConnectivityGroups(self, SubtypeCode):
##        u'Connectivity groups in which the specified subtype of this junction feature source participates.'
##        #return groups
##
##    def _get(self):
##        u'Policy determining how all junction elements in this source connect to other edge elements.'
##        #return policy
##    def _set(self, policy):
##        u'Policy determining how all junction elements in this source connect to other edge elements.'
##    ClassConnectivityPolicy = property(_get, _set, doc = _set.__doc__)
##
##    def RemoveAllSubtypeConnectivityGroups(self, SubtypeCode):
##        u'Removes all connectivity groups in which the specified subtype of this junction feature source participates.'
##        #return 
##

class IFieldEdit(IField):
    _case_insensitive_ = True
    u'Provides access to members that edit the field properties.'
    _iid_ = GUID('{300AA631-B207-11D0-BECA-00805F7C4268}')
    _idlflags_ = ['oleautomation']
IFieldEdit._methods_ = [
    COMMETHOD(['propput', helpstring(u'The name of the field.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The alias name of the field.')], HRESULT, 'AliasName',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The default domain of the field.')], HRESULT, 'Domain',
              ( ['in'], POINTER(IDomain), 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The default value of the field.')], HRESULT, 'DefaultValue',
              ( ['in'], VARIANT, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The type for the field.')], HRESULT, 'Type',
              ( ['in'], esriFieldType, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The maximum length, in bytes, for field values.')], HRESULT, 'Length',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The precision for field values.')], HRESULT, 'Precision',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The scale for field values.')], HRESULT, 'Scale',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Indicates if field values can be null.')], HRESULT, 'IsNullable',
              ( ['in'], VARIANT_BOOL, 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The geometry definition if IsGeometry is TRUE.')], HRESULT, 'GeometryDef',
              ( ['in'], POINTER(IGeometryDef), 'rhs' )),
    COMMETHOD(['propput', helpstring(u"Indicates if the field's domain cannot be modified.")], HRESULT, 'DomainFixed',
              ( ['in'], VARIANT_BOOL, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the field is required.')], HRESULT, 'Required',
              ( ['in'], VARIANT_BOOL, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the field can be edited. This should always be set to true.')], HRESULT, 'Editable',
              ( ['in'], VARIANT_BOOL, 'rhs' )),
]
################################################################
## code template for IFieldEdit implementation
##class IFieldEdit_Impl(object):
##    def Domain(self, rhs):
##        u'The default domain of the field.'
##        #return 
##
##    def _set(self, rhs):
##        u'The scale for field values.'
##    Scale = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The name of the field.'
##    Name = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The default value of the field.'
##    DefaultValue = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Indicates if the field is required.'
##    Required = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Indicates if the field can be edited. This should always be set to true.'
##    Editable = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The precision for field values.'
##    Precision = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The maximum length, in bytes, for field values.'
##    Length = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The alias name of the field.'
##    AliasName = property(fset = _set, doc = _set.__doc__)
##
##    def GeometryDef(self, rhs):
##        u'The geometry definition if IsGeometry is TRUE.'
##        #return 
##
##    def _set(self, rhs):
##        u"Indicates if the field's domain cannot be modified."
##    DomainFixed = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The type for the field.'
##    Type = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Indicates if field values can be null.'
##    IsNullable = property(fset = _set, doc = _set.__doc__)
##

class IGeometryDefEdit(IGeometryDef):
    _case_insensitive_ = True
    u'Provides access to members that modify the geometry definition.'
    _iid_ = GUID('{439A0D51-3915-11D1-9CA7-0000F8780619}')
    _idlflags_ = ['oleautomation']
IGeometryDef._methods_ = [
    COMMETHOD(['propget', helpstring(u'The estimated average number of points per feature.')], HRESULT, 'AvgNumPoints',
              ( ['retval', 'out'], POINTER(c_int), 'points' )),
    COMMETHOD(['propget', helpstring(u'The enumerated geometry type.')], HRESULT, 'GeometryType',
              ( ['retval', 'out'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType), 'GeometryType' )),
    COMMETHOD(['propget', helpstring(u'The size of a spatial index grid.')], HRESULT, 'GridSize',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(c_double), 'Size' )),
    COMMETHOD(['propget', helpstring(u'The number of spatial index grids.')], HRESULT, 'GridCount',
              ( ['retval', 'out'], POINTER(c_int), 'grids' )),
    COMMETHOD(['propget', helpstring(u'The spatial reference for the dataset.')], HRESULT, 'SpatialReference',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference)), 'SpatialReference' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the featureClass has Z values.')], HRESULT, 'HasZ',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasZ' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the feature class has measure (M) values.')], HRESULT, 'HasM',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasM' )),
]
################################################################
## code template for IGeometryDef implementation
##class IGeometryDef_Impl(object):
##    @property
##    def HasM(self):
##        u'Indicates if the feature class has measure (M) values.'
##        #return HasM
##
##    @property
##    def GridSize(self, Index):
##        u'The size of a spatial index grid.'
##        #return Size
##
##    @property
##    def SpatialReference(self):
##        u'The spatial reference for the dataset.'
##        #return SpatialReference
##
##    @property
##    def AvgNumPoints(self):
##        u'The estimated average number of points per feature.'
##        #return points
##
##    @property
##    def GeometryType(self):
##        u'The enumerated geometry type.'
##        #return GeometryType
##
##    @property
##    def HasZ(self):
##        u'Indicates if the featureClass has Z values.'
##        #return HasZ
##
##    @property
##    def GridCount(self):
##        u'The number of spatial index grids.'
##        #return grids
##

IGeometryDefEdit._methods_ = [
    COMMETHOD(['propput', helpstring(u'The estimated average number of points per feature.')], HRESULT, 'AvgNumPoints',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The geometry type.')], HRESULT, 'GeometryType',
              ( ['in'], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The size of a spatial index grid.')], HRESULT, 'GridSize',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], c_double, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The number of spatial index grids.')], HRESULT, 'GridCount',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The spatial reference of the dataset.')], HRESULT, 'SpatialReference',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the feature class will support Z values.')], HRESULT, 'HasZ',
              ( ['in'], VARIANT_BOOL, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the feature class will support M values.')], HRESULT, 'HasM',
              ( ['in'], VARIANT_BOOL, 'rhs' )),
]
################################################################
## code template for IGeometryDefEdit implementation
##class IGeometryDefEdit_Impl(object):
##    def _set(self, rhs):
##        u'Indicates if the feature class will support M values.'
##    HasM = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, Index, rhs):
##        u'The size of a spatial index grid.'
##    GridSize = property(fset = _set, doc = _set.__doc__)
##
##    def SpatialReference(self, rhs):
##        u'The spatial reference of the dataset.'
##        #return 
##
##    def _set(self, rhs):
##        u'The estimated average number of points per feature.'
##    AvgNumPoints = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The geometry type.'
##    GeometryType = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Indicates if the feature class will support Z values.'
##    HasZ = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The number of spatial index grids.'
##    GridCount = property(fset = _set, doc = _set.__doc__)
##

INetworkClass._methods_ = [
    COMMETHOD(['propget', helpstring(u'The geometric network in which this class participates.')], HRESULT, 'GeometricNetwork',
              ( ['retval', 'out'], POINTER(POINTER(IGeometricNetwork)), 'Network' )),
    COMMETHOD(['propget', helpstring(u'The specified field to Weight mapping for the logical network.')], HRESULT, 'FieldToWeightMapping',
              ( ['in'], c_int, 'FieldIndex' ),
              ( ['retval', 'out'], POINTER(c_int), 'WeightID' )),
    COMMETHOD(['propget', helpstring(u'The possible network ancillary roles of the contained Features.')], HRESULT, 'NetworkAncillaryRole',
              ( ['retval', 'out'], POINTER(esriNetworkClassAncillaryRole), 'Role' )),
]
################################################################
## code template for INetworkClass implementation
##class INetworkClass_Impl(object):
##    @property
##    def NetworkAncillaryRole(self):
##        u'The possible network ancillary roles of the contained Features.'
##        #return Role
##
##    @property
##    def GeometricNetwork(self):
##        u'The geometric network in which this class participates.'
##        #return Network
##
##    @property
##    def FieldToWeightMapping(self, FieldIndex):
##        u'The specified field to Weight mapping for the logical network.'
##        #return WeightID
##

class IPlugInFileSystemDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members describing a file-system dataset.'
    _iid_ = GUID('{A553189F-79F4-4647-9D5C-898D69DC59AE}')
    _idlflags_ = ['oleautomation']
IPlugInFileSystemDataset._methods_ = [
    COMMETHOD(['propget', helpstring(u'The full path to the dataset.')], HRESULT, 'FullPath',
              ( ['retval', 'out'], POINTER(BSTR), 'Path' )),
    COMMETHOD(['propget', helpstring(u'The size of the dataset (in bytes).')], HRESULT, 'Size',
              ( ['retval', 'out'], POINTER(c_int), 'Size' )),
]
################################################################
## code template for IPlugInFileSystemDataset implementation
##class IPlugInFileSystemDataset_Impl(object):
##    @property
##    def FullPath(self):
##        u'The full path to the dataset.'
##        #return Path
##
##    @property
##    def Size(self):
##        u'The size of the dataset (in bytes).'
##        #return Size
##

IFeatureProject._methods_ = [
    COMMETHOD([helpstring(u'Project the feature geometry to the provided spatial reference.')], HRESULT, 'Project',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'outputSR' )),
]
################################################################
## code template for IFeatureProject implementation
##class IFeatureProject_Impl(object):
##    def Project(self, outputSR):
##        u'Project the feature geometry to the provided spatial reference.'
##        #return 
##

ILocatorWorkspaceName._methods_ = [
    COMMETHOD(['propget', helpstring(u'The path to the folder that contains the locator workspace.')], HRESULT, 'Path',
              ( ['retval', 'out'], POINTER(BSTR), 'Path' )),
    COMMETHOD(['propput', helpstring(u'The path to the folder that contains the locator workspace.')], HRESULT, 'Path',
              ( ['in'], BSTR, 'Path' )),
    COMMETHOD(['propget', helpstring(u'The Name object for the ArcSDE workspace that contains the locator workspace.')], HRESULT, 'WorkspaceName',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspaceName)), 'wksName' )),
    COMMETHOD(['propputref', helpstring(u'The Name object for the ArcSDE workspace that contains the locator workspace.')], HRESULT, 'WorkspaceName',
              ( ['in'], POINTER(IWorkspaceName), 'wksName' )),
    COMMETHOD(['propget', helpstring(u'The type of locator workspace.')], HRESULT, 'Type',
              ( ['retval', 'out'], POINTER(esriLocatorWorkspaceType), 'locWksType' )),
]
################################################################
## code template for ILocatorWorkspaceName implementation
##class ILocatorWorkspaceName_Impl(object):
##    def _get(self):
##        u'The path to the folder that contains the locator workspace.'
##        #return Path
##    def _set(self, Path):
##        u'The path to the folder that contains the locator workspace.'
##    Path = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def Type(self):
##        u'The type of locator workspace.'
##        #return locWksType
##
##    def WorkspaceName(self, wksName):
##        u'The Name object for the ArcSDE workspace that contains the locator workspace.'
##        #return 
##

class INetworkFunctionEvaluator(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of a function evaluator.'
    _iid_ = GUID('{6699C29B-86CC-4C25-B3DD-98959760477B}')
    _idlflags_ = ['oleautomation']
INetworkFunctionEvaluator._methods_ = [
    COMMETHOD(['propput', helpstring(u'The attribute name or constant value representing the first argument of the function.')], HRESULT, 'FirstArgument',
              ( ['in'], VARIANT, 'arg1' )),
    COMMETHOD(['propget', helpstring(u'The attribute name or constant value representing the first argument of the function.')], HRESULT, 'FirstArgument',
              ( ['retval', 'out'], POINTER(VARIANT), 'arg1' )),
    COMMETHOD(['propput', helpstring(u'The operator used in the function.')], HRESULT, 'Operator',
              ( ['in'], BSTR, 'op' )),
    COMMETHOD(['propget', helpstring(u'The operator used in the function.')], HRESULT, 'Operator',
              ( ['retval', 'out'], POINTER(BSTR), 'op' )),
    COMMETHOD(['propput', helpstring(u'The parameter name or constant value representing the second argument of the function.')], HRESULT, 'SecondArgument',
              ( ['in'], VARIANT, 'arg2' )),
    COMMETHOD(['propget', helpstring(u'The parameter name or constant value representing the second argument of the function.')], HRESULT, 'SecondArgument',
              ( ['retval', 'out'], POINTER(VARIANT), 'arg2' )),
    COMMETHOD([helpstring(u'Get the list of supported binary operator names.')], HRESULT, 'GetOperators',
              ( ['in'], esriNetworkAttributeDataType, 'returnDataType' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IEnumBSTR)), 'opNames' )),
]
################################################################
## code template for INetworkFunctionEvaluator implementation
##class INetworkFunctionEvaluator_Impl(object):
##    def _get(self):
##        u'The operator used in the function.'
##        #return op
##    def _set(self, op):
##        u'The operator used in the function.'
##    Operator = property(_get, _set, doc = _set.__doc__)
##
##    def GetOperators(self, returnDataType):
##        u'Get the list of supported binary operator names.'
##        #return opNames
##
##    def _get(self):
##        u'The attribute name or constant value representing the first argument of the function.'
##        #return arg1
##    def _set(self, arg1):
##        u'The attribute name or constant value representing the first argument of the function.'
##    FirstArgument = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The parameter name or constant value representing the second argument of the function.'
##        #return arg2
##    def _set(self, arg2):
##        u'The parameter name or constant value representing the second argument of the function.'
##    SecondArgument = property(_get, _set, doc = _set.__doc__)
##

class IFieldEdit2(IFieldEdit):
    _case_insensitive_ = True
    u'Provides access to members that edit the field properties including raster column definition.'
    _iid_ = GUID('{8BAD0DB3-A817-4DBB-9752-3FAF6757E22C}')
    _idlflags_ = ['oleautomation']
IFieldEdit2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The raster column definition.')], HRESULT, 'RasterDef',
              ( ['retval', 'out'], POINTER(POINTER(IRasterDef)), 'RasterDef' )),
    COMMETHOD(['propputref', helpstring(u'The raster column definition.')], HRESULT, 'RasterDef',
              ( ['in'], POINTER(IRasterDef), 'RasterDef' )),
]
################################################################
## code template for IFieldEdit2 implementation
##class IFieldEdit2_Impl(object):
##    def RasterDef(self, RasterDef):
##        u'The raster column definition.'
##        #return 
##


# values for enumeration 'esriTinIgnoredElementType'
esriTinNothing = 1
esriTinNodesWithNonZeroTag = 2
esriTinNodesWithZeroTag = 4
esriTinIgnoredElementType = c_int # enum
IObjectClassName._methods_ = [
    COMMETHOD(['propget', helpstring(u'The object class ID.')], HRESULT, 'ObjectClassID',
              ( ['retval', 'out'], POINTER(c_int), 'ID' )),
]
################################################################
## code template for IObjectClassName implementation
##class IObjectClassName_Impl(object):
##    @property
##    def ObjectClassID(self):
##        u'The object class ID.'
##        #return ID
##

ITinPolygon._methods_ = [
    COMMETHOD([helpstring(u'The specified polygon as TIN nodes.')], HRESULT, 'AsNodes',
              ( ['retval', 'out'], POINTER(POINTER(IEnumTinNode)), 'ppNodes' )),
    COMMETHOD([helpstring(u'The specified polygon as triangle edges.')], HRESULT, 'AsEdges',
              ( ['retval', 'out'], POINTER(POINTER(IEnumTinEdge)), 'ppEdges' )),
    COMMETHOD([helpstring(u'The specified polygon as its constituent triangles.')], HRESULT, 'AsTriangles',
              ( ['retval', 'out'], POINTER(POINTER(IEnumTinTriangle)), 'ppTriangles' )),
    COMMETHOD([helpstring(u'The specified polygon as polygon geometry.')], HRESULT, 'AsPolygon',
              ( ['in'], POINTER(ITinFilter), 'pNodeFilter' ),
              ( ['in'], VARIANT_BOOL, 'bGetZ' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon)), 'ppPolygon' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'GetBoundaryEdgeType',
              ( ['out'], POINTER(esriTinEdgeType), 'pType' )),
]
################################################################
## code template for ITinPolygon implementation
##class ITinPolygon_Impl(object):
##    def AsNodes(self):
##        u'The specified polygon as TIN nodes.'
##        #return ppNodes
##
##    def AsEdges(self):
##        u'The specified polygon as triangle edges.'
##        #return ppEdges
##
##    def GetBoundaryEdgeType(self):
##        u'Restricted.'
##        #return pType
##
##    def AsPolygon(self, pNodeFilter, bGetZ):
##        u'The specified polygon as polygon geometry.'
##        #return ppPolygon
##
##    def AsTriangles(self):
##        u'The specified polygon as its constituent triangles.'
##        #return ppTriangles
##

class IGeoDatabaseErrorRecords(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the GeoDatabase Error Records.'
    _iid_ = GUID('{C5B058A3-C789-11D2-AAEA-00C04FA37585}')
    _idlflags_ = ['oleautomation']
IGeoDatabaseErrorRecords._methods_ = [
    COMMETHOD(['propget', helpstring(u'The count of error records.')], HRESULT, 'ErrorCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The description of the specified error record.')], HRESULT, 'ErrorDescription',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(BSTR), 'Description' )),
]
################################################################
## code template for IGeoDatabaseErrorRecords implementation
##class IGeoDatabaseErrorRecords_Impl(object):
##    @property
##    def ErrorDescription(self, Index):
##        u'The description of the specified error record.'
##        #return Description
##
##    @property
##    def ErrorCount(self):
##        u'The count of error records.'
##        #return Count
##

class IField2(IField):
    _case_insensitive_ = True
    u'Provides access to members that return information about the field including raster column definition.'
    _iid_ = GUID('{F19F696B-F4F1-4066-9A7F-273754D9DC2A}')
    _idlflags_ = ['oleautomation']
IField2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The raster column definition.')], HRESULT, 'RasterDef',
              ( ['retval', 'out'], POINTER(POINTER(IRasterDef)), 'RasterDef' )),
]
################################################################
## code template for IField2 implementation
##class IField2_Impl(object):
##    @property
##    def RasterDef(self):
##        u'The raster column definition.'
##        #return RasterDef
##

IFeatureProgress._methods_ = [
    COMMETHOD(['propput', helpstring(u'Input feature class name.')], HRESULT, 'FeatureClassName',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Minimum number of features/rows in the input objectclass.')], HRESULT, 'MinFeatures',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Maximum number of features/rows in the input object class.')], HRESULT, 'MaxFeatures',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Current feature/row that currently converted by the converter.')], HRESULT, 'Position',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Current position of conversion.')], HRESULT, 'StepValue',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD([helpstring(u'Step the progressor interval.')], HRESULT, 'Step'),
    COMMETHOD(['propget', helpstring(u'Indicates whether the cancel button is pressed.  The data conversion will be cancelled if the user press the cancel button.')], HRESULT, 'IsCancelled',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsCancelled' )),
]
################################################################
## code template for IFeatureProgress implementation
##class IFeatureProgress_Impl(object):
##    def _set(self, rhs):
##        u'Current position of conversion.'
##    StepValue = property(fset = _set, doc = _set.__doc__)
##
##    @property
##    def IsCancelled(self):
##        u'Indicates whether the cancel button is pressed.  The data conversion will be cancelled if the user press the cancel button.'
##        #return pbIsCancelled
##
##    def _set(self, rhs):
##        u'Maximum number of features/rows in the input object class.'
##    MaxFeatures = property(fset = _set, doc = _set.__doc__)
##
##    def Step(self):
##        u'Step the progressor interval.'
##        #return 
##
##    def _set(self, rhs):
##        u'Minimum number of features/rows in the input objectclass.'
##    MinFeatures = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Current feature/row that currently converted by the converter.'
##    Position = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Input feature class name.'
##    FeatureClassName = property(fset = _set, doc = _set.__doc__)
##

class InvalidObjectInfo(CoClass):
    u'Esri Invalid Object Info object.'
    _reg_clsid_ = GUID('{23A73296-AB83-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
InvalidObjectInfo._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IInvalidObjectInfo]

IEnumLocatorName._methods_ = [
    COMMETHOD([helpstring(u'Returns the next Name object.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(ILocatorName)), 'outLocatorName' )),
    COMMETHOD([helpstring(u'Returns the previous Name object.')], HRESULT, 'Previous',
              ( ['retval', 'out'], POINTER(POINTER(ILocatorName)), 'outLocatorName' )),
    COMMETHOD([helpstring(u'Resets the enumeration.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Creates a copy of the enumeration.')], HRESULT, 'Clone',
              ( ['retval', 'out'], POINTER(POINTER(IEnumLocatorName)), 'outNameEnumerator' )),
    COMMETHOD(['propget', helpstring(u'Number of Name objects in the enumeration.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
]
################################################################
## code template for IEnumLocatorName implementation
##class IEnumLocatorName_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration.'
##        #return 
##
##    @property
##    def Count(self):
##        u'Number of Name objects in the enumeration.'
##        #return Count
##
##    def Clone(self):
##        u'Creates a copy of the enumeration.'
##        #return outNameEnumerator
##
##    def Previous(self):
##        u'Returns the previous Name object.'
##        #return outLocatorName
##
##    def Next(self):
##        u'Returns the next Name object.'
##        #return outLocatorName
##

class IDataConvertProcess(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the Data Convert Process.'
    _iid_ = GUID('{27E4225D-1AFD-11D4-812E-00C04F686238}')
    _idlflags_ = ['oleautomation']
IDataConvertProcess._methods_ = [
    COMMETHOD([helpstring(u'Initializes the process function with output table.')], HRESULT, 'Init',
              ( ['in'], POINTER(ITable), 'outputTable' )),
    COMMETHOD([helpstring(u'Processes the row buffer.')], HRESULT, 'ProcessRowbuffer',
              ( ['in'], POINTER(IRowBuffer), 'RowBuffer' )),
]
################################################################
## code template for IDataConvertProcess implementation
##class IDataConvertProcess_Impl(object):
##    def Init(self, outputTable):
##        u'Initializes the process function with output table.'
##        #return 
##
##    def ProcessRowbuffer(self, RowBuffer):
##        u'Processes the row buffer.'
##        #return 
##

class IFields2(IFields):
    _case_insensitive_ = True
    u'Provides access to members that return information about the fields.'
    _iid_ = GUID('{C3EDA031-6EC1-11D3-A024-00C04F6BDF0E}')
    _idlflags_ = ['oleautomation']
IFields2._methods_ = [
    COMMETHOD([helpstring(u'Finds the index of a field given a particular SQLSyntax workspace.')], HRESULT, 'FindFieldIgnoreQualification',
              ( [], POINTER(ISQLSyntax), 'sqlSyntax' ),
              ( ['in'], BSTR, 'Name' ),
              ( ['out'], POINTER(c_int), 'Index' )),
]
################################################################
## code template for IFields2 implementation
##class IFields2_Impl(object):
##    def FindFieldIgnoreQualification(self, sqlSyntax, Name):
##        u'Finds the index of a field given a particular SQLSyntax workspace.'
##        #return Index
##

class IFieldsEdit(IFields):
    _case_insensitive_ = True
    u'Provides access to members that modify a fields collection.'
    _iid_ = GUID('{6B2072E4-23F7-11D1-89D8-006097AFF44E}')
    _idlflags_ = ['oleautomation']
IFieldsEdit._methods_ = [
    COMMETHOD(['propput', helpstring(u'The Number of fields in this field collection.')], HRESULT, 'FieldCount',
              ( ['in'], c_int, 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The field at the specified position.')], HRESULT, 'Field',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(IField), 'rhs' )),
    COMMETHOD(['hidden', helpstring(u'Add a field to the fields collection.')], HRESULT, 'AddField',
              ( ['in'], POINTER(IField), 'Field' )),
    COMMETHOD(['hidden', helpstring(u'Delete a field from the fields collection.')], HRESULT, 'DeleteField',
              ( ['in'], POINTER(IField), 'Field' )),
    COMMETHOD(['hidden', helpstring(u'Delete all the fields from the fields collection.')], HRESULT, 'DeleteAllFields'),
]
################################################################
## code template for IFieldsEdit implementation
##class IFieldsEdit_Impl(object):
##    def Field(self, Index, rhs):
##        u'The field at the specified position.'
##        #return 
##
##    def _set(self, rhs):
##        u'The Number of fields in this field collection.'
##    FieldCount = property(fset = _set, doc = _set.__doc__)
##
##    def DeleteField(self, Field):
##        u'Delete a field from the fields collection.'
##        #return 
##
##    def DeleteAllFields(self):
##        u'Delete all the fields from the fields collection.'
##        #return 
##
##    def AddField(self, Field):
##        u'Add a field to the fields collection.'
##        #return 
##

IQueryFilter2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The spatial resolution in which to output geometry.')], HRESULT, 'SpatialResolution',
              ( ['retval', 'out'], POINTER(c_double), 'resolution' )),
    COMMETHOD(['propput', helpstring(u'The spatial resolution in which to output geometry.')], HRESULT, 'SpatialResolution',
              ( ['in'], c_double, 'resolution' )),
]
################################################################
## code template for IQueryFilter2 implementation
##class IQueryFilter2_Impl(object):
##    def _get(self):
##        u'The spatial resolution in which to output geometry.'
##        #return resolution
##    def _set(self, resolution):
##        u'The spatial resolution in which to output geometry.'
##    SpatialResolution = property(_get, _set, doc = _set.__doc__)
##

class ITopologyClassName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return information about the topology class.'
    _iid_ = GUID('{5B4B95C8-A6EF-4218-9E6E-5CD7605E1291}')
    _idlflags_ = ['oleautomation']
ITopologyClassName._methods_ = [
    COMMETHOD(['propget', helpstring(u'The Topology Name object.')], HRESULT, 'TopologyName',
              ( ['retval', 'out'], POINTER(POINTER(ITopologyName)), 'TopologyName' )),
    COMMETHOD(['propputref', helpstring(u'The Topology Name object.')], HRESULT, 'TopologyName',
              ( ['in'], POINTER(ITopologyName), 'TopologyName' )),
]
################################################################
## code template for ITopologyClassName implementation
##class ITopologyClassName_Impl(object):
##    def TopologyName(self, TopologyName):
##        u'The Topology Name object.'
##        #return 
##

IModelInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'The model name of the field.')], HRESULT, 'ModelName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The model name of the field.')], HRESULT, 'ModelName',
              ( ['in'], BSTR, 'Name' )),
]
################################################################
## code template for IModelInfo implementation
##class IModelInfo_Impl(object):
##    def _get(self):
##        u'The model name of the field.'
##        #return Name
##    def _set(self, Name):
##        u'The model name of the field.'
##    ModelName = property(_get, _set, doc = _set.__doc__)
##

class EnumInvalidObject(CoClass):
    u'Esri EnumInvalidObject object.'
    _reg_clsid_ = GUID('{23A73295-AB83-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
EnumInvalidObject._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumInvalidObject]

class DddServerEnvironment(CoClass):
    u'3D Server Environment (license) singleton object.'
    _reg_clsid_ = GUID('{3B6C52A4-7231-4189-B341-C30E7FB58BCF}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DddServerEnvironment._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IExtension, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IExtensionConfig, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class IRelQueryTableName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that define a relationship query table name.'
    _iid_ = GUID('{64485E14-DCCA-4747-8046-EE7D82A01928}')
    _idlflags_ = ['oleautomation']
IRelQueryTableName._methods_ = [
    COMMETHOD(['propputref', helpstring(u'The name object for the RelationshipClass that defines the RelQueryTable.')], HRESULT, 'RelationshipClassName',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'relClassName' )),
    COMMETHOD(['propget', helpstring(u'The name object for the RelationshipClass that defines the RelQueryTable.')], HRESULT, 'RelationshipClassName',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'relClassName' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the originPrimaryClass of the RelationshipClass is the SourceTable.')], HRESULT, 'ForwardDirection',
              ( ['in'], VARIANT_BOOL, 'forward' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the originPrimaryClass of the RelationshipClass is the SourceTable.')], HRESULT, 'ForwardDirection',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'forward' )),
    COMMETHOD(['propputref', helpstring(u'A QueryFilter applied to a cursor opened from the RelQueryTable.')], HRESULT, 'SrcQueryFilter',
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' )),
    COMMETHOD(['propget', helpstring(u'A QueryFilter applied to a cursor opened from the RelQueryTable.')], HRESULT, 'SrcQueryFilter',
              ( ['retval', 'out'], POINTER(POINTER(IQueryFilter)), 'QueryFilter' )),
    COMMETHOD(['propputref', helpstring(u'A SelectionSet applied to a cursor opened from the RelQueryTable.')], HRESULT, 'SrcSelectionSet',
              ( ['in'], POINTER(ISelectionSet), 'SelectionSet' )),
    COMMETHOD(['propget', helpstring(u'A SelectionSet applied to a cursor opened from the RelQueryTable.')], HRESULT, 'SrcSelectionSet',
              ( ['retval', 'out'], POINTER(POINTER(ISelectionSet)), 'SelectionSet' )),
    COMMETHOD(['propput', helpstring(u'The destination dataset columns available in a cursor opened from the RelTableTable.')], HRESULT, 'TargetColumns',
              ( ['in'], BSTR, 'TargetColumns' )),
    COMMETHOD(['propget', helpstring(u'The destination dataset columns available in a cursor opened from the RelTableTable.')], HRESULT, 'TargetColumns',
              ( ['retval', 'out'], POINTER(BSTR), 'TargetColumns' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the join is processed on the client.')], HRESULT, 'DoNotPushJoinToDB',
              ( ['in'], VARIANT_BOOL, 'DoNotPushJoinToDB' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the join is processed on the client.')], HRESULT, 'DoNotPushJoinToDB',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'DoNotPushJoinToDB' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the type of join will be a left outer join.')], HRESULT, 'LeftOuterJoin',
              ( ['in'], VARIANT_BOOL, 'LeftOuterJoin' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the type of join will be a left outer join.')], HRESULT, 'LeftOuterJoin',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'LeftOuterJoin' )),
]
################################################################
## code template for IRelQueryTableName implementation
##class IRelQueryTableName_Impl(object):
##    @property
##    def SrcQueryFilter(self, QueryFilter):
##        u'A QueryFilter applied to a cursor opened from the RelQueryTable.'
##        #return 
##
##    def _get(self):
##        u'Indicates if the originPrimaryClass of the RelationshipClass is the SourceTable.'
##        #return forward
##    def _set(self, forward):
##        u'Indicates if the originPrimaryClass of the RelationshipClass is the SourceTable.'
##    ForwardDirection = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the join is processed on the client.'
##        #return DoNotPushJoinToDB
##    def _set(self, DoNotPushJoinToDB):
##        u'Indicates if the join is processed on the client.'
##    DoNotPushJoinToDB = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The destination dataset columns available in a cursor opened from the RelTableTable.'
##        #return TargetColumns
##    def _set(self, TargetColumns):
##        u'The destination dataset columns available in a cursor opened from the RelTableTable.'
##    TargetColumns = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the type of join will be a left outer join.'
##        #return LeftOuterJoin
##    def _set(self, LeftOuterJoin):
##        u'Indicates if the type of join will be a left outer join.'
##    LeftOuterJoin = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def RelationshipClassName(self, relClassName):
##        u'The name object for the RelationshipClass that defines the RelQueryTable.'
##        #return 
##
##    @property
##    def SrcSelectionSet(self, SelectionSet):
##        u'A SelectionSet applied to a cursor opened from the RelQueryTable.'
##        #return 
##

class ITinEdgeTypeFilter2(ITinEdgeTypeFilter):
    _case_insensitive_ = True
    u'Provides access to members that control TIN edge type filters.'
    _iid_ = GUID('{18BBF602-373F-4093-B553-39AA9762C77F}')
    _idlflags_ = ['oleautomation']
ITinEdgeTypeFilter2._methods_ = [
    COMMETHOD(['propput', helpstring(u'Indicates if regular edges should be excluded.')], HRESULT, 'RegularEdgesExcluded',
              ( ['in'], VARIANT_BOOL, 'pbExcludeRegularEdge' )),
    COMMETHOD(['propget', helpstring(u'Indicates if regular edges should be excluded.')], HRESULT, 'RegularEdgesExcluded',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbExcludeRegularEdge' )),
]
################################################################
## code template for ITinEdgeTypeFilter2 implementation
##class ITinEdgeTypeFilter2_Impl(object):
##    def _get(self):
##        u'Indicates if regular edges should be excluded.'
##        #return pbExcludeRegularEdge
##    def _set(self, pbExcludeRegularEdge):
##        u'Indicates if regular edges should be excluded.'
##    RegularEdgesExcluded = property(_get, _set, doc = _set.__doc__)
##

class ISimpleDataConverter2(ISimpleDataConverter):
    _case_insensitive_ = True
    u'Provides access to members used for data conversions.'
    _iid_ = GUID('{D1E48D08-EE0B-11D3-A0A1-00C04F6BC626}')
    _idlflags_ = ['oleautomation']
ISimpleDataConverter2._methods_ = [
    COMMETHOD(['propputref', helpstring(u'The set of objects to convert.')], HRESULT, 'InputSelectionSet',
              ( ['in'], POINTER(ISelectionSet), 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The data converter process object.')], HRESULT, 'DataConvertProcess',
              ( ['in'], POINTER(IDataConvertProcess), 'rhs' )),
]
################################################################
## code template for ISimpleDataConverter2 implementation
##class ISimpleDataConverter2_Impl(object):
##    def DataConvertProcess(self, rhs):
##        u'The data converter process object.'
##        #return 
##
##    def InputSelectionSet(self, rhs):
##        u'The set of objects to convert.'
##        #return 
##

class IQueryName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the associated query definition.'
    _iid_ = GUID('{C833C1F6-90B8-11D3-9F7B-00C04F6BC886}')
    _idlflags_ = ['oleautomation']
class IQueryName2(IQueryName):
    _case_insensitive_ = True
    u'Provides access to the associated query definition.'
    _iid_ = GUID('{C1E0F902-0857-434E-84DB-351B6747F155}')
    _idlflags_ = ['oleautomation']
IQueryName._methods_ = [
    COMMETHOD(['propget', helpstring(u'QueryDef of feature class name.')], HRESULT, 'QueryDef',
              ( ['retval', 'out'], POINTER(POINTER(IQueryDef)), 'QueryDef' )),
    COMMETHOD(['propput', helpstring(u'QueryDef of feature class name.')], HRESULT, 'QueryDef',
              ( ['in'], POINTER(IQueryDef), 'QueryDef' )),
]
################################################################
## code template for IQueryName implementation
##class IQueryName_Impl(object):
##    def _get(self):
##        u'QueryDef of feature class name.'
##        #return QueryDef
##    def _set(self, QueryDef):
##        u'QueryDef of feature class name.'
##    QueryDef = property(_get, _set, doc = _set.__doc__)
##

IQueryName2._methods_ = [
    COMMETHOD(['propput', helpstring(u'Indicates if the data must be copied locally.')], HRESULT, 'CopyLocally',
              ( ['in'], VARIANT_BOOL, 'CopyLocally' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the data must be copied locally.')], HRESULT, 'CopyLocally',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CopyLocally' )),
    COMMETHOD(['propput', helpstring(u'The primary key field names.')], HRESULT, 'PrimaryKey',
              ( ['in'], BSTR, 'fieldNames' )),
    COMMETHOD(['propget', helpstring(u'The primary key field names.')], HRESULT, 'PrimaryKey',
              ( ['retval', 'out'], POINTER(BSTR), 'fieldNames' )),
]
################################################################
## code template for IQueryName2 implementation
##class IQueryName2_Impl(object):
##    def _get(self):
##        u'The primary key field names.'
##        #return fieldNames
##    def _set(self, fieldNames):
##        u'The primary key field names.'
##    PrimaryKey = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the data must be copied locally.'
##        #return CopyLocally
##    def _set(self, CopyLocally):
##        u'Indicates if the data must be copied locally.'
##    CopyLocally = property(_get, _set, doc = _set.__doc__)
##

ILocatorName._methods_ = [
    COMMETHOD(['propget', helpstring(u'Name of the locator.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'Name of the locator.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'Description of the locator.')], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'Description' )),
    COMMETHOD(['propput', helpstring(u'Description of the locator.')], HRESULT, 'Description',
              ( ['in'], BSTR, 'Description' )),
    COMMETHOD(['propget', helpstring(u'Category of the locator.')], HRESULT, 'Category',
              ( ['retval', 'out'], POINTER(BSTR), 'Category' )),
    COMMETHOD(['propput', helpstring(u'Category of the locator.')], HRESULT, 'Category',
              ( ['in'], BSTR, 'Category' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this is a locator style.')], HRESULT, 'Style',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isStyle' )),
    COMMETHOD(['propput', helpstring(u'Indicates if this is a locator style.')], HRESULT, 'Style',
              ( ['in'], VARIANT_BOOL, 'isStyle' )),
    COMMETHOD(['propget', helpstring(u'Name object for the locator workspace that contains the locator.')], HRESULT, 'LocatorWorkspaceName',
              ( ['retval', 'out'], POINTER(POINTER(ILocatorWorkspaceName)), 'LocatorWorkspaceName' )),
    COMMETHOD(['propputref', helpstring(u'Name object for the locator workspace that contains the locator.')], HRESULT, 'LocatorWorkspaceName',
              ( ['in'], POINTER(ILocatorWorkspaceName), 'LocatorWorkspaceName' )),
]
################################################################
## code template for ILocatorName implementation
##class ILocatorName_Impl(object):
##    def _get(self):
##        u'Category of the locator.'
##        #return Category
##    def _set(self, Category):
##        u'Category of the locator.'
##    Category = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if this is a locator style.'
##        #return isStyle
##    def _set(self, isStyle):
##        u'Indicates if this is a locator style.'
##    Style = property(_get, _set, doc = _set.__doc__)
##
##    def LocatorWorkspaceName(self, LocatorWorkspaceName):
##        u'Name object for the locator workspace that contains the locator.'
##        #return 
##
##    def _get(self):
##        u'Name of the locator.'
##        #return Name
##    def _set(self, Name):
##        u'Name of the locator.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Description of the locator.'
##        #return Description
##    def _set(self, Description):
##        u'Description of the locator.'
##    Description = property(_get, _set, doc = _set.__doc__)
##

class SimpleDataConverter(CoClass):
    u'Convert a set of shape files into Access or SDE.'
    _reg_clsid_ = GUID('{4866984B-FAFA-11D1-AAB1-00C04FA33C20}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
SimpleDataConverter._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ISimpleDataConverter, ISimpleDataConverter2, comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IConnectionPointContainer, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]
SimpleDataConverter._outgoing_interfaces_ = [IFeatureProgress]

IEnumFeatureClass._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next feature class in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IFeatureClass)), 'FeatureClass' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumFeatureClass implementation
##class IEnumFeatureClass_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next feature class in the enumeration sequence.'
##        #return FeatureClass
##

class TinEdgeEnumerator(CoClass):
    u'The Esri TinEdgeEnumerator component.'
    _reg_clsid_ = GUID('{F4377D43-2F1D-11D2-92F7-444553540000}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinEdgeEnumerator._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumTinElement, IEnumTinEdge, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class TinPolygon(CoClass):
    u'The Esri TinPolygon component.'
    _reg_clsid_ = GUID('{2FA264B7-A214-11D3-AB4B-0008C73FD50C}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinPolygon._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITinPolygon, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class TinNodeEnumerator(CoClass):
    u'The Esri TinNodeEnumerator component.'
    _reg_clsid_ = GUID('{F4377D42-2F1D-11D2-92F7-444553540000}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinNodeEnumerator._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumTinElement, IEnumTinNode, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

IEnumTinElement._methods_ = [
    COMMETHOD([helpstring(u'Resets the enumerator.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Gets next element.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(ITinElement)), 'ppElement' )),
    COMMETHOD([helpstring(u'Queries next element.')], HRESULT, 'QueryNext',
              ( ['in'], POINTER(ITinElement), 'pElement' )),
]
################################################################
## code template for IEnumTinElement implementation
##class IEnumTinElement_Impl(object):
##    def Reset(self):
##        u'Resets the enumerator.'
##        #return 
##
##    def QueryNext(self, pElement):
##        u'Queries next element.'
##        #return 
##
##    def Next(self):
##        u'Gets next element.'
##        #return ppElement
##

class IFeatureClassCreation(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a member that determines if features can be created from a point.'
    _iid_ = GUID('{60749651-4F54-11D2-89FC-006097AFF44E}')
    _idlflags_ = ['oleautomation']
IFeatureClassCreation._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the features in this feature class know how to create their shapes given an input point geometry.')], HRESULT, 'CanCreateFromPoint',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanCreateFromPoint' )),
]
################################################################
## code template for IFeatureClassCreation implementation
##class IFeatureClassCreation_Impl(object):
##    @property
##    def CanCreateFromPoint(self):
##        u'Indicates if the features in this feature class know how to create their shapes given an input point geometry.'
##        #return CanCreateFromPoint
##

IGPName._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the GPName object.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the GPName object.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The descriptive display name of the GPName object.')], HRESULT, 'DisplayName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The descriptive display name of the GPName object.')], HRESULT, 'DisplayName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The description of the GPName object.')], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'Description' )),
    COMMETHOD(['propput', helpstring(u'The description of the GPName object.')], HRESULT, 'Description',
              ( ['in'], BSTR, 'Description' )),
    COMMETHOD(['propget', helpstring(u'The category of the GPName object.')], HRESULT, 'Category',
              ( ['retval', 'out'], POINTER(BSTR), 'Path' )),
    COMMETHOD(['propput', helpstring(u'The category of the GPName object.')], HRESULT, 'Category',
              ( ['in'], BSTR, 'Path' )),
    COMMETHOD(['propget', helpstring(u'The factory object of the GPName object.')], HRESULT, 'Factory',
              ( ['retval', 'out'], POINTER(POINTER(IUnknown)), 'Factory' )),
    COMMETHOD(['propputref', helpstring(u'The factory object of the GPName object.')], HRESULT, 'Factory',
              ( ['in'], POINTER(IUnknown), 'Factory' )),
]
################################################################
## code template for IGPName implementation
##class IGPName_Impl(object):
##    def _get(self):
##        u'The category of the GPName object.'
##        #return Path
##    def _set(self, Path):
##        u'The category of the GPName object.'
##    Category = property(_get, _set, doc = _set.__doc__)
##
##    def Factory(self, Factory):
##        u'The factory object of the GPName object.'
##        #return 
##
##    def _get(self):
##        u'The descriptive display name of the GPName object.'
##        #return Name
##    def _set(self, Name):
##        u'The descriptive display name of the GPName object.'
##    DisplayName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the GPName object.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the GPName object.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The description of the GPName object.'
##        #return Description
##    def _set(self, Description):
##        u'The description of the GPName object.'
##    Description = property(_get, _set, doc = _set.__doc__)
##

class TinTriangleEnumerator(CoClass):
    u'The Esri TinTriangleEnumerator component.'
    _reg_clsid_ = GUID('{F4377D44-2F1D-11D2-92F7-444553540000}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinTriangleEnumerator._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumTinElement, IEnumTinTriangle, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

ISQLCheck._methods_ = [
    COMMETHOD([helpstring(u'Checks select list for invalid characters.')], HRESULT, 'CheckSelectList',
              ( ['in'], BSTR, 'selctList' )),
    COMMETHOD([helpstring(u'Checks where clause for invalid characters.')], HRESULT, 'CheckWhereClause',
              ( ['in'], BSTR, 'WhereClause' )),
]
################################################################
## code template for ISQLCheck implementation
##class ISQLCheck_Impl(object):
##    def CheckWhereClause(self, WhereClause):
##        u'Checks where clause for invalid characters.'
##        #return 
##
##    def CheckSelectList(self, selctList):
##        u'Checks select list for invalid characters.'
##        #return 
##

IRecordNumberSet._methods_ = [
    COMMETHOD([helpstring(u'Sets the starting and ending record numbers for the record number collection, then adds all record numbers between those values to the collection.')], HRESULT, 'SetBounds',
              ( ['in'], c_int, 'startRecordNumber' ),
              ( ['in'], c_int, 'maxRecordNumber' )),
    COMMETHOD(['propget', helpstring(u'The minimum record in the record number collection.')], HRESULT, 'MinimumRecordNumber',
              ( ['retval', 'out'], POINTER(c_int), 'startRecordNumber' )),
    COMMETHOD(['propget', helpstring(u'The maximum record in the record number collection.')], HRESULT, 'MaximumRecordNumber',
              ( ['retval', 'out'], POINTER(c_int), 'maxRecordNumber' )),
    COMMETHOD([helpstring(u'Adds a record number to the collection.')], HRESULT, 'Add',
              ( [], c_int, 'recordNumber' )),
    COMMETHOD([helpstring(u'Removes a record number from the collection.')], HRESULT, 'Delete',
              ( [], c_int, 'recordNumber' )),
    COMMETHOD([helpstring(u'Adds a range of record numbers to the collection starting with the minRecord and ending with the maxRecord.')], HRESULT, 'AddRange',
              ( ['in'], c_int, 'minRecord' ),
              ( ['in'], c_int, 'maxRecord' )),
    COMMETHOD([helpstring(u'Set all record numbers.')], HRESULT, 'SetAll'),
    COMMETHOD([helpstring(u'Clear all record numbers.')], HRESULT, 'ClearAll'),
    COMMETHOD([helpstring(u'Combines the record numbers that are common to both collections into a single collection.')], HRESULT, 'And',
              ( ['in'], POINTER(IRecordNumberSet), 'otherRecordNumberSet' ),
              ( ['retval', 'out'], POINTER(POINTER(IRecordNumberSet)), 'newRecordNumberSet' )),
    COMMETHOD([helpstring(u'Combines all the record numbers that are in one or the other collection into a single collection.')], HRESULT, 'Or',
              ( ['in'], POINTER(IRecordNumberSet), 'otherRecordNumberSet' ),
              ( ['retval', 'out'], POINTER(POINTER(IRecordNumberSet)), 'newRecordNumberSet' )),
    COMMETHOD([helpstring(u'Combines the record numbers that are in one of the collections, but not both collections, into a single collection.')], HRESULT, 'XOr',
              ( ['in'], POINTER(IRecordNumberSet), 'otherRecordNumberSet' ),
              ( ['retval', 'out'], POINTER(POINTER(IRecordNumberSet)), 'newRecordNumberSet' )),
    COMMETHOD([helpstring(u'Returns the record numbers that are not in the collection, but are present in the input collection.')], HRESULT, 'Difference',
              ( ['in'], POINTER(IRecordNumberSet), 'otherRecordNumberSet' ),
              ( ['retval', 'out'], POINTER(POINTER(IRecordNumberSet)), 'newRecordNumberSet' )),
    COMMETHOD([helpstring(u'Inverts the collection; selected records become unselected and unselected records become selected.')], HRESULT, 'Negate',
              ( ['retval', 'out'], POINTER(POINTER(IRecordNumberSet)), 'newRecordNumberSet' )),
    COMMETHOD(['propget', helpstring(u'Enumerates the record numbers in the record number collection.')], HRESULT, 'IDs',
              ( ['retval', 'out'], POINTER(POINTER(IEnumIDs)), 'pEnumIDs' )),
]
################################################################
## code template for IRecordNumberSet implementation
##class IRecordNumberSet_Impl(object):
##    def And(self, otherRecordNumberSet):
##        u'Combines the record numbers that are common to both collections into a single collection.'
##        #return newRecordNumberSet
##
##    def SetBounds(self, startRecordNumber, maxRecordNumber):
##        u'Sets the starting and ending record numbers for the record number collection, then adds all record numbers between those values to the collection.'
##        #return 
##
##    def XOr(self, otherRecordNumberSet):
##        u'Combines the record numbers that are in one of the collections, but not both collections, into a single collection.'
##        #return newRecordNumberSet
##
##    @property
##    def IDs(self):
##        u'Enumerates the record numbers in the record number collection.'
##        #return pEnumIDs
##
##    def SetAll(self):
##        u'Set all record numbers.'
##        #return 
##
##    @property
##    def MaximumRecordNumber(self):
##        u'The maximum record in the record number collection.'
##        #return maxRecordNumber
##
##    @property
##    def MinimumRecordNumber(self):
##        u'The minimum record in the record number collection.'
##        #return startRecordNumber
##
##    def AddRange(self, minRecord, maxRecord):
##        u'Adds a range of record numbers to the collection starting with the minRecord and ending with the maxRecord.'
##        #return 
##
##    def Add(self, recordNumber):
##        u'Adds a record number to the collection.'
##        #return 
##
##    def Negate(self):
##        u'Inverts the collection; selected records become unselected and unselected records become selected.'
##        #return newRecordNumberSet
##
##    def Difference(self, otherRecordNumberSet):
##        u'Returns the record numbers that are not in the collection, but are present in the input collection.'
##        #return newRecordNumberSet
##
##    def ClearAll(self):
##        u'Clear all record numbers.'
##        #return 
##
##    def Or(self, otherRecordNumberSet):
##        u'Combines all the record numbers that are in one or the other collection into a single collection.'
##        #return newRecordNumberSet
##
##    def Delete(self, recordNumber):
##        u'Removes a record number from the collection.'
##        #return 
##


# values for enumeration 'esriDrawStyle'
esriDSNormal = 1
esriDSValid = 2
esriDSInvalid = 4
esriDSUnknown = 8
esriDrawStyle = c_int # enum
IFeatureDraw._methods_ = [
    COMMETHOD([helpstring(u'Draws the feature on the display.')], HRESULT, 'Draw',
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.esriDrawPhase, 'drawPhase' ),
              ( ['in'], POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IDisplay), 'Display' ),
              ( ['in'], POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.ISymbol), 'symbol' ),
              ( ['in'], VARIANT_BOOL, 'symbolInstalled' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'Geometry' ),
              ( ['in'], esriDrawStyle, 'drawStyle' )),
    COMMETHOD(['propputref', helpstring(u'The area to be drawn.')], HRESULT, 'InvalidArea',
              ( ['in'], POINTER(IInvalidArea), 'InvalidArea' )),
    COMMETHOD(['propget', helpstring(u'The area to be drawn.')], HRESULT, 'InvalidArea',
              ( ['retval', 'out'], POINTER(POINTER(IInvalidArea)), 'InvalidArea' )),
]
################################################################
## code template for IFeatureDraw implementation
##class IFeatureDraw_Impl(object):
##    @property
##    def InvalidArea(self, InvalidArea):
##        u'The area to be drawn.'
##        #return 
##
##    def Draw(self, drawPhase, Display, symbol, symbolInstalled, Geometry, drawStyle):
##        u'Draws the feature on the display.'
##        #return 
##

class IReplica3(IReplica2):
    _case_insensitive_ = True
    u'Provides access to members that get information about a replica.'
    _iid_ = GUID('{A3213932-009D-4A49-AE5E-945F32E079F2}')
    _idlflags_ = ['oleautomation']
IReplica3._methods_ = [
    COMMETHOD(['propget', helpstring(u'Use archiving instead of versions to track replica changes.')], HRESULT, 'UseArchiving',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'UseArchiving' )),
    COMMETHOD(['propput', helpstring(u'Use archiving instead of versions to track replica changes.')], HRESULT, 'UseArchiving',
              ( ['in'], VARIANT_BOOL, 'UseArchiving' )),
]
################################################################
## code template for IReplica3 implementation
##class IReplica3_Impl(object):
##    def _get(self):
##        u'Use archiving instead of versions to track replica changes.'
##        #return UseArchiving
##    def _set(self, UseArchiving):
##        u'Use archiving instead of versions to track replica changes.'
##    UseArchiving = property(_get, _set, doc = _set.__doc__)
##

class TinSurfaceElement(CoClass):
    u'The Esri TinSurfaceElement component.'
    _reg_clsid_ = GUID('{B9767BC1-D0DF-11D2-9F76-00C04F8ECE27}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinSurfaceElement._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITinSurfaceElement]

class ISpatialFilter(IQueryFilter):
    _case_insensitive_ = True
    u'Provides access to members that return and modify the type of spatial relationship that the filter will use.'
    _iid_ = GUID('{FDFEBD94-ED75-11D0-9A95-080009EC734B}')
    _idlflags_ = ['oleautomation']
ISpatialFilter._methods_ = [
    COMMETHOD(['propget', helpstring(u'The search order used by the filter.')], HRESULT, 'SearchOrder',
              ( ['retval', 'out'], POINTER(esriSearchOrder), 'order' )),
    COMMETHOD(['propput', helpstring(u'The search order used by the filter.')], HRESULT, 'SearchOrder',
              ( ['in'], esriSearchOrder, 'order' )),
    COMMETHOD(['propget', helpstring(u'The spatial relationship  checked by the filter.')], HRESULT, 'SpatialRel',
              ( ['retval', 'out'], POINTER(esriSpatialRelEnum), 'SpatialRel' )),
    COMMETHOD(['propput', helpstring(u'The spatial relationship  checked by the filter.')], HRESULT, 'SpatialRel',
              ( ['in'], esriSpatialRelEnum, 'SpatialRel' )),
    COMMETHOD(['propget', helpstring(u'The query geometry used to filter results.')], HRESULT, 'Geometry',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Geometry' )),
    COMMETHOD(['propputref', helpstring(u'The query geometry used to filter results.')], HRESULT, 'Geometry',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'Geometry' )),
    COMMETHOD(['propputref', helpstring(u'The query geometry used to filter results.')], HRESULT, 'GeometryEx',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'Geometry' ),
              ( ['in'], VARIANT_BOOL, 'rhs' )),
    COMMETHOD(['propget', helpstring(u'Indicates whether the filter owns the query geometry.')], HRESULT, 'FilterOwnsGeometry',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'spatialFilterOwnsGeometry' )),
    COMMETHOD(['propget', helpstring(u'The name of the Geometry field to which the filter applies.')], HRESULT, 'GeometryField',
              ( ['retval', 'out'], POINTER(BSTR), 'geomField' )),
    COMMETHOD(['propput', helpstring(u'The name of the Geometry field to which the filter applies.')], HRESULT, 'GeometryField',
              ( ['in'], BSTR, 'geomField' )),
    COMMETHOD(['propget', helpstring(u"The array elements which describe the spatial relation between the query geometry and the requested geometries. There are 9 chars in this string which can be either 'F', 'T' or '*'; e.g., TT*FFT***' represents CONTAIN.")], HRESULT, 'SpatialRelDescription',
              ( ['retval', 'out'], POINTER(BSTR), 'SpatialRelDescription' )),
    COMMETHOD(['propput', helpstring(u"The array elements which describe the spatial relation between the query geometry and the requested geometries. There are 9 chars in this string which can be either 'F', 'T' or '*'; e.g., TT*FFT***' represents CONTAIN.")], HRESULT, 'SpatialRelDescription',
              ( ['in'], BSTR, 'SpatialRelDescription' )),
]
################################################################
## code template for ISpatialFilter implementation
##class ISpatialFilter_Impl(object):
##    def _get(self):
##        u"The array elements which describe the spatial relation between the query geometry and the requested geometries. There are 9 chars in this string which can be either 'F', 'T' or '*'; e.g., TT*FFT***' represents CONTAIN."
##        #return SpatialRelDescription
##    def _set(self, SpatialRelDescription):
##        u"The array elements which describe the spatial relation between the query geometry and the requested geometries. There are 9 chars in this string which can be either 'F', 'T' or '*'; e.g., TT*FFT***' represents CONTAIN."
##    SpatialRelDescription = property(_get, _set, doc = _set.__doc__)
##
##    def Geometry(self, Geometry):
##        u'The query geometry used to filter results.'
##        #return 
##
##    def _get(self):
##        u'The spatial relationship  checked by the filter.'
##        #return SpatialRel
##    def _set(self, SpatialRel):
##        u'The spatial relationship  checked by the filter.'
##    SpatialRel = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def FilterOwnsGeometry(self):
##        u'Indicates whether the filter owns the query geometry.'
##        #return spatialFilterOwnsGeometry
##
##    def _get(self):
##        u'The search order used by the filter.'
##        #return order
##    def _set(self, order):
##        u'The search order used by the filter.'
##    SearchOrder = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the Geometry field to which the filter applies.'
##        #return geomField
##    def _set(self, geomField):
##        u'The name of the Geometry field to which the filter applies.'
##    GeometryField = property(_get, _set, doc = _set.__doc__)
##
##    def GeometryEx(self, Geometry, rhs):
##        u'The query geometry used to filter results.'
##        #return 
##

ICollectionTableVersionChanges._methods_ = [
    COMMETHOD([helpstring(u'Tables whose version has been changed.')], HRESULT, 'Add',
              ( ['in'], POINTER(ITable), 'oldTable' ),
              ( ['in'], POINTER(ITable), 'newTable' )),
    COMMETHOD([helpstring(u'Remove all stored tables.')], HRESULT, 'RemoveAll'),
]
################################################################
## code template for ICollectionTableVersionChanges implementation
##class ICollectionTableVersionChanges_Impl(object):
##    def RemoveAll(self):
##        u'Remove all stored tables.'
##        #return 
##
##    def Add(self, oldTable, newTable):
##        u'Tables whose version has been changed.'
##        #return 
##

class IMemoryRelationshipClassFactory(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that open a memory relationship class.'
    _iid_ = GUID('{9AAE7F41-E171-4BBA-9D77-AB6A02309116}')
    _idlflags_ = ['oleautomation']
IMemoryRelationshipClassFactory._methods_ = [
    COMMETHOD([helpstring(u'Opens the memory relationship class specified by the given properties.')], HRESULT, 'Open',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IObjectClass), 'originPrimaryClass' ),
              ( ['in'], BSTR, 'originPrimaryKeyField' ),
              ( ['in'], POINTER(IObjectClass), 'originForeignClass' ),
              ( ['in'], BSTR, 'originForeignKeyField' ),
              ( ['in'], BSTR, 'ForwardPathLabel' ),
              ( ['in'], BSTR, 'BackwardPathLabel' ),
              ( ['in'], esriRelCardinality, 'Cardinality' ),
              ( ['retval', 'out'], POINTER(POINTER(IRelationshipClass)), 'RelationshipClass' )),
]
################################################################
## code template for IMemoryRelationshipClassFactory implementation
##class IMemoryRelationshipClassFactory_Impl(object):
##    def Open(self, Name, originPrimaryClass, originPrimaryKeyField, originForeignClass, originForeignKeyField, ForwardPathLabel, BackwardPathLabel, Cardinality):
##        u'Opens the memory relationship class specified by the given properties.'
##        #return RelationshipClass
##

IFIDSet._methods_ = [
    COMMETHOD([helpstring(u'Adds a feature id to the set.')], HRESULT, 'Add',
              ( ['in'], c_int, 'fID' )),
    COMMETHOD([helpstring(u'Deletes a feature id from the set.')], HRESULT, 'Delete',
              ( ['in'], c_int, 'fID' )),
    COMMETHOD([helpstring(u'Finds a feature id in the set.')], HRESULT, 'Find',
              ( ['in'], c_int, 'fID' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'doesExist' )),
    COMMETHOD([helpstring(u'Gets the next feature id from the set.')], HRESULT, 'Next',
              ( ['out'], POINTER(c_int), 'fID' )),
    COMMETHOD([helpstring(u'Resets the internal cursor.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'The number of elements in the FID set.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD([helpstring(u'Empties the FID set.')], HRESULT, 'SetEmpty'),
]
################################################################
## code template for IFIDSet implementation
##class IFIDSet_Impl(object):
##    def Reset(self):
##        u'Resets the internal cursor.'
##        #return 
##
##    def Count(self):
##        u'The number of elements in the FID set.'
##        #return Count
##
##    def Next(self):
##        u'Gets the next feature id from the set.'
##        #return fID
##
##    def Add(self, fID):
##        u'Adds a feature id to the set.'
##        #return 
##
##    def SetEmpty(self):
##        u'Empties the FID set.'
##        #return 
##
##    def Find(self, fID):
##        u'Finds a feature id in the set.'
##        #return doesExist
##
##    def Delete(self, fID):
##        u'Deletes a feature id from the set.'
##        #return 
##

IFIDSet2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Enumerates the object ids in the FID set.')], HRESULT, 'IDs',
              ( ['retval', 'out'], POINTER(POINTER(IEnumIDs)), 'EnumIDs' )),
]
################################################################
## code template for IFIDSet2 implementation
##class IFIDSet2_Impl(object):
##    @property
##    def IDs(self):
##        u'Enumerates the object ids in the FID set.'
##        #return EnumIDs
##

IGeometricNetworkReconcileProperties._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the reconcile plan for the network reduces network conflicts.')], HRESULT, 'ReduceNetworkConflicts',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'ReduceNetworkConflicts' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the reconcile plan for the network reduces network conflicts.')], HRESULT, 'ReduceNetworkConflicts',
              ( ['in'], VARIANT_BOOL, 'ReduceNetworkConflicts' )),
]
################################################################
## code template for IGeometricNetworkReconcileProperties implementation
##class IGeometricNetworkReconcileProperties_Impl(object):
##    def _get(self):
##        u'Indicates if the reconcile plan for the network reduces network conflicts.'
##        #return ReduceNetworkConflicts
##    def _set(self, ReduceNetworkConflicts):
##        u'Indicates if the reconcile plan for the network reduces network conflicts.'
##    ReduceNetworkConflicts = property(_get, _set, doc = _set.__doc__)
##

ITable._methods_ = [
    COMMETHOD([helpstring(u'Creates a row in the database with a system assigned object ID and null property values.')], HRESULT, 'CreateRow',
              ( ['retval', 'out'], POINTER(POINTER(IRow)), 'Row' )),
    COMMETHOD([helpstring(u'The row from the database with the specified object ID.')], HRESULT, 'GetRow',
              ( ['in'], c_int, 'OID' ),
              ( ['retval', 'out'], POINTER(POINTER(IRow)), 'Row' )),
    COMMETHOD([helpstring(u'The cursor of rows based on a set of object ids.')], HRESULT, 'GetRows',
              ( ['in'], VARIANT, 'oids' ),
              ( ['in'], VARIANT_BOOL, 'Recycling' ),
              ( ['retval', 'out'], POINTER(POINTER(ICursor)), 'Cursor' )),
    COMMETHOD([helpstring(u'Creates a row buffer that can be used with an insert cursor.')], HRESULT, 'CreateRowBuffer',
              ( ['retval', 'out'], POINTER(POINTER(IRowBuffer)), 'buffer' )),
    COMMETHOD([helpstring(u'Update the Rows in the database selected by the specified query.')], HRESULT, 'UpdateSearchedRows',
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' ),
              ( ['in'], POINTER(IRowBuffer), 'buffer' )),
    COMMETHOD([helpstring(u'Delete the Rows in the database selected by the specified query.')], HRESULT, 'DeleteSearchedRows',
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' )),
    COMMETHOD([helpstring(u'The number of Rows selected by the specified query.')], HRESULT, 'RowCount',
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' ),
              ( ['retval', 'out'], POINTER(c_int), 'numRows' )),
    COMMETHOD([helpstring(u'An object cursor that can be used to fetch row objects selected by the specified query.')], HRESULT, 'Search',
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' ),
              ( ['in'], VARIANT_BOOL, 'Recycling' ),
              ( ['retval', 'out'], POINTER(POINTER(ICursor)), 'Cursor' )),
    COMMETHOD([helpstring(u'Returns a cursor that can be used to update Rows selected by the specified query.')], HRESULT, 'Update',
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' ),
              ( ['in'], VARIANT_BOOL, 'Recycling' ),
              ( ['retval', 'out'], POINTER(POINTER(ICursor)), 'Cursor' )),
    COMMETHOD([helpstring(u'Returns a  cursor that can be used to insert new Rows.')], HRESULT, 'Insert',
              ( ['in'], VARIANT_BOOL, 'useBuffering' ),
              ( ['retval', 'out'], POINTER(POINTER(ICursor)), 'Cursor' )),
    COMMETHOD([helpstring(u'A selection that contains the object ids selected by the specified query.')], HRESULT, 'Select',
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' ),
              ( ['in'], esriSelectionType, 'selType' ),
              ( ['in'], esriSelectionOption, 'selOption' ),
              ( ['in'], POINTER(IWorkspace), 'selectionContainer' ),
              ( ['retval', 'out'], POINTER(POINTER(ISelectionSet)), 'SelectionSet' )),
]
################################################################
## code template for ITable implementation
##class ITable_Impl(object):
##    def UpdateSearchedRows(self, QueryFilter, buffer):
##        u'Update the Rows in the database selected by the specified query.'
##        #return 
##
##    def Search(self, QueryFilter, Recycling):
##        u'An object cursor that can be used to fetch row objects selected by the specified query.'
##        #return Cursor
##
##    def RowCount(self, QueryFilter):
##        u'The number of Rows selected by the specified query.'
##        #return numRows
##
##    def GetRows(self, oids, Recycling):
##        u'The cursor of rows based on a set of object ids.'
##        #return Cursor
##
##    def Update(self, QueryFilter, Recycling):
##        u'Returns a cursor that can be used to update Rows selected by the specified query.'
##        #return Cursor
##
##    def GetRow(self, OID):
##        u'The row from the database with the specified object ID.'
##        #return Row
##
##    def CreateRowBuffer(self):
##        u'Creates a row buffer that can be used with an insert cursor.'
##        #return buffer
##
##    def Insert(self, useBuffering):
##        u'Returns a  cursor that can be used to insert new Rows.'
##        #return Cursor
##
##    def CreateRow(self):
##        u'Creates a row in the database with a system assigned object ID and null property values.'
##        #return Row
##
##    def Select(self, QueryFilter, selType, selOption, selectionContainer):
##        u'A selection that contains the object ids selected by the specified query.'
##        #return SelectionSet
##
##    def DeleteSearchedRows(self, QueryFilter):
##        u'Delete the Rows in the database selected by the specified query.'
##        #return 
##

IDifferenceCursorEx._methods_ = [
    COMMETHOD([helpstring(u'Returns the source row, the difference row and an array with indices of fields with different values.')], HRESULT, 'Next',
              ( ['out'], POINTER(c_int), 'OID' ),
              ( ['out'], POINTER(POINTER(IRow)), 'SourceRow' ),
              ( ['out'], POINTER(POINTER(IRow)), 'differenceRow' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray)), 'differentValueIndices' )),
]
################################################################
## code template for IDifferenceCursorEx implementation
##class IDifferenceCursorEx_Impl(object):
##    def Next(self):
##        u'Returns the source row, the difference row and an array with indices of fields with different values.'
##        #return OID, SourceRow, differenceRow, differentValueIndices
##

class FeatureCursor(CoClass):
    u'Esri Feature Cursor object.'
    _reg_clsid_ = GUID('{4DD32C19-1720-11D5-A664-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
FeatureCursor._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ICursor, IFeatureCursor]

class DifferenceCursor(CoClass):
    u'Esri Difference Cursor object.'
    _reg_clsid_ = GUID('{23A7329E-AB83-11D4-A64C-0008C711C8C1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DifferenceCursor._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDifferenceCursor]

class NetworkScriptEvaluator(CoClass):
    u'A container for describing a network attribute evaluator whose values are derived from VBScript expressions.'
    _reg_clsid_ = GUID('{FDF2BB9C-9EA4-4752-BC9C-67A5C6780606}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class INetworkScriptEvaluator(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of a network attribute evaluator whose values are derived from VBScript expressions.'
    _iid_ = GUID('{9603B546-894D-4DCD-93ED-A2E046FAF32C}')
    _idlflags_ = ['oleautomation']
class INetworkScriptEvaluator2(INetworkScriptEvaluator):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of a network attribute evaluator whose values are derived from VBScript expressions.'
    _iid_ = GUID('{6430E4F4-AD03-4310-9A30-0A24FF6C413A}')
    _idlflags_ = ['oleautomation']
NetworkScriptEvaluator._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkEvaluator, INetworkEvaluator2, INetworkScriptEvaluator, INetworkScriptEvaluator2, INetworkEvaluatorSetup, IGPDescribe]

class TableQueryName(CoClass):
    u'Esri Table Query Name object.'
    _reg_clsid_ = GUID('{81CAA5D8-90C5-11D3-9F7B-00C04F6BC886}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TableQueryName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, IQueryName, IQueryName2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

class NetworkGlobalTurnDelayCategory(CoClass):
    u'A container for defining global turn delay for a specified angle category and from, to, and cross road category.'
    _reg_clsid_ = GUID('{615C84CE-A6C5-4ADA-AD2E-A478350C009B}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class INetworkGlobalTurnDelayCategory(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the turn delay for a specified category of global turns.'
    _iid_ = GUID('{A67BF724-A607-4820-B8E4-7017A398066C}')
    _idlflags_ = ['oleautomation']
NetworkGlobalTurnDelayCategory._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkGlobalTurnDelayCategory, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class FeatureClassName(CoClass):
    u'Esri Feature Class Name object.'
    _reg_clsid_ = GUID('{198846D0-CA42-11D1-AA7C-00C04FA33A15}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
FeatureClassName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, IDatasetName2, ITableName, IObjectClassName, IFeatureClassName, ITopologyClassName, IModelInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IMetadata, IMetadataEdit, INativeTypeInfo, ISQLPrivilege]

class NetworkGlobalTurnDelayEvaluator(CoClass):
    u'A container for describing a network attribute evaluator for global turn delay whose values are specified by global turn delay settings.'
    _reg_clsid_ = GUID('{CE072DE5-8C43-4D4F-945B-5FCEB34A7281}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class INetworkGlobalTurnDelayEvaluator(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the global turn delay evaluator.'
    _iid_ = GUID('{17D76A4B-1365-4E09-A4E0-9BF02DBF07B2}')
    _idlflags_ = ['oleautomation']
NetworkGlobalTurnDelayEvaluator._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkEvaluator, INetworkEvaluator2, INetworkEvaluatorSetup, INetworkGlobalTurnDelayEvaluator, IGPDescribe]

class FeatureQueryName(CoClass):
    u'Esri Feature Query Name object.'
    _reg_clsid_ = GUID('{81CAA5D9-90C5-11D3-9F7B-00C04F6BC886}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
FeatureQueryName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, IFeatureClassName, IQueryName, IQueryName2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

class AttachmentDataArray(CoClass):
    u'Esri AttachmentDataArray object.'
    _reg_clsid_ = GUID('{99AD256B-EEF2-406C-AE5C-F11F7A3AF7F3}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
AttachmentDataArray._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IAttachmentDataArray, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

class NetworkSourceDirections(CoClass):
    u'A container for describing how to generate driving directions for a network dataset source.'
    _reg_clsid_ = GUID('{29E5825C-6BCD-4063-A6DA-F943E8B262BD}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
NetworkSourceDirections._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkSourceDirections, INetworkSourceDirections2, INetworkSourceDirections3]

class NetworkFunctionEvaluator(CoClass):
    u'A container for describing a network evaluator function.'
    _reg_clsid_ = GUID('{92B433F5-556E-4A39-B674-D02213634CC4}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
NetworkFunctionEvaluator._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkEvaluator, INetworkEvaluator2, INetworkEvaluatorSetup, INetworkFunctionEvaluator, IGPDescribe]

class MemoryRelationshipClassName(CoClass):
    u'A name class that represents as in memory relationship class.'
    _reg_clsid_ = GUID('{6DBA211B-EBDB-11D3-9F84-00C04F6BC886}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IMemoryRelationshipClassName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that define a memory relationship class name.'
    _iid_ = GUID('{91DBC553-EB2D-11D3-9F84-00C04F6BC886}')
    _idlflags_ = ['oleautomation']
MemoryRelationshipClassName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, IRelationshipClassName, IMemoryRelationshipClassName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

class Record(CoClass):
    u'Esri Record Object.'
    _reg_clsid_ = GUID('{6C2DE02A-1B28-4680-B65F-5F2F58BF1FFA}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Record._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRecord, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize]

class Shields(CoClass):
    u'A container for describing how driving directions are refined using shields.'
    _reg_clsid_ = GUID('{F2D646B4-F0D6-40B5-A798-823C1BFA4E99}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Shields._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IShields]

ITinNodeInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'Node info.')], HRESULT, 'NodeEditInfo',
              ( ['in'], c_int, 'nodeIndex' ),
              ( ['retval', 'out'], POINTER(c_int), 'pInfo' )),
]
################################################################
## code template for ITinNodeInfo implementation
##class ITinNodeInfo_Impl(object):
##    @property
##    def NodeEditInfo(self, nodeIndex):
##        u'Node info.'
##        #return pInfo
##

class QueryTableName(CoClass):
    u'Esri Query table Name object.'
    _reg_clsid_ = GUID('{793873DE-C0BB-48F4-A6BF-F6F83FA3C1BC}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
QueryTableName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IQueryTableName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, ITableName]

class StreetNameFields(CoClass):
    u'A container for describing street name fields used to generate driving directions.'
    _reg_clsid_ = GUID('{FE4B2823-407B-418E-AB25-40D85767EA24}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
StreetNameFields._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IStreetNameFields, IStreetNameFields2]

class NetworkDirections(CoClass):
    u'A container for describing and using network directions.'
    _reg_clsid_ = GUID('{F921BD59-A8AD-4425-B5A0-75BCE88D22FE}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
NetworkDirections._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkDirections, INetworkDirections2, ISignposts]

class INetworkEdge2(INetworkEdge):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of this network edge element.'
    _iid_ = GUID('{97669D60-6FEA-450D-AAD4-A917F19FD420}')
    _idlflags_ = ['dual', 'oleautomation']
INetworkEdge2._methods_ = [
    COMMETHOD([dispid(210), helpstring(u'Value of this edge element along the given range for the given network attribute ID.'), 'propget'], HRESULT, 'PartialEdgeAttributeValue',
              ( ['in'], c_double, 'fromPosition' ),
              ( ['in'], c_double, 'toPosition' ),
              ( ['in'], c_int, 'AttributeID' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'AttributeValue' )),
    COMMETHOD([dispid(1610874881), helpstring(u'Value of this network element for the given network attribute ID and local time.'), 'propget'], HRESULT, 'AttributeValueAtTime',
              ( ['in'], c_int, 'AttributeID' ),
              ( ['in'], c_double, 'localTime' ),
              ( ['in'], esriNetworkTimeUsage, 'timeUsage' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'AttributeValue' )),
    COMMETHOD([dispid(1610874882), helpstring(u'Value of this partial edge element for the given network attribute ID and local.'), 'propget'], HRESULT, 'PartialEdgeAttributeValueAtTime',
              ( ['in'], c_double, 'fromPosition' ),
              ( ['in'], c_double, 'toPosition' ),
              ( ['in'], c_int, 'AttributeID' ),
              ( ['in'], c_double, 'localTime' ),
              ( ['in'], esriNetworkTimeUsage, 'timeUsage' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'AttributeValue' )),
    COMMETHOD([dispid(1610874883), helpstring(u'Indicates if the network edge element is a hyperedge.'), 'propget'], HRESULT, 'IsHyperedge',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsHyperedge' )),
    COMMETHOD([dispid(1610874884), helpstring(u'Indicates if the network edge element has a covering hyperedge.'), 'propget'], HRESULT, 'HasCoveringHyperedge',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasCoveringHyperedge' )),
    COMMETHOD([dispid(1610874885), helpstring(u'Queries the covering hyperedge of the network edge element and returns its related positions along the covering hyperedge.')], HRESULT, 'QueryCoveringHyperedge',
              ( ['in'], POINTER(INetworkEdge), 'Edge' ),
              ( ['out'], POINTER(c_double), 'fromPosition' ),
              ( ['out'], POINTER(c_double), 'toPosition' )),
    COMMETHOD([dispid(1610874886), helpstring(u'Returns the number of edges covered by this edge.'), 'propget'], HRESULT, 'CoveredEdgeCount',
              ( ['retval', 'out'], POINTER(c_int), 'CoveredEdgeCount' )),
    COMMETHOD([dispid(1610874887), helpstring(u'Used to iterate over the edges covered by this edge.')], HRESULT, 'QueryCoveredEdge',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(INetworkEdge), 'Edge' )),
]
################################################################
## code template for INetworkEdge2 implementation
##class INetworkEdge2_Impl(object):
##    @property
##    def PartialEdgeAttributeValue(self, fromPosition, toPosition, AttributeID):
##        u'Value of this edge element along the given range for the given network attribute ID.'
##        #return AttributeValue
##
##    @property
##    def HasCoveringHyperedge(self):
##        u'Indicates if the network edge element has a covering hyperedge.'
##        #return HasCoveringHyperedge
##
##    @property
##    def IsHyperedge(self):
##        u'Indicates if the network edge element is a hyperedge.'
##        #return IsHyperedge
##
##    @property
##    def AttributeValueAtTime(self, AttributeID, localTime, timeUsage):
##        u'Value of this network element for the given network attribute ID and local time.'
##        #return AttributeValue
##
##    def QueryCoveredEdge(self, Index, Edge):
##        u'Used to iterate over the edges covered by this edge.'
##        #return 
##
##    @property
##    def PartialEdgeAttributeValueAtTime(self, fromPosition, toPosition, AttributeID, localTime, timeUsage):
##        u'Value of this partial edge element for the given network attribute ID and local.'
##        #return AttributeValue
##
##    @property
##    def CoveredEdgeCount(self):
##        u'Returns the number of edges covered by this edge.'
##        #return CoveredEdgeCount
##
##    def QueryCoveringHyperedge(self, Edge):
##        u'Queries the covering hyperedge of the network edge element and returns its related positions along the covering hyperedge.'
##        #return fromPosition, toPosition
##

class AttachmentData(CoClass):
    u'Esri AttachmentData object.'
    _reg_clsid_ = GUID('{0B8EBBC6-7944-4AF8-9914-C2946CEDD8EB}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
AttachmentData._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IAttachmentData, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

ISurfaceIntersectionEvents._methods_ = [
    COMMETHOD([helpstring(u'This event is fired when the difference/depth-surface has been completed.')], HRESULT, 'OnIntersect',
              ( ['in'], POINTER(ITinSurface), 'pDifferenceSurface' )),
]
################################################################
## code template for ISurfaceIntersectionEvents implementation
##class ISurfaceIntersectionEvents_Impl(object):
##    def OnIntersect(self, pDifferenceSurface):
##        u'This event is fired when the difference/depth-surface has been completed.'
##        #return 
##

class AttachmentInfo(CoClass):
    u'Esri AttachmentInfo object.'
    _reg_clsid_ = GUID('{B78722FB-E016-40B7-BC4E-CBAF9C74E7DC}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
AttachmentInfo._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IAttachmentInfo2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class RelationshipClassName(CoClass):
    u'Esri Relationship Class Name object.'
    _reg_clsid_ = GUID('{311C2EE1-DA65-11D2-8A54-000000000000}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
RelationshipClassName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, IRelationshipClassName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IMetadata, IMetadataEdit, INativeTypeInfo, ISQLPrivilege]

class DirectionsAttributeMapping(CoClass):
    u'A container for a directions attribute mapping.'
    _reg_clsid_ = GUID('{D8366160-0E1F-4109-A765-FAC6D37C2EF2}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDirectionsAttributeMapping(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the properties for directions attribute mapping.'
    _iid_ = GUID('{1AC4346C-1C68-4FE9-A5DA-FAE0EEAFC02E}')
    _idlflags_ = ['oleautomation']
DirectionsAttributeMapping._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDirectionsAttributeMapping]

class DirectionsLandmarkSource(CoClass):
    u'Directions source information for landmark source feature classes.'
    _reg_clsid_ = GUID('{64C88F04-9557-4113-89C9-469955527422}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DirectionsLandmarkSource._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDirectionsLandmarkSource]

class NetworkDatasetFDExtension(CoClass):
    u"A container for describing this network dataset's feature dataset extension properties."
    _reg_clsid_ = GUID('{C9C119F6-A49C-4BB9-948B-CF04C30701D4}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IFeatureDatasetExtension(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to standard functionality found in all feature dataset extensions.'
    _iid_ = GUID('{F0A333BF-B864-4B71-8FF5-086DA66851D8}')
    _idlflags_ = ['oleautomation']
NetworkDatasetFDExtension._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IFeatureDatasetExtension, IDatasetContainer3, IDatasetEdit]

class AttachmentInfoArray(CoClass):
    u'Esri AttachmentInfoArray object.'
    _reg_clsid_ = GUID('{0B85E7B3-5FF9-457A-A3EF-1043E2CC1611}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
AttachmentInfoArray._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IAttachmentInfoArray, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

class NetworkDatasetWorkspaceExtension(CoClass):
    u"A container for describing this network dataset's workspace extension properties."
    _reg_clsid_ = GUID('{4C1B151C-48C3-46C5-AB57-E6B941A1D00A}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IWorkspaceExtension2(IWorkspaceExtension):
    _case_insensitive_ = True
    u'Provides access to members that supply workspace extension information.'
    _iid_ = GUID('{727F1038-6DF0-4972-B504-4A44CFEA2B57}')
    _idlflags_ = ['oleautomation']
NetworkDatasetWorkspaceExtension._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IWorkspaceExtension2, IWorkspaceExtensionControl, IDatasetContainer3, IDatasetEdit]

ITinEdit2._methods_ = [
    COMMETHOD([helpstring(u"Reset TIN's extent.")], HRESULT, 'ResetExtent',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'pExtent' )),
    COMMETHOD([helpstring(u'Apply constrained Delaunay from now on.')], HRESULT, 'SetToConstrainedDelaunay'),
    COMMETHOD([helpstring(u'Swap the specified edge and set the TIN as constrained Delaunay triangulation.')], HRESULT, 'SwapEdge',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], esriTinEdgeType, 'Type' ),
              ( ['in'], c_int, 'Tag' ),
              ( ['retval', 'out'], POINTER(c_int), 'pNewIndex' )),
    COMMETHOD([helpstring(u'Adds features from a 3D multi-point feature class to the TIN.')], HRESULT, 'AddFrom3dMultipointFeatureClass',
              ( ['in'], POINTER(IFeatureClass), 'pFeatureClass' ),
              ( ['in'], POINTER(ISpatialFilter), 'pClippingFilter' )),
    COMMETHOD([helpstring(u'Saves a snapshot of the TIN that is been edited to disk.')], HRESULT, 'SaveSnapshot',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], VARIANT_BOOL, 'bOverWrite' )),
]
################################################################
## code template for ITinEdit2 implementation
##class ITinEdit2_Impl(object):
##    def SwapEdge(self, Index, Type, Tag):
##        u'Swap the specified edge and set the TIN as constrained Delaunay triangulation.'
##        #return pNewIndex
##
##    def SaveSnapshot(self, Name, bOverWrite):
##        u'Saves a snapshot of the TIN that is been edited to disk.'
##        #return 
##
##    def SetToConstrainedDelaunay(self):
##        u'Apply constrained Delaunay from now on.'
##        #return 
##
##    def ResetExtent(self, pExtent):
##        u"Reset TIN's extent."
##        #return 
##
##    def AddFrom3dMultipointFeatureClass(self, pFeatureClass, pClippingFilter):
##        u'Adds features from a 3D multi-point feature class to the TIN.'
##        #return 
##

class WorkspaceName(CoClass):
    u'Esri Workspace Name object.'
    _reg_clsid_ = GUID('{5A350011-E371-11D1-AA82-00C04FA33A15}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
WorkspaceName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IWorkspaceName, IWorkspaceName2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IDatabaseCompact, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize]

class INetworkDataset2(INetworkDataset):
    _case_insensitive_ = True
    u'Provides access to members that query the schema of the network dataset.'
    _iid_ = GUID('{D108C47B-2030-47C6-9B1A-269C73CDD1FB}')
    _idlflags_ = ['oleautomation']
INetworkDataset2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The dirty area polygon of the network dataset.')], HRESULT, 'DirtyArea',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon), 'Location' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon)), 'dirtyAreaPolygon' )),
]
################################################################
## code template for INetworkDataset2 implementation
##class INetworkDataset2_Impl(object):
##    @property
##    def DirtyArea(self, Location):
##        u'The dirty area polygon of the network dataset.'
##        #return dirtyAreaPolygon
##

class NetworkDatasetName(CoClass):
    u"A container for describing this network dataset's name properties."
    _reg_clsid_ = GUID('{8167FE6A-E992-4ECB-B6AE-E5DFE4655247}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class INetworkDatasetName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to properties of a network dataset name.'
    _iid_ = GUID('{F0294B3E-F11D-4857-A932-B468F5ABC02B}')
    _idlflags_ = ['oleautomation']
NetworkDatasetName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkDatasetName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, IDatasetName2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IMetadata, IMetadataEdit, INativeTypeInfo]

class EditorTrackingInfo(CoClass):
    u'EditorTrackingInfo co-class.'
    _reg_clsid_ = GUID('{11E0012E-B45D-42D5-89EB-BCF9D1CFCFBE}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
EditorTrackingInfo._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEditorTrackingInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class GeometricNetworkName(CoClass):
    u'Esri Geometric Network Name object.'
    _reg_clsid_ = GUID('{F452B4D2-9A95-11D2-AACF-00C04FA37B82}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
GeometricNetworkName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, IGeometricNetworkName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IMetadata, IMetadataEdit, INativeTypeInfo]

class NetworkTurn(CoClass):
    u'A container for querying information on a network dataset turn element.'
    _reg_clsid_ = GUID('{94B4C767-CC2B-41D5-A9DD-4F1F8FBCA1BA}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
NetworkTurn._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkElement, INetworkTurn, INetworkTurn2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class NetworkDataset(CoClass):
    u'A container for querying information about a network dataset.'
    _reg_clsid_ = GUID('{5F1F09D6-571A-4B71-8DDE-DDA40C2A61BB}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IDatasetComponent2(IDatasetComponent):
    _case_insensitive_ = True
    u'Provides access to the common functionality found on all dataset components.'
    _iid_ = GUID('{06422A95-1F61-4E3C-9523-BCDAE837DDCB}')
    _idlflags_ = ['oleautomation']
NetworkDataset._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDatasetComponent2, IFeatureClassContainer, INetworkDataset, INetworkDataset2, INetworkBuild, INetworkQuery, INetworkQuery2, INetworkQuery3, IDataset, IDatasetEdit, IDatasetEditInfo, ISchemaLock, IVersionedObject2, IDatasetAnalyze, IGeoDataset, IGeoDatasetSchemaEdit, IMetadata, IMetadataEdit, INativeTypeInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class Attachment(CoClass):
    u'.'
    _reg_clsid_ = GUID('{6BB22B36-EEF6-4945-83DB-0BE9D010CF6B}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Attachment._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IAttachment2]

class NetworkJunction(CoClass):
    u'A container for querying information on a network dataset junction element.'
    _reg_clsid_ = GUID('{69244A33-366D-47C2-8C9C-96CAC2CD6A14}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class INetworkJunction2(INetworkJunction):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of this network junction element.'
    _iid_ = GUID('{10C79F21-F00B-4F1F-B6D3-372C8DC3C129}')
    _idlflags_ = ['dual', 'oleautomation']
NetworkJunction._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkElement, INetworkJunction, INetworkJunction2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class AttributeRule(CoClass):
    u'Esri attribute rule object.'
    _reg_clsid_ = GUID('{54C085D0-84EB-11D2-AB61-000000000000}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IAttributeRule(IRule):
    _case_insensitive_ = True
    u'Provides access to members that return, modify and validate attribute rules.'
    _iid_ = GUID('{9ED62772-475D-11D2-9932-0000F80372B4}')
    _idlflags_ = ['oleautomation']
AttributeRule._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRule, IAttributeRule]

class UnknownDatasetName(CoClass):
    u'Esri Unknown Dataset Name object.'
    _reg_clsid_ = GUID('{06783DB1-E5EE-11D1-B0A2-0000F878082E}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
UnknownDatasetName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName]

class NetworkForwardStarAdjacencies(CoClass):
    u'A container for retrieving information about the elements adjacent to a given network element.'
    _reg_clsid_ = GUID('{C8D3323A-CA44-4303-AB9E-F92A19BB61CB}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
NetworkForwardStarAdjacencies._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkForwardStarAdjacencies]

class NetworkEdge(CoClass):
    u'A container for querying information on a network dataset edge element.'
    _reg_clsid_ = GUID('{6976B647-C243-49AB-9CFB-8D7E253F3B1A}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
NetworkEdge._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkElement, INetworkEdge, INetworkEdge2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class EnumAttachment(CoClass):
    u'.'
    _reg_clsid_ = GUID('{2501262B-34A1-4362-B40C-BBBC185318D6}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
EnumAttachment._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumAttachment]

class Replica(CoClass):
    u'Esri Replica object.'
    _reg_clsid_ = GUID('{92008893-9E26-46EB-BAF7-FDF8BEAC848E}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Replica._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IReplica, IReplica2, IReplica3, IReplicaEdit, IReplicaEdit2]

class AttachmentManager(CoClass):
    u'.'
    _reg_clsid_ = GUID('{431A70D7-5F78-4574-82E4-C2CE96356D79}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
AttachmentManager._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IAttachmentManager]

class CodedValueDomain(CoClass):
    u'Esri Attribute set constraint object.'
    _reg_clsid_ = GUID('{F84C6C1B-47FF-11D2-9933-0000F80372B4}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
CodedValueDomain._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDomain, ICodedValueDomain, ICodedValueDomain2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, ISchemaLock, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize]

class OwnershipBasedAccessControl(CoClass):
    u'Ownership-based feature-level Access Control.'
    _reg_clsid_ = GUID('{4FFA97B6-ED84-4B38-A6E7-D06C3DD6D0B5}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
OwnershipBasedAccessControl._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IOwnershipBasedAccessControl, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class ISaveAs2(ISaveAs):
    _case_insensitive_ = True
    u'Provides access to methods for saving as a new Raster Dataset.'
    _iid_ = GUID('{BA3968E7-A18B-416D-8140-E4A06068CF1B}')
    _idlflags_ = ['oleautomation']
ISaveAs2._methods_ = [
    COMMETHOD([helpstring(u'Creates a new persistent Raster Dataset of a given format and specified storage definition.')], HRESULT, 'SaveAsRasterDataset',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IWorkspace), 'Workspace' ),
              ( ['in'], BSTR, 'Format' ),
              ( ['in'], POINTER(IRasterStorageDef), 'StorageDef' ),
              ( ['retval', 'out'], POINTER(POINTER(IRasterDataset)), 'Dataset' )),
]
################################################################
## code template for ISaveAs2 implementation
##class ISaveAs2_Impl(object):
##    def SaveAsRasterDataset(self, Name, Workspace, Format, StorageDef):
##        u'Creates a new persistent Raster Dataset of a given format and specified storage definition.'
##        #return Dataset
##

class NetworkScriptEvaluatorFunctions(CoClass):
    u'A container for scriptable members in a network script evaluator.'
    _reg_clsid_ = GUID('{77B4488D-BD07-4A6D-9479-2EADF8CA761A}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
NetworkScriptEvaluatorFunctions._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkScriptEvaluatorFunctions]


# values for enumeration 'esriNetworkSourceType'
esriNSTNetworkSource = 0
esriNSTSystemJunction = 1
esriNSTJunctionFeature = 2
esriNSTEdgeFeature = 3
esriNSTTurnFeature = 4
esriNetworkSourceType = c_int # enum
INetworkSource._methods_ = [
    COMMETHOD(['propget', helpstring(u'Unique identifier of this network source.')], HRESULT, 'ID',
              ( ['retval', 'out'], POINTER(c_int), 'ID' )),
    COMMETHOD(['propget', helpstring(u'Network element type of this network source.')], HRESULT, 'ElementType',
              ( ['retval', 'out'], POINTER(esriNetworkElementType), 'ElementType' )),
    COMMETHOD(['propput', helpstring(u'Network element type of this network source.')], HRESULT, 'ElementType',
              ( ['in'], esriNetworkElementType, 'ElementType' )),
    COMMETHOD(['propget', helpstring(u'Name of the class associated with this network source.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'SourceName' )),
    COMMETHOD(['propput', helpstring(u'Name of the class associated with this network source.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'SourceName' )),
    COMMETHOD(['propget', helpstring(u'Property set of this network source.')], HRESULT, 'Properties',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'sourceProperties' )),
    COMMETHOD(['propput', helpstring(u'Property set of this network source.')], HRESULT, 'Properties',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'sourceProperties' )),
    COMMETHOD(['propget', helpstring(u"Indicates if the source object's geometry is used in determining network connectivity.")], HRESULT, 'UsesGeometryInConnectivity',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'usesGeometry' )),
    COMMETHOD(['propget', helpstring(u'Type of network source.')], HRESULT, 'SourceType',
              ( ['retval', 'out'], POINTER(esriNetworkSourceType), 'SourceType' )),
    COMMETHOD(['propget', helpstring(u'The driving directions settings for this network source.')], HRESULT, 'NetworkSourceDirections',
              ( ['retval', 'out'], POINTER(POINTER(INetworkSourceDirections)), 'sourceDirections' )),
    COMMETHOD(['propputref', helpstring(u'The driving directions settings for this network source.')], HRESULT, 'NetworkSourceDirections',
              ( ['in'], POINTER(INetworkSourceDirections), 'sourceDirections' )),
]
################################################################
## code template for INetworkSource implementation
##class INetworkSource_Impl(object):
##    @property
##    def SourceType(self):
##        u'Type of network source.'
##        #return SourceType
##
##    @property
##    def ID(self):
##        u'Unique identifier of this network source.'
##        #return ID
##
##    def NetworkSourceDirections(self, sourceDirections):
##        u'The driving directions settings for this network source.'
##        #return 
##
##    @property
##    def UsesGeometryInConnectivity(self):
##        u"Indicates if the source object's geometry is used in determining network connectivity."
##        #return usesGeometry
##
##    def _get(self):
##        u'Network element type of this network source.'
##        #return ElementType
##    def _set(self, ElementType):
##        u'Network element type of this network source.'
##    ElementType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Property set of this network source.'
##        #return sourceProperties
##    def _set(self, sourceProperties):
##        u'Property set of this network source.'
##    Properties = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Name of the class associated with this network source.'
##        #return SourceName
##    def _set(self, SourceName):
##        u'Name of the class associated with this network source.'
##    Name = property(_get, _set, doc = _set.__doc__)
##

IAttachmentData._methods_ = [
    COMMETHOD(['propget', helpstring(u'Attachment as bytes.')], HRESULT, 'Data',
              ( ['retval', 'out'], POINTER(_midlSAFEARRAY(c_ubyte)), 'Data' )),
    COMMETHOD(['propput', helpstring(u'Attachment as bytes.')], HRESULT, 'Data',
              ( ['in'], _midlSAFEARRAY(c_ubyte), 'Data' )),
    COMMETHOD(['propget', helpstring(u'Content type that indicates the type of the mime content.')], HRESULT, 'AttachmentInfo',
              ( ['retval', 'out'], POINTER(POINTER(IAttachmentInfo)), 'AttachmentInfo' )),
    COMMETHOD(['propputref', helpstring(u'Content type that indicates the type of the mime content.')], HRESULT, 'AttachmentInfo',
              ( ['in'], POINTER(IAttachmentInfo), 'AttachmentInfo' )),
    COMMETHOD(['propget', helpstring(u'URL.')], HRESULT, 'URL',
              ( ['retval', 'out'], POINTER(BSTR), 'URL' )),
    COMMETHOD(['propput', helpstring(u'URL.')], HRESULT, 'URL',
              ( ['in'], BSTR, 'URL' )),
    COMMETHOD(['propget', helpstring(u'Transport Type.')], HRESULT, 'TransportType',
              ( ['retval', 'out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.esriTransportType), 'pTransportType' )),
    COMMETHOD(['propput', helpstring(u'Transport Type.')], HRESULT, 'TransportType',
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.esriTransportType, 'pTransportType' )),
]
################################################################
## code template for IAttachmentData implementation
##class IAttachmentData_Impl(object):
##    def _get(self):
##        u'URL.'
##        #return URL
##    def _set(self, URL):
##        u'URL.'
##    URL = property(_get, _set, doc = _set.__doc__)
##
##    def AttachmentInfo(self, AttachmentInfo):
##        u'Content type that indicates the type of the mime content.'
##        #return 
##
##    def _get(self):
##        u'Transport Type.'
##        #return pTransportType
##    def _set(self, pTransportType):
##        u'Transport Type.'
##    TransportType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Attachment as bytes.'
##        #return Data
##    def _set(self, Data):
##        u'Attachment as bytes.'
##    Data = property(_get, _set, doc = _set.__doc__)
##

IWorkspaceHelper._methods_ = [
    COMMETHOD(['propget', helpstring(u'The workspace for this workspace helper.')], HRESULT, 'Workspace',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'Workspace' )),
]
################################################################
## code template for IWorkspaceHelper implementation
##class IWorkspaceHelper_Impl(object):
##    @property
##    def Workspace(self):
##        u'The workspace for this workspace helper.'
##        #return Workspace
##

IWorkspaceExtensionControl._methods_ = [
    COMMETHOD([helpstring(u'Initializes the  extension, passing in a reference to its workspace helper.')], HRESULT, 'Init',
              ( ['in'], POINTER(IWorkspaceHelper), 'WorkspaceHelper' )),
    COMMETHOD([helpstring(u'Informs the extension that its workspace helper (and workspace) are going away.')], HRESULT, 'Shutdown'),
]
################################################################
## code template for IWorkspaceExtensionControl implementation
##class IWorkspaceExtensionControl_Impl(object):
##    def Init(self, WorkspaceHelper):
##        u'Initializes the  extension, passing in a reference to its workspace helper.'
##        #return 
##
##    def Shutdown(self):
##        u'Informs the extension that its workspace helper (and workspace) are going away.'
##        #return 
##

class IRepairConnectivityProgress(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return the warnings found while repairing connectivity.'
    _iid_ = GUID('{EAE208A2-2CBA-4BB6-A854-B05D389AA798}')
    _idlflags_ = ['oleautomation']
IRepairConnectivityProgress._methods_ = [
    COMMETHOD(['propget', helpstring(u'An array of strings that display errors found while repairing connectivity.')], HRESULT, 'Warnings',
              ( ['retval', 'out'], POINTER(VARIANT), 'Warnings' )),
]
################################################################
## code template for IRepairConnectivityProgress implementation
##class IRepairConnectivityProgress_Impl(object):
##    @property
##    def Warnings(self):
##        u'An array of strings that display errors found while repairing connectivity.'
##        #return Warnings
##

IGPMessagesCallback._methods_ = [
    COMMETHOD([helpstring(u'Fired when a geoprocessing message is added.')], HRESULT, 'MessageAdded',
              ( ['in'], POINTER(IGPMessage), 'Message' )),
]
################################################################
## code template for IGPMessagesCallback implementation
##class IGPMessagesCallback_Impl(object):
##    def MessageAdded(self, Message):
##        u'Fired when a geoprocessing message is added.'
##        #return 
##

IWorkspaceEditEvents._methods_ = [
    COMMETHOD([helpstring(u'This event is fired after editing is started on a workspace.')], HRESULT, 'OnStartEditing',
              ( ['in'], VARIANT_BOOL, 'withUndoRedo' )),
    COMMETHOD([helpstring(u'This event is fired after editing is stopped on a workspace.')], HRESULT, 'OnStopEditing',
              ( ['in'], VARIANT_BOOL, 'saveEdits' )),
    COMMETHOD([helpstring(u'This event is fired after an edit operation is started.')], HRESULT, 'OnStartEditOperation'),
    COMMETHOD([helpstring(u'This event is fired after an edit operation is aborted. Any cached row objects must be discarded / refreshed.')], HRESULT, 'OnAbortEditOperation'),
    COMMETHOD([helpstring(u'This event is fired after an edit operation is stopped (successfully completed).')], HRESULT, 'OnStopEditOperation'),
    COMMETHOD([helpstring(u'This event is fired after a (completed) edit operation is undone. Any cached row objects must be discarded / refreshed.')], HRESULT, 'OnUndoEditOperation'),
    COMMETHOD([helpstring(u'This event is fired after an undone edit operation is redone. Any cached row objects must be discarded / refreshed.')], HRESULT, 'OnRedoEditOperation'),
]
################################################################
## code template for IWorkspaceEditEvents implementation
##class IWorkspaceEditEvents_Impl(object):
##    def OnStartEditing(self, withUndoRedo):
##        u'This event is fired after editing is started on a workspace.'
##        #return 
##
##    def OnUndoEditOperation(self):
##        u'This event is fired after a (completed) edit operation is undone. Any cached row objects must be discarded / refreshed.'
##        #return 
##
##    def OnAbortEditOperation(self):
##        u'This event is fired after an edit operation is aborted. Any cached row objects must be discarded / refreshed.'
##        #return 
##
##    def OnRedoEditOperation(self):
##        u'This event is fired after an undone edit operation is redone. Any cached row objects must be discarded / refreshed.'
##        #return 
##
##    def OnStartEditOperation(self):
##        u'This event is fired after an edit operation is started.'
##        #return 
##
##    def OnStopEditOperation(self):
##        u'This event is fired after an edit operation is stopped (successfully completed).'
##        #return 
##
##    def OnStopEditing(self, saveEdits):
##        u'This event is fired after editing is stopped on a workspace.'
##        #return 
##

class IRelationshipClass3(IRelationshipClass2):
    _case_insensitive_ = True
    u'Provides access to .'
    _iid_ = GUID('{79CE2129-71DB-422A-87D8-B6A3807B2062}')
    _idlflags_ = ['oleautomation']
class IEnumRelationship(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate relationships.'
    _iid_ = GUID('{22B00695-8895-11D2-8A0D-006097AFF44E}')
    _idlflags_ = ['oleautomation']
IRelationshipClass._methods_ = [
    COMMETHOD(['propget', helpstring(u'The relationship origin primary Key.')], HRESULT, 'OriginPrimaryKey',
              ( ['retval', 'out'], POINTER(BSTR), 'relOrigPKey' )),
    COMMETHOD(['propget', helpstring(u'The relationship destination primary Key.')], HRESULT, 'DestinationPrimaryKey',
              ( ['retval', 'out'], POINTER(BSTR), 'relDestPKey' )),
    COMMETHOD(['propget', helpstring(u'The relationship origin foreign Key.')], HRESULT, 'OriginForeignKey',
              ( ['retval', 'out'], POINTER(BSTR), 'relOrigFKey' )),
    COMMETHOD(['propget', helpstring(u'The relationship destination foreign Key.')], HRESULT, 'DestinationForeignKey',
              ( ['retval', 'out'], POINTER(BSTR), 'relDestFKey' )),
    COMMETHOD(['propget', helpstring(u'The relationship class ID.')], HRESULT, 'RelationshipClassID',
              ( ['retval', 'out'], POINTER(c_int), 'relClassId' )),
    COMMETHOD(['propget', helpstring(u'The origin object class.')], HRESULT, 'OriginClass',
              ( ['retval', 'out'], POINTER(POINTER(IObjectClass)), 'OriginClass' )),
    COMMETHOD(['propget', helpstring(u'The destination object class.')], HRESULT, 'DestinationClass',
              ( ['retval', 'out'], POINTER(POINTER(IObjectClass)), 'DestinationClass' )),
    COMMETHOD(['propget', helpstring(u'The feature dataset, if any, to which this relationship class belongs.')], HRESULT, 'FeatureDataset',
              ( ['retval', 'out'], POINTER(POINTER(IFeatureDataset)), 'FeatureDataset' )),
    COMMETHOD(['propget', helpstring(u'The forward path label for the relationship class.')], HRESULT, 'ForwardPathLabel',
              ( ['retval', 'out'], POINTER(BSTR), 'ForwardLabel' )),
    COMMETHOD(['propget', helpstring(u'The backward path label for the relationship class.')], HRESULT, 'BackwardPathLabel',
              ( ['retval', 'out'], POINTER(BSTR), 'BackwardLabel' )),
    COMMETHOD(['propget', helpstring(u'The cardinality for the relationship class.')], HRESULT, 'Cardinality',
              ( ['retval', 'out'], POINTER(esriRelCardinality), 'Cardinality' )),
    COMMETHOD(['propget', helpstring(u'The notification direction for the relationship class.')], HRESULT, 'Notification',
              ( ['retval', 'out'], POINTER(esriRelNotification), 'Notification' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the relationships in this relationship class have attributes.')], HRESULT, 'IsAttributed',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsAttributed' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the relationship class represents a composite relationship in which the origin object class represents the composite object.')], HRESULT, 'IsComposite',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsComposite' )),
    COMMETHOD([helpstring(u'Creates a new relationship between the two specified objects.')], HRESULT, 'CreateRelationship',
              ( ['in'], POINTER(IObject), 'OriginObject' ),
              ( ['in'], POINTER(IObject), 'DestinationObject' ),
              ( ['retval', 'out'], POINTER(POINTER(IRelationship)), 'Relationship' )),
    COMMETHOD([helpstring(u'Get the relationship that associates the two specified objects.')], HRESULT, 'GetRelationship',
              ( ['in'], POINTER(IObject), 'OriginObject' ),
              ( ['in'], POINTER(IObject), 'DestinationObject' ),
              ( ['retval', 'out'], POINTER(POINTER(IRelationship)), 'Relationship' )),
    COMMETHOD([helpstring(u'Deletes the relationship that associates the two specified objects.')], HRESULT, 'DeleteRelationship',
              ( ['in'], POINTER(IObject), 'OriginObject' ),
              ( ['in'], POINTER(IObject), 'DestinationObject' )),
    COMMETHOD([helpstring(u'Gets the objects that are related to the specified object.')], HRESULT, 'GetObjectsRelatedToObject',
              ( ['in'], POINTER(IObject), 'anObject' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet)), 'relatedObjects' )),
    COMMETHOD([helpstring(u'Get all relationships that apply to a specified object.')], HRESULT, 'GetRelationshipsForObject',
              ( ['in'], POINTER(IObject), 'anObject' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumRelationship)), 'relationships' )),
    COMMETHOD([helpstring(u'Deletes all relationships that apply to a specified object.')], HRESULT, 'DeleteRelationshipsForObject',
              ( ['in'], POINTER(IObject), 'anObject' )),
    COMMETHOD([helpstring(u'Gets the objects that are related to the specified origin or destination object set.')], HRESULT, 'GetObjectsRelatedToObjectSet',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'anObjectSet' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet)), 'relatedObjectSet' )),
    COMMETHOD([helpstring(u'Get all relationships that apply to the specified origin or destination object set.')], HRESULT, 'GetRelationshipsForObjectSet',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'anObjectSet' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumRelationship)), 'relationships' )),
    COMMETHOD([helpstring(u'Gets rows pairs of objects that are related to the specified origin or destination object set.')], HRESULT, 'GetObjectsMatchingObjectSet',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'srcObjectSet' ),
              ( ['retval', 'out'], POINTER(POINTER(IRelClassEnumRowPairs)), 'matchedPairRows' )),
    COMMETHOD([helpstring(u'Deletes all relationships that apply to the specified origin or destination object set.')], HRESULT, 'DeleteRelationshipsForObjectSet',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'anObjectSet' )),
    COMMETHOD(['propget', helpstring(u'The relationship rules that apply to this relationship class.')], HRESULT, 'RelationshipRules',
              ( ['retval', 'out'], POINTER(POINTER(IEnumRule)), 'Rules' )),
    COMMETHOD([helpstring(u'Adds a relationship rule to this relationship class.')], HRESULT, 'AddRelationshipRule',
              ( ['in'], POINTER(IRule), 'Rule' )),
    COMMETHOD([helpstring(u'Deletes a relationship rule from this relationship class.')], HRESULT, 'DeleteRelationshipRule',
              ( ['in'], POINTER(IRule), 'Rule' )),
]
################################################################
## code template for IRelationshipClass implementation
##class IRelationshipClass_Impl(object):
##    @property
##    def OriginPrimaryKey(self):
##        u'The relationship origin primary Key.'
##        #return relOrigPKey
##
##    @property
##    def DestinationPrimaryKey(self):
##        u'The relationship destination primary Key.'
##        #return relDestPKey
##
##    def DeleteRelationship(self, OriginObject, DestinationObject):
##        u'Deletes the relationship that associates the two specified objects.'
##        #return 
##
##    @property
##    def Notification(self):
##        u'The notification direction for the relationship class.'
##        #return Notification
##
##    @property
##    def OriginClass(self):
##        u'The origin object class.'
##        #return OriginClass
##
##    @property
##    def FeatureDataset(self):
##        u'The feature dataset, if any, to which this relationship class belongs.'
##        #return FeatureDataset
##
##    def DeleteRelationshipRule(self, Rule):
##        u'Deletes a relationship rule from this relationship class.'
##        #return 
##
##    @property
##    def DestinationClass(self):
##        u'The destination object class.'
##        #return DestinationClass
##
##    @property
##    def BackwardPathLabel(self):
##        u'The backward path label for the relationship class.'
##        #return BackwardLabel
##
##    @property
##    def DestinationForeignKey(self):
##        u'The relationship destination foreign Key.'
##        #return relDestFKey
##
##    @property
##    def Cardinality(self):
##        u'The cardinality for the relationship class.'
##        #return Cardinality
##
##    def GetRelationshipsForObjectSet(self, anObjectSet):
##        u'Get all relationships that apply to the specified origin or destination object set.'
##        #return relationships
##
##    @property
##    def RelationshipClassID(self):
##        u'The relationship class ID.'
##        #return relClassId
##
##    def AddRelationshipRule(self, Rule):
##        u'Adds a relationship rule to this relationship class.'
##        #return 
##
##    @property
##    def IsComposite(self):
##        u'Indicates if the relationship class represents a composite relationship in which the origin object class represents the composite object.'
##        #return IsComposite
##
##    @property
##    def OriginForeignKey(self):
##        u'The relationship origin foreign Key.'
##        #return relOrigFKey
##
##    def GetObjectsRelatedToObjectSet(self, anObjectSet):
##        u'Gets the objects that are related to the specified origin or destination object set.'
##        #return relatedObjectSet
##
##    @property
##    def ForwardPathLabel(self):
##        u'The forward path label for the relationship class.'
##        #return ForwardLabel
##
##    def GetObjectsMatchingObjectSet(self, srcObjectSet):
##        u'Gets rows pairs of objects that are related to the specified origin or destination object set.'
##        #return matchedPairRows
##
##    def DeleteRelationshipsForObject(self, anObject):
##        u'Deletes all relationships that apply to a specified object.'
##        #return 
##
##    def GetRelationship(self, OriginObject, DestinationObject):
##        u'Get the relationship that associates the two specified objects.'
##        #return Relationship
##
##    @property
##    def RelationshipRules(self):
##        u'The relationship rules that apply to this relationship class.'
##        #return Rules
##
##    def GetRelationshipsForObject(self, anObject):
##        u'Get all relationships that apply to a specified object.'
##        #return relationships
##
##    @property
##    def IsAttributed(self):
##        u'Indicates if the relationships in this relationship class have attributes.'
##        #return IsAttributed
##
##    def DeleteRelationshipsForObjectSet(self, anObjectSet):
##        u'Deletes all relationships that apply to the specified origin or destination object set.'
##        #return 
##
##    def GetObjectsRelatedToObject(self, anObject):
##        u'Gets the objects that are related to the specified object.'
##        #return relatedObjects
##
##    def CreateRelationship(self, OriginObject, DestinationObject):
##        u'Creates a new relationship between the two specified objects.'
##        #return Relationship
##

IRelationshipClass2._methods_ = [
    COMMETHOD([helpstring(u'Gets rows pairs of objects that are related to the specified origin or destination object set, that also meet the query filter expression.')], HRESULT, 'GetObjectsMatchingObjectSetEx',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'srcObjectSet' ),
              ( ['in'], POINTER(IQueryFilter), 'queryFilterAppliedToMatchingObjects' ),
              ( ['in'], VARIANT_BOOL, 'returnAllObjectMatches' ),
              ( ['retval', 'out'], POINTER(POINTER(IRelClassEnumRowPairs)), 'matchedPairRows' )),
    COMMETHOD([helpstring(u'Gets rows pairs of objects that are related to the specified origin or destination object array, that also meet the query filter expression.')], HRESULT, 'GetObjectsMatchingObjectArray',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'srcObjectArray' ),
              ( ['in'], POINTER(IQueryFilter), 'queryFilterAppliedToMatchingObjects' ),
              ( ['in'], VARIANT_BOOL, 'returnAllObjectMatches' ),
              ( ['retval', 'out'], POINTER(POINTER(IRelClassEnumRowPairs)), 'matchedPairRows' )),
]
################################################################
## code template for IRelationshipClass2 implementation
##class IRelationshipClass2_Impl(object):
##    def GetObjectsMatchingObjectArray(self, srcObjectArray, queryFilterAppliedToMatchingObjects, returnAllObjectMatches):
##        u'Gets rows pairs of objects that are related to the specified origin or destination object array, that also meet the query filter expression.'
##        #return matchedPairRows
##
##    def GetObjectsMatchingObjectSetEx(self, srcObjectSet, queryFilterAppliedToMatchingObjects, returnAllObjectMatches):
##        u'Gets rows pairs of objects that are related to the specified origin or destination object set, that also meet the query filter expression.'
##        #return matchedPairRows
##

IRelationshipClass3._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the relationships in this relationship class corresponds to table attachments.')], HRESULT, 'IsAttachmentRelationship',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsAttachment' )),
]
################################################################
## code template for IRelationshipClass3 implementation
##class IRelationshipClass3_Impl(object):
##    @property
##    def IsAttachmentRelationship(self):
##        u'Indicates if the relationships in this relationship class corresponds to table attachments.'
##        #return IsAttachment
##

class Names(CoClass):
    u'An object to hold a collection of names.'
    _reg_clsid_ = GUID('{E141C7AF-1C30-4B67-99A1-2DDD2FF2C04D}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Names._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

IWorkspaceEditEvents2._methods_ = [
    COMMETHOD([helpstring(u'This event is fired after editing is stopped on a workspace but before edits are saved.')], HRESULT, 'OnBeginStopEditing',
              ( ['in'], VARIANT_BOOL, 'saveEdits' )),
]
################################################################
## code template for IWorkspaceEditEvents2 implementation
##class IWorkspaceEditEvents2_Impl(object):
##    def OnBeginStopEditing(self, saveEdits):
##        u'This event is fired after editing is stopped on a workspace but before edits are saved.'
##        #return 
##

IWorkspaceExtension._methods_ = [
    COMMETHOD(['propget', helpstring(u'The Name for this Workspace Extension.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The GUID that identifies this Workspace Extension.')], HRESULT, 'GUID',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'GUID' )),
    COMMETHOD(['propget', helpstring(u'The private datasets that should not be exposed to browsers.')], HRESULT, 'PrivateDatasetNames',
              ( ['in'], esriDatasetType, 'dtype' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IEnumBSTR)), 'privateNames' )),
    COMMETHOD(['propget', helpstring(u'Any data dictionary tables that should not be exposed to browsers and should not participate in edit sessions.')], HRESULT, 'DataDictionaryTableNames',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IEnumBSTR)), 'privateNames' )),
]
################################################################
## code template for IWorkspaceExtension implementation
##class IWorkspaceExtension_Impl(object):
##    @property
##    def DataDictionaryTableNames(self):
##        u'Any data dictionary tables that should not be exposed to browsers and should not participate in edit sessions.'
##        #return privateNames
##
##    @property
##    def PrivateDatasetNames(self, dtype):
##        u'The private datasets that should not be exposed to browsers.'
##        #return privateNames
##
##    @property
##    def GUID(self):
##        u'The GUID that identifies this Workspace Extension.'
##        #return GUID
##
##    @property
##    def Name(self):
##        u'The Name for this Workspace Extension.'
##        #return Name
##

class GPVersionInfos(CoClass):
    u'A collection of GPVersionInfo objects.'
    _reg_clsid_ = GUID('{A3003C8D-E092-4BE7-AB7D-AE5CCB94DA84}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
GPVersionInfos._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPVersionInfos, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

ISpatialCacheManager._methods_ = [
    COMMETHOD([helpstring(u'Fills the spatial cache using the specified extent.')], HRESULT, 'FillCache',
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'Extent' )),
    COMMETHOD([helpstring(u'Empties the spatial cache.')], HRESULT, 'EmptyCache'),
    COMMETHOD(['propget', helpstring(u'Indicates if the spatial cache is full.')], HRESULT, 'CacheIsFull',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsFull' )),
    COMMETHOD(['propget', helpstring(u'The extent of the spatial cache.')], HRESULT, 'CacheExtent',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'envelope' )),
]
################################################################
## code template for ISpatialCacheManager implementation
##class ISpatialCacheManager_Impl(object):
##    def EmptyCache(self):
##        u'Empties the spatial cache.'
##        #return 
##
##    def FillCache(self, Extent):
##        u'Fills the spatial cache using the specified extent.'
##        #return 
##
##    @property
##    def CacheIsFull(self):
##        u'Indicates if the spatial cache is full.'
##        #return IsFull
##
##    @property
##    def CacheExtent(self):
##        u'The extent of the spatial cache.'
##        #return envelope
##

IRelatedObjectEvents._methods_ = [
    COMMETHOD([helpstring(u'Notifies this object that a related object changed.')], HRESULT, 'RelatedObjectChanged',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(IObject), 'objectThatChanged' )),
    COMMETHOD([helpstring(u'Notifies this object that a related object moved.')], HRESULT, 'RelatedObjectMoved',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(IObject), 'objectThatChanged' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ILine), 'moveVector' )),
    COMMETHOD([helpstring(u'Notifies this object that a set of objects with relationships to the input set of objects moved.')], HRESULT, 'RelatedObjectSetMoved',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'objectsThatNeedToChange' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'objectsThatChanged' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ILine), 'moveVector' )),
    COMMETHOD([helpstring(u'Notifies this object that a related object rotated.')], HRESULT, 'RelatedObjectRotated',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(IObject), 'objectThatChanged' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'Origin' ),
              ( [], c_double, 'Angle' )),
    COMMETHOD([helpstring(u'Notifies this object that a set of objects with relationships to the input set of objects rotated.')], HRESULT, 'RelatedObjectSetRotated',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'objectsThatNeedToChange' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'objectsThatChanged' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'Origin' ),
              ( [], c_double, 'Angle' )),
]
################################################################
## code template for IRelatedObjectEvents implementation
##class IRelatedObjectEvents_Impl(object):
##    def RelatedObjectChanged(self, RelationshipClass, objectThatChanged):
##        u'Notifies this object that a related object changed.'
##        #return 
##
##    def RelatedObjectSetRotated(self, RelationshipClass, objectsThatNeedToChange, objectsThatChanged, Origin, Angle):
##        u'Notifies this object that a set of objects with relationships to the input set of objects rotated.'
##        #return 
##
##    def RelatedObjectMoved(self, RelationshipClass, objectThatChanged, moveVector):
##        u'Notifies this object that a related object moved.'
##        #return 
##
##    def RelatedObjectSetMoved(self, RelationshipClass, objectsThatNeedToChange, objectsThatChanged, moveVector):
##        u'Notifies this object that a set of objects with relationships to the input set of objects moved.'
##        #return 
##
##    def RelatedObjectRotated(self, RelationshipClass, objectThatChanged, Origin, Angle):
##        u'Notifies this object that a related object rotated.'
##        #return 
##

class IPlugInFileOperationsClass(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for copying, deleting and renaming classes in a dataset helper.'
    _iid_ = GUID('{0936597F-EBE1-4B29-BAC4-47DAFCE72A36}')
    _idlflags_ = ['oleautomation']
IPlugInFileOperationsClass._methods_ = [
    COMMETHOD([helpstring(u'True if this dataset can be copied.')], HRESULT, 'CanCopy',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanCopy' )),
    COMMETHOD([helpstring(u'Copies this dataset to a new dataset with the specified name.')], HRESULT, 'Copy',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['in'], BSTR, 'copyName' ),
              ( ['in'], POINTER(IWorkspace), 'copyWorkspace' )),
    COMMETHOD([helpstring(u'True if this dataset can be deleted.')], HRESULT, 'CanDelete',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanDelete' )),
    COMMETHOD([helpstring(u'Deletes this dataset.')], HRESULT, 'Delete',
              ( ['in'], c_int, 'ClassIndex' )),
    COMMETHOD([helpstring(u'True if this dataset can be renamed.')], HRESULT, 'CanRename',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanRename' )),
    COMMETHOD([helpstring(u'Renames this dataset.')], HRESULT, 'Rename',
              ( ['in'], c_int, 'ClassIndex' ),
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(BSTR), 'newName' )),
]
################################################################
## code template for IPlugInFileOperationsClass implementation
##class IPlugInFileOperationsClass_Impl(object):
##    def Rename(self, ClassIndex, Name):
##        u'Renames this dataset.'
##        #return newName
##
##    def CanCopy(self, ClassIndex):
##        u'True if this dataset can be copied.'
##        #return CanCopy
##
##    def CanDelete(self, ClassIndex):
##        u'True if this dataset can be deleted.'
##        #return CanDelete
##
##    def Copy(self, ClassIndex, copyName, copyWorkspace):
##        u'Copies this dataset to a new dataset with the specified name.'
##        #return 
##
##    def CanRename(self, ClassIndex):
##        u'True if this dataset can be renamed.'
##        #return CanRename
##
##    def Delete(self, ClassIndex):
##        u'Deletes this dataset.'
##        #return 
##

class GPVersionInfo(CoClass):
    u'The (GP) VersionInfo object.'
    _reg_clsid_ = GUID('{4FF43CDC-CBF0-4ECF-A31B-6B80433AD46D}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
GPVersionInfo._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPVersionInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class DEGeoDataServer(CoClass):
    u'GeoDataServer Object Data Element object.'
    _reg_clsid_ = GUID('{D6E941E4-9EF4-438D-AE31-2FB082A2814D}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DEGeoDataServer._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEGeoDataServer, IDEServerObject, IDataElement, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDocumentVersionSupportGEN, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class ISpatialCacheManager3(ISpatialCacheManager2):
    _case_insensitive_ = True
    u'Provides access to members that control the Spatial Cache Management.'
    _iid_ = GUID('{74D077B7-4F42-439D-8ACA-2433CBD15916}')
    _idlflags_ = ['oleautomation']
ISpatialCacheManager2._methods_ = [
    COMMETHOD([helpstring(u'Fills the spatial cache using the specified extent with an expansion factor.')], HRESULT, 'FillCacheEx',
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'Extent' ),
              ( [], c_double, 'expansionFactor' )),
    COMMETHOD(['propget', helpstring(u'The extent expansion factor for the spatial cache.')], HRESULT, 'CacheExpansionFactor',
              ( ['retval', 'out'], POINTER(c_double), 'expansionFactor' )),
]
################################################################
## code template for ISpatialCacheManager2 implementation
##class ISpatialCacheManager2_Impl(object):
##    @property
##    def CacheExpansionFactor(self):
##        u'The extent expansion factor for the spatial cache.'
##        #return expansionFactor
##
##    def FillCacheEx(self, Extent, expansionFactor):
##        u'Fills the spatial cache using the specified extent with an expansion factor.'
##        #return 
##

ISpatialCacheManager3._methods_ = [
    COMMETHOD([helpstring(u'Fills the spatial cache using the specified extent with an expansion factor.')], HRESULT, 'FillCacheWithCancel',
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'Extent' ),
              ( [], c_double, 'expansionFactor' ),
              ( [], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITrackCancel), 'cancelTraker' )),
]
################################################################
## code template for ISpatialCacheManager3 implementation
##class ISpatialCacheManager3_Impl(object):
##    def FillCacheWithCancel(self, Extent, expansionFactor, cancelTraker):
##        u'Fills the spatial cache using the specified extent with an expansion factor.'
##        #return 
##

class IEnumNodeEdge(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the set of edges incident on the specified node.'
    _iid_ = GUID('{5CEE64BE-56DC-11D5-9FEE-00C04F6BDD7F}')
    _idlflags_ = ['oleautomation']
IEnumNodeEdge._methods_ = [
    COMMETHOD([helpstring(u'Resets this eumerator.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u"Returns the next edge in clockwise or counterclockwise order about the node. 'atFrom' is true if the from point of the edge is incident on this node.")], HRESULT, 'Next',
              ( ['out'], POINTER(POINTER(ITopologyEdge)), 'nextEdge' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'atFrom' )),
    COMMETHOD(['propget', helpstring(u'The number of edges entering and leaving this node. A closed edge will be counted twice.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'EdgeCount' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this enumerator is returning edges in clockwise order, or false if it is returning them in counterclockwise order.')], HRESULT, 'IsClockwise',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'clockwise' )),
]
################################################################
## code template for IEnumNodeEdge implementation
##class IEnumNodeEdge_Impl(object):
##    def Reset(self):
##        u'Resets this eumerator.'
##        #return 
##
##    @property
##    def Count(self):
##        u'The number of edges entering and leaving this node. A closed edge will be counted twice.'
##        #return EdgeCount
##
##    @property
##    def IsClockwise(self):
##        u'Indicates if this enumerator is returning edges in clockwise order, or false if it is returning them in counterclockwise order.'
##        #return clockwise
##
##    def Next(self):
##        u"Returns the next edge in clockwise or counterclockwise order about the node. 'atFrom' is true if the from point of the edge is incident on this node."
##        #return nextEdge, atFrom
##

IWorkspaceExtension2._methods_ = [
    COMMETHOD([helpstring(u'Indicates if the workspace extension owns the dataset type.')], HRESULT, 'OwnsDatasetType',
              ( ['in'], esriDatasetType, 'DatasetType' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'ownsType' )),
    COMMETHOD(['propget', helpstring(u'The workspace associated with this Workspace Extension.')], HRESULT, 'Workspace',
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'Workspace' )),
]
################################################################
## code template for IWorkspaceExtension2 implementation
##class IWorkspaceExtension2_Impl(object):
##    def OwnsDatasetType(self, DatasetType):
##        u'Indicates if the workspace extension owns the dataset type.'
##        #return ownsType
##
##    @property
##    def Workspace(self):
##        u'The workspace associated with this Workspace Extension.'
##        #return Workspace
##

IRecord._methods_ = [
    COMMETHOD(['propget'], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget'], HRESULT, 'Value',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
    COMMETHOD([], HRESULT, 'Add',
              ( ['in'], VARIANT, 'Value' )),
    COMMETHOD(['propput'], HRESULT, 'Value',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], VARIANT, 'Value' )),
]
################################################################
## code template for IRecord implementation
##class IRecord_Impl(object):
##    @property
##    def Count(self):
##        '-no docstring-'
##        #return Count
##
##    def Add(self, Value):
##        '-no docstring-'
##        #return 
##
##    def _get(self, Index):
##        '-no docstring-'
##        #return Value
##    def _set(self, Index, Value):
##        '-no docstring-'
##    Value = property(_get, _set, doc = _set.__doc__)
##

ITinNodeArray._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of elements in the array.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'pCount' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'Remove',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'RemoveAll'),
    COMMETHOD(['propget', helpstring(u'The element in the array.')], HRESULT, 'Element',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinNode)), 'ppNode' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'Add',
              ( ['in'], POINTER(ITinNode), 'pNode' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'Insert',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(ITinNode), 'pNode' )),
]
################################################################
## code template for ITinNodeArray implementation
##class ITinNodeArray_Impl(object):
##    @property
##    def Count(self):
##        u'The number of elements in the array.'
##        #return pCount
##
##    def Insert(self, Index, pNode):
##        u'Restricted.'
##        #return 
##
##    def Remove(self, Index):
##        u'Restricted.'
##        #return 
##
##    @property
##    def Element(self, Index):
##        u'The element in the array.'
##        #return ppNode
##
##    def RemoveAll(self):
##        u'Restricted.'
##        #return 
##
##    def Add(self, pNode):
##        u'Restricted.'
##        #return 
##

ITableName._methods_ = [
]
################################################################
## code template for ITableName implementation
##class ITableName_Impl(object):

class IGeoDataset2(IGeoDataset):
    _case_insensitive_ = True
    u'Provides access to members that provide geodata transformation information about a Dataset.'
    _iid_ = GUID('{8FEFCCB6-9519-4700-9E01-3450106A11A4}')
    _idlflags_ = ['oleautomation']
IGeoDataset2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The geodata transformation of the GeoDataset.')], HRESULT, 'GeodataXform',
              ( ['retval', 'out'], POINTER(POINTER(IGeodataXform)), 'xform' )),
    COMMETHOD(['propget', helpstring(u'The native spatial reference of the GeoDataset (before transformation applied).')], HRESULT, 'NativeSpatialReference',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference)), 'SpatialReference' )),
    COMMETHOD(['propget', helpstring(u'The native extent of the GeoDataset (before transformation applied).')], HRESULT, 'NativeExtent',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope)), 'Extent' )),
]
################################################################
## code template for IGeoDataset2 implementation
##class IGeoDataset2_Impl(object):
##    @property
##    def GeodataXform(self):
##        u'The geodata transformation of the GeoDataset.'
##        #return xform
##
##    @property
##    def NativeSpatialReference(self):
##        u'The native spatial reference of the GeoDataset (before transformation applied).'
##        #return SpatialReference
##
##    @property
##    def NativeExtent(self):
##        u'The native extent of the GeoDataset (before transformation applied).'
##        #return Extent
##

ITinEdgeArray._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of elements in the array.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'pCount' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'Remove',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'RemoveAll'),
    COMMETHOD(['propget', helpstring(u'The element in the array.')], HRESULT, 'Element',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinEdge)), 'ppEdge' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'Add',
              ( ['in'], POINTER(ITinEdge), 'pEdge' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'Insert',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(ITinEdge), 'pEdge' )),
]
################################################################
## code template for ITinEdgeArray implementation
##class ITinEdgeArray_Impl(object):
##    @property
##    def Count(self):
##        u'The number of elements in the array.'
##        #return pCount
##
##    def Insert(self, Index, pEdge):
##        u'Restricted.'
##        #return 
##
##    def Remove(self, Index):
##        u'Restricted.'
##        #return 
##
##    @property
##    def Element(self, Index):
##        u'The element in the array.'
##        #return ppEdge
##
##    def RemoveAll(self):
##        u'Restricted.'
##        #return 
##
##    def Add(self, pEdge):
##        u'Restricted.'
##        #return 
##

IGeodataXform._methods_ = [
    COMMETHOD(['propget', helpstring(u'The output spatial reference after applying this transform.')], HRESULT, 'SpatialReference',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference)), 'spatialRefence' )),
    COMMETHOD(['propputref', helpstring(u'The output spatial reference after applying this transform.')], HRESULT, 'SpatialReference',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'spatialRefence' )),
    COMMETHOD(['propget', helpstring(u'The domains in output space.')], HRESULT, 'Domains',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometryCollection)), 'Domains' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this geodata transform is an identity transform.')], HRESULT, 'IsIdentity',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsIdentity' )),
    COMMETHOD([helpstring(u'Transforms a set of points in a given direction.')], HRESULT, 'Transform',
              ( ['in'], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriTransformDirection, 'Direction' ),
              ( ['in'], c_int, 'npoints' ),
              ( ['in', 'out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPoint), 'points' )),
    COMMETHOD([helpstring(u'Transforms a cellsize in a given direction.')], HRESULT, 'TransformCellsize',
              ( ['in'], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriTransformDirection, 'Direction' ),
              ( ['in', 'out'], POINTER(c_double), 'dx' ),
              ( ['in', 'out'], POINTER(c_double), 'dy' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'AreaOfInterest' )),
    COMMETHOD([helpstring(u'Transforms an extent in a given direction.')], HRESULT, 'TransformExtent',
              ( ['in'], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriTransformDirection, 'Direction' ),
              ( ['in', 'out'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'Extent' )),
    COMMETHOD([helpstring(u'Transforms a point collection in a given direction')], HRESULT, 'TransformPoints',
              ( ['in'], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriTransformDirection, 'Direction' ),
              ( ['in', 'out'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPointCollection), 'points' )),
]
################################################################
## code template for IGeodataXform implementation
##class IGeodataXform_Impl(object):
##    def Transform(self, Direction, npoints):
##        u'Transforms a set of points in a given direction.'
##        #return points
##
##    def TransformPoints(self, Direction):
##        u'Transforms a point collection in a given direction'
##        #return points
##
##    def SpatialReference(self, spatialRefence):
##        u'The output spatial reference after applying this transform.'
##        #return 
##
##    def TransformExtent(self, Direction):
##        u'Transforms an extent in a given direction.'
##        #return Extent
##
##    @property
##    def IsIdentity(self):
##        u'Indicates if this geodata transform is an identity transform.'
##        #return IsIdentity
##
##    @property
##    def Domains(self):
##        u'The domains in output space.'
##        #return Domains
##
##    def TransformCellsize(self, Direction, AreaOfInterest):
##        u'Transforms a cellsize in a given direction.'
##        #return dx, dy
##

class DEGlobeServerType(CoClass):
    u'MapServer Object Data Element object type.'
    _reg_clsid_ = GUID('{7EF7D3E7-D2EE-4B19-AF27-56DDEE7E0B14}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DEGlobeServerType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEGlobeServerType, IDEServerObjectType, IGxFilterInfo, IDataElementType, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class IRelatedObjectClassEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that occur when related objects are created.'
    _iid_ = GUID('{22B00699-8895-11D2-8A0D-006097AFF44E}')
    _idlflags_ = ['oleautomation']
IRelatedObjectClassEvents._methods_ = [
    COMMETHOD([helpstring(u'Notifies this object class that a related object was created.')], HRESULT, 'RelatedObjectCreated',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(IObject), 'objectThatWasCreated' )),
]
################################################################
## code template for IRelatedObjectClassEvents implementation
##class IRelatedObjectClassEvents_Impl(object):
##    def RelatedObjectCreated(self, RelationshipClass, objectThatWasCreated):
##        u'Notifies this object class that a related object was created.'
##        #return 
##

IWorkspaceExtensionManager._methods_ = [
    COMMETHOD([helpstring(u'Finds the specified workspace extension by its globally unique id.')], HRESULT, 'FindExtension',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'GUID' ),
              ( ['retval', 'out'], POINTER(POINTER(IWorkspaceExtension)), 'WorkspaceExtension' )),
    COMMETHOD(['propget', helpstring(u'The number of workspace extensions.')], HRESULT, 'ExtensionCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The workspace extension at this index.')], HRESULT, 'Extension',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IWorkspaceExtension)), 'Extension' )),
    COMMETHOD([helpstring(u'Registers this workspace extension with the database making it required for successful connection to this database.')], HRESULT, 'RegisterExtension',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'GUID' )),
    COMMETHOD([helpstring(u'UnRegisters this workspace extension making it no longer required for successful connection to this database.')], HRESULT, 'UnRegisterExtension',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'GUID' )),
]
################################################################
## code template for IWorkspaceExtensionManager implementation
##class IWorkspaceExtensionManager_Impl(object):
##    def FindExtension(self, GUID):
##        u'Finds the specified workspace extension by its globally unique id.'
##        #return WorkspaceExtension
##
##    @property
##    def ExtensionCount(self):
##        u'The number of workspace extensions.'
##        #return Count
##
##    def RegisterExtension(self, Name, GUID):
##        u'Registers this workspace extension with the database making it required for successful connection to this database.'
##        #return 
##
##    def UnRegisterExtension(self, GUID):
##        u'UnRegisters this workspace extension making it no longer required for successful connection to this database.'
##        #return 
##
##    @property
##    def Extension(self, Index):
##        u'The workspace extension at this index.'
##        #return Extension
##

class DEMapServer(CoClass):
    u'MapServer Object Data Element object.'
    _reg_clsid_ = GUID('{69D74387-7684-458E-84A3-BD9E013669C0}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DEMapServer._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEMapServer, IDEServerObject, IDataElement, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDocumentVersionSupportGEN, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class IPlugInCreateDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{6E845A7E-4C0B-4CC0-AFE2-7A17215E7EEF}')
    _idlflags_ = ['oleautomation']
IPlugInCreateDataset._methods_ = [
    COMMETHOD([], HRESULT, 'CreateDataset',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IFields), 'FieldSet' ),
              ( ['retval', 'out'], POINTER(POINTER(IPlugInDatasetHelper)), 'datasetHelper' )),
]
################################################################
## code template for IPlugInCreateDataset implementation
##class IPlugInCreateDataset_Impl(object):
##    def CreateDataset(self, Name, FieldSet):
##        '-no docstring-'
##        #return datasetHelper
##

IPlugInDatasetLoader._methods_ = [
    COMMETHOD([], HRESULT, 'InsertRow',
              ( ['in'], POINTER(IRowBuffer), 'Row' )),
]
################################################################
## code template for IPlugInDatasetLoader implementation
##class IPlugInDatasetLoader_Impl(object):
##    def InsertRow(self, Row):
##        '-no docstring-'
##        #return 
##

IGeoDatasetSchemaEdit._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the spatial reference of the dataset can be altered.')], HRESULT, 'CanAlterSpatialReference',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'canAlter' )),
    COMMETHOD([helpstring(u'Alters the spatial reference of the dataset to match the coordinate system of the input spatial reference, does not reproject the data.')], HRESULT, 'AlterSpatialReference',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference' )),
]
################################################################
## code template for IGeoDatasetSchemaEdit implementation
##class IGeoDatasetSchemaEdit_Impl(object):
##    def AlterSpatialReference(self, SpatialReference):
##        u'Alters the spatial reference of the dataset to match the coordinate system of the input spatial reference, does not reproject the data.'
##        #return 
##
##    @property
##    def CanAlterSpatialReference(self):
##        u'Indicates if the spatial reference of the dataset can be altered.'
##        #return canAlter
##

class IRelatedObjectClassEvents2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that occur when related objects are modified.'
    _iid_ = GUID('{C0E79D54-844C-11D4-80ED-00C04F601565}')
    _idlflags_ = ['oleautomation']
IRelatedObjectClassEvents2._methods_ = [
    COMMETHOD([helpstring(u'Notifies this object that a related object changed.')], HRESULT, 'RelatedObjectChanged',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(IObject), 'objectThatChanged' ),
              ( ['in'], POINTER(IObject), 'RelatedObject' )),
    COMMETHOD([helpstring(u'Notifies this object that a related object moved.')], HRESULT, 'RelatedObjectMoved',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(IObject), 'objectThatChanged' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ILine), 'moveVector' ),
              ( ['in'], POINTER(IObject), 'RelatedObject' )),
    COMMETHOD([helpstring(u'Notifies this object that a set of objects with relationships to the input set of objects moved.')], HRESULT, 'RelatedObjectSetMoved',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'objectsThatNeedToChange' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'objectsThatChanged' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ILine), 'moveVector' )),
    COMMETHOD([helpstring(u'Notifies this object that a related object rotated.')], HRESULT, 'RelatedObjectRotated',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(IObject), 'objectThatChanged' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'Origin' ),
              ( ['in'], c_double, 'Angle' ),
              ( ['in'], POINTER(IObject), 'RelatedObject' )),
    COMMETHOD([helpstring(u'Notifies this object that a set of objects with relationships to the input set of objects rotated.')], HRESULT, 'RelatedObjectSetRotated',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'objectsThatNeedToChange' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'objectsThatChanged' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'Origin' ),
              ( ['in'], c_double, 'Angle' )),
]
################################################################
## code template for IRelatedObjectClassEvents2 implementation
##class IRelatedObjectClassEvents2_Impl(object):
##    def RelatedObjectChanged(self, RelationshipClass, objectThatChanged, RelatedObject):
##        u'Notifies this object that a related object changed.'
##        #return 
##
##    def RelatedObjectSetRotated(self, RelationshipClass, objectsThatNeedToChange, objectsThatChanged, Origin, Angle):
##        u'Notifies this object that a set of objects with relationships to the input set of objects rotated.'
##        #return 
##
##    def RelatedObjectMoved(self, RelationshipClass, objectThatChanged, moveVector, RelatedObject):
##        u'Notifies this object that a related object moved.'
##        #return 
##
##    def RelatedObjectSetMoved(self, RelationshipClass, objectsThatNeedToChange, objectsThatChanged, moveVector):
##        u'Notifies this object that a set of objects with relationships to the input set of objects moved.'
##        #return 
##
##    def RelatedObjectRotated(self, RelationshipClass, objectThatChanged, Origin, Angle, RelatedObject):
##        u'Notifies this object that a related object rotated.'
##        #return 
##

class PlugInWorkspaceFactory(CoClass):
    u'Esri Plug-In Workspace Factory.'
    _reg_clsid_ = GUID('{13BA0A70-7FE3-4A24-BB0B-750B44E72AD6}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
PlugInWorkspaceFactory._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IWorkspaceFactory, IWorkspaceFactory2]

ITinTriangleArray._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of elements in the array.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'pCount' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'Remove',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'RemoveAll'),
    COMMETHOD(['propget', helpstring(u'The element in the array.')], HRESULT, 'Element',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinTriangle)), 'ppTriangle' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'Add',
              ( ['in'], POINTER(ITinTriangle), 'pTriangle' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'Insert',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(ITinTriangle), 'pTriangle' )),
]
################################################################
## code template for ITinTriangleArray implementation
##class ITinTriangleArray_Impl(object):
##    @property
##    def Count(self):
##        u'The number of elements in the array.'
##        #return pCount
##
##    def Insert(self, Index, pTriangle):
##        u'Restricted.'
##        #return 
##
##    def Remove(self, Index):
##        u'Restricted.'
##        #return 
##
##    @property
##    def Element(self, Index):
##        u'The element in the array.'
##        #return ppTriangle
##
##    def RemoveAll(self):
##        u'Restricted.'
##        #return 
##
##    def Add(self, pTriangle):
##        u'Restricted.'
##        #return 
##

IValidate._methods_ = [
    COMMETHOD([helpstring(u'Returns all invalid fields.')], HRESULT, 'GetInvalidFields',
              ( ['retval', 'out'], POINTER(POINTER(IFields)), 'invalidFields' )),
    COMMETHOD([helpstring(u'The set of all invalid rules.')], HRESULT, 'GetInvalidRules',
              ( ['retval', 'out'], POINTER(POINTER(IEnumRule)), 'invalidRules' )),
    COMMETHOD([helpstring(u'The set of all invalid rules for the specified field.')], HRESULT, 'GetInvalidRulesByField',
              ( ['in'], BSTR, 'FieldName' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumRule)), 'invalidRules' )),
    COMMETHOD([helpstring(u'Validates the row.')], HRESULT, 'Validate',
              ( ['out'], POINTER(BSTR), 'errorMessage' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isValid' )),
]
################################################################
## code template for IValidate implementation
##class IValidate_Impl(object):
##    def GetInvalidFields(self):
##        u'Returns all invalid fields.'
##        #return invalidFields
##
##    def Validate(self):
##        u'Validates the row.'
##        #return errorMessage, isValid
##
##    def GetInvalidRules(self):
##        u'The set of all invalid rules.'
##        #return invalidRules
##
##    def GetInvalidRulesByField(self, FieldName):
##        u'The set of all invalid rules for the specified field.'
##        #return invalidRules
##

ITinEdge._methods_ = [
    COMMETHOD(['propget', helpstring(u'The type of the specified edge.')], HRESULT, 'Type',
              ( ['retval', 'out'], POINTER(esriTinEdgeType), 'pType' )),
    COMMETHOD(['propget', helpstring(u'The originating node of the specified edge.')], HRESULT, 'FromNode',
              ( ['retval', 'out'], POINTER(POINTER(ITinNode)), 'ppNode' )),
    COMMETHOD(['propget', helpstring(u'The terminating node of the specified edge.')], HRESULT, 'ToNode',
              ( ['retval', 'out'], POINTER(POINTER(ITinNode)), 'ppNode' )),
    COMMETHOD(['propget', helpstring(u'The triangle on the left (opposite) side of the specified edge.')], HRESULT, 'LeftTriangle',
              ( ['retval', 'out'], POINTER(POINTER(ITinTriangle)), 'ppTriangle' )),
    COMMETHOD(['propget', helpstring(u'The triangle on the right side of the specified edge.')], HRESULT, 'RightTriangle',
              ( ['retval', 'out'], POINTER(POINTER(ITinTriangle)), 'ppTriangle' )),
    COMMETHOD(['propget', helpstring(u'The projected length of the specified edge.')], HRESULT, 'Length',
              ( ['retval', 'out'], POINTER(c_double), 'pLength' )),
    COMMETHOD(['propget', helpstring(u'The length of the specified edge measured on the TIN surface.')], HRESULT, 'Length3D',
              ( ['retval', 'out'], POINTER(c_double), 'pLength' )),
    COMMETHOD(['hidden', helpstring(u'The azimuthal direction of the specified edge beginning at the FromNode in radians.'), 'propget'], HRESULT, 'AzimuthRadians',
              ( ['retval', 'out'], POINTER(c_double), 'pAzimuth' )),
    COMMETHOD(['propget', helpstring(u'The azimuthal direction of the specified edge beginning at the FromNode in degrees.')], HRESULT, 'AzimuthDegrees',
              ( ['retval', 'out'], POINTER(c_double), 'pAzimuth' )),
    COMMETHOD([helpstring(u'Sets the specified edge equal to a line.')], HRESULT, 'QueryAsLine',
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ILine), 'pLine' )),
    COMMETHOD([helpstring(u'Sets the specified edge equal to its nodes as points with z values.')], HRESULT, 'QueryAsWKSPointZs',
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pFrom' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pTo' )),
    COMMETHOD([helpstring(u'Returns the next triangle sharing the FromNode of the specified edge in a clockwise direction.')], HRESULT, 'GetNextInTriangle',
              ( ['retval', 'out'], POINTER(POINTER(ITinEdge)), 'ppEdge' )),
    COMMETHOD([helpstring(u'Returns the next triangle sharing the FromNode of the specified edge in a counter-clockwise direction.')], HRESULT, 'GetPreviousInTriangle',
              ( ['retval', 'out'], POINTER(POINTER(ITinEdge)), 'ppEdge' )),
    COMMETHOD([helpstring(u'Returns the corresponding edge of the triangle opposite to the specified edge.')], HRESULT, 'GetNeighbor',
              ( ['retval', 'out'], POINTER(POINTER(ITinEdge)), 'ppEdge' )),
    COMMETHOD([helpstring(u'Returns the edge beginning at the ToNode of the specified edge.')], HRESULT, 'GetNextCW',
              ( ['retval', 'out'], POINTER(POINTER(ITinEdge)), 'ppEdge' )),
    COMMETHOD([helpstring(u'Returns the edge terminating at the FromNode of the specified edge.')], HRESULT, 'GetNextCCW',
              ( ['retval', 'out'], POINTER(POINTER(ITinEdge)), 'ppEdge' )),
    COMMETHOD(['restricted', helpstring(u'Restricted.')], HRESULT, 'IsSameEdge',
              ( ['in'], POINTER(ITinEdge), 'pEdge' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsTheSame' )),
]
################################################################
## code template for ITinEdge implementation
##class ITinEdge_Impl(object):
##    @property
##    def Length3D(self):
##        u'The length of the specified edge measured on the TIN surface.'
##        #return pLength
##
##    @property
##    def RightTriangle(self):
##        u'The triangle on the right side of the specified edge.'
##        #return ppTriangle
##
##    def IsSameEdge(self, pEdge):
##        u'Restricted.'
##        #return pbIsTheSame
##
##    def GetNeighbor(self):
##        u'Returns the corresponding edge of the triangle opposite to the specified edge.'
##        #return ppEdge
##
##    def GetPreviousInTriangle(self):
##        u'Returns the next triangle sharing the FromNode of the specified edge in a counter-clockwise direction.'
##        #return ppEdge
##
##    @property
##    def FromNode(self):
##        u'The originating node of the specified edge.'
##        #return ppNode
##
##    @property
##    def ToNode(self):
##        u'The terminating node of the specified edge.'
##        #return ppNode
##
##    @property
##    def LeftTriangle(self):
##        u'The triangle on the left (opposite) side of the specified edge.'
##        #return ppTriangle
##
##    @property
##    def Length(self):
##        u'The projected length of the specified edge.'
##        #return pLength
##
##    @property
##    def AzimuthRadians(self):
##        u'The azimuthal direction of the specified edge beginning at the FromNode in radians.'
##        #return pAzimuth
##
##    def QueryAsWKSPointZs(self):
##        u'Sets the specified edge equal to its nodes as points with z values.'
##        #return pFrom, pTo
##
##    def GetNextCW(self):
##        u'Returns the edge beginning at the ToNode of the specified edge.'
##        #return ppEdge
##
##    @property
##    def AzimuthDegrees(self):
##        u'The azimuthal direction of the specified edge beginning at the FromNode in degrees.'
##        #return pAzimuth
##
##    def QueryAsLine(self, pLine):
##        u'Sets the specified edge equal to a line.'
##        #return 
##
##    def GetNextInTriangle(self):
##        u'Returns the next triangle sharing the FromNode of the specified edge in a clockwise direction.'
##        #return ppEdge
##
##    @property
##    def Type(self):
##        u'The type of the specified edge.'
##        #return pType
##
##    def GetNextCCW(self):
##        u'Returns the edge terminating at the FromNode of the specified edge.'
##        #return ppEdge
##

class ITinNode2(ITinNode):
    _case_insensitive_ = True
    u'Provides access to members that control TIN nodes.'
    _iid_ = GUID('{3D212052-AD4B-11D5-ABB8-0008C73FD50C}')
    _idlflags_ = []
ITinNode2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The source of the node.')], HRESULT, 'Source',
              ( ['retval', 'out'], POINTER(esriTinNodeSourceType), 'pSource' )),
    COMMETHOD(['propget', helpstring(u'The degree of the node.')], HRESULT, 'Degree',
              ( ['in'], VARIANT_BOOL, 'bEnforcedEdgesOnly' ),
              ( ['retval', 'out'], POINTER(c_int), 'pDegree' )),
    COMMETHOD(['propget', helpstring(u"Indicates if the specified node is on domain's boundary.")], HRESULT, 'IsOnDomainBoundary',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbIsOn' )),
    COMMETHOD([helpstring(u'Returns all nodes connecting to the node.')], HRESULT, 'QueryAdjacentNodeIndices',
              ( [], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'pNodes' )),
    COMMETHOD([helpstring(u'Returns all edges sharing the node.')], HRESULT, 'QueryIncidentEdgeIndices',
              ( [], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'pEdges' )),
    COMMETHOD([helpstring(u'Returns all triangles sharing the node.')], HRESULT, 'QueryIncidentTriangleIndices',
              ( [], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'pTriangles' )),
    COMMETHOD([helpstring(u"Returns any triangle having the node as one of it's vertices.")], HRESULT, 'IncidentTriangle',
              ( ['retval', 'out'], POINTER(POINTER(ITinTriangle)), 'ppTriangle' )),
    COMMETHOD([helpstring(u"Returns the index of any triangle having the node as one of it's vertices.")], HRESULT, 'IncidentTriangleIndex',
              ( ['retval', 'out'], POINTER(c_int), 'pTriangle' )),
]
################################################################
## code template for ITinNode2 implementation
##class ITinNode2_Impl(object):
##    def QueryIncidentTriangleIndices(self, pTriangles):
##        u'Returns all triangles sharing the node.'
##        #return 
##
##    @property
##    def Degree(self, bEnforcedEdgesOnly):
##        u'The degree of the node.'
##        #return pDegree
##
##    @property
##    def IsOnDomainBoundary(self):
##        u"Indicates if the specified node is on domain's boundary."
##        #return pbIsOn
##
##    @property
##    def Source(self):
##        u'The source of the node.'
##        #return pSource
##
##    def IncidentTriangleIndex(self):
##        u"Returns the index of any triangle having the node as one of it's vertices."
##        #return pTriangle
##
##    def QueryIncidentEdgeIndices(self, pEdges):
##        u'Returns all edges sharing the node.'
##        #return 
##
##    def IncidentTriangle(self):
##        u"Returns any triangle having the node as one of it's vertices."
##        #return ppTriangle
##
##    def QueryAdjacentNodeIndices(self, pNodes):
##        u'Returns all nodes connecting to the node.'
##        #return 
##

IWorkspaceEvents._methods_ = [
    COMMETHOD([helpstring(u'This event is fired when a dataset is created.')], HRESULT, 'OnCreateDataset',
              ( ['in'], POINTER(IDataset), 'Dataset' )),
    COMMETHOD([helpstring(u'This event is fired when a dataset is renamed.')], HRESULT, 'OnRenameDataset',
              ( ['in'], POINTER(IDataset), 'Dataset' ),
              ( ['in'], BSTR, 'oldName' ),
              ( ['in'], BSTR, 'newName' )),
    COMMETHOD([helpstring(u'This event is fired when a dataset is deleted.')], HRESULT, 'OnDeleteDataset',
              ( ['in'], POINTER(IDataset), 'Dataset' )),
]
################################################################
## code template for IWorkspaceEvents implementation
##class IWorkspaceEvents_Impl(object):
##    def OnRenameDataset(self, Dataset, oldName, newName):
##        u'This event is fired when a dataset is renamed.'
##        #return 
##
##    def OnCreateDataset(self, Dataset):
##        u'This event is fired when a dataset is created.'
##        #return 
##
##    def OnDeleteDataset(self, Dataset):
##        u'This event is fired when a dataset is deleted.'
##        #return 
##

IWorkspaceEvents2._methods_ = [
    COMMETHOD([helpstring(u'This event is fired when a dataset is modified.')], HRESULT, 'OnModifyDataset',
              ( ['in'], POINTER(IDataset), 'Dataset' )),
]
################################################################
## code template for IWorkspaceEvents2 implementation
##class IWorkspaceEvents2_Impl(object):
##    def OnModifyDataset(self, Dataset):
##        u'This event is fired when a dataset is modified.'
##        #return 
##

IDERasterDatasetEx._methods_ = [
    COMMETHOD(['propget', helpstring(u'The storage definition of this RasterRataset.')], HRESULT, 'StorageDef',
              ( ['retval', 'out'], POINTER(POINTER(IRasterStorageDef)), 'StorageDef' )),
    COMMETHOD(['propput', helpstring(u'The storage definition of this RasterRataset.')], HRESULT, 'StorageDef',
              ( ['in'], POINTER(IRasterStorageDef), 'StorageDef' )),
]
################################################################
## code template for IDERasterDatasetEx implementation
##class IDERasterDatasetEx_Impl(object):
##    def _get(self):
##        u'The storage definition of this RasterRataset.'
##        #return StorageDef
##    def _set(self, StorageDef):
##        u'The storage definition of this RasterRataset.'
##    StorageDef = property(_get, _set, doc = _set.__doc__)
##

class IComplexNativeType(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that supply complex native types.'
    _iid_ = GUID('{D425F87A-5B3A-4200-A050-380084CBEDF0}')
    _idlflags_ = ['oleautomation']
IComplexNativeType._methods_ = [
    COMMETHOD([helpstring(u'Adds a child.')], HRESULT, 'AddChild',
              ( ['in'], POINTER(INativeType), 'child' )),
    COMMETHOD([helpstring(u'Returns the nth child.')], HRESULT, 'GetChild',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(INativeType)), 'child' )),
    COMMETHOD(['propget', helpstring(u'The number of children.')], HRESULT, 'NumChildren',
              ( ['retval', 'out'], POINTER(c_int), 'pNumChildren' )),
]
################################################################
## code template for IComplexNativeType implementation
##class IComplexNativeType_Impl(object):
##    def AddChild(self, child):
##        u'Adds a child.'
##        #return 
##
##    @property
##    def NumChildren(self):
##        u'The number of children.'
##        #return pNumChildren
##
##    def GetChild(self, Index):
##        u'Returns the nth child.'
##        #return child
##

ISQLPrivilege._methods_ = [
    COMMETHOD(['propget', helpstring(u'The database privileges.')], HRESULT, 'SQLPrivileges',
              ( ['retval', 'out'], POINTER(c_int), 'privileges' )),
    COMMETHOD([helpstring(u'Grants privileges for the database user.')], HRESULT, 'Grant',
              ( ['in'], BSTR, 'UserName' ),
              ( ['in'], c_int, 'privileges' ),
              ( ['in'], VARIANT_BOOL, 'withGrant' )),
    COMMETHOD([helpstring(u'Revokes privileges for the database user.')], HRESULT, 'Revoke',
              ( ['in'], BSTR, 'UserName' ),
              ( ['in'], c_int, 'privileges' )),
]
################################################################
## code template for ISQLPrivilege implementation
##class ISQLPrivilege_Impl(object):
##    @property
##    def SQLPrivileges(self):
##        u'The database privileges.'
##        #return privileges
##
##    def Revoke(self, UserName, privileges):
##        u'Revokes privileges for the database user.'
##        #return 
##
##    def Grant(self, UserName, privileges, withGrant):
##        u'Grants privileges for the database user.'
##        #return 
##

class IReplicaFilterDescriptionEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to members that set a replica's properties."
    _iid_ = GUID('{50BEFD5A-3978-470F-B6DB-15916162C15C}')
    _idlflags_ = ['oleautomation']
IReplicaFilterDescriptionEdit._methods_ = [
    COMMETHOD(['propputref', helpstring(u'The geometry used to determine which features to extract or check out.')], HRESULT, 'Geometry',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The spatial operator used for a replica.')], HRESULT, 'SpatialRelation',
              ( ['in'], esriSpatialRelEnum, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Indicates if a spatial extent will be used when checking out a dataset.')], HRESULT, 'TableUsesQueryGeometry',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], VARIANT_BOOL, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Indicates if a selection will be used when checking out a dataset.')], HRESULT, 'TableUsesSelection',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], VARIANT_BOOL, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Indicates if a definition query will be used when checking out a dataset.')], HRESULT, 'TableUsesDefQuery',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], VARIANT_BOOL, 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The selection set to use when checking out a dataset.')], HRESULT, 'TableSelection',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(ISelectionSet), 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The definition query to use when checking out a dataset.')], HRESULT, 'TableDefQuery',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Replica row type options.')], HRESULT, 'RowsType',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], esriRowsType, 'rhs' )),
]
################################################################
## code template for IReplicaFilterDescriptionEdit implementation
##class IReplicaFilterDescriptionEdit_Impl(object):
##    def TableSelection(self, Index, rhs):
##        u'The selection set to use when checking out a dataset.'
##        #return 
##
##    def _set(self, rhs):
##        u'The spatial operator used for a replica.'
##    SpatialRelation = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, Index, rhs):
##        u'Indicates if a spatial extent will be used when checking out a dataset.'
##    TableUsesQueryGeometry = property(fset = _set, doc = _set.__doc__)
##
##    def Geometry(self, rhs):
##        u'The geometry used to determine which features to extract or check out.'
##        #return 
##
##    def _set(self, Index, rhs):
##        u'Indicates if a selection will be used when checking out a dataset.'
##    TableUsesSelection = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, Index, rhs):
##        u'Indicates if a definition query will be used when checking out a dataset.'
##    TableUsesDefQuery = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, Index, rhs):
##        u'Replica row type options.'
##    RowsType = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, Index, rhs):
##        u'The definition query to use when checking out a dataset.'
##    TableDefQuery = property(fset = _set, doc = _set.__doc__)
##

IFeatureDataConverter2._methods_ = [
    COMMETHOD([helpstring(u'Converts a featureDataset to Personal Geodatabase/Geodatabase featuredataset.')], HRESULT, 'ConvertFeatureDataset',
              ( ['in'], POINTER(IFeatureDatasetName), 'inputFDatasetName' ),
              ( ['in'], POINTER(IFeatureDatasetName), 'outputFDatasetName' ),
              ( ['in'], POINTER(IGeometryDef), 'OutputGeometryDef' ),
              ( ['in'], BSTR, 'configKey' ),
              ( ['in'], c_int, 'FlushInterval' ),
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'parentHWND' )),
    COMMETHOD([helpstring(u'Converts a featureClass to a Personal Geodatabase/Geodatabase featureClass.')], HRESULT, 'ConvertFeatureClass',
              ( ['in'], POINTER(IDatasetName), 'inputFClassName' ),
              ( ['in'], POINTER(IQueryFilter), 'InputQueryFilter' ),
              ( ['in'], POINTER(ISelectionSet), 'InputSelectionSet' ),
              ( ['in'], POINTER(IFeatureDatasetName), 'outputFDatasetName' ),
              ( ['in'], POINTER(IFeatureClassName), 'outputFClassName' ),
              ( ['in'], POINTER(IGeometryDef), 'OutputGeometryDef' ),
              ( ['in'], POINTER(IFields), 'OutputFields' ),
              ( ['in'], BSTR, 'configKey' ),
              ( ['in'], c_int, 'FlushInterval' ),
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'parentHWND' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumInvalidObject)), 'EnumInvalidObject' )),
    COMMETHOD([helpstring(u'Converts a table to a Personal Geodatabase/Geodatabase table.')], HRESULT, 'ConvertTable',
              ( ['in'], POINTER(IDatasetName), 'InputDatasetName' ),
              ( ['in'], POINTER(IQueryFilter), 'InputQueryFilter' ),
              ( ['in'], POINTER(ISelectionSet), 'InputSelectionSet' ),
              ( ['in'], POINTER(IDatasetName), 'OutputDatasetName' ),
              ( ['in'], POINTER(IFields), 'OutputFields' ),
              ( ['in'], BSTR, 'configKey' ),
              ( ['in'], c_int, 'FlushInterval' ),
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'parentHWND' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumInvalidObject)), 'EnumInvalidObject' )),
]
################################################################
## code template for IFeatureDataConverter2 implementation
##class IFeatureDataConverter2_Impl(object):
##    def ConvertFeatureClass(self, inputFClassName, InputQueryFilter, InputSelectionSet, outputFDatasetName, outputFClassName, OutputGeometryDef, OutputFields, configKey, FlushInterval, parentHWND):
##        u'Converts a featureClass to a Personal Geodatabase/Geodatabase featureClass.'
##        #return EnumInvalidObject
##
##    def ConvertFeatureDataset(self, inputFDatasetName, outputFDatasetName, OutputGeometryDef, configKey, FlushInterval, parentHWND):
##        u'Converts a featureDataset to Personal Geodatabase/Geodatabase featuredataset.'
##        #return 
##
##    def ConvertTable(self, InputDatasetName, InputQueryFilter, InputSelectionSet, OutputDatasetName, OutputFields, configKey, FlushInterval, parentHWND):
##        u'Converts a table to a Personal Geodatabase/Geodatabase table.'
##        #return EnumInvalidObject
##

class IEnumProperty(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate Property.'
    _iid_ = GUID('{40A9E881-5533-11D0-98BE-00805F7CED21}')
    _idlflags_ = ['oleautomation']
    def __iter__(self):
        return self

    def next(self):
        item, fetched = self.Next(1)
        if fetched:
            return item
        raise StopIteration

    def __getitem__(self, index):
        self.Reset()
        self.Skip(index)
        item, fetched = self.Next(1)
        if fetched:
            return item
        raise IndexError(index)

class IProperty(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that control the Property functionality.'
    _iid_ = GUID('{40A9E882-5533-11D0-98BE-00805F7CED21}')
    _idlflags_ = ['oleautomation']
IEnumProperty._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next Property in the enumeration sequence.')], HRESULT, 'Next',
              ( ['in'], c_int, 'numRequested' ),
              ( ['out'], POINTER(POINTER(IProperty)), 'props' ),
              ( ['out'], POINTER(c_int), 'numFetched' )),
    COMMETHOD([helpstring(u'Skips the next Property in the enumeration.')], HRESULT, 'Skip',
              ( ['in'], c_int, 'numToSkip' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Creates a clone of the current enumeration.')], HRESULT, 'Clone',
              ( ['out'], POINTER(POINTER(IEnumProperty)), 'Property' )),
]
################################################################
## code template for IEnumProperty implementation
##class IEnumProperty_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Skip(self, numToSkip):
##        u'Skips the next Property in the enumeration.'
##        #return 
##
##    def Clone(self):
##        u'Creates a clone of the current enumeration.'
##        #return Property
##
##    def Next(self, numRequested):
##        u'Retrieves the next Property in the enumeration sequence.'
##        #return props, numFetched
##

IProperty._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the property.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the property.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The value of the property.')], HRESULT, 'Value',
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The value of the property.')], HRESULT, 'Value',
              ( ['in'], VARIANT, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The subtype of the property.')], HRESULT, 'SubType',
              ( ['retval', 'out'], POINTER(c_int), 'SubType' )),
]
################################################################
## code template for IProperty implementation
##class IProperty_Impl(object):
##    @property
##    def SubType(self):
##        u'The subtype of the property.'
##        #return SubType
##
##    def _get(self):
##        u'The name of the property.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the property.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The value of the property.'
##        #return Value
##    def _set(self, Value):
##        u'The value of the property.'
##    Value = property(_get, _set, doc = _set.__doc__)
##

IGPReplicaDescription._methods_ = [
    COMMETHOD([helpstring(u'Initializes the object from an existing replica.')], HRESULT, 'Init',
              ( ['in'], POINTER(IReplica), 'Replica' )),
    COMMETHOD(['propput', helpstring(u'The replica model type.')], HRESULT, 'ModelType',
              ( ['in'], esriReplicaModelType, 'ModelType' )),
    COMMETHOD(['propget', helpstring(u'The replica model type.')], HRESULT, 'ModelType',
              ( ['retval', 'out'], POINTER(esriReplicaModelType), 'ModelType' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the replica is a check-out.')], HRESULT, 'SingleGeneration',
              ( ['in'], VARIANT_BOOL, 'SingleGeneration' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the replica is a check-out.')], HRESULT, 'SingleGeneration',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'SingleGeneration' )),
    COMMETHOD(['propput', helpstring(u'Defines how the shape returned by the QueryGeometry property is applied during replication and synchronization.')], HRESULT, 'SpatialRelation',
              ( ['in'], esriSpatialRelEnum, 'SpatialRelation' )),
    COMMETHOD(['propget', helpstring(u'Defines how the shape returned by the QueryGeometry property is applied during replication and synchronization.')], HRESULT, 'SpatialRelation',
              ( ['retval', 'out'], POINTER(esriSpatialRelEnum), 'SpatialRelation' )),
    COMMETHOD(['propputref', helpstring(u'The shape that determines which features are replicated.')], HRESULT, 'QueryGeometry',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'QueryGeometry' )),
    COMMETHOD(['propget', helpstring(u'The shape that determines which features are replicated.')], HRESULT, 'QueryGeometry',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'QueryGeometry' )),
    COMMETHOD(['propputref', helpstring(u'The datasets in the replica.')], HRESULT, 'ReplicaDatasets',
              ( ['in'], POINTER(IGPReplicaDatasets), 'ReplicaDatasets' )),
    COMMETHOD(['propget', helpstring(u'The datasets in the replica.')], HRESULT, 'ReplicaDatasets',
              ( ['retval', 'out'], POINTER(POINTER(IGPReplicaDatasets)), 'ReplicaDatasets' )),
    COMMETHOD(['propput', helpstring(u'Indicates if related objects are replicated.')], HRESULT, 'TransferRelatedObjects',
              ( ['in'], VARIANT_BOOL, 'transferRelObjects' )),
    COMMETHOD(['propget', helpstring(u'Indicates if related objects are replicated.')], HRESULT, 'TransferRelatedObjects',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'transferRelObjects' )),
]
################################################################
## code template for IGPReplicaDescription implementation
##class IGPReplicaDescription_Impl(object):
##    @property
##    def ReplicaDatasets(self, ReplicaDatasets):
##        u'The datasets in the replica.'
##        #return 
##
##    @property
##    def QueryGeometry(self, QueryGeometry):
##        u'The shape that determines which features are replicated.'
##        #return 
##
##    def _get(self):
##        u'Defines how the shape returned by the QueryGeometry property is applied during replication and synchronization.'
##        #return SpatialRelation
##    def _set(self, SpatialRelation):
##        u'Defines how the shape returned by the QueryGeometry property is applied during replication and synchronization.'
##    SpatialRelation = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if related objects are replicated.'
##        #return transferRelObjects
##    def _set(self, transferRelObjects):
##        u'Indicates if related objects are replicated.'
##    TransferRelatedObjects = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the replica is a check-out.'
##        #return SingleGeneration
##    def _set(self, SingleGeneration):
##        u'Indicates if the replica is a check-out.'
##    SingleGeneration = property(_get, _set, doc = _set.__doc__)
##
##    def Init(self, Replica):
##        u'Initializes the object from an existing replica.'
##        #return 
##
##    def _get(self):
##        u'The replica model type.'
##        #return ModelType
##    def _set(self, ModelType):
##        u'The replica model type.'
##    ModelType = property(_get, _set, doc = _set.__doc__)
##

IEnumDomain._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next domain in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IDomain)), 'Domain' )),
    COMMETHOD([helpstring(u'Reset enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumDomain implementation
##class IEnumDomain_Impl(object):
##    def Reset(self):
##        u'Reset enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next domain in the enumeration sequence.'
##        #return Domain
##

class IReplicaFilterDescription(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to members that return a replica's properties."
    _iid_ = GUID('{F0455780-BE29-46E4-A25A-459DCAFF6276}')
    _idlflags_ = ['oleautomation']
IReplicaFilterDescription._methods_ = [
    COMMETHOD(['propget', helpstring(u'The geometry used to determine which features to extract or check out.')], HRESULT, 'Geometry',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'qGeometry' )),
    COMMETHOD(['propget', helpstring(u'The spatial operator used for a replica.')], HRESULT, 'SpatialRelation',
              ( ['retval', 'out'], POINTER(esriSpatialRelEnum), 'SpatialRel' )),
    COMMETHOD(['propget', helpstring(u'Indicates if a spatial extent will be used when checking out a dataset.')], HRESULT, 'TableUsesQueryGeometry',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'UseGeometry' )),
    COMMETHOD(['propget', helpstring(u'Indicates if a selection will be used when checking out a dataset.')], HRESULT, 'TableUsesSelection',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'useSelection' )),
    COMMETHOD(['propget', helpstring(u'Indicates if a definition query will be used when checking out a dataset.')], HRESULT, 'TableUsesDefQuery',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'useDefinition' )),
    COMMETHOD(['propget', helpstring(u'The selection set to use when checking out a dataset.')], HRESULT, 'TableSelection',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(ISelectionSet)), 'selections' )),
    COMMETHOD(['propget', helpstring(u'The definition query to use when checking out a dataset.')], HRESULT, 'TableDefQuery',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(BSTR), 'DefQuery' )),
    COMMETHOD(['propget', helpstring(u'Replica row type options.')], HRESULT, 'RowsType',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(esriRowsType), 'rType' )),
]
################################################################
## code template for IReplicaFilterDescription implementation
##class IReplicaFilterDescription_Impl(object):
##    @property
##    def TableSelection(self, Index):
##        u'The selection set to use when checking out a dataset.'
##        #return selections
##
##    @property
##    def SpatialRelation(self):
##        u'The spatial operator used for a replica.'
##        #return SpatialRel
##
##    @property
##    def TableUsesQueryGeometry(self, Index):
##        u'Indicates if a spatial extent will be used when checking out a dataset.'
##        #return UseGeometry
##
##    @property
##    def Geometry(self):
##        u'The geometry used to determine which features to extract or check out.'
##        #return qGeometry
##
##    @property
##    def TableUsesSelection(self, Index):
##        u'Indicates if a selection will be used when checking out a dataset.'
##        #return useSelection
##
##    @property
##    def TableUsesDefQuery(self, Index):
##        u'Indicates if a definition query will be used when checking out a dataset.'
##        #return useDefinition
##
##    @property
##    def RowsType(self, Index):
##        u'Replica row type options.'
##        #return rType
##
##    @property
##    def TableDefQuery(self, Index):
##        u'The definition query to use when checking out a dataset.'
##        #return DefQuery
##

class IWorkspaceReplicaSyncEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to replica events that may be fired after a check-in synchronization operation.'
    _iid_ = GUID('{6AB1120F-81DF-4C11-B255-C5DD15690939}')
    _idlflags_ = ['oleautomation']
IWorkspaceReplicaSyncEvents._methods_ = [
    COMMETHOD([helpstring(u'Occurs in the replica geodatabase before data changes are exported from that replica geodatabase to a delta database.')], HRESULT, 'BeforeExportingDataChanges',
              ( ['in'], POINTER(IReplica), 'sourceReplica' ),
              ( ['in'], POINTER(IUnknown), 'dataChangesSource' ),
              ( ['in'], POINTER(IUnknown), 'DeltaFile' )),
    COMMETHOD([helpstring(u'Occurs in the replica geodatabase after data changes have been exported from that replica geodatabase to a delta database.')], HRESULT, 'AfterExportingDataChanges',
              ( ['in'], POINTER(IReplica), 'sourceReplica' ),
              ( ['in'], POINTER(IUnknown), 'dataChangesSource' ),
              ( ['in'], POINTER(IUnknown), 'DeltaFile' )),
    COMMETHOD([helpstring(u'Occurs in the master geodatabase before data changes in either a replica geodatabase or delta database are transferred to the master geodatabase.')], HRESULT, 'BeforeSynchronizingDataChanges',
              ( ['in'], POINTER(IReplica), 'targetReplica' ),
              ( ['in'], POINTER(IUnknown), 'dataChangesSource' )),
    COMMETHOD([helpstring(u'Occurs in the master geodatabase after data changes in either a replica geodatabase or delta database are transferred to the master geodatabase.')], HRESULT, 'AfterSynchronizingDataChanges',
              ( ['in'], POINTER(IReplica), 'targetReplica' ),
              ( ['in'], POINTER(IUnknown), 'dataChangesSource' ),
              ( ['in'], POINTER(ITable), 'oidMappingTable' ),
              ( ['in'], POINTER(ITable), 'changesTable' )),
]
################################################################
## code template for IWorkspaceReplicaSyncEvents implementation
##class IWorkspaceReplicaSyncEvents_Impl(object):
##    def BeforeSynchronizingDataChanges(self, targetReplica, dataChangesSource):
##        u'Occurs in the master geodatabase before data changes in either a replica geodatabase or delta database are transferred to the master geodatabase.'
##        #return 
##
##    def BeforeExportingDataChanges(self, sourceReplica, dataChangesSource, DeltaFile):
##        u'Occurs in the replica geodatabase before data changes are exported from that replica geodatabase to a delta database.'
##        #return 
##
##    def AfterExportingDataChanges(self, sourceReplica, dataChangesSource, DeltaFile):
##        u'Occurs in the replica geodatabase after data changes have been exported from that replica geodatabase to a delta database.'
##        #return 
##
##    def AfterSynchronizingDataChanges(self, targetReplica, dataChangesSource, oidMappingTable, changesTable):
##        u'Occurs in the master geodatabase after data changes in either a replica geodatabase or delta database are transferred to the master geodatabase.'
##        #return 
##

IWorkspaceDomains3._methods_ = [
    COMMETHOD([helpstring(u'Alters an existing domain in the workspace.')], HRESULT, 'AlterDomainWithName',
              ( ['in'], POINTER(IDomain), 'Domain' ),
              ( ['in'], BSTR, 'oldDomainName' )),
]
################################################################
## code template for IWorkspaceDomains3 implementation
##class IWorkspaceDomains3_Impl(object):
##    def AlterDomainWithName(self, Domain, oldDomainName):
##        u'Alters an existing domain in the workspace.'
##        #return 
##

IDatasetEditInfo._methods_ = [
    COMMETHOD(['hidden', helpstring(u'True if the dataset supports edit sessions with the ability to discard edits on save.'), 'propget'], HRESULT, 'CanEdit',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanEdit' )),
    COMMETHOD(['hidden', helpstring(u'True if the dataset supports edit sessions with the ability to undo individual edit operations.'), 'propget'], HRESULT, 'CanUndo',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanUndo' )),
    COMMETHOD(['hidden', helpstring(u'True if the dataset supports edit sessions with the ability to redo undone operations.'), 'propget'], HRESULT, 'CanRedo',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanUndo' )),
]
################################################################
## code template for IDatasetEditInfo implementation
##class IDatasetEditInfo_Impl(object):
##    @property
##    def CanRedo(self):
##        u'True if the dataset supports edit sessions with the ability to redo undone operations.'
##        #return CanUndo
##
##    @property
##    def CanEdit(self):
##        u'True if the dataset supports edit sessions with the ability to discard edits on save.'
##        #return CanEdit
##
##    @property
##    def CanUndo(self):
##        u'True if the dataset supports edit sessions with the ability to undo individual edit operations.'
##        #return CanUndo
##

IFeatureWorkspaceAnno._methods_ = [
    COMMETHOD([helpstring(u'Creates a new annotation feature class in the workspace.')], HRESULT, 'CreateAnnotationClass',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IFields), 'Fields' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'CLSID' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'EXTCLSID' ),
              ( ['in'], BSTR, 'ShapeFieldName' ),
              ( ['in'], BSTR, 'ConfigKeyword' ),
              ( ['in'], POINTER(IFeatureDataset), 'dstFeatureDataset' ),
              ( ['in'], POINTER(IFeatureClass), 'srcFeatureClass' ),
              ( ['in'], POINTER(IUnknown), 'annoProperties' ),
              ( ['in'], POINTER(IUnknown), 'referenceScale' ),
              ( ['in'], POINTER(IUnknown), 'symbolCollection' ),
              ( ['in'], VARIANT_BOOL, 'autoCreate' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureClass)), 'FeatureClass' )),
    COMMETHOD([helpstring(u'Updates the symbol collection in the class extension.')], HRESULT, 'AddSymbolCollection',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IUnknown), 'symbolCollection' )),
    COMMETHOD([helpstring(u'Replaces the symbol collection in the class extension.')], HRESULT, 'ReplaceSymbolCollection',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IUnknown), 'symbolCollection' )),
]
################################################################
## code template for IFeatureWorkspaceAnno implementation
##class IFeatureWorkspaceAnno_Impl(object):
##    def AddSymbolCollection(self, Name, symbolCollection):
##        u'Updates the symbol collection in the class extension.'
##        #return 
##
##    def CreateAnnotationClass(self, Name, Fields, CLSID, EXTCLSID, ShapeFieldName, ConfigKeyword, dstFeatureDataset, srcFeatureClass, annoProperties, referenceScale, symbolCollection, autoCreate):
##        u'Creates a new annotation feature class in the workspace.'
##        #return FeatureClass
##
##    def ReplaceSymbolCollection(self, Name, symbolCollection):
##        u'Replaces the symbol collection in the class extension.'
##        #return 
##

class IReplicaFilterDescription2(IReplicaFilterDescription):
    _case_insensitive_ = True
    u"Provides access to members that return a replica's properties."
    _iid_ = GUID('{40F7CB0D-C8A1-413E-9112-C7862DB1BEE1}')
    _idlflags_ = ['oleautomation']
IReplicaFilterDescription2._methods_ = [
    COMMETHOD(['propget', helpstring(u"The ID's of the rows and features that are replicated when a selection set id ussd.")], HRESULT, 'TableSelectionIDs',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IFIDSet)), 'SelectionIDs' )),
]
################################################################
## code template for IReplicaFilterDescription2 implementation
##class IReplicaFilterDescription2_Impl(object):
##    @property
##    def TableSelectionIDs(self, Index):
##        u"The ID's of the rows and features that are replicated when a selection set id ussd."
##        #return SelectionIDs
##

class IGPSystemToolboxLocation(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provide access to the system toolbox location object.'
    _iid_ = GUID('{CAD53770-A929-4EF5-888C-FDB802350D3E}')
    _idlflags_ = ['oleautomation']
IGPSystemToolboxLocation._methods_ = [
    COMMETHOD(['propput', helpstring(u'Path of the additional system toolbox of GP tools.')], HRESULT, 'PathName',
              ( ['in'], BSTR, 'PathName' )),
    COMMETHOD(['propget', helpstring(u'Path of the additional system toolbox of GP tools.')], HRESULT, 'PathName',
              ( ['retval', 'out'], POINTER(BSTR), 'PathName' )),
]
################################################################
## code template for IGPSystemToolboxLocation implementation
##class IGPSystemToolboxLocation_Impl(object):
##    def _get(self):
##        u'Path of the additional system toolbox of GP tools.'
##        #return PathName
##    def _set(self, PathName):
##        u'Path of the additional system toolbox of GP tools.'
##    PathName = property(_get, _set, doc = _set.__doc__)
##

class IReplicaDescriptionExtensionManager(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to replica description extension manager.'
    _iid_ = GUID('{3F980B98-EB3D-4A29-82AE-A2475701048D}')
    _idlflags_ = ['oleautomation']
class IReplicaDescriptionExtension(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a replica description extension.'
    _iid_ = GUID('{8DCD2EE1-4297-4FD3-916D-FD7DE9EAFB2A}')
    _idlflags_ = ['oleautomation']
IReplicaDescriptionExtensionManager._methods_ = [
    COMMETHOD([helpstring(u'Finds the specified description extension by its globally unique id.')], HRESULT, 'FindExtension',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'pGuid' ),
              ( ['retval', 'out'], POINTER(c_int), 'Index' )),
    COMMETHOD(['propget', helpstring(u'The number of replica description extensions.')], HRESULT, 'ExtensionCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The replica description extension at this index.')], HRESULT, 'Extension',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IReplicaDescriptionExtension)), 'rdExtension' )),
    COMMETHOD([helpstring(u'Registers this description extension.')], HRESULT, 'RegisterExtension',
              ( ['in'], POINTER(IReplicaDescriptionExtension), 'rdExtension' )),
    COMMETHOD([helpstring(u'UnRegisters this replica description.')], HRESULT, 'UnRegisterExtension',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID), 'pGuid' )),
]
################################################################
## code template for IReplicaDescriptionExtensionManager implementation
##class IReplicaDescriptionExtensionManager_Impl(object):
##    def FindExtension(self, pGuid):
##        u'Finds the specified description extension by its globally unique id.'
##        #return Index
##
##    @property
##    def ExtensionCount(self):
##        u'The number of replica description extensions.'
##        #return Count
##
##    def RegisterExtension(self, rdExtension):
##        u'Registers this description extension.'
##        #return 
##
##    def UnRegisterExtension(self, pGuid):
##        u'UnRegisters this replica description.'
##        #return 
##
##    @property
##    def Extension(self, Index):
##        u'The replica description extension at this index.'
##        #return rdExtension
##

class FieldType(CoClass):
    u'Field Data Element object Type.'
    _reg_clsid_ = GUID('{B44EF553-FA9F-4987-804C-FCAA537024ED}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IGPChoiceList(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return Geoprocessing Choice Lists.'
    _iid_ = GUID('{1A4B7A52-E1D9-4AB8-A741-70467CBF9F5F}')
    _idlflags_ = ['oleautomation']
FieldType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IFieldType, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, IGPChoiceList]

class DEWorkspaceType(CoClass):
    u'Workspace Data Element object Type.'
    _reg_clsid_ = GUID('{DE546F38-3266-48D2-BFE8-61FA0BAEF5D1}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DEWorkspaceType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEWorkspaceType, IGxFilterInfo, IDataElementType, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class DEBrowseOptions(CoClass):
    u'Data Element Browse Options Class.'
    _reg_clsid_ = GUID('{0592F426-4F2C-4016-ADC7-0A84ED2E1BC0}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DEBrowseOptions._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEBrowseOptions, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDocumentVersionSupportGEN, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

IDatasetEdit._methods_ = [
    COMMETHOD([helpstring(u'True if the dataset is being edited.')], HRESULT, 'IsBeingEdited',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsBeingEdited' )),
]
################################################################
## code template for IDatasetEdit implementation
##class IDatasetEdit_Impl(object):
##    def IsBeingEdited(self):
##        u'True if the dataset is being edited.'
##        #return IsBeingEdited
##

ITransactions._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if there is already a transaction in progress.')], HRESULT, 'InTransaction',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'InTransaction' )),
    COMMETHOD([helpstring(u'Begins a new transaction.')], HRESULT, 'StartTransaction'),
    COMMETHOD([helpstring(u'Commits the current transaction.')], HRESULT, 'CommitTransaction'),
    COMMETHOD([helpstring(u'Aborts the current transaction.')], HRESULT, 'AbortTransaction'),
]
################################################################
## code template for ITransactions implementation
##class ITransactions_Impl(object):
##    def CommitTransaction(self):
##        u'Commits the current transaction.'
##        #return 
##
##    def AbortTransaction(self):
##        u'Aborts the current transaction.'
##        #return 
##
##    def StartTransaction(self):
##        u'Begins a new transaction.'
##        #return 
##
##    @property
##    def InTransaction(self):
##        u'Indicates if there is already a transaction in progress.'
##        #return InTransaction
##

class DETableType(CoClass):
    u'Table Data Element object Type.'
    _reg_clsid_ = GUID('{D19DD6FC-2460-42C0-9197-5D2E840AC485}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DETableType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDETableType, IDEDatasetType, IGxFilterInfo, IDataElementType, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class IWorkspaceReplicaEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to replica events that may be fired after extracting data or schema in a checkout or a child replica.'
    _iid_ = GUID('{56DF3B04-8684-4432-9A21-CB5E72D73E56}')
    _idlflags_ = ['oleautomation']
IWorkspaceReplicaEvents._methods_ = [
    COMMETHOD([helpstring(u'Occurs in the master geodatabase when a replica operation begins.')], HRESULT, 'BeforeCreateChildReplica',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], esriReplicaType, 'parentReplicaType' ),
              ( ['in'], POINTER(IReplicaDescription), 'rDescription' ),
              ( ['in'], POINTER(IWorkspace), 'childWorkspace' )),
    COMMETHOD([helpstring(u'Occurs in the master geodatabase when a replica operation ends.')], HRESULT, 'AfterCreateChildReplica',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], esriReplicaType, 'parentReplicaType' ),
              ( ['in'], POINTER(IReplicaDescription), 'rDescription' ),
              ( ['in'], POINTER(IWorkspace), 'childWorkspace' )),
]
################################################################
## code template for IWorkspaceReplicaEvents implementation
##class IWorkspaceReplicaEvents_Impl(object):
##    def BeforeCreateChildReplica(self, Name, parentReplicaType, rDescription, childWorkspace):
##        u'Occurs in the master geodatabase when a replica operation begins.'
##        #return 
##
##    def AfterCreateChildReplica(self, Name, parentReplicaType, rDescription, childWorkspace):
##        u'Occurs in the master geodatabase when a replica operation ends.'
##        #return 
##

IGPReplicaDataset2._methods_ = [
    COMMETHOD(['propput', helpstring(u'The target name for the GPReplicaDataset.')], HRESULT, 'TargetName',
              ( ['in'], BSTR, 'TargetName' )),
    COMMETHOD(['propget', helpstring(u'The target name for the GPReplicaDataset.')], HRESULT, 'TargetName',
              ( ['retval', 'out'], POINTER(BSTR), 'TargetName' )),
    COMMETHOD(['propput', helpstring(u'Set parent owner for the GPReplicaDataset.')], HRESULT, 'ParentOwner',
              ( ['in'], BSTR, 'ParentOwner' )),
    COMMETHOD(['propget', helpstring(u'Set parent owner for the GPReplicaDataset.')], HRESULT, 'ParentOwner',
              ( ['retval', 'out'], POINTER(BSTR), 'ParentOwner' )),
    COMMETHOD(['propput', helpstring(u'Set parent dbase for the GPReplicaDataset.')], HRESULT, 'ParentDatabase',
              ( ['in'], BSTR, 'parentDBase' )),
    COMMETHOD(['propget', helpstring(u'Set parent dbase for the GPReplicaDataset.')], HRESULT, 'ParentDatabase',
              ( ['retval', 'out'], POINTER(BSTR), 'parentDBase' )),
    COMMETHOD(['propput', helpstring(u'Set datasetID for a ReplicaDataset.')], HRESULT, 'DatasetID',
              ( ['in'], c_int, 'DatasetID' )),
    COMMETHOD(['propget', helpstring(u'Set datasetID for a ReplicaDataset.')], HRESULT, 'DatasetID',
              ( ['retval', 'out'], POINTER(c_int), 'DatasetID' )),
    COMMETHOD(['propput', helpstring(u'Set layerID for a ReplicaDataset.')], HRESULT, 'LayerID',
              ( ['in'], c_int, 'LayerID' )),
    COMMETHOD(['propget', helpstring(u'Set layerID for a ReplicaDataset.')], HRESULT, 'LayerID',
              ( ['retval', 'out'], POINTER(c_int), 'LayerID' )),
]
################################################################
## code template for IGPReplicaDataset2 implementation
##class IGPReplicaDataset2_Impl(object):
##    def _get(self):
##        u'Set parent dbase for the GPReplicaDataset.'
##        #return parentDBase
##    def _set(self, parentDBase):
##        u'Set parent dbase for the GPReplicaDataset.'
##    ParentDatabase = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The target name for the GPReplicaDataset.'
##        #return TargetName
##    def _set(self, TargetName):
##        u'The target name for the GPReplicaDataset.'
##    TargetName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Set datasetID for a ReplicaDataset.'
##        #return DatasetID
##    def _set(self, DatasetID):
##        u'Set datasetID for a ReplicaDataset.'
##    DatasetID = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Set parent owner for the GPReplicaDataset.'
##        #return ParentOwner
##    def _set(self, ParentOwner):
##        u'Set parent owner for the GPReplicaDataset.'
##    ParentOwner = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Set layerID for a ReplicaDataset.'
##        #return LayerID
##    def _set(self, LayerID):
##        u'Set layerID for a ReplicaDataset.'
##    LayerID = property(_get, _set, doc = _set.__doc__)
##

class IDatasetMigration(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that migrate a dataset.'
    _iid_ = GUID('{42FBB518-FFB1-4FF5-91B4-23B10F92FF18}')
    _idlflags_ = ['oleautomation']
IDatasetMigration._methods_ = [
    COMMETHOD([helpstring(u'Migrate all binary field storage.')], HRESULT, 'MigrateStorage',
              ( ['in'], BSTR, 'ConfigurationKeyword' )),
    COMMETHOD([helpstring(u'Migrate the geometry field storage.')], HRESULT, 'MigrateGeometryStorage',
              ( ['in'], BSTR, 'ConfigurationKeyword' )),
    COMMETHOD([helpstring(u'Migrate the attribute field storage.')], HRESULT, 'MigrateAttributeStorage',
              ( ['in'], BSTR, 'ConfigurationKeyword' )),
    COMMETHOD([helpstring(u'Migrate the raster storage.')], HRESULT, 'MigrateRasterStorage',
              ( ['in'], BSTR, 'ConfigurationKeyword' )),
]
################################################################
## code template for IDatasetMigration implementation
##class IDatasetMigration_Impl(object):
##    def MigrateGeometryStorage(self, ConfigurationKeyword):
##        u'Migrate the geometry field storage.'
##        #return 
##
##    def MigrateAttributeStorage(self, ConfigurationKeyword):
##        u'Migrate the attribute field storage.'
##        #return 
##
##    def MigrateStorage(self, ConfigurationKeyword):
##        u'Migrate all binary field storage.'
##        #return 
##
##    def MigrateRasterStorage(self, ConfigurationKeyword):
##        u'Migrate the raster storage.'
##        #return 
##

IVersionedWorkspace._methods_ = [
    COMMETHOD(['propget', helpstring(u'All versions the user owns and those which are public or protected.')], HRESULT, 'Versions',
              ( ['retval', 'out'], POINTER(POINTER(IEnumVersionInfo)), 'infoEnum' )),
    COMMETHOD(['propget', helpstring(u'The Default version.')], HRESULT, 'DefaultVersion',
              ( ['retval', 'out'], POINTER(POINTER(IVersion)), 'DefaultVersion' )),
    COMMETHOD([helpstring(u"Finds a specific version given it's name.")], HRESULT, 'FindVersion',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IVersion)), 'resultVersion' )),
    COMMETHOD([helpstring(u'Compresses the database by removing states not referenced by a version.')], HRESULT, 'Compress'),
]
################################################################
## code template for IVersionedWorkspace implementation
##class IVersionedWorkspace_Impl(object):
##    def Compress(self):
##        u'Compresses the database by removing states not referenced by a version.'
##        #return 
##
##    @property
##    def DefaultVersion(self):
##        u'The Default version.'
##        #return DefaultVersion
##
##    def FindVersion(self, Name):
##        u"Finds a specific version given it's name."
##        #return resultVersion
##
##    @property
##    def Versions(self):
##        u'All versions the user owns and those which are public or protected.'
##        #return infoEnum
##

class IndexType(CoClass):
    u'Index Data Element object Type.'
    _reg_clsid_ = GUID('{37B22058-107E-4BCE-9A52-81B31FB2F0A4}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
IndexType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IIndexType, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class Topology(CoClass):
    u'Esri Topology object.'
    _reg_clsid_ = GUID('{AB456700-E5B2-482B-B935-2911BCD94567}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Topology._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDataset, IDatasetEdit, IGeoDataset, ISchemaLock, comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IConnectionPointContainer, IFeatureClassContainer, ITopology2, ITopologyProperties, ITopologyRuleContainer, IErrorFeatureContainer, IMetadata, IMetadataEdit]

class GeometryServer(CoClass):
    u"Provides access to standard operations on geometric 'value' objects. The input geometries are never modified by these operations. Designed for use in building web services and web applications."
    _reg_clsid_ = GUID('{167C8C43-D0DD-4DBB-95B6-B01777AB8AF6}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
GeometryServer._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IObjectConstruct, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IRequestHandler, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IRequestHandler2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IObjectActivate, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILogSupport, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, comtypes.gen._18F2FC71_6B30_45B9_B101_037A8B868B66_0_10_2.IServerObject, comtypes.gen._18F2FC71_6B30_45B9_B101_037A8B868B66_0_10_2.IServerObjectExtensionManager, comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometryServer, comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometryServer2]

class RepresentationWorkspaceExtension(CoClass):
    u'Workspace extension to support representations in a geodatabase.'
    _reg_clsid_ = GUID('{FD05270A-8E0B-4823-9DEE-F149347C32B6}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IRepresentationWorkspaceExtension(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that supply representation workspace extension information.'
    _iid_ = GUID('{8B22787F-F0D2-4390-99D2-2D971861025B}')
    _idlflags_ = ['oleautomation']
RepresentationWorkspaceExtension._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRepresentationWorkspaceExtension, IWorkspaceExtension, IWorkspaceExtension2, IDatasetContainer, IDatasetContainer2, IDatasetContainer3, IWorkspaceExtensionControl, IWorkspaceEvents, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class FeatureConstruction(CoClass):
    u'Esri Feature Construction object.'
    _reg_clsid_ = GUID('{B92B8AD8-9555-4E14-8142-F7D589072354}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IFeatureConstruction(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that add features to a specified feature class using other features and geometries.'
    _iid_ = GUID('{FDBC8766-19C6-43B7-A887-E556F15EC185}')
    _idlflags_ = ['oleautomation']
FeatureConstruction._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IFeatureConstruction]

IEdgeFeature._methods_ = [
    COMMETHOD(['hidden', helpstring(u'Perform the disconnection at either or both of the endpoint.')], HRESULT, 'DisconnectAtEndpoint',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], c_int, 'fromEID' ),
              ( ['in'], c_int, 'toEID' ),
              ( ['in'], VARIANT_BOOL, 'disconnectFrom' ),
              ( ['in'], VARIANT_BOOL, 'disconnectTo' )),
    COMMETHOD(['hidden', helpstring(u'Perform the disconnection at the specified junction.')], HRESULT, 'DisconnectAtJunction',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], c_int, 'junctionEID' )),
    COMMETHOD(['propget', helpstring(u'The geometry corresponding to the element with the given subID.')], HRESULT, 'GeometryForEdgeElement',
              ( ['in'], c_int, 'subID' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Geometry' )),
    COMMETHOD(['propget', helpstring(u'The junction element EID that corresponds to the from endpoint.')], HRESULT, 'FromJunctionEID',
              ( ['retval', 'out'], POINTER(c_int), 'EID' )),
    COMMETHOD(['propget', helpstring(u'The junction that corresponds to the from endpoint.')], HRESULT, 'FromJunctionFeature',
              ( ['retval', 'out'], POINTER(POINTER(IJunctionFeature)), 'Junction' )),
    COMMETHOD(['propget', helpstring(u'The junction element EID that corresponds to the to endpoint.')], HRESULT, 'ToJunctionEID',
              ( ['retval', 'out'], POINTER(c_int), 'EID' )),
    COMMETHOD(['propget', helpstring(u'The junction that corresponds to the to endpoint.')], HRESULT, 'ToJunctionFeature',
              ( ['retval', 'out'], POINTER(POINTER(IJunctionFeature)), 'Junction' )),
    COMMETHOD(['propget', helpstring(u'The FROM and TO junction element EIDs (the first is the FROM, the second is the TO).')], HRESULT, 'FromToJunctionEIDs',
              ( ['retval', 'out'], POINTER(POINTER(IEnumNetEID)), 'EIDs' )),
    COMMETHOD(['hidden', helpstring(u'Programmatic update of the NetworkFeature.')], HRESULT, 'Update',
              ( ['in'], POINTER(INetworkFeature), 'callingFeature' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'oldJunctionLocation' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'newJunctionLocation' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'rigidEdges' ),
              ( ['in'], POINTER(ITransformGroup), 'group' )),
]
################################################################
## code template for IEdgeFeature implementation
##class IEdgeFeature_Impl(object):
##    @property
##    def GeometryForEdgeElement(self, subID):
##        u'The geometry corresponding to the element with the given subID.'
##        #return Geometry
##
##    @property
##    def FromToJunctionEIDs(self):
##        u'The FROM and TO junction element EIDs (the first is the FROM, the second is the TO).'
##        #return EIDs
##
##    @property
##    def ToJunctionFeature(self):
##        u'The junction that corresponds to the to endpoint.'
##        #return Junction
##
##    def Update(self, callingFeature, oldJunctionLocation, newJunctionLocation, rigidEdges, group):
##        u'Programmatic update of the NetworkFeature.'
##        #return 
##
##    @property
##    def ToJunctionEID(self):
##        u'The junction element EID that corresponds to the to endpoint.'
##        #return EID
##
##    def DisconnectAtEndpoint(self, EID, fromEID, toEID, disconnectFrom, disconnectTo):
##        u'Perform the disconnection at either or both of the endpoint.'
##        #return 
##
##    @property
##    def FromJunctionFeature(self):
##        u'The junction that corresponds to the from endpoint.'
##        #return Junction
##
##    @property
##    def FromJunctionEID(self):
##        u'The junction element EID that corresponds to the from endpoint.'
##        #return EID
##
##    def DisconnectAtJunction(self, EID, junctionEID):
##        u'Perform the disconnection at the specified junction.'
##        #return 
##

IAttributeRule._methods_ = [
    COMMETHOD(['propget', helpstring(u'The domain name associated with the attribute rule.')], HRESULT, 'DomainName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The domain name associated with the attribute rule.')], HRESULT, 'DomainName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The field name associated with the attribute rule.')], HRESULT, 'FieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The field name associated with the attribute rule.')], HRESULT, 'FieldName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The subtype code.')], HRESULT, 'SubtypeCode',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The subtype code.')], HRESULT, 'SubtypeCode',
              ( ['in'], c_int, 'Value' )),
    COMMETHOD(['hidden', helpstring(u'Validates the rule.')], HRESULT, 'Validate',
              ( ['in'], POINTER(IRow), 'Row' ),
              ( ['out'], POINTER(BSTR), 'errorMessage' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isValid' )),
]
################################################################
## code template for IAttributeRule implementation
##class IAttributeRule_Impl(object):
##    def Validate(self, Row):
##        u'Validates the rule.'
##        #return errorMessage, isValid
##
##    def _get(self):
##        u'The field name associated with the attribute rule.'
##        #return Name
##    def _set(self, Name):
##        u'The field name associated with the attribute rule.'
##    FieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The subtype code.'
##        #return Value
##    def _set(self, Value):
##        u'The subtype code.'
##    SubtypeCode = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The domain name associated with the attribute rule.'
##        #return Name
##    def _set(self, Name):
##        u'The domain name associated with the attribute rule.'
##    DomainName = property(_get, _set, doc = _set.__doc__)
##

class TopologyGraph(CoClass):
    u'Esri Topology Graph object.'
    _reg_clsid_ = GUID('{201D6A15-781C-4345-B9DA-E679DEC0B692}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class ITopologyGraph2(ITopologyGraph):
    _case_insensitive_ = True
    u'Provides access to members that control the topology graph.'
    _iid_ = GUID('{08198140-4151-4218-B6E1-CDDB110E1D0C}')
    _idlflags_ = ['oleautomation']
class ITopologyGraph3(ITopologyGraph2):
    _case_insensitive_ = True
    u'Provides access to members that control the topology graph.'
    _iid_ = GUID('{15736F85-DD4F-4297-9921-65168571ACA0}')
    _idlflags_ = ['oleautomation']
TopologyGraph._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, ITopologyGraph, ITopologyGraph2, ITopologyGraph3]
TopologyGraph._outgoing_interfaces_ = [ITopologyGraphEvents]

class RepresentationClassName(CoClass):
    u'Name coclass for representation classes.'
    _reg_clsid_ = GUID('{4E74AA22-A1B6-47D4-9914-20F8C6C2B699}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
RepresentationClassName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRepresentationClassName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, IDatasetName2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDocumentVersionSupportGEN]

IPlugInWorkspaceHelper._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if a dataset has to count each row to get the number of rows in the dataset.')], HRESULT, 'RowCountIsCalculated',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'rowCountCalculated' )),
    COMMETHOD(['propget', helpstring(u"Indicates whether the OID is the number of the record, i.e., whether id's are continuous.")], HRESULT, 'OIDIsRecordNumber',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'OIDIsRecordNumber' )),
    COMMETHOD(['propget', helpstring(u'The native type object for datasetType.')], HRESULT, 'NativeType',
              ( ['in'], esriDatasetType, 'DatasetType' ),
              ( ['in'], BSTR, 'localName' ),
              ( ['retval', 'out'], POINTER(POINTER(INativeType)), 'NativeType' )),
    COMMETHOD(['propget', helpstring(u'An array of dataset helpers for each dataset in the workspace.')], HRESULT, 'DatasetNames',
              ( ['in'], esriDatasetType, 'DatasetType' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'DatasetNames' )),
    COMMETHOD([helpstring(u'Opens a dataset helper for the dataset identified by localName.')], HRESULT, 'OpenDataset',
              ( ['in'], BSTR, 'localName' ),
              ( ['retval', 'out'], POINTER(POINTER(IPlugInDatasetHelper)), 'datasetHelper' )),
]
################################################################
## code template for IPlugInWorkspaceHelper implementation
##class IPlugInWorkspaceHelper_Impl(object):
##    def OpenDataset(self, localName):
##        u'Opens a dataset helper for the dataset identified by localName.'
##        #return datasetHelper
##
##    @property
##    def OIDIsRecordNumber(self):
##        u"Indicates whether the OID is the number of the record, i.e., whether id's are continuous."
##        #return OIDIsRecordNumber
##
##    @property
##    def NativeType(self, DatasetType, localName):
##        u'The native type object for datasetType.'
##        #return NativeType
##
##    @property
##    def DatasetNames(self, DatasetType):
##        u'An array of dataset helpers for each dataset in the workspace.'
##        #return DatasetNames
##
##    @property
##    def RowCountIsCalculated(self):
##        u'Indicates if a dataset has to count each row to get the number of rows in the dataset.'
##        #return rowCountCalculated
##

IJunctionFeature._methods_ = [
    COMMETHOD(['propget', helpstring(u'The geometry (point) corresponding to the junction with the given subID.')], HRESULT, 'GeometryForJunctionElement',
              ( ['in'], c_int, 'subID' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Geometry' )),
    COMMETHOD(['propget', helpstring(u'The geometry (point) corresponding to the junction with the given subID.')], HRESULT, 'OriginalGeometryForJunctionElement',
              ( ['in'], c_int, 'subID' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Geometry' )),
    COMMETHOD(['hidden', helpstring(u'Programmatic update of the NetworkFeature.')], HRESULT, 'Update',
              ( ['in'], POINTER(INetworkFeature), 'callingFeature' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IAffineTransformation2D), 'transformation' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'rigidEdges' ),
              ( ['in'], POINTER(ITransformGroup), 'group' )),
    COMMETHOD(['propget', helpstring(u'Programmatic update of the NetworkFeature.')], HRESULT, 'NetworkAncillaryRole',
              ( ['retval', 'out'], POINTER(esriNetworkFeatureAncillaryRole), 'Role' )),
    COMMETHOD(['propput', helpstring(u'Programmatic update of the NetworkFeature.')], HRESULT, 'NetworkAncillaryRole',
              ( ['in'], esriNetworkFeatureAncillaryRole, 'Role' )),
]
################################################################
## code template for IJunctionFeature implementation
##class IJunctionFeature_Impl(object):
##    def _get(self):
##        u'Programmatic update of the NetworkFeature.'
##        #return Role
##    def _set(self, Role):
##        u'Programmatic update of the NetworkFeature.'
##    NetworkAncillaryRole = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def OriginalGeometryForJunctionElement(self, subID):
##        u'The geometry (point) corresponding to the junction with the given subID.'
##        #return Geometry
##
##    @property
##    def GeometryForJunctionElement(self, subID):
##        u'The geometry (point) corresponding to the junction with the given subID.'
##        #return Geometry
##
##    def Update(self, callingFeature, transformation, rigidEdges, group):
##        u'Programmatic update of the NetworkFeature.'
##        #return 
##


# values for enumeration 'esriXmlPropertyType'
esriXPTText = 0
esriXPTBinaryEnclosure = 1
esriXPTLink = 2
esriXPTPicture = 3
esriXPTImage = 4
esriXPTPictureX = 5
esriXmlPropertyType = c_int # enum

# values for enumeration 'esriSyncModel'
esriSyncModelPerReplica = 0
esriSyncModelPerLayer = 1
esriSyncModel = c_int # enum
class TopologyEdge(CoClass):
    u'Esri Topology Edge object.'
    _reg_clsid_ = GUID('{C8D4A1E1-ABC1-4269-BECB-6A3EA04FE444}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TopologyEdge._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITopologyElement, ITopologyEdge]


# values for enumeration 'esriXmlSetPropertyAction'
esriXSPAAddOrReplace = 0
esriXSPAAddIfNotExists = 1
esriXSPAReplaceIfExists = 2
esriXSPAAddDuplicate = 3
esriXmlSetPropertyAction = c_int # enum
IXmlPropertySet._methods_ = [
    COMMETHOD(['propget', helpstring(u'Number of occurrances of an element in the metadata.')], HRESULT, 'CountX',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD([helpstring(u'Returns the set of names and values for elements which have the specified attribute value.')], HRESULT, 'GetPropertiesByAttribute',
              ( ['in'], BSTR, 'Attribute' ),
              ( ['in'], BSTR, 'Value' ),
              ( ['in'], VARIANT_BOOL, 'noValues' ),
              ( ['out'], POINTER(VARIANT), 'Tags' ),
              ( ['out'], POINTER(VARIANT), 'values' )),
    COMMETHOD([helpstring(u'Sets the value of the specified element.')], HRESULT, 'SetPropertyX',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], VARIANT, 'Value' ),
              ( ['in'], esriXmlPropertyType, 'propType' ),
              ( ['in'], esriXmlSetPropertyAction, 'action' ),
              ( [], VARIANT_BOOL, 'syncing' )),
    COMMETHOD([helpstring(u'Deletes the specified elements.')], HRESULT, 'DeleteProperty',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD([helpstring(u'Deletes the elements which have the specified attribute value.')], HRESULT, 'DeletePropertyByAttribute',
              ( ['in'], BSTR, 'Attribute' ),
              ( ['in'], BSTR, 'Value' ),
              ( ['in'], VARIANT_BOOL, 'deleteParent' )),
    COMMETHOD(['hidden', helpstring(u'The values of the specified property.')], HRESULT, 'SimpleGetProperty',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(BSTR), 'Value' )),
    COMMETHOD([helpstring(u'Transforms the metadata using an XSL stylesheet if specified, writes out the header if specified, and saves it in a file.')], HRESULT, 'SaveAsFile',
              ( ['in'], BSTR, 'xslPath' ),
              ( ['in'], BSTR, 'header' ),
              ( ['in'], VARIANT_BOOL, 'outputANSI' ),
              ( ['in', 'out'], POINTER(BSTR), 'outPath' )),
    COMMETHOD(['propget', helpstring(u'Indicates if a new XmlPropertySet was created on retrieving the metadata.')], HRESULT, 'IsNew',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsNew' )),
    COMMETHOD([helpstring(u'Sets the attribute of the specified element.')], HRESULT, 'SetAttribute',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], BSTR, 'Attribute' ),
              ( ['in'], VARIANT, 'Value' ),
              ( ['in'], esriXmlSetPropertyAction, 'action' )),
    COMMETHOD([helpstring(u'Transforms encoded thumbnail and image enclosures to files and links them into the metadata.')], HRESULT, 'TransformImages',
              ( ['in'], BSTR, 'Path' ),
              ( ['out'], POINTER(VARIANT), 'fileNames' )),
    COMMETHOD([helpstring(u'Initializes an XmlPropertySet and adds the Esri group of elements.')], HRESULT, 'InitExisting'),
]
################################################################
## code template for IXmlPropertySet implementation
##class IXmlPropertySet_Impl(object):
##    def SimpleGetProperty(self, Name):
##        u'The values of the specified property.'
##        #return Value
##
##    def TransformImages(self, Path):
##        u'Transforms encoded thumbnail and image enclosures to files and links them into the metadata.'
##        #return fileNames
##
##    @property
##    def IsNew(self):
##        u'Indicates if a new XmlPropertySet was created on retrieving the metadata.'
##        #return IsNew
##
##    def SetAttribute(self, Name, Attribute, Value, action):
##        u'Sets the attribute of the specified element.'
##        #return 
##
##    def SetPropertyX(self, Name, Value, propType, action, syncing):
##        u'Sets the value of the specified element.'
##        #return 
##
##    def InitExisting(self):
##        u'Initializes an XmlPropertySet and adds the Esri group of elements.'
##        #return 
##
##    @property
##    def CountX(self, Name):
##        u'Number of occurrances of an element in the metadata.'
##        #return Count
##
##    def DeletePropertyByAttribute(self, Attribute, Value, deleteParent):
##        u'Deletes the elements which have the specified attribute value.'
##        #return 
##
##    def GetPropertiesByAttribute(self, Attribute, Value, noValues):
##        u'Returns the set of names and values for elements which have the specified attribute value.'
##        #return Tags, values
##
##    def SaveAsFile(self, xslPath, header, outputANSI):
##        u'Transforms the metadata using an XSL stylesheet if specified, writes out the header if specified, and saves it in a file.'
##        #return outPath
##
##    def DeleteProperty(self, Name):
##        u'Deletes the specified elements.'
##        #return 
##

class TopologyNode(CoClass):
    u'Esri Topology Node object.'
    _reg_clsid_ = GUID('{AA177A93-8E87-4392-B14B-571908BD3688}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TopologyNode._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITopologyElement, ITopologyNode]

IGPRelationshipClassKey._methods_ = [
    COMMETHOD(['propput', helpstring(u'The role of the key in the relationship class.')], HRESULT, 'KeyRole',
              ( ['in'], esriRelKeyRole, 'Role' )),
    COMMETHOD(['propget', helpstring(u'The role of the key in the relationship class.')], HRESULT, 'KeyRole',
              ( ['retval', 'out'], POINTER(esriRelKeyRole), 'Role' )),
    COMMETHOD(['propput', helpstring(u'The name of the field that contains object identifiers.')], HRESULT, 'ObjectKeyName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The name of the field that contains object identifiers.')], HRESULT, 'ObjectKeyName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the field that contains object class identifiers.')], HRESULT, 'ClassKeyName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The name of the field that contains object class identifiers.')], HRESULT, 'ClassKeyName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
]
################################################################
## code template for IGPRelationshipClassKey implementation
##class IGPRelationshipClassKey_Impl(object):
##    def _get(self):
##        u'The name of the field that contains object class identifiers.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the field that contains object class identifiers.'
##    ClassKeyName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the field that contains object identifiers.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the field that contains object identifiers.'
##    ObjectKeyName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The role of the key in the relationship class.'
##        #return Role
##    def _set(self, Role):
##        u'The role of the key in the relationship class.'
##    KeyRole = property(_get, _set, doc = _set.__doc__)
##

INetworkFeature._methods_ = [
    COMMETHOD(['propget', helpstring(u'The containing GeometricNetwork.')], HRESULT, 'GeometricNetwork',
              ( ['retval', 'out'], POINTER(POINTER(IGeometricNetwork)), 'Network' )),
    COMMETHOD(['propget', helpstring(u'Indicates whether the NetworkFeature is open or not (i.e., closed).')], HRESULT, 'Enabled',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isEnabled' )),
    COMMETHOD(['propput', helpstring(u'Indicates whether the NetworkFeature is open or not (i.e., closed).')], HRESULT, 'Enabled',
              ( ['in'], VARIANT_BOOL, 'isEnabled' )),
    COMMETHOD([helpstring(u'Connect the Feature to the geometrically coincident NetworkFeature.')], HRESULT, 'Connect'),
    COMMETHOD([helpstring(u'Disconnect the Feature from all connected NetworkFeatures.')], HRESULT, 'Disconnect'),
    COMMETHOD([helpstring(u'Preparation for disconnecting the NetworkFeature.')], HRESULT, 'OnDisconnect'),
    COMMETHOD([helpstring(u'Create the necessary NetworkElements in the associated Logical Network.')], HRESULT, 'CreateNetworkElements',
              ( ['retval', 'out'], POINTER(POINTER(IEnumNetEID)), 'newEIDs' )),
]
################################################################
## code template for INetworkFeature implementation
##class INetworkFeature_Impl(object):
##    def Disconnect(self):
##        u'Disconnect the Feature from all connected NetworkFeatures.'
##        #return 
##
##    def OnDisconnect(self):
##        u'Preparation for disconnecting the NetworkFeature.'
##        #return 
##
##    def _get(self):
##        u'Indicates whether the NetworkFeature is open or not (i.e., closed).'
##        #return isEnabled
##    def _set(self, isEnabled):
##        u'Indicates whether the NetworkFeature is open or not (i.e., closed).'
##    Enabled = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def GeometricNetwork(self):
##        u'The containing GeometricNetwork.'
##        #return Network
##
##    def Connect(self):
##        u'Connect the Feature to the geometrically coincident NetworkFeature.'
##        #return 
##
##    def CreateNetworkElements(self):
##        u'Create the necessary NetworkElements in the associated Logical Network.'
##        #return newEIDs
##

class DataElementHelper(CoClass):
    u'Esri Data Element Helper object.'
    _reg_clsid_ = GUID('{52865BC9-81C0-4AEC-B339-047C0A6CB425}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DataElementHelper._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDataElementHelper]

ITopologyRule._methods_ = [
    COMMETHOD(['propget', helpstring(u'Name of the topology rule.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'Name of the topology rule.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'GUID of the topology rule.')], HRESULT, 'GUID',
              ( ['retval', 'out'], POINTER(BSTR), 'GUID' )),
    COMMETHOD(['propget', helpstring(u'Origin ClassID of the topology rule.')], HRESULT, 'OriginClassID',
              ( ['retval', 'out'], POINTER(c_int), 'ClassID' )),
    COMMETHOD(['propput', helpstring(u'Origin ClassID of the topology rule.')], HRESULT, 'OriginClassID',
              ( ['in'], c_int, 'ClassID' )),
    COMMETHOD(['propget', helpstring(u'Origin subtype of the topology rule.')], HRESULT, 'OriginSubtype',
              ( ['retval', 'out'], POINTER(c_int), 'SubType' )),
    COMMETHOD(['propput', helpstring(u'Origin subtype of the topology rule.')], HRESULT, 'OriginSubtype',
              ( ['in'], c_int, 'SubType' )),
    COMMETHOD(['propget', helpstring(u'Destination ClassID of the topology rule.')], HRESULT, 'DestinationClassID',
              ( ['retval', 'out'], POINTER(c_int), 'ClassID' )),
    COMMETHOD(['propput', helpstring(u'Destination ClassID of the topology rule.')], HRESULT, 'DestinationClassID',
              ( ['in'], c_int, 'ClassID' )),
    COMMETHOD(['propget', helpstring(u'Destination subtype of the topology rule.')], HRESULT, 'DestinationSubtype',
              ( ['retval', 'out'], POINTER(c_int), 'SubType' )),
    COMMETHOD(['propput', helpstring(u'Destination subtype of the topology rule.')], HRESULT, 'DestinationSubtype',
              ( ['in'], c_int, 'SubType' )),
    COMMETHOD(['propget', helpstring(u'Topology rule type of the topology rule.')], HRESULT, 'TopologyRuleType',
              ( ['retval', 'out'], POINTER(esriTopologyRuleType), 'ruleType' )),
    COMMETHOD(['propput', helpstring(u'Topology rule type of the topology rule.')], HRESULT, 'TopologyRuleType',
              ( ['in'], esriTopologyRuleType, 'ruleType' )),
    COMMETHOD(['propget', helpstring(u'Indicates if error events are triggered for the topology rule.')], HRESULT, 'TriggerErrorEvents',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'errorEvents' )),
    COMMETHOD(['propput', helpstring(u'Indicates if error events are triggered for the topology rule.')], HRESULT, 'TriggerErrorEvents',
              ( ['in'], VARIANT_BOOL, 'errorEvents' )),
    COMMETHOD([helpstring(u'Indicates the shape types of errors for the topology rule.')], HRESULT, 'ErrorShapeTypes',
              ( ['out'], POINTER(VARIANT_BOOL), 'multipoints' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'polylines' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'polygons' )),
    COMMETHOD(['propget', helpstring(u'Indicates if all origin subtypes are specified for the topology rule.')], HRESULT, 'AllOriginSubtypes',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'allSubtypes' )),
    COMMETHOD(['propput', helpstring(u'Indicates if all origin subtypes are specified for the topology rule.')], HRESULT, 'AllOriginSubtypes',
              ( ['in'], VARIANT_BOOL, 'allSubtypes' )),
    COMMETHOD(['propget', helpstring(u'Indicates if all destination subtypes are specified for the topology rule.')], HRESULT, 'AllDestinationSubtypes',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'allSubtypes' )),
    COMMETHOD(['propput', helpstring(u'Indicates if all destination subtypes are specified for the topology rule.')], HRESULT, 'AllDestinationSubtypes',
              ( ['in'], VARIANT_BOOL, 'allSubtypes' )),
    COMMETHOD(['propget', helpstring(u'Indicates if an origin subtype has been specified.')], HRESULT, 'OriginSubtypeSpecified',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'subtypeSpecified' )),
    COMMETHOD(['propget', helpstring(u'Indicates if a destination subtype has been specified.')], HRESULT, 'DestinationSubtypeSpecified',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'subtypeSpecified' )),
]
################################################################
## code template for ITopologyRule implementation
##class ITopologyRule_Impl(object):
##    def _get(self):
##        u'Destination subtype of the topology rule.'
##        #return SubType
##    def _set(self, SubType):
##        u'Destination subtype of the topology rule.'
##    DestinationSubtype = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Name of the topology rule.'
##        #return Name
##    def _set(self, Name):
##        u'Name of the topology rule.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def ErrorShapeTypes(self):
##        u'Indicates the shape types of errors for the topology rule.'
##        #return multipoints, polylines, polygons
##
##    def _get(self):
##        u'Topology rule type of the topology rule.'
##        #return ruleType
##    def _set(self, ruleType):
##        u'Topology rule type of the topology rule.'
##    TopologyRuleType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if all origin subtypes are specified for the topology rule.'
##        #return allSubtypes
##    def _set(self, allSubtypes):
##        u'Indicates if all origin subtypes are specified for the topology rule.'
##    AllOriginSubtypes = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def OriginSubtypeSpecified(self):
##        u'Indicates if an origin subtype has been specified.'
##        #return subtypeSpecified
##
##    def _get(self):
##        u'Indicates if all destination subtypes are specified for the topology rule.'
##        #return allSubtypes
##    def _set(self, allSubtypes):
##        u'Indicates if all destination subtypes are specified for the topology rule.'
##    AllDestinationSubtypes = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Destination ClassID of the topology rule.'
##        #return ClassID
##    def _set(self, ClassID):
##        u'Destination ClassID of the topology rule.'
##    DestinationClassID = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if error events are triggered for the topology rule.'
##        #return errorEvents
##    def _set(self, errorEvents):
##        u'Indicates if error events are triggered for the topology rule.'
##    TriggerErrorEvents = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Origin ClassID of the topology rule.'
##        #return ClassID
##    def _set(self, ClassID):
##        u'Origin ClassID of the topology rule.'
##    OriginClassID = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def DestinationSubtypeSpecified(self):
##        u'Indicates if a destination subtype has been specified.'
##        #return subtypeSpecified
##
##    @property
##    def GUID(self):
##        u'GUID of the topology rule.'
##        #return GUID
##
##    def _get(self):
##        u'Origin subtype of the topology rule.'
##        #return SubType
##    def _set(self, SubType):
##        u'Origin subtype of the topology rule.'
##    OriginSubtype = property(_get, _set, doc = _set.__doc__)
##

class TopologyRule(CoClass):
    u'Esri Topology Rule object.'
    _reg_clsid_ = GUID('{8AD43889-F2A4-43B2-83DC-6D1D38DDBCC8}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TopologyRule._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRule, ITopologyRule, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

class TopologyErrorFeature(CoClass):
    u'Esri Topology Error Feature object.'
    _reg_clsid_ = GUID('{AC7DBF37-7523-4186-8D40-B20FA197AF19}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TopologyErrorFeature._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRow, IRowBuffer, IRowEvents, IRowSubtypes, IRowChanges, IRowCompare, IFeature, IFeatureBuffer, IFeatureEvents, IFeatureChanges, IValidate, IFeatureDraw, IRowEdit, IFeatureEdit, IFeatureSimplify, IRelatedObjectEvents, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, ITopologyFeature, ITopologyErrorFeature, IFeatureProject]

class IPlugInFastQueryValues(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that query record values quickly.'
    _iid_ = GUID('{865271A7-61C1-41E8-9F6E-31D825B37B57}')
    _idlflags_ = ['oleautomation']
IPlugInFastQueryValues._methods_ = [
    COMMETHOD([helpstring(u'Gets the values for the non-geometry fields in the current record.')], HRESULT, 'FastQueryValues',
              ( ['in'], POINTER(FieldValue), 'values' )),
]
################################################################
## code template for IPlugInFastQueryValues implementation
##class IPlugInFastQueryValues_Impl(object):
##    def FastQueryValues(self, values):
##        u'Gets the values for the non-geometry fields in the current record.'
##        #return 
##

IFIDSetOperator._methods_ = [
    COMMETHOD([helpstring(u'Combines all the feature IDs that are in one or the other collection into a single collection.')], HRESULT, 'Union',
              ( ['in'], POINTER(IFIDSet), 'otherFIDSet' ),
              ( ['retval', 'out'], POINTER(POINTER(IFIDSet)), 'newFIDSet' )),
    COMMETHOD([helpstring(u'Combines the feature IDs that are common to both collections into a single collection.')], HRESULT, 'Intersect',
              ( ['in'], POINTER(IFIDSet), 'otherFIDSet' ),
              ( ['retval', 'out'], POINTER(POINTER(IFIDSet)), 'newFIDSet' )),
    COMMETHOD([helpstring(u'Returns the feature IDs that are not in the collection, but are present in the input collection.')], HRESULT, 'Difference',
              ( ['in'], POINTER(IFIDSet), 'otherFIDSet' ),
              ( ['retval', 'out'], POINTER(POINTER(IFIDSet)), 'newFIDSet' )),
    COMMETHOD([helpstring(u'Combines the feature IDs that are in one of the collections, but not both collections, into a single collection.')], HRESULT, 'SymmetricDifference',
              ( ['in'], POINTER(IFIDSet), 'otherFIDSet' ),
              ( ['retval', 'out'], POINTER(POINTER(IFIDSet)), 'newFIDSet' )),
]
################################################################
## code template for IFIDSetOperator implementation
##class IFIDSetOperator_Impl(object):
##    def Union(self, otherFIDSet):
##        u'Combines all the feature IDs that are in one or the other collection into a single collection.'
##        #return newFIDSet
##
##    def Difference(self, otherFIDSet):
##        u'Returns the feature IDs that are not in the collection, but are present in the input collection.'
##        #return newFIDSet
##
##    def Intersect(self, otherFIDSet):
##        u'Combines the feature IDs that are common to both collections into a single collection.'
##        #return newFIDSet
##
##    def SymmetricDifference(self, otherFIDSet):
##        u'Combines the feature IDs that are in one of the collections, but not both collections, into a single collection.'
##        #return newFIDSet
##

ISimpleJunctionFeature._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of EdgeFeatures associated with this junction.')], HRESULT, 'EdgeFeatureCount',
              ( ['retval', 'out'], POINTER(c_int), 'numFeatures' )),
    COMMETHOD(['propget', helpstring(u'The EdgeFeature associated with the specified index value.')], HRESULT, 'EdgeFeature',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IEdgeFeature)), 'EdgeFeature' )),
    COMMETHOD(['propget', helpstring(u'The logical network element ID of this junction.')], HRESULT, 'EID',
              ( ['retval', 'out'], POINTER(c_int), 'ElementID' )),
]
################################################################
## code template for ISimpleJunctionFeature implementation
##class ISimpleJunctionFeature_Impl(object):
##    @property
##    def EdgeFeature(self, Index):
##        u'The EdgeFeature associated with the specified index value.'
##        #return EdgeFeature
##
##    @property
##    def EdgeFeatureCount(self):
##        u'The number of EdgeFeatures associated with this junction.'
##        #return numFeatures
##
##    @property
##    def EID(self):
##        u'The logical network element ID of this junction.'
##        #return ElementID
##

class ITableNameSet(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that describe a set of table names.'
    _iid_ = GUID('{612806D1-9887-4BF7-B555-03B84AA8C8E5}')
    _idlflags_ = ['oleautomation']
ITableNameSet._methods_ = [
    COMMETHOD([helpstring(u'Add table to set.')], HRESULT, 'Add',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IDatasetName), 'TableName' )),
    COMMETHOD([helpstring(u'Remove table from set.')], HRESULT, 'Remove',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD([helpstring(u'Find table in set.')], HRESULT, 'Find',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IDatasetName)), 'TableName' )),
    COMMETHOD(['propget', helpstring(u'Does the set contain this table.')], HRESULT, 'Exists',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Exists' )),
]
################################################################
## code template for ITableNameSet implementation
##class ITableNameSet_Impl(object):
##    @property
##    def Exists(self, Name):
##        u'Does the set contain this table.'
##        #return Exists
##
##    def Add(self, Name, TableName):
##        u'Add table to set.'
##        #return 
##
##    def Find(self, Name):
##        u'Find table in set.'
##        #return TableName
##
##    def Remove(self, Name):
##        u'Remove table from set.'
##        #return 
##

IRecordSetInit._methods_ = [
    COMMETHOD(['propget', helpstring(u'The maximum number of records for the recordset.')], HRESULT, 'MaxRecordCount',
              ( ['retval', 'out'], POINTER(c_int), 'MaxRecordCount' )),
    COMMETHOD(['propput', helpstring(u'The maximum number of records for the recordset.')], HRESULT, 'MaxRecordCount',
              ( ['in'], c_int, 'MaxRecordCount' )),
    COMMETHOD([helpstring(u'Sets the source table or feature class for a Recordset.')], HRESULT, 'SetSourceTable',
              ( ['in'], POINTER(ITable), 'Table' ),
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' )),
    COMMETHOD([helpstring(u'Sets the source QueryDef for a Recordset.')], HRESULT, 'SetSourceQueryDef',
              ( ['in'], POINTER(IQueryDef), 'QueryDef' )),
    COMMETHOD([helpstring(u'Creates an empty table or feature class for a Recordset.')], HRESULT, 'CreateTable',
              ( ['in'], POINTER(IFields), 'Fields' )),
    COMMETHOD([helpstring(u'Creates a row buffer that can be used with an insert cursor.')], HRESULT, 'CreateRowBuffer',
              ( ['retval', 'out'], POINTER(POINTER(IRowBuffer)), 'RowBuffer' )),
    COMMETHOD([helpstring(u'Returns a  cursor that can be used to insert new rows.')], HRESULT, 'Insert',
              ( ['retval', 'out'], POINTER(POINTER(ICursor)), 'Cursor' )),
]
################################################################
## code template for IRecordSetInit implementation
##class IRecordSetInit_Impl(object):
##    def _get(self):
##        u'The maximum number of records for the recordset.'
##        #return MaxRecordCount
##    def _set(self, MaxRecordCount):
##        u'The maximum number of records for the recordset.'
##    MaxRecordCount = property(_get, _set, doc = _set.__doc__)
##
##    def Insert(self):
##        u'Returns a  cursor that can be used to insert new rows.'
##        #return Cursor
##
##    def SetSourceQueryDef(self, QueryDef):
##        u'Sets the source QueryDef for a Recordset.'
##        #return 
##
##    def CreateRowBuffer(self):
##        u'Creates a row buffer that can be used with an insert cursor.'
##        #return RowBuffer
##
##    def CreateTable(self, Fields):
##        u'Creates an empty table or feature class for a Recordset.'
##        #return 
##
##    def SetSourceTable(self, Table, QueryFilter):
##        u'Sets the source table or feature class for a Recordset.'
##        #return 
##

IXmlPropertySetEdit._methods_ = [
    COMMETHOD(['propputref', helpstring(u'Dataset whose metadata will be edited.')], HRESULT, 'Dataset',
              ( ['in'], POINTER(IDataset), 'rhs' )),
    COMMETHOD([helpstring(u'Returns the set of values for the specified element.')], HRESULT, 'GetProperty',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'values' )),
    COMMETHOD([helpstring(u'Sets the value of the specified element.')], HRESULT, 'SetProperty',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], VARIANT, 'Value' ),
              ( ['in'], esriXmlPropertyType, 'propType' ),
              ( ['in'], esriXmlSetPropertyAction, 'action' )),
]
################################################################
## code template for IXmlPropertySetEdit implementation
##class IXmlPropertySetEdit_Impl(object):
##    def SetProperty(self, Name, Value, propType, action):
##        u'Sets the value of the specified element.'
##        #return 
##
##    def GetProperty(self, Name):
##        u'Returns the set of values for the specified element.'
##        #return values
##
##    def Dataset(self, rhs):
##        u'Dataset whose metadata will be edited.'
##        #return 
##

IReplicaLog._methods_ = [
    COMMETHOD(['propget', helpstring(u'The ID of the Replica Log.')], HRESULT, 'LogID',
              ( ['retval', 'out'], POINTER(c_int), 'LogID' )),
    COMMETHOD(['propget', helpstring(u'The ID of the replica.')], HRESULT, 'ReplicaID',
              ( ['retval', 'out'], POINTER(c_int), 'ReplicaID' )),
    COMMETHOD(['propget', helpstring(u'The synchronize operation.')], HRESULT, 'SynchronizeOperation',
              ( ['retval', 'out'], POINTER(esriSynchronizationOperations), 'syncOp' )),
    COMMETHOD(['propget', helpstring(u'Error code associated with log event.')], HRESULT, 'ErrorCode',
              ( ['retval', 'out'], POINTER(HRESULT), 'ErrorCode' )),
    COMMETHOD(['propget', helpstring(u'Date of the synchronization event.')], HRESULT, 'LogDate',
              ( ['retval', 'out'], POINTER(VARIANT), 'LogDate' )),
    COMMETHOD(['propget', helpstring(u'Source generation start number.')], HRESULT, 'SourceStartGen',
              ( ['retval', 'out'], POINTER(c_int), 'startGen' )),
    COMMETHOD(['propget', helpstring(u'Source generation end number.')], HRESULT, 'SourceEndGen',
              ( ['retval', 'out'], POINTER(c_int), 'endGen' )),
    COMMETHOD(['propget', helpstring(u'Target generation number.')], HRESULT, 'TargetGen',
              ( ['retval', 'out'], POINTER(c_int), 'TargetGen' )),
]
################################################################
## code template for IReplicaLog implementation
##class IReplicaLog_Impl(object):
##    @property
##    def ErrorCode(self):
##        u'Error code associated with log event.'
##        #return ErrorCode
##
##    @property
##    def SourceEndGen(self):
##        u'Source generation end number.'
##        #return endGen
##
##    @property
##    def TargetGen(self):
##        u'Target generation number.'
##        #return TargetGen
##
##    @property
##    def LogID(self):
##        u'The ID of the Replica Log.'
##        #return LogID
##
##    @property
##    def ReplicaID(self):
##        u'The ID of the replica.'
##        #return ReplicaID
##
##    @property
##    def SynchronizeOperation(self):
##        u'The synchronize operation.'
##        #return syncOp
##
##    @property
##    def SourceStartGen(self):
##        u'Source generation start number.'
##        #return startGen
##
##    @property
##    def LogDate(self):
##        u'Date of the synchronization event.'
##        #return LogDate
##

class ReplicaDescription(CoClass):
    u'Defines the datasets in a replica.'
    _reg_clsid_ = GUID('{1858B629-9870-49F1-AD2E-947C7CF5D47A}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
ReplicaDescription._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IReplicaDescription, IReplicaFilterDescription, IReplicaFilterDescription2, IReplicaDescription2, IReplicaDescription3, IReplicaDescription4, IXMLReplicaDescription, IReplicaFilterDescriptionEdit, IReplicaDescriptionExtensionManager, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDocumentVersionSupportGEN]

IDENetworkDataset2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The type of the network elevation model.')], HRESULT, 'ElevationModel',
              ( ['retval', 'out'], POINTER(esriNetworkElevationModel), 'networkElevationModel' )),
    COMMETHOD(['propput', helpstring(u'The type of the network elevation model.')], HRESULT, 'ElevationModel',
              ( ['in'], esriNetworkElevationModel, 'networkElevationModel' )),
    COMMETHOD(['propget', helpstring(u'Traffic data.')], HRESULT, 'TrafficData',
              ( ['retval', 'out'], POINTER(POINTER(ITrafficData)), 'TrafficData' )),
    COMMETHOD(['propputref', helpstring(u'Traffic data.')], HRESULT, 'TrafficData',
              ( ['in'], POINTER(ITrafficData), 'TrafficData' )),
    COMMETHOD(['propget', helpstring(u'Name of the time zone attribute.')], HRESULT, 'TimeZoneAttributeName',
              ( ['retval', 'out'], POINTER(BSTR), 'AttributeName' )),
    COMMETHOD(['propput', helpstring(u'Name of the time zone attribute.')], HRESULT, 'TimeZoneAttributeName',
              ( ['in'], BSTR, 'AttributeName' )),
    COMMETHOD(['propget', helpstring(u'Name of the time zone table.')], HRESULT, 'TimeZoneTableName',
              ( ['retval', 'out'], POINTER(BSTR), 'TableName' )),
    COMMETHOD(['propput', helpstring(u'Name of the time zone table.')], HRESULT, 'TimeZoneTableName',
              ( ['in'], BSTR, 'TableName' )),
]
################################################################
## code template for IDENetworkDataset2 implementation
##class IDENetworkDataset2_Impl(object):
##    def TrafficData(self, TrafficData):
##        u'Traffic data.'
##        #return 
##
##    def _get(self):
##        u'The type of the network elevation model.'
##        #return networkElevationModel
##    def _set(self, networkElevationModel):
##        u'The type of the network elevation model.'
##    ElevationModel = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Name of the time zone attribute.'
##        #return AttributeName
##    def _set(self, AttributeName):
##        u'Name of the time zone attribute.'
##    TimeZoneAttributeName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Name of the time zone table.'
##        #return TableName
##    def _set(self, TableName):
##        u'Name of the time zone table.'
##    TimeZoneTableName = property(_get, _set, doc = _set.__doc__)
##

class IGPNetworkDatasetMembership(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u"Provides access to members that describe the properties of a feature class' network dataset membership."
    _iid_ = GUID('{911AA830-945B-40B7-BD9B-97B451CFBE7A}')
    _idlflags_ = ['oleautomation']
IGPNetworkDatasetMembership._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the network dataset this feature class participates in.')], HRESULT, 'NetworkDatasetName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the network dataset this feature class participates in.')], HRESULT, 'NetworkDatasetName',
              ( ['in'], BSTR, 'Name' )),
]
################################################################
## code template for IGPNetworkDatasetMembership implementation
##class IGPNetworkDatasetMembership_Impl(object):
##    def _get(self):
##        u'The name of the network dataset this feature class participates in.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the network dataset this feature class participates in.'
##    NetworkDatasetName = property(_get, _set, doc = _set.__doc__)
##

IXMLFilterDef._methods_ = [
    COMMETHOD(['propget', helpstring(u'The field name.')], HRESULT, 'FieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propput', helpstring(u'The field name.')], HRESULT, 'FieldName',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'The filter expression.')], HRESULT, 'Expression',
              ( ['retval', 'out'], POINTER(BSTR), 'expr' )),
    COMMETHOD(['propput', helpstring(u'The filter expression.')], HRESULT, 'Expression',
              ( ['in'], BSTR, 'expr' )),
]
################################################################
## code template for IXMLFilterDef implementation
##class IXMLFilterDef_Impl(object):
##    def _get(self):
##        u'The filter expression.'
##        #return expr
##    def _set(self, expr):
##        u'The filter expression.'
##    Expression = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The field name.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The field name.'
##    FieldName = property(_get, _set, doc = _set.__doc__)
##

class NetworkFieldEvaluator(CoClass):
    u'A container for describing a network attribute evaluator whose values are derived from object field attributes.'
    _reg_clsid_ = GUID('{68055FC4-37D5-4BD0-81A5-CD177A29759C}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class INetworkFieldEvaluator(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of a network attribute evaluator whose values are derived from object field attributes.'
    _iid_ = GUID('{6337AB0F-7A5E-4DE6-BB75-492B407146FF}')
    _idlflags_ = ['oleautomation']
class INetworkFieldEvaluator2(INetworkFieldEvaluator):
    _case_insensitive_ = True
    u'Provides access to members that specify the properties of a network attribute evaluator whose values are derived from object field attributes.'
    _iid_ = GUID('{371F4A7D-EDEA-457E-920D-4B7DE2D2B6A5}')
    _idlflags_ = ['oleautomation']
NetworkFieldEvaluator._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkEvaluator, INetworkEvaluator2, INetworkFieldEvaluator, INetworkFieldEvaluator2, INetworkEvaluatorSetup, IGPDescribe]

class EdgeFeatureSource(CoClass):
    u'A container for describing a network dataset source whose edge elements are derived from line feature geometry.'
    _reg_clsid_ = GUID('{F2140D50-6B26-414D-A39F-F35AC54D10DE}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
EdgeFeatureSource._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkSource, IEdgeFeatureSource]

IDataStatistics._methods_ = [
    COMMETHOD(['propput', helpstring(u'The field for which to gather statistics.')], HRESULT, 'Field',
              ( ['in'], BSTR, 'Field' )),
    COMMETHOD(['propget', helpstring(u'The field for which to gather statistics.')], HRESULT, 'Field',
              ( ['retval', 'out'], POINTER(BSTR), 'Field' )),
    COMMETHOD(['propputref', helpstring(u'The cursor which will generate the statistics.')], HRESULT, 'Cursor',
              ( ['in'], POINTER(ICursor), 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The maximum number of records to sample at a time (-1 means pull all records).')], HRESULT, 'SampleRate',
              ( ['in'], c_int, 'maxRecords' )),
    COMMETHOD(['propget', helpstring(u'The maximum number of records to sample at a time (-1 means pull all records).')], HRESULT, 'SampleRate',
              ( ['retval', 'out'], POINTER(c_int), 'maxRecords' )),
    COMMETHOD(['propput', helpstring(u'Indicates whether only simple statistics are generated.')], HRESULT, 'SimpleStats',
              ( ['in'], VARIANT_BOOL, 'simple' )),
    COMMETHOD(['propget', helpstring(u'Indicates whether only simple statistics are generated.')], HRESULT, 'SimpleStats',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'simple' )),
    COMMETHOD(['propget', helpstring(u'The statistics for the current field over the current cursor.')], HRESULT, 'Statistics',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStatisticsResults)), 'results' )),
    COMMETHOD(['propget', helpstring(u'The unique values for the current field over the current cursor.')], HRESULT, 'UniqueValues',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IEnumVARIANT)), 'values' )),
    COMMETHOD(['propget', helpstring(u'The number of unique values for the current sample.')], HRESULT, 'UniqueValueCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the cursor contains more records than the current sample.')], HRESULT, 'Continue',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'canContinue' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the operation has been cancelled.')], HRESULT, 'Cancelled',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Cancelled' )),
]
################################################################
## code template for IDataStatistics implementation
##class IDataStatistics_Impl(object):
##    @property
##    def UniqueValueCount(self):
##        u'The number of unique values for the current sample.'
##        #return Count
##
##    @property
##    def Statistics(self):
##        u'The statistics for the current field over the current cursor.'
##        #return results
##
##    @property
##    def Cancelled(self):
##        u'Indicates if the operation has been cancelled.'
##        #return Cancelled
##
##    @property
##    def Continue(self):
##        u'Indicates if the cursor contains more records than the current sample.'
##        #return canContinue
##
##    def Cursor(self, rhs):
##        u'The cursor which will generate the statistics.'
##        #return 
##
##    def _get(self):
##        u'The field for which to gather statistics.'
##        #return Field
##    def _set(self, Field):
##        u'The field for which to gather statistics.'
##    Field = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def UniqueValues(self):
##        u'The unique values for the current field over the current cursor.'
##        #return values
##
##    def _get(self):
##        u'Indicates whether only simple statistics are generated.'
##        #return simple
##    def _set(self, simple):
##        u'Indicates whether only simple statistics are generated.'
##    SimpleStats = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The maximum number of records to sample at a time (-1 means pull all records).'
##        #return maxRecords
##    def _set(self, maxRecords):
##        u'The maximum number of records to sample at a time (-1 means pull all records).'
##    SampleRate = property(_get, _set, doc = _set.__doc__)
##

class SpatialFilter(CoClass):
    u'Esri Spatial Filter object.'
    _reg_clsid_ = GUID('{FDFEBD96-ED75-11D0-9A95-080009EC734B}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
SpatialFilter._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ISpatialFilter, IQueryFilter, IQueryFilter2, IQueryFilterDefinition, IQueryFilterDefinition2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize]

INetworkAttributeParameter._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the parameter.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the parameter.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The default value of the parameter.')], HRESULT, 'DefaultValue',
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The default value of the parameter.')], HRESULT, 'DefaultValue',
              ( ['in'], VARIANT, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The current value of the parameter.')], HRESULT, 'Value',
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The current value of the parameter.')], HRESULT, 'Value',
              ( ['in'], VARIANT, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The VARTYPE of the parameter (e.g. VT_I4).')], HRESULT, 'VarType',
              ( ['retval', 'out'], POINTER(c_int), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The VARTYPE of the parameter (e.g. VT_I4).')], HRESULT, 'VarType',
              ( ['in'], c_int, 'Value' )),
]
################################################################
## code template for INetworkAttributeParameter implementation
##class INetworkAttributeParameter_Impl(object):
##    def _get(self):
##        u'The default value of the parameter.'
##        #return Value
##    def _set(self, Value):
##        u'The default value of the parameter.'
##    DefaultValue = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The VARTYPE of the parameter (e.g. VT_I4).'
##        #return Value
##    def _set(self, Value):
##        u'The VARTYPE of the parameter (e.g. VT_I4).'
##    VarType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the parameter.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the parameter.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The current value of the parameter.'
##        #return Value
##    def _set(self, Value):
##        u'The current value of the parameter.'
##    Value = property(_get, _set, doc = _set.__doc__)
##

ITopologyClass._methods_ = [
    COMMETHOD(['propget', helpstring(u'The Topology associated with the class.')], HRESULT, 'Topology',
              ( ['retval', 'out'], POINTER(POINTER(ITopology)), 'Topology' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the class is in a topology.')], HRESULT, 'IsInTopology',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'inTopology' )),
    COMMETHOD(['propget', helpstring(u'The weight of the class in the topology.')], HRESULT, 'Weight',
              ( ['retval', 'out'], POINTER(c_double), 'Weight' )),
    COMMETHOD(['propget', helpstring(u'The XY rank of the class in the topology.')], HRESULT, 'XYRank',
              ( ['retval', 'out'], POINTER(c_int), 'XYRank' )),
    COMMETHOD(['propget', helpstring(u'The Z rank of the class in the topology.')], HRESULT, 'ZRank',
              ( ['retval', 'out'], POINTER(c_int), 'ZRank' )),
    COMMETHOD(['propget', helpstring(u'Indicates if event notification is fired on validate.')], HRESULT, 'EventNotificationOnValidate',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'eventNotification' )),
]
################################################################
## code template for ITopologyClass implementation
##class ITopologyClass_Impl(object):
##    @property
##    def Weight(self):
##        u'The weight of the class in the topology.'
##        #return Weight
##
##    @property
##    def EventNotificationOnValidate(self):
##        u'Indicates if event notification is fired on validate.'
##        #return eventNotification
##
##    @property
##    def XYRank(self):
##        u'The XY rank of the class in the topology.'
##        #return XYRank
##
##    @property
##    def ZRank(self):
##        u'The Z rank of the class in the topology.'
##        #return ZRank
##
##    @property
##    def IsInTopology(self):
##        u'Indicates if the class is in a topology.'
##        #return inTopology
##
##    @property
##    def Topology(self):
##        u'The Topology associated with the class.'
##        #return Topology
##

IRelQueryTableSettings._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if Fire row changed events.')], HRESULT, 'FireRowChangedEvents',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'fireRowEvents' )),
    COMMETHOD(['propput', helpstring(u'Indicates if Fire row changed events.')], HRESULT, 'FireRowChangedEvents',
              ( ['in'], VARIANT_BOOL, 'fireRowEvents' )),
]
################################################################
## code template for IRelQueryTableSettings implementation
##class IRelQueryTableSettings_Impl(object):
##    def _get(self):
##        u'Indicates if Fire row changed events.'
##        #return fireRowEvents
##    def _set(self, fireRowEvents):
##        u'Indicates if Fire row changed events.'
##    FireRowChangedEvents = property(_get, _set, doc = _set.__doc__)
##

ITopologyClassEvents._methods_ = [
    COMMETHOD([helpstring(u'This event is fired when the topology containing the class is validated.')], HRESULT, 'OnValidate',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'validatedArea' )),
]
################################################################
## code template for ITopologyClassEvents implementation
##class ITopologyClassEvents_Impl(object):
##    def OnValidate(self, validatedArea):
##        u'This event is fired when the topology containing the class is validated.'
##        #return 
##

INetworkAttributeParameter2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The usage type of the parameter.')], HRESULT, 'ParameterUsageType',
              ( ['retval', 'out'], POINTER(esriNetworkAttributeParameterUsageType), 'ParameterUsageType' )),
    COMMETHOD(['propput', helpstring(u'The usage type of the parameter.')], HRESULT, 'ParameterUsageType',
              ( ['in'], esriNetworkAttributeParameterUsageType, 'ParameterUsageType' )),
]
################################################################
## code template for INetworkAttributeParameter2 implementation
##class INetworkAttributeParameter2_Impl(object):
##    def _get(self):
##        u'The usage type of the parameter.'
##        #return ParameterUsageType
##    def _set(self, ParameterUsageType):
##        u'The usage type of the parameter.'
##    ParameterUsageType = property(_get, _set, doc = _set.__doc__)
##

IWorkspaceFactory._methods_ = [
    COMMETHOD([helpstring(u'Opens the workspace specified by the connection properties.')], HRESULT, 'Open',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'ConnectionProperties' ),
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'hWnd' ),
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'Workspace' )),
    COMMETHOD([helpstring(u'Opens the workspace specified by the given file name.')], HRESULT, 'OpenFromFile',
              ( ['in'], BSTR, 'fileName' ),
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'hWnd' ),
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'Workspace' )),
    COMMETHOD([helpstring(u'Creates a new workspace specified by the directory, file name, and connection properties.')], HRESULT, 'Create',
              ( ['in'], BSTR, 'parentDirectory' ),
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'ConnectionProperties' ),
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'hWnd' ),
              ( ['retval', 'out'], POINTER(POINTER(IWorkspaceName)), 'WorkspaceName' )),
    COMMETHOD([helpstring(u'Indicates if parentDirectory contains a valid workspace, or is a valid file-system workspace.')], HRESULT, 'ContainsWorkspace',
              ( ['in'], BSTR, 'parentDirectory' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IFileNames), 'fileNames' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'ContainsWorkspace' )),
    COMMETHOD([helpstring(u'Retrieves the workspace name of a workspace from the given list of file names.')], HRESULT, 'GetWorkspaceName',
              ( ['in'], BSTR, 'parentDirectory' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IFileNames), 'fileNames' ),
              ( ['retval', 'out'], POINTER(POINTER(IWorkspaceName)), 'WorkspaceName' )),
    COMMETHOD([helpstring(u'The class ID of the WorkspaceFactory.')], HRESULT, 'GetClassID',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'ClassID' )),
    COMMETHOD([helpstring(u'True if the specified file identifies a workspace supported by the workspace factory.')], HRESULT, 'IsWorkspace',
              ( ['in'], BSTR, 'fileName' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsWorkspace' )),
    COMMETHOD([helpstring(u'The connection properties from the specified file.')], HRESULT, 'ReadConnectionPropertiesFromFile',
              ( ['in'], BSTR, 'fileName' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'ConnectionProperties' )),
    COMMETHOD(['propget', helpstring(u'A singular or plural description of the type of workspace the workspace factory opens/creates.')], HRESULT, 'WorkspaceDescription',
              ( ['in'], VARIANT_BOOL, 'plural' ),
              ( ['retval', 'out'], POINTER(BSTR), 'Description' )),
    COMMETHOD(['propget', helpstring(u'The type of workspace the workspace factory opens/creates.')], HRESULT, 'WorkspaceType',
              ( ['retval', 'out'], POINTER(esriWorkspaceType), 'Type' )),
    COMMETHOD([helpstring(u'Copies a workspace to the specified destination folder.')], HRESULT, 'Copy',
              ( ['in'], POINTER(IWorkspaceName), 'WorkspaceName' ),
              ( ['in'], BSTR, 'destinationFolder' ),
              ( ['out'], POINTER(POINTER(IWorkspaceName)), 'workspaceNameCopy' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'successfulCopy' )),
    COMMETHOD([helpstring(u'Moves a workspace to the specified destination folder.')], HRESULT, 'Move',
              ( ['in'], POINTER(IWorkspaceName), 'WorkspaceName' ),
              ( ['in'], BSTR, 'destinationFolder' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'successfulMove' )),
]
################################################################
## code template for IWorkspaceFactory implementation
##class IWorkspaceFactory_Impl(object):
##    def Copy(self, WorkspaceName, destinationFolder):
##        u'Copies a workspace to the specified destination folder.'
##        #return workspaceNameCopy, successfulCopy
##
##    def OpenFromFile(self, fileName, hWnd):
##        u'Opens the workspace specified by the given file name.'
##        #return Workspace
##
##    def GetWorkspaceName(self, parentDirectory, fileNames):
##        u'Retrieves the workspace name of a workspace from the given list of file names.'
##        #return WorkspaceName
##
##    def GetClassID(self):
##        u'The class ID of the WorkspaceFactory.'
##        #return ClassID
##
##    def Create(self, parentDirectory, Name, ConnectionProperties, hWnd):
##        u'Creates a new workspace specified by the directory, file name, and connection properties.'
##        #return WorkspaceName
##
##    def Move(self, WorkspaceName, destinationFolder):
##        u'Moves a workspace to the specified destination folder.'
##        #return successfulMove
##
##    @property
##    def WorkspaceType(self):
##        u'The type of workspace the workspace factory opens/creates.'
##        #return Type
##
##    def IsWorkspace(self, fileName):
##        u'True if the specified file identifies a workspace supported by the workspace factory.'
##        #return IsWorkspace
##
##    @property
##    def WorkspaceDescription(self, plural):
##        u'A singular or plural description of the type of workspace the workspace factory opens/creates.'
##        #return Description
##
##    def Open(self, ConnectionProperties, hWnd):
##        u'Opens the workspace specified by the connection properties.'
##        #return Workspace
##
##    def ReadConnectionPropertiesFromFile(self, fileName):
##        u'The connection properties from the specified file.'
##        #return ConnectionProperties
##
##    def ContainsWorkspace(self, parentDirectory, fileNames):
##        u'Indicates if parentDirectory contains a valid workspace, or is a valid file-system workspace.'
##        #return ContainsWorkspace
##

INetworkAttribute2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Array of parameters for this network attribute.')], HRESULT, 'Parameters',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'Parameters' )),
    COMMETHOD(['propputref', helpstring(u'Array of parameters for this network attribute.')], HRESULT, 'Parameters',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'Parameters' )),
    COMMETHOD([helpstring(u'Refresh the network evaluators assigned to this network attribute.')], HRESULT, 'Refresh'),
    COMMETHOD(['propget', helpstring(u'Indicates if this network attribute is to be used by default.')], HRESULT, 'UseByDefault',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'UseByDefault' )),
    COMMETHOD(['propput', helpstring(u'Indicates if this network attribute is to be used by default.')], HRESULT, 'UseByDefault',
              ( ['in'], VARIANT_BOOL, 'UseByDefault' )),
]
################################################################
## code template for INetworkAttribute2 implementation
##class INetworkAttribute2_Impl(object):
##    def Refresh(self):
##        u'Refresh the network evaluators assigned to this network attribute.'
##        #return 
##
##    def Parameters(self, Parameters):
##        u'Array of parameters for this network attribute.'
##        #return 
##
##    def _get(self):
##        u'Indicates if this network attribute is to be used by default.'
##        #return UseByDefault
##    def _set(self, UseByDefault):
##        u'Indicates if this network attribute is to be used by default.'
##    UseByDefault = property(_get, _set, doc = _set.__doc__)
##

INetworkAttribute3._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the network attribute is time aware.')], HRESULT, 'IsTimeAware',
              ( [], esriNetworkElementType, 'ElementType' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsTimeAware' )),
]
################################################################
## code template for INetworkAttribute3 implementation
##class INetworkAttribute3_Impl(object):
##    @property
##    def IsTimeAware(self, ElementType):
##        u'Indicates if the network attribute is time aware.'
##        #return IsTimeAware
##

ITopologyGraph2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the topology graph contains pseudo nodes.')], HRESULT, 'HasPseudoNodes',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasPseudoNodes' )),
]
################################################################
## code template for ITopologyGraph2 implementation
##class ITopologyGraph2_Impl(object):
##    @property
##    def HasPseudoNodes(self):
##        u'Indicates if the topology graph contains pseudo nodes.'
##        #return HasPseudoNodes
##

class IXMLIndexTemplateManage(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Manages the collection of XML Index Templates for this Geodatabase instance.'
    _iid_ = GUID('{E33C6591-6510-4528-8F93-0E19F424A38A}')
    _idlflags_ = ['oleautomation']
IXMLIndexTemplateManage._methods_ = [
    COMMETHOD(['propget', helpstring(u'Retrieves the currently installed templates.')], HRESULT, 'Templates',
              ( ['retval', 'out'], POINTER(POINTER(IEnumXMLIndexTemplate)), 'templateEnum' )),
    COMMETHOD([helpstring(u'Installs a new template.')], HRESULT, 'InstallTemplate',
              ( ['in'], POINTER(IXMLIndexTemplate), 'newTemplate' )),
    COMMETHOD([helpstring(u'Uninstalls an existing template.')], HRESULT, 'UninstallTemplate',
              ( ['in'], POINTER(IXMLIndexTemplate), 'existingTemplate' )),
    COMMETHOD([helpstring(u"Populate an XML Index's IncludedTags and ExcludedTags properties from an installed template.")], HRESULT, 'PopulateIndexTags',
              ( ['in'], POINTER(IXMLIndexTemplate), 'sourceTemplate' ),
              ( ['in'], POINTER(IXMLIndex), 'Index' )),
]
################################################################
## code template for IXMLIndexTemplateManage implementation
##class IXMLIndexTemplateManage_Impl(object):
##    @property
##    def Templates(self):
##        u'Retrieves the currently installed templates.'
##        #return templateEnum
##
##    def PopulateIndexTags(self, sourceTemplate, Index):
##        u"Populate an XML Index's IncludedTags and ExcludedTags properties from an installed template."
##        #return 
##
##    def InstallTemplate(self, newTemplate):
##        u'Installs a new template.'
##        #return 
##
##    def UninstallTemplate(self, existingTemplate):
##        u'Uninstalls an existing template.'
##        #return 
##


# values for enumeration 'esriMetadataChangeType'
esriMCTAddRule = 0
esriMCTDeleteRule = 1
esriMCTChangeTolerance = 2
esriMCTAttributeMapping = 3
esriMCTConnectivityPolicy = 4
esriMetadataChangeType = c_int # enum
IRepresentationWorkspaceExtension._methods_ = [
    COMMETHOD([helpstring(u'Opens a representation class.')], HRESULT, 'OpenRepresentationClass',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(POINTER(IRepresentationClass)), 'repClass' )),
    COMMETHOD([helpstring(u'Creates a representation class.')], HRESULT, 'CreateRepresentationClass',
              ( ['in'], POINTER(IFeatureClass), 'FeatureClass' ),
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], BSTR, 'ruleIDFldName' ),
              ( ['in'], BSTR, 'overrideFldName' ),
              ( ['in'], VARIANT_BOOL, 'RequireShapeOverride' ),
              ( ['in'], POINTER(IRepresentationRules), 'Rules' ),
              ( ['in'], POINTER(comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IGraphicAttributes), 'ClassAttributes' ),
              ( ['retval', 'out'], POINTER(POINTER(IRepresentationClass)), 'repClass' )),
    COMMETHOD(['propget', helpstring(u'Representation class names defined in the workspace.')], HRESULT, 'RepresentationClassNames',
              ( ['retval', 'out'], POINTER(POINTER(IEnumDatasetName)), 'enumNames' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the feature class has representations.')], HRESULT, 'FeatureClassHasRepresentations',
              ( ['in'], POINTER(IFeatureClass), 'FeatureClass' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'hasRep' )),
    COMMETHOD(['propget', helpstring(u'Representation class names associated to a given feature class.')], HRESULT, 'FeatureClassRepresentationNames',
              ( ['in'], POINTER(IFeatureClass), 'FeatureClass' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumDatasetName)), 'enumDataset' )),
]
################################################################
## code template for IRepresentationWorkspaceExtension implementation
##class IRepresentationWorkspaceExtension_Impl(object):
##    def CreateRepresentationClass(self, FeatureClass, Name, ruleIDFldName, overrideFldName, RequireShapeOverride, Rules, ClassAttributes):
##        u'Creates a representation class.'
##        #return repClass
##
##    def OpenRepresentationClass(self, Name):
##        u'Opens a representation class.'
##        #return repClass
##
##    @property
##    def FeatureClassRepresentationNames(self, FeatureClass):
##        u'Representation class names associated to a given feature class.'
##        #return enumDataset
##
##    @property
##    def FeatureClassHasRepresentations(self, FeatureClass):
##        u'Indicates if the feature class has representations.'
##        #return hasRep
##
##    @property
##    def RepresentationClassNames(self):
##        u'Representation class names defined in the workspace.'
##        #return enumNames
##

ITinNodeCollection._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of nodes in the TIN.')], HRESULT, 'NodeCount',
              ( ['retval', 'out'], POINTER(c_int), 'pcNodes' )),
    COMMETHOD([helpstring(u'The node referenced by the index.')], HRESULT, 'GetNode',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(ITinNode)), 'ppNode' )),
    COMMETHOD([helpstring(u'Sets the node equal to that specified by the index.')], HRESULT, 'QueryNode',
              ( ['in'], c_int, 'Index' ),
              ( [], POINTER(ITinNode), 'pNode' )),
    COMMETHOD([helpstring(u'Sets the node equal to a point specified by the index.')], HRESULT, 'QueryNodeAsPoint',
              ( ['in'], c_int, 'Index' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pPoint' )),
    COMMETHOD([helpstring(u'Sets the node equal to a z-value point specified by the index.')], HRESULT, 'QueryNodeAsWKSPointZ',
              ( ['in'], c_int, 'Index' ),
              ( ['out'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ), 'pPoint' )),
    COMMETHOD(['hidden', helpstring(u'Returns a Voronoi polygon about the node referenced by the index.')], HRESULT, 'GetVoronoiRegionNoClip',
              ( ['in'], c_int, 'nodeIndex' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon)), 'ppRegion' )),
    COMMETHOD([helpstring(u'Returns a Voronoi polygon about the node referenced by the index.')], HRESULT, 'GetVoronoiRegion',
              ( ['in'], c_int, 'nodeIndex' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon), 'pClippingPolygon' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon)), 'ppRegion' )),
    COMMETHOD([helpstring(u'Writes the set of Voronoi polygons for each node to a feature class.')], HRESULT, 'ConvertToVoronoiRegions',
              ( [], POINTER(IFeatureClass), 'pFeatureClass' ),
              ( ['in'], POINTER(ITinFilter), 'pFilter' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon), 'pClippingPolygon' ),
              ( ['in'], BSTR, 'indexFieldName' ),
              ( ['in'], BSTR, 'tagFieldName' )),
    COMMETHOD([helpstring(u'Returns the z value of the node referenced by the index.')], HRESULT, 'GetNodeZ',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(c_double), 'pZ' )),
    COMMETHOD([helpstring(u'Returns the tag value of the TIN node specified by the index.')], HRESULT, 'GetNodeTagValue',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(c_int), 'pValue' )),
    COMMETHOD(['propget', helpstring(u'Indicates if TIN nodes have tag values.')], HRESULT, 'HasNodeTagValues',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbHasNodeValues' )),
]
################################################################
## code template for ITinNodeCollection implementation
##class ITinNodeCollection_Impl(object):
##    def ConvertToVoronoiRegions(self, pFeatureClass, pFilter, pClippingPolygon, indexFieldName, tagFieldName):
##        u'Writes the set of Voronoi polygons for each node to a feature class.'
##        #return 
##
##    def GetNodeTagValue(self, Index):
##        u'Returns the tag value of the TIN node specified by the index.'
##        #return pValue
##
##    def QueryNodeAsPoint(self, Index, pPoint):
##        u'Sets the node equal to a point specified by the index.'
##        #return 
##
##    @property
##    def HasNodeTagValues(self):
##        u'Indicates if TIN nodes have tag values.'
##        #return pbHasNodeValues
##
##    @property
##    def NodeCount(self):
##        u'The number of nodes in the TIN.'
##        #return pcNodes
##
##    def QueryNode(self, Index, pNode):
##        u'Sets the node equal to that specified by the index.'
##        #return 
##
##    def GetNodeZ(self, Index):
##        u'Returns the z value of the node referenced by the index.'
##        #return pZ
##
##    def GetVoronoiRegionNoClip(self, nodeIndex):
##        u'Returns a Voronoi polygon about the node referenced by the index.'
##        #return ppRegion
##
##    def QueryNodeAsWKSPointZ(self, Index):
##        u'Sets the node equal to a z-value point specified by the index.'
##        #return pPoint
##
##    def GetVoronoiRegion(self, nodeIndex, pClippingPolygon):
##        u'Returns a Voronoi polygon about the node referenced by the index.'
##        #return ppRegion
##
##    def GetNode(self, Index):
##        u'The node referenced by the index.'
##        #return ppNode
##

ITopologyGraph3._methods_ = [
    COMMETHOD([helpstring(u'Provides the invalid area of the topology graph.')], HRESULT, 'PostEx',
              ( [], POINTER(IInvalidArea), 'InvalidArea' )),
]
################################################################
## code template for ITopologyGraph3 implementation
##class ITopologyGraph3_Impl(object):
##    def PostEx(self, InvalidArea):
##        u'Provides the invalid area of the topology graph.'
##        #return 
##

class ITopologyGraph4(ITopologyGraph3):
    _case_insensitive_ = True
    u'Provides access to members that control the topology graph.'
    _iid_ = GUID('{2174251C-D2F1-4188-824B-785A1CC6D673}')
    _idlflags_ = ['oleautomation']
ITopologyGraph4._methods_ = [
    COMMETHOD([helpstring(u'Creates topo elements from all topology feature classes intersecting the specified polygon. The topology graph takes ownership of the input polygon.')], HRESULT, 'BuildFromPolygon',
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon), 'Extent' ),
              ( [], VARIANT_BOOL, 'preserveSelection' )),
    COMMETHOD(['propget', helpstring(u'The polygon used to determine the contents of the topology graph. The topology graph maintains ownership of this reference.')], HRESULT, 'BuildPolygonExtent',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolygon)), 'BuildExtent' )),
    COMMETHOD([helpstring(u'Nodes located outside a polygonal build extent do not have a known degree (valence). Apply this method before using the Degree or IsDegreeKnown properties of a topology node from this graph.')], HRESULT, 'DetermineNodeDegree'),
    COMMETHOD([helpstring(u'Merge a connected sequence of selected edges that has the same feature parent set.')], HRESULT, 'MergeSelectedEdges'),
]
################################################################
## code template for ITopologyGraph4 implementation
##class ITopologyGraph4_Impl(object):
##    def DetermineNodeDegree(self):
##        u'Nodes located outside a polygonal build extent do not have a known degree (valence). Apply this method before using the Degree or IsDegreeKnown properties of a topology node from this graph.'
##        #return 
##
##    def BuildFromPolygon(self, Extent, preserveSelection):
##        u'Creates topo elements from all topology feature classes intersecting the specified polygon. The topology graph takes ownership of the input polygon.'
##        #return 
##
##    @property
##    def BuildPolygonExtent(self):
##        u'The polygon used to determine the contents of the topology graph. The topology graph maintains ownership of this reference.'
##        #return BuildExtent
##
##    def MergeSelectedEdges(self):
##        u'Merge a connected sequence of selected edges that has the same feature parent set.'
##        #return 
##

IHistoricalTrafficData2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The field name for base speed in the join table.')], HRESULT, 'JoinTableBaseSpeedFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propput', helpstring(u'The field name for base speed in the join table.')], HRESULT, 'JoinTableBaseSpeedFieldName',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'Base speed units.')], HRESULT, 'JoinTableBaseSpeedUnits',
              ( ['retval', 'out'], POINTER(esriNetworkAttributeUnits), 'Units' )),
    COMMETHOD(['propput', helpstring(u'Base speed units.')], HRESULT, 'JoinTableBaseSpeedUnits',
              ( ['in'], esriNetworkAttributeUnits, 'Units' )),
]
################################################################
## code template for IHistoricalTrafficData2 implementation
##class IHistoricalTrafficData2_Impl(object):
##    def _get(self):
##        u'The field name for base speed in the join table.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The field name for base speed in the join table.'
##    JoinTableBaseSpeedFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Base speed units.'
##        #return Units
##    def _set(self, Units):
##        u'Base speed units.'
##    JoinTableBaseSpeedUnits = property(_get, _set, doc = _set.__doc__)
##

class ICancelOperation(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that indicate if an operation has been cancelled.'
    _iid_ = GUID('{E9C5F595-6B3A-4F00-B201-05FF64F99BD3}')
    _idlflags_ = []
ICancelOperation._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the operation has been cancelled.')], HRESULT, 'IsCancelled',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsCancelled' )),
]
################################################################
## code template for ICancelOperation implementation
##class ICancelOperation_Impl(object):
##    @property
##    def IsCancelled(self):
##        u'Indicates if the operation has been cancelled.'
##        #return IsCancelled
##

class IRepairConnectivityProgressEvents(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to events that occur when the Repair Connectivity Tool is progressing through the features.'
    _iid_ = GUID('{CFA5B406-5B16-4817-86E5-BC632A7988C8}')
    _idlflags_ = ['oleautomation']
IRepairConnectivityProgressEvents._methods_ = [
    COMMETHOD([helpstring(u'The message displayed on the progress window.')], HRESULT, 'PutMessage',
              ( ['in'], BSTR, 'phaseMessage' )),
    COMMETHOD([helpstring(u'The maximum number of features to repair.')], HRESULT, 'MaxFeatures',
              ( ['in'], c_int, 'MaxFeatures' )),
    COMMETHOD([helpstring(u'The current position where the iterator currently is.')], HRESULT, 'StepValue',
              ( ['in'], c_int, 'StepValue' )),
    COMMETHOD([helpstring(u'Increments the StepValue.')], HRESULT, 'Step'),
    COMMETHOD([helpstring(u'Indicates if the cancel button has been clicked.')], HRESULT, 'IsCancelled',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsCancelled' )),
]
################################################################
## code template for IRepairConnectivityProgressEvents implementation
##class IRepairConnectivityProgressEvents_Impl(object):
##    def MaxFeatures(self, MaxFeatures):
##        u'The maximum number of features to repair.'
##        #return 
##
##    def StepValue(self, StepValue):
##        u'The current position where the iterator currently is.'
##        #return 
##
##    def PutMessage(self, phaseMessage):
##        u'The message displayed on the progress window.'
##        #return 
##
##    def IsCancelled(self):
##        u'Indicates if the cancel button has been clicked.'
##        #return IsCancelled
##
##    def Step(self):
##        u'Increments the StepValue.'
##        #return 
##

IDirectionsAttributeMapping._methods_ = [
    COMMETHOD(['propput', helpstring(u'The key name to be used for driving directions generation.')], HRESULT, 'KeyName',
              ( ['in'], BSTR, 'KeyName' )),
    COMMETHOD(['propget', helpstring(u'The key name to be used for driving directions generation.')], HRESULT, 'KeyName',
              ( ['retval', 'out'], POINTER(BSTR), 'KeyName' )),
    COMMETHOD(['propput', helpstring(u'The network attribute name associated with the directions key name.')], HRESULT, 'AttributeName',
              ( ['in'], BSTR, 'AttributeName' )),
    COMMETHOD(['propget', helpstring(u'The network attribute name associated with the directions key name.')], HRESULT, 'AttributeName',
              ( ['retval', 'out'], POINTER(BSTR), 'AttributeName' )),
]
################################################################
## code template for IDirectionsAttributeMapping implementation
##class IDirectionsAttributeMapping_Impl(object):
##    def _get(self):
##        u'The key name to be used for driving directions generation.'
##        #return KeyName
##    def _set(self, KeyName):
##        u'The key name to be used for driving directions generation.'
##    KeyName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The network attribute name associated with the directions key name.'
##        #return AttributeName
##    def _set(self, AttributeName):
##        u'The network attribute name associated with the directions key name.'
##    AttributeName = property(_get, _set, doc = _set.__doc__)
##

class RepairConnectivityProgress(CoClass):
    u'An object for showing progress while repairing connectivity.'
    _reg_clsid_ = GUID('{168D1FB6-FE34-4AD7-A011-541A3FCCB92C}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
RepairConnectivityProgress._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._59FCCD31_434C_4017_BDEF_DB4B7EDC9CE0_0_10_2.IConnectionPointContainer, IRepairConnectivityProgress]
RepairConnectivityProgress._outgoing_interfaces_ = [IRepairConnectivityProgressEvents]

class INetworkElement64(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that specify the 64-bit IDs for a network element.'
    _iid_ = GUID('{3FC192F4-D423-4B49-AE4E-407D6A9AA62E}')
    _idlflags_ = ['dual', 'oleautomation']
INetworkElement64._methods_ = [
    COMMETHOD([dispid(10), helpstring(u'64-bit element ID for this network element.'), 'propget'], HRESULT, 'EID',
              ( ['retval', 'out'], POINTER(c_longlong), 'EID' )),
    COMMETHOD([dispid(20), helpstring(u'64-bit object ID of the object corresponding to this network element.'), 'propget'], HRESULT, 'OID',
              ( ['retval', 'out'], POINTER(c_longlong), 'OID' )),
]
################################################################
## code template for INetworkElement64 implementation
##class INetworkElement64_Impl(object):
##    @property
##    def OID(self):
##        u'64-bit object ID of the object corresponding to this network element.'
##        #return OID
##
##    @property
##    def EID(self):
##        u'64-bit element ID for this network element.'
##        #return EID
##

IFeatureConstruction._methods_ = [
    COMMETHOD([helpstring(u'Adds line to an fc, using the map selection as the feature source. The selection can contain polygons and polylines from multiple features classes - including the target feature class. -1 for c.t. means use c.t. of target sr.')], HRESULT, 'ConstructLines',
              ( [], POINTER(ICancelOperation), 'cancel' ),
              ( [], POINTER(IFeatureClass), 'targetFC' ),
              ( [], POINTER(IEnumFeature), 'sel' ),
              ( [], VARIANT_BOOL, 'replaceExistingInTarget' ),
              ( [], POINTER(IInvalidArea), 'InvalidArea' ),
              ( [], c_double, 'ClusterTolerance' )),
    COMMETHOD([helpstring(u'Adds line to a feature class, using a feature cursor as the feature source. The cursor can return features from the target feature class, in which case the original features will be deleted. -1 for c.t. means use c.t. of target sr.')], HRESULT, 'ConstructLinesFromCursor',
              ( [], POINTER(ICancelOperation), 'cancel' ),
              ( [], POINTER(IFeatureClass), 'targetFC' ),
              ( [], POINTER(IFeatureCursor), 'sel' ),
              ( [], VARIANT_BOOL, 'replaceExistingInTarget' ),
              ( [], POINTER(IInvalidArea), 'InvalidArea' ),
              ( [], c_double, 'ClusterTolerance' )),
    COMMETHOD([helpstring(u"Constructs polygons into the feature class, using the map's polyline selection as the feature source.")], HRESULT, 'ConstructPolygonsFromFeatures',
              ( [], POINTER(ICancelOperation), 'cancel' ),
              ( [], POINTER(IFeatureClass), 'FeatureClass' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'processingBounds' ),
              ( [], VARIANT_BOOL, 'modifyExisting' ),
              ( [], VARIANT_BOOL, 'replaceTargetSelection' ),
              ( [], POINTER(IEnumFeature), 'lineSrc' ),
              ( [], POINTER(IInvalidArea), 'InvalidArea' ),
              ( [], c_double, 'ClusterTolerance' ),
              ( [], POINTER(IFeatureClass), 'labels' )),
    COMMETHOD([helpstring(u'Constructs polygons into the specified feature class, using the cursor as the feature source.')], HRESULT, 'ConstructPolygonsFromFeaturesFromCursor',
              ( [], POINTER(ICancelOperation), 'cancel' ),
              ( [], POINTER(IFeatureClass), 'targetFC' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'processingBounds' ),
              ( [], VARIANT_BOOL, 'modifyExisting' ),
              ( [], VARIANT_BOOL, 'replaceTargetSelection' ),
              ( [], POINTER(IFeatureCursor), 'pLineSrc' ),
              ( [], POINTER(IInvalidArea), 'InvalidArea' ),
              ( [], c_double, 'ClusterTolerance' ),
              ( [], POINTER(IFeatureClass), 'pLabels' )),
    COMMETHOD([helpstring(u'Constructs polygons into the specified feature class, using the specified set of polyline geometries to define new boundaries (possibly in combination with existing polygons features).')], HRESULT, 'ConstructPolygonsFromGeometries',
              ( [], POINTER(ICancelOperation), 'cancel' ),
              ( [], POINTER(IFeatureClass), 'FeatureClass' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'processingBounds' ),
              ( [], VARIANT_BOOL, 'modifyExisting' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnumGeometry), 'pLineSrc' ),
              ( [], POINTER(IInvalidArea), 'InvalidArea' ),
              ( [], c_double, 'ClusterTolerance' )),
    COMMETHOD([helpstring(u'Splits polygons in the specified feature class, using the polyline selection as the feature source.')], HRESULT, 'SplitPolygonsWithLines',
              ( [], POINTER(ICancelOperation), 'cancel' ),
              ( [], POINTER(IFeatureClass), 'FeatureClass' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'processingBounds' ),
              ( [], POINTER(IEnumFeature), 'lineSrc' ),
              ( [], POINTER(IInvalidArea), 'InvalidArea' ),
              ( [], c_double, 'ClusterTolerance' )),
    COMMETHOD([helpstring(u'Splits polygons in the specified feature class, using the polyline selection as the feature source.')], HRESULT, 'SplitPolygonsWithLinesFromCursor',
              ( [], POINTER(ICancelOperation), 'cancel' ),
              ( [], POINTER(IFeatureClass), 'FeatureClass' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'processingBounds' ),
              ( [], POINTER(IFeatureCursor), 'pLineSrc' ),
              ( [], POINTER(IInvalidArea), 'InvalidArea' ),
              ( [], c_double, 'ClusterTolerance' )),
    COMMETHOD([helpstring(u'Adds polygons to the specified feature class by combining existing polygons with the specified line source.')], HRESULT, 'AutoCompleteFromGeometries',
              ( [], POINTER(IFeatureClass), 'FeatureClass' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'processingBounds' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnumGeometry), 'lineSrc' ),
              ( [], POINTER(IInvalidArea), 'InvalidArea' ),
              ( [], c_double, 'ClusterTolerance' ),
              ( [], POINTER(IWorkspace), 'selectionWorkspace' ),
              ( ['out'], POINTER(POINTER(ISelectionSet)), 'SelectionSet' )),
    COMMETHOD([helpstring(u'Adds polygons to the specified feature class by combining existing polygons with the specified line source.')], HRESULT, 'AutoCompleteFromFeatures',
              ( [], POINTER(IFeatureClass), 'FeatureClass' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'processingBounds' ),
              ( [], POINTER(IEnumFeature), 'lineSrc' ),
              ( [], POINTER(IInvalidArea), 'InvalidArea' ),
              ( [], c_double, 'ClusterTolerance' ),
              ( [], POINTER(IWorkspace), 'selectionWorkspace' ),
              ( ['out'], POINTER(POINTER(ISelectionSet)), 'SelectionSet' )),
    COMMETHOD([helpstring(u'Adds polygons to the specified feature class by combining existing polygons with the specified line source.')], HRESULT, 'AutoCompleteFromFeaturesFromCursor',
              ( [], POINTER(IFeatureClass), 'FeatureClass' ),
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'processingBounds' ),
              ( [], POINTER(IFeatureCursor), 'lineSrc' ),
              ( [], POINTER(IInvalidArea), 'InvalidArea' ),
              ( [], c_double, 'ClusterTolerance' ),
              ( [], POINTER(IWorkspace), 'selectionWorkspace' ),
              ( ['out'], POINTER(POINTER(ISelectionSet)), 'SelectionSet' )),
    COMMETHOD([helpstring(u'Replaces the line selection set with a planarized version of it. Assumes all lines are from same feature class.')], HRESULT, 'PlanarizeLines',
              ( [], POINTER(ICancelOperation), 'cancel' ),
              ( [], POINTER(IEnumFeature), 'enumFeature' ),
              ( [], c_double, 'ClusterTolerance' )),
    COMMETHOD([helpstring(u'Replaces the line selection set with a planarized version of it.')], HRESULT, 'PlanarizeLinesFromCursor',
              ( [], POINTER(ICancelOperation), 'cancel' ),
              ( [], POINTER(IFeatureClass), 'FeatureClass' ),
              ( [], POINTER(IFeatureCursor), 'FeatureCursor' ),
              ( [], c_double, 'ClusterTolerance' )),
    COMMETHOD(['propput', helpstring(u'The subtype for subsequently constructed features.')], HRESULT, 'ConstructedFeaturesSubtype',
              ( [], c_int, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The z value to be used when constructing features from inputs that are not z-aware.')], HRESULT, 'DefaultZ',
              ( [], c_double, 'rhs' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the last IFeatureConstruction method created or altered features.')], HRESULT, 'FeaturesChanged',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'FeaturesChanged' )),
]
################################################################
## code template for IFeatureConstruction implementation
##class IFeatureConstruction_Impl(object):
##    def AutoCompleteFromFeatures(self, FeatureClass, processingBounds, lineSrc, InvalidArea, ClusterTolerance, selectionWorkspace):
##        u'Adds polygons to the specified feature class by combining existing polygons with the specified line source.'
##        #return SelectionSet
##
##    def AutoCompleteFromGeometries(self, FeatureClass, processingBounds, lineSrc, InvalidArea, ClusterTolerance, selectionWorkspace):
##        u'Adds polygons to the specified feature class by combining existing polygons with the specified line source.'
##        #return SelectionSet
##
##    def ConstructLinesFromCursor(self, cancel, targetFC, sel, replaceExistingInTarget, InvalidArea, ClusterTolerance):
##        u'Adds line to a feature class, using a feature cursor as the feature source. The cursor can return features from the target feature class, in which case the original features will be deleted. -1 for c.t. means use c.t. of target sr.'
##        #return 
##
##    def _set(self, rhs):
##        u'The subtype for subsequently constructed features.'
##    ConstructedFeaturesSubtype = property(fset = _set, doc = _set.__doc__)
##
##    def ConstructLines(self, cancel, targetFC, sel, replaceExistingInTarget, InvalidArea, ClusterTolerance):
##        u'Adds line to an fc, using the map selection as the feature source. The selection can contain polygons and polylines from multiple features classes - including the target feature class. -1 for c.t. means use c.t. of target sr.'
##        #return 
##
##    def ConstructPolygonsFromGeometries(self, cancel, FeatureClass, processingBounds, modifyExisting, pLineSrc, InvalidArea, ClusterTolerance):
##        u'Constructs polygons into the specified feature class, using the specified set of polyline geometries to define new boundaries (possibly in combination with existing polygons features).'
##        #return 
##
##    def PlanarizeLinesFromCursor(self, cancel, FeatureClass, FeatureCursor, ClusterTolerance):
##        u'Replaces the line selection set with a planarized version of it.'
##        #return 
##
##    def SplitPolygonsWithLines(self, cancel, FeatureClass, processingBounds, lineSrc, InvalidArea, ClusterTolerance):
##        u'Splits polygons in the specified feature class, using the polyline selection as the feature source.'
##        #return 
##
##    def ConstructPolygonsFromFeatures(self, cancel, FeatureClass, processingBounds, modifyExisting, replaceTargetSelection, lineSrc, InvalidArea, ClusterTolerance, labels):
##        u"Constructs polygons into the feature class, using the map's polyline selection as the feature source."
##        #return 
##
##    def AutoCompleteFromFeaturesFromCursor(self, FeatureClass, processingBounds, lineSrc, InvalidArea, ClusterTolerance, selectionWorkspace):
##        u'Adds polygons to the specified feature class by combining existing polygons with the specified line source.'
##        #return SelectionSet
##
##    @property
##    def FeaturesChanged(self):
##        u'Indicates if the last IFeatureConstruction method created or altered features.'
##        #return FeaturesChanged
##
##    def PlanarizeLines(self, cancel, enumFeature, ClusterTolerance):
##        u'Replaces the line selection set with a planarized version of it. Assumes all lines are from same feature class.'
##        #return 
##
##    def SplitPolygonsWithLinesFromCursor(self, cancel, FeatureClass, processingBounds, pLineSrc, InvalidArea, ClusterTolerance):
##        u'Splits polygons in the specified feature class, using the polyline selection as the feature source.'
##        #return 
##
##    def ConstructPolygonsFromFeaturesFromCursor(self, cancel, targetFC, processingBounds, modifyExisting, replaceTargetSelection, pLineSrc, InvalidArea, ClusterTolerance, pLabels):
##        u'Constructs polygons into the specified feature class, using the cursor as the feature source.'
##        #return 
##
##    def _set(self, rhs):
##        u'The z value to be used when constructing features from inputs that are not z-aware.'
##    DefaultZ = property(fset = _set, doc = _set.__doc__)
##

class RelQueryTableName(CoClass):
    u'A name class that represents a RelQueryTable.'
    _reg_clsid_ = GUID('{DAB3EE10-0F92-455D-8AA2-3D4ADE5B2F7D}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
RelQueryTableName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, IRelQueryTableName, IRelQueryTableName2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

class RecordArray(CoClass):
    u'Esri RecordArray object.'
    _reg_clsid_ = GUID('{E0A5BFFB-C720-4562-A61F-43679C04CAF3}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
RecordArray._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRecordArray]

ICopyHelper._methods_ = [
    COMMETHOD([helpstring(u'Call this after creating a copy of a dataset, workspace, or file.')], HRESULT, 'UpdateMetadata',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'src' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'dest' ),
              ( ['in'], VARIANT_BOOL, 'isMove' )),
    COMMETHOD([helpstring(u'Call this while creating a copy of a dataset in a geodatabase.')], HRESULT, 'UpdateDatabaseMetadata',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'destPropertySet' ),
              ( ['in'], POINTER(IDatasetName), 'src' ),
              ( ['in'], POINTER(IDatasetName), 'dest' )),
]
################################################################
## code template for ICopyHelper implementation
##class ICopyHelper_Impl(object):
##    def UpdateMetadata(self, src, dest, isMove):
##        u'Call this after creating a copy of a dataset, workspace, or file.'
##        #return 
##
##    def UpdateDatabaseMetadata(self, destPropertySet, src, dest):
##        u'Call this while creating a copy of a dataset in a geodatabase.'
##        #return 
##

IGeometricNetworkConnectivity2._methods_ = [
    COMMETHOD([helpstring(u'Checks and optionally repairs connectivity.')], HRESULT, 'CheckAndRepairConnectivity',
              ( ['in'], VARIANT_BOOL, 'checkOnly' ),
              ( ['in'], BSTR, 'logFilePath' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet)), 'errorSelectionSets' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'hasInternalInconsistencies' ),
              ( ['in'], POINTER(IRepairConnectivityProgress), 'RepairConnectivityProgress' )),
    COMMETHOD([helpstring(u'Incrementally rebuilds connectivity for features within and intersecting the specified envelope. Version 2.')], HRESULT, 'RebuildConnectivity2',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'incrementalRebuildArea' )),
]
################################################################
## code template for IGeometricNetworkConnectivity2 implementation
##class IGeometricNetworkConnectivity2_Impl(object):
##    def RebuildConnectivity2(self, incrementalRebuildArea):
##        u'Incrementally rebuilds connectivity for features within and intersecting the specified envelope. Version 2.'
##        #return 
##
##    def CheckAndRepairConnectivity(self, checkOnly, logFilePath, RepairConnectivityProgress):
##        u'Checks and optionally repairs connectivity.'
##        #return errorSelectionSets, hasInternalInconsistencies
##

IGeometricNetworkErrorDetection._methods_ = [
    COMMETHOD(['propget', helpstring(u'The error table currently associated with the geometric network. This property will return nothing unless it has been set within the running application.')], HRESULT, 'ErrorTable',
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'ErrorTable' )),
    COMMETHOD(['propput', helpstring(u'The error table currently associated with the geometric network. This property will return nothing unless it has been set within the running application.')], HRESULT, 'ErrorTable',
              ( ['in'], POINTER(ITable), 'ErrorTable' )),
    COMMETHOD([helpstring(u'Returns a set of selection sets of the features in the geometric network Error Table.')], HRESULT, 'CreateSelectionSetFromErrorTable',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet)), 'selectionSets' )),
    COMMETHOD([helpstring(u'Creates a non-versioned table that can be used to persist error information.')], HRESULT, 'CreateErrorTable',
              ( ['in'], BSTR, 'Name' ),
              ( ['out'], POINTER(POINTER(ITable)), 'ErrorTable' )),
    COMMETHOD([helpstring(u'The features in the geometric network with connectivity problems.')], HRESULT, 'DetectNetworkErrors',
              ( ['in'], esriNetworkErrorType, 'errorType' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnvelope), 'AreaOfInterest' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'selectionSets' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet)), 'problemSelectionSets' )),
    COMMETHOD([helpstring(u'Deletes the network elements associated with the specified network features.')], HRESULT, 'DeleteNetworkElements',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'selectionSets' )),
]
################################################################
## code template for IGeometricNetworkErrorDetection implementation
##class IGeometricNetworkErrorDetection_Impl(object):
##    def CreateSelectionSetFromErrorTable(self):
##        u'Returns a set of selection sets of the features in the geometric network Error Table.'
##        #return selectionSets
##
##    def CreateErrorTable(self, Name):
##        u'Creates a non-versioned table that can be used to persist error information.'
##        #return ErrorTable
##
##    def DeleteNetworkElements(self, selectionSets):
##        u'Deletes the network elements associated with the specified network features.'
##        #return 
##
##    def _get(self):
##        u'The error table currently associated with the geometric network. This property will return nothing unless it has been set within the running application.'
##        #return ErrorTable
##    def _set(self, ErrorTable):
##        u'The error table currently associated with the geometric network. This property will return nothing unless it has been set within the running application.'
##    ErrorTable = property(_get, _set, doc = _set.__doc__)
##
##    def DetectNetworkErrors(self, errorType, AreaOfInterest, selectionSets):
##        u'The features in the geometric network with connectivity problems.'
##        #return problemSelectionSets
##

class Field(CoClass):
    u'Esri Field object.'
    _reg_clsid_ = GUID('{F94F7534-9FDF-11D0-BEC7-00805F7C4268}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Field._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IField, IField2, IFieldEdit, IFieldEdit2, IModelInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe]

ITrafficFeedGPService._methods_ = [
    COMMETHOD(['propget', helpstring(u'Connection properties of the GP service.')], HRESULT, 'ConnectionProperties',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'ConnectionProperties' )),
    COMMETHOD(['propput', helpstring(u'Connection properties of the GP service.')], HRESULT, 'ConnectionProperties',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'ConnectionProperties' )),
    COMMETHOD(['propget', helpstring(u'The name of the GP service.')], HRESULT, 'ServiceName',
              ( ['retval', 'out'], POINTER(BSTR), 'ServiceName' )),
    COMMETHOD(['propput', helpstring(u'The name of the GP service.')], HRESULT, 'ServiceName',
              ( ['in'], BSTR, 'ServiceName' )),
    COMMETHOD(['propget', helpstring(u'The name of the GP service task which returns a URL to TrafficIndex.xml.')], HRESULT, 'TaskName',
              ( ['retval', 'out'], POINTER(BSTR), 'TaskName' )),
    COMMETHOD(['propput', helpstring(u'The name of the GP service task which returns a URL to TrafficIndex.xml.')], HRESULT, 'TaskName',
              ( ['in'], BSTR, 'TaskName' )),
]
################################################################
## code template for ITrafficFeedGPService implementation
##class ITrafficFeedGPService_Impl(object):
##    def _get(self):
##        u'The name of the GP service task which returns a URL to TrafficIndex.xml.'
##        #return TaskName
##    def _set(self, TaskName):
##        u'The name of the GP service task which returns a URL to TrafficIndex.xml.'
##    TaskName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Connection properties of the GP service.'
##        #return ConnectionProperties
##    def _set(self, ConnectionProperties):
##        u'Connection properties of the GP service.'
##    ConnectionProperties = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the GP service.'
##        #return ServiceName
##    def _set(self, ServiceName):
##        u'The name of the GP service.'
##    ServiceName = property(_get, _set, doc = _set.__doc__)
##

class IDataElementInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to get associated the data element.'
    _iid_ = GUID('{D9ED1335-8E1D-40CA-9EE2-E54772EE500D}')
    _idlflags_ = ['oleautomation']
IDataElementInfo._methods_ = [
    COMMETHOD([helpstring(u'Returns the associated data element.')], HRESULT, 'GetDataElement',
              ( ['in'], POINTER(IDEBrowseOptions), 'browseOptions' ),
              ( ['retval', 'out'], POINTER(POINTER(IDataElement)), 'DataElement' )),
]
################################################################
## code template for IDataElementInfo implementation
##class IDataElementInfo_Impl(object):
##    def GetDataElement(self, browseOptions):
##        u'Returns the associated data element.'
##        #return DataElement
##

class SimpleRelationship(CoClass):
    u'Esri Simple Relationship object.'
    _reg_clsid_ = GUID('{A07E9CB2-9A95-11D2-891A-0000F877762D}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
SimpleRelationship._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRelationship]

class Fields(CoClass):
    u'Esri Fields object.'
    _reg_clsid_ = GUID('{F94F7535-9FDF-11D0-BEC7-00805F7C4268}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Fields._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IFields, IFieldsEdit, IFields2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

ITrafficFeedDirectory._methods_ = [
    COMMETHOD(['propget', helpstring(u'The directory containing dynamic traffic data.')], HRESULT, 'TrafficDirectory',
              ( ['retval', 'out'], POINTER(BSTR), 'directory' )),
    COMMETHOD(['propput', helpstring(u'The directory containing dynamic traffic data.')], HRESULT, 'TrafficDirectory',
              ( ['in'], BSTR, 'directory' )),
]
################################################################
## code template for ITrafficFeedDirectory implementation
##class ITrafficFeedDirectory_Impl(object):
##    def _get(self):
##        u'The directory containing dynamic traffic data.'
##        #return directory
##    def _set(self, directory):
##        u'The directory containing dynamic traffic data.'
##    TrafficDirectory = property(_get, _set, doc = _set.__doc__)
##

ITrafficFeedLocation._methods_ = [
]
################################################################
## code template for ITrafficFeedLocation implementation
##class ITrafficFeedLocation_Impl(object):

IEnumReplica._methods_ = [
    COMMETHOD([helpstring(u'Retreives the next replica in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IReplica)), 'Replica' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumReplica implementation
##class IEnumReplica_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retreives the next replica in the enumeration sequence.'
##        #return Replica
##

class CoverageAnnotationFeature(CoClass):
    u'Esri Coverage Annotation Feature.'
    _reg_clsid_ = GUID('{9C285DE9-6A15-11D3-9F58-00C04F6BDDD9}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
CoverageAnnotationFeature._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRow, IRowBuffer, IRowEvents, IRowSubtypes, IRowChanges, IRowCompare, IFeature, IFeatureBuffer, IFeatureEvents, IValidate, IFeatureDraw, IFeatureEdit, IFeatureEdit2, IFeatureChanges, IFeatureSimplify, IFeatureSimplify2, ICoverageAnnotationFeature, IRelatedObjectEvents, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, IFeatureProject]

class Index(CoClass):
    u'Esri Index object.'
    _reg_clsid_ = GUID('{826E2701-4DA6-11D1-8824-0000F877762D}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Index._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IIndex, IIndexEdit, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe]

IDynamicTrafficData._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the dynamic traffic table.')], HRESULT, 'DynamicTrafficTableName',
              ( ['retval', 'out'], POINTER(BSTR), 'DynamicTrafficTableName' )),
    COMMETHOD(['propput', helpstring(u'The name of the dynamic traffic table.')], HRESULT, 'DynamicTrafficTableName',
              ( ['in'], BSTR, 'DynamicTrafficTableName' )),
    COMMETHOD(['propget', helpstring(u'The field name for the dynamic traffic TMCs in the dynamic traffic.')], HRESULT, 'DynamicTrafficTMCFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'DynamicTrafficTMCFieldName' )),
    COMMETHOD(['propput', helpstring(u'The field name for the dynamic traffic TMCs in the dynamic traffic.')], HRESULT, 'DynamicTrafficTMCFieldName',
              ( ['in'], BSTR, 'DynamicTrafficTMCFieldName' )),
    COMMETHOD(['propget', helpstring(u'The traffic feed location.')], HRESULT, 'TrafficFeedLocation',
              ( ['retval', 'out'], POINTER(POINTER(ITrafficFeedLocation)), 'TrafficFeedLocation' )),
    COMMETHOD(['propputref', helpstring(u'The traffic feed location.')], HRESULT, 'TrafficFeedLocation',
              ( ['in'], POINTER(ITrafficFeedLocation), 'TrafficFeedLocation' )),
]
################################################################
## code template for IDynamicTrafficData implementation
##class IDynamicTrafficData_Impl(object):
##    def _get(self):
##        u'The name of the dynamic traffic table.'
##        #return DynamicTrafficTableName
##    def _set(self, DynamicTrafficTableName):
##        u'The name of the dynamic traffic table.'
##    DynamicTrafficTableName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The field name for the dynamic traffic TMCs in the dynamic traffic.'
##        #return DynamicTrafficTMCFieldName
##    def _set(self, DynamicTrafficTMCFieldName):
##        u'The field name for the dynamic traffic TMCs in the dynamic traffic.'
##    DynamicTrafficTMCFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def TrafficFeedLocation(self, TrafficFeedLocation):
##        u'The traffic feed location.'
##        #return 
##

class Indexes(CoClass):
    u'Esri Indices object.'
    _reg_clsid_ = GUID('{03859813-4DA5-11D1-8824-0000F877762D}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Indexes._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IIndexes, IIndexesEdit, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

class EnumFeatureGeometry(CoClass):
    u'Esri enumerator for geometries of a feature class or selection set.'
    _reg_clsid_ = GUID('{39466CF4-54BE-11D3-9F45-00C04F6BDD7F}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IEnumGeometryBind(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that bind a feature cursor or a selection to a geometry enumerator.'
    _iid_ = GUID('{3BB37818-5029-11D3-9F44-00C04F6BDD7F}')
    _idlflags_ = ['oleautomation']
EnumFeatureGeometry._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IEnumGeometry, IEnumGeometryBind, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class NetworkSource(CoClass):
    u'A container for describing a network dataset source.'
    _reg_clsid_ = GUID('{32E3D06D-F792-45EB-1089-A6EA57232BC0}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
NetworkSource._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkSource]

IHistoricalTravelTimeEvaluator._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the weekday fallback attribute.')], HRESULT, 'WeekdayFallbackAttributeName',
              ( ['retval', 'out'], POINTER(BSTR), 'AttributeName' )),
    COMMETHOD(['propput', helpstring(u'The name of the weekday fallback attribute.')], HRESULT, 'WeekdayFallbackAttributeName',
              ( ['in'], BSTR, 'AttributeName' )),
    COMMETHOD(['propget', helpstring(u'The name of the weekend fallback attribute.')], HRESULT, 'WeekendFallbackAttributeName',
              ( ['retval', 'out'], POINTER(BSTR), 'AttributeName' )),
    COMMETHOD(['propput', helpstring(u'The name of the weekend fallback attribute.')], HRESULT, 'WeekendFallbackAttributeName',
              ( ['in'], BSTR, 'AttributeName' )),
    COMMETHOD(['propget', helpstring(u'The name of the attribute for time-neutral queries.')], HRESULT, 'TimeNeutralAttributeName',
              ( ['retval', 'out'], POINTER(BSTR), 'AttributeName' )),
    COMMETHOD(['propput', helpstring(u'The name of the attribute for time-neutral queries.')], HRESULT, 'TimeNeutralAttributeName',
              ( ['in'], BSTR, 'AttributeName' )),
]
################################################################
## code template for IHistoricalTravelTimeEvaluator implementation
##class IHistoricalTravelTimeEvaluator_Impl(object):
##    def _get(self):
##        u'The name of the weekday fallback attribute.'
##        #return AttributeName
##    def _set(self, AttributeName):
##        u'The name of the weekday fallback attribute.'
##    WeekdayFallbackAttributeName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the attribute for time-neutral queries.'
##        #return AttributeName
##    def _set(self, AttributeName):
##        u'The name of the attribute for time-neutral queries.'
##    TimeNeutralAttributeName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the weekend fallback attribute.'
##        #return AttributeName
##    def _set(self, AttributeName):
##        u'The name of the weekend fallback attribute.'
##    WeekendFallbackAttributeName = property(_get, _set, doc = _set.__doc__)
##

class GeometryDef(CoClass):
    u'Esri Geometry Definition object.'
    _reg_clsid_ = GUID('{439A0D52-3915-11D1-9CA7-0000F8780619}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
GeometryDef._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGeometryDef, IGeometryDefEdit, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize]

class NetworkForwardStar(CoClass):
    u'A container for querying information about adjacent elements in the network dataset.'
    _reg_clsid_ = GUID('{FD93E68C-3CFE-4C12-B34D-2FDB38B38D4E}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
NetworkForwardStar._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INetworkForwardStar, INetworkForwardStarSetup, INetworkForwardStarEx, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class Row(CoClass):
    u'Esri Row object.'
    _reg_clsid_ = GUID('{F94F7533-9FDF-11D0-BEC7-00805F7C4268}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Row._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRow, IRowBuffer, IRowEvents, IRowSubtypes, IRowChanges, IRowCompare, IRowEdit, IValidate, IRelatedObjectEvents, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class ClassHelper(CoClass):
    u'Esri Class Helper.'
    _reg_clsid_ = GUID('{9AAAC925-A14E-11D3-9F97-00C04F6BDF0C}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
class IClassHelper(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the associated class.'
    _iid_ = GUID('{65DED622-A14E-11D3-9F97-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
ClassHelper._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IClassHelper]

ITimeAwareEvaluator._methods_ = [
    COMMETHOD([helpstring(u'Query the travel time for the current time.')], HRESULT, 'QueryValueAtTime',
              ( ['in'], POINTER(INetworkElement), 'Element' ),
              ( ['in'], c_double, 'localTime' ),
              ( ['in'], esriNetworkTimeUsage, 'timeUsage' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
]
################################################################
## code template for ITimeAwareEvaluator implementation
##class ITimeAwareEvaluator_Impl(object):
##    def QueryValueAtTime(self, Element, localTime, timeUsage):
##        u'Query the travel time for the current time.'
##        #return Value
##

class Feature(CoClass):
    u'Esri Feature.'
    _reg_clsid_ = GUID('{52353152-891A-11D0-BEC6-00805F7C4268}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Feature._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRow, IRowBuffer, IRowEvents, IRowSubtypes, IRowChanges, IRowCompare, IFeature, IFeatureBuffer, IFeatureEvents, IFeatureChanges, IValidate, IFeatureDraw, IRowEdit, IFeatureEdit2, IFeatureSimplify, IFeatureSimplify2, IRelatedObjectEvents, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, IFeatureProject]

class EnumNetworkElement(CoClass):
    u'A container for network elements.'
    _reg_clsid_ = GUID('{7B90405E-6882-47DC-B4EC-7C54CB537D2E}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
EnumNetworkElement._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumNetworkElement]

class Object(CoClass):
    u'Esri Object object.'
    _reg_clsid_ = GUID('{7A566981-C114-11D2-8A28-006097AFF44E}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
Object._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRow, IRowBuffer, IRowEvents, IRowChanges, IRowCompare, IRowEdit, IRowSubtypes, IValidate, IObject, IRelatedObjectEvents, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

IRelQueryTableFactory._methods_ = [
    COMMETHOD([helpstring(u'Opens a join table specified by the given properties.')], HRESULT, 'Open',
              ( ['in'], POINTER(IRelationshipClass), 'RelationshipClass' ),
              ( ['in'], VARIANT_BOOL, 'joinForward' ),
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' ),
              ( ['in'], POINTER(ISelectionSet), 'SrcSelectionSet' ),
              ( ['in'], BSTR, 'TargetColumns' ),
              ( ['in'], VARIANT_BOOL, 'DoNotPushJoinToDB' ),
              ( ['in'], VARIANT_BOOL, 'openAsLeftOuterJoin' ),
              ( ['retval', 'out'], POINTER(POINTER(IRelQueryTable)), 'Table' )),
]
################################################################
## code template for IRelQueryTableFactory implementation
##class IRelQueryTableFactory_Impl(object):
##    def Open(self, RelationshipClass, joinForward, QueryFilter, SrcSelectionSet, TargetColumns, DoNotPushJoinToDB, openAsLeftOuterJoin):
##        u'Opens a join table specified by the given properties.'
##        #return Table
##

class ObjectClassDescription(CoClass):
    u'Esri Object Class Description.'
    _reg_clsid_ = GUID('{08136232-A72E-11D2-8924-0000F877762D}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
ObjectClassDescription._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IObjectClassDescription]

class FeatureClassDescription(CoClass):
    u'Esri Feature Class Description object.'
    _reg_clsid_ = GUID('{08136233-A72E-11D2-8924-0000F877762D}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
FeatureClassDescription._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IObjectClassDescription, IFeatureClassDescription]

class ForwardStar(CoClass):
    u'A container for querying information about adjacent elements in the logical network.'
    _reg_clsid_ = GUID('{91DD8AB8-E33D-11D4-9FEA-00C04F68E627}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
ForwardStar._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IForwardStarGEN, IForwardStar]

IDirectionsFieldMapping._methods_ = [
    COMMETHOD(['propput', helpstring(u'The directions key name of the directions field mapping.')], HRESULT, 'KeyName',
              ( ['in'], BSTR, 'KeyName' )),
    COMMETHOD(['propget', helpstring(u'The directions key name of the directions field mapping.')], HRESULT, 'KeyName',
              ( ['retval', 'out'], POINTER(BSTR), 'KeyName' )),
    COMMETHOD(['propput', helpstring(u'The network source field name associated with the directions key name and direction.')], HRESULT, 'FieldName',
              ( ['in'], esriNetworkEdgeDirection, 'Direction' ),
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'The network source field name associated with the directions key name and direction.')], HRESULT, 'FieldName',
              ( ['in'], esriNetworkEdgeDirection, 'Direction' ),
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
]
################################################################
## code template for IDirectionsFieldMapping implementation
##class IDirectionsFieldMapping_Impl(object):
##    def _get(self):
##        u'The directions key name of the directions field mapping.'
##        #return KeyName
##    def _set(self, KeyName):
##        u'The directions key name of the directions field mapping.'
##    KeyName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self, Direction):
##        u'The network source field name associated with the directions key name and direction.'
##        #return FieldName
##    def _set(self, Direction, FieldName):
##        u'The network source field name associated with the directions key name and direction.'
##    FieldName = property(_get, _set, doc = _set.__doc__)
##

class IEnumJunctionFeature(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate junction features and resets the enumeration.'
    _iid_ = GUID('{91644B26-55FC-11D1-AE55-0000F80372B4}')
    _idlflags_ = ['oleautomation']
IEnumJunctionFeature._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next JunctionFeature in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IJunctionFeature)), 'Junction' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumJunctionFeature implementation
##class IEnumJunctionFeature_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next JunctionFeature in the enumeration sequence.'
##        #return Junction
##

INetworkConstantEvaluator._methods_ = [
    COMMETHOD(['propput', helpstring(u'Value returned by the network evaluator for all elements of the network.')], HRESULT, 'ConstantValue',
              ( ['in'], VARIANT, 'val' )),
    COMMETHOD(['propget', helpstring(u'Value returned by the network evaluator for all elements of the network.')], HRESULT, 'ConstantValue',
              ( ['retval', 'out'], POINTER(VARIANT), 'val' )),
]
################################################################
## code template for INetworkConstantEvaluator implementation
##class INetworkConstantEvaluator_Impl(object):
##    def _get(self):
##        u'Value returned by the network evaluator for all elements of the network.'
##        #return val
##    def _set(self, val):
##        u'Value returned by the network evaluator for all elements of the network.'
##    ConstantValue = property(_get, _set, doc = _set.__doc__)
##

IFeatureDatasetExtension._methods_ = [
    COMMETHOD(['propget', helpstring(u'Provides access to the feature dataset containing the extension.')], HRESULT, 'FeatureDataset',
              ( ['retval', 'out'], POINTER(POINTER(IFeatureDataset)), 'Dataset' )),
    COMMETHOD([helpstring(u'Initialize the feature dataset extension.')], HRESULT, 'Init',
              ( ['in'], POINTER(IFeatureDataset), 'Dataset' )),
]
################################################################
## code template for IFeatureDatasetExtension implementation
##class IFeatureDatasetExtension_Impl(object):
##    def Init(self, Dataset):
##        u'Initialize the feature dataset extension.'
##        #return 
##
##    @property
##    def FeatureDataset(self):
##        u'Provides access to the feature dataset containing the extension.'
##        #return Dataset
##

IEnumNetEIDBuilder._methods_ = [
    COMMETHOD(['propputref', helpstring(u'Network from which these elements came.')], HRESULT, 'Network',
              ( ['in'], POINTER(INetwork), 'rhs' )),
    COMMETHOD([helpstring(u'Adds an element to this EID enumeration.')], HRESULT, 'Add',
              ( ['in'], c_int, 'EID' )),
    COMMETHOD(['propput', helpstring(u'Type of network elements to be in this enumeration.')], HRESULT, 'ElementType',
              ( ['in'], esriElementType, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Array of EIDs in this enumeration.')], HRESULT, 'EIDs',
              ( ['in'], c_int, 'Count' ),
              ( ['in'], POINTER(c_int), 'rhs' )),
]
################################################################
## code template for IEnumNetEIDBuilder implementation
##class IEnumNetEIDBuilder_Impl(object):
##    def Add(self, EID):
##        u'Adds an element to this EID enumeration.'
##        #return 
##
##    def _set(self, rhs):
##        u'Type of network elements to be in this enumeration.'
##    ElementType = property(fset = _set, doc = _set.__doc__)
##
##    def Network(self, rhs):
##        u'Network from which these elements came.'
##        #return 
##
##    def _set(self, Count, rhs):
##        u'Array of EIDs in this enumeration.'
##    EIDs = property(fset = _set, doc = _set.__doc__)
##

IFeatureDatasetName2._methods_ = [
    COMMETHOD(['propget', helpstring(u'An enumerator over the topology names in this FeatureDataset.')], HRESULT, 'TopologyNames',
              ( ['retval', 'out'], POINTER(POINTER(IEnumDatasetName)), 'TopologyNames' )),
]
################################################################
## code template for IFeatureDatasetName2 implementation
##class IFeatureDatasetName2_Impl(object):
##    @property
##    def TopologyNames(self):
##        u'An enumerator over the topology names in this FeatureDataset.'
##        #return TopologyNames
##

INetAttributes._methods_ = [
    COMMETHOD([helpstring(u'Returns the disabled state of the specified network element.')], HRESULT, 'GetDisabledState',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], esriElementType, 'ElementType' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'disabledState' )),
    COMMETHOD([helpstring(u'Returns the weight value of the specified network element for the specified weight.')], HRESULT, 'GetWeightValue',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], esriElementType, 'ElementType' ),
              ( ['in'], c_int, 'weightInternalID' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'weightValue' )),
]
################################################################
## code template for INetAttributes implementation
##class INetAttributes_Impl(object):
##    def GetWeightValue(self, EID, ElementType, weightInternalID):
##        u'Returns the weight value of the specified network element for the specified weight.'
##        #return weightValue
##
##    def GetDisabledState(self, EID, ElementType):
##        u'Returns the disabled state of the specified network element.'
##        #return disabledState
##


# values for enumeration 'fdoError'
FDO_E_LOADING_RESOURCE = -2147220991
FDO_E_INDEX_OUT_OF_RANGE = -2147220990
FDO_E_NOT_SUPPORTED = -2147220989
FDO_E_NOT_ENOUGH_SPACE = -2147220988
FDO_E_NO_PERMISSION = -2147220987
FDO_E_IMPLEMENTATION = -2147220986
FDO_E_INVALID_SQL = -2147220985
FDO_E_NETWORK = -2147220984
FDO_E_DATE_CONVERSION = -2147220983
FDO_E_OBJECT_IS_DELETED = -2147220982
FDO_E_WORKSPACE_NOT_COMPATIBLE = -2147220981
FDO_E_OBJECT_IS_READONLY = -2147220980
FDO_E_OBJECT_IN_USE = -2147220979
FDO_E_OBJECT_MAX_REACHED = -2147220978
FDO_E_OBJECT_IS_LOCKED = -2147220977
FDO_E_INVALID_ENVELOPE = -2147220976
FDO_E_FILE_IO = -2147220975
FDO_E_LICENSE_FAILURE = -2147220974
FDO_E_DBMS_ERROR = -2147220973
FDO_E_COERCING = -2147220972
FDO_E_BINDING = -2147220971
FDO_E_SCHEMA_LOCK_CONFLICT = -2147220970
FDO_E_MUST_BE_OWNER = -2147220969
FDO_E_OBJECT_NOT_LOCKED = -2147220968
FDO_E_ESRI_PROVIDER_CONNECT_INVALID = -2147220967
FDO_E_CONNECTION_CANCELLED = -2147220966
FDO_E_INVALID_RELEASE = -2147220965
FDO_E_NO_SYSTEM_TABLES = -2147220964
FDO_E_CONNECT_PARAMETERS_CONFLICT = -2147220963
FDO_E_FIELDINFO_SYSTEM_TABLE_INCONSISTENCY = -2147220962
FDO_E_NO_EDIT_LICENSE = -2147220961
FDO_E_NO_SCHEMA_LICENSE = -2147220960
FDO_E_NO_OPERATION_LICENSE = -2147220959
FDO_E_OPERATION_CANNOT_BE_UNDONE = -2147220958
FDO_E_EDIT_OPERATION_REQUIRED = -2147220957
FDO_E_RECONCILE_CANNOT_BE_UNDONE = -2147220956
FDO_E_OBJECT_NOT_INITIALIZED = -2147220955
FDO_E_INTEGER_REQUIRES_64BITS = -2147220954
FDO_E_SYNTAX_ERROR = -2147220953
FDO_E_LICENSE_NOT_INITIALIZED = -2147220952
FDO_E_TABLE_SIZE_EXCEEDED = -2147220951
FDO_E_SECURED_DATA_NO_ACCESS = -2147220950
FDO_E_INVALID_SQLQUERY = -2147220949
FDO_E_INVALID_NAME = -2147220948
FDO_E_LOCK_CONFLICT = -2147220947
FDO_E_UPGRADE_NEEDS_WRITE_ACCESS = -2147220946
FDO_E_NEGATIVE_FID = -2147220945
FDO_E_INCOMPATIBLE_CLIENT_VERSION = -2147220944
FDO_E_NEW_SCHEMA_REQUIRED = -2147220943
FDO_E_NON_FORWARD_COMPATIBLE_CONNECTION = -2147220942
FDO_E_WORKSPACE_NOT_CONNECTED = -2147220911
FDO_E_WORKSPACE_ALREADY_CONNECTED = -2147220910
FDO_E_SERVER_NOT_FOUND = -2147220909
FDO_E_SERVER_NOT_AVAILABLE = -2147220908
FDO_E_SERVER_MAX_CONNECTIONS = -2147220907
FDO_E_USER_INVALID = -2147220906
FDO_E_USER_NOACCESS = -2147220905
FDO_E_DATABASE_NOT_FOUND = -2147220904
FDO_E_DATABASE_NOT_AVAILABLE = -2147220903
FDO_E_WORKSPACE_ALREADY_EXISTS = -2147220902
FDO_E_WORKSPACE_EXTENSION_CREATE_FAILED = -2147220901
FDO_E_WORKSPACE_EXTENSION_INIT_FAILED = -2147220900
FDO_E_WORKSPACE_EXTENSION_DATASET_CREATE_FAILED = -2147220899
FDO_E_WORKSPACE_EXTENSION_DATASET_RENAME_FAILED = -2147220898
FDO_E_WORKSPACE_EXTENSION_DATASET_DELETE_FAILED = -2147220897
FDO_E_WORKSPACE_EXTENSION_DUP_NAME = -2147220896
FDO_E_WORKSPACE_EXTENSION_DUP_GUID = -2147220895
FDO_E_WORKSPACE_EXTENSION_NO_REG_PRIV = -2147220894
FDO_E_WORKSPACE_READONLY = -2147220893
FDO_E_DATASET_NOT_SUPPORTED_AT_WORKSPACE_LEVEL = -2147220892
FDO_E_WORKSPACE_NO_KEYSETTABLEMANAGER = -2147220891
FDO_E_WORKSPACE_NO_KEYSETTABLE = -2147220890
FDO_E_WORKSPACE_INVALID_KEYSETID = -2147220889
FDO_E_WORKSPACEFACTORY_BAD_CONNECTIONPROPERTY = -2147220888
FDO_E_WORKSPACE_EXTENSION_NOT_SUPPORTED = -2147220887
FDO_E_WORKSPACE_EXTENSION_DATASET_MODIFY_FAILED = -2147220886
FDO_E_WORKSPACE_NO_SPATIAL_TYPE = -2147220885
FDO_E_HISTORICAL_MARKER_ALREADY_EXISTS = -2147220885
FDO_E_OLEDB_NOT_SUPPORTED_ON_LINUX = -2147220884
FDO_E_DATASET_NOT_FOUND = -2147220735
FDO_E_DATASET_INVALID_NAME = -2147220734
FDO_E_DATASET_ALREADY_EXISTS = -2147220733
FDO_E_DATASET_CANNOT_RENAME = -2147220732
FDO_E_DATASET_INVALID_TYPE = -2147220731
FDO_E_DATASET_CANNOT_DELETE = -2147220730
FDO_E_DATASET_EXTENSION_TYPE_NOT_FOUND = -2147220729
FDO_E_DATASET_PASTE_NOT_SUPPORTED_IN_RELEASE = -2147220728
FDO_E_DATASET_CANNOT_RENAME_NOT_SUPPORTED = -2147220727
FDO_E_DATASET_EXTENSION_CREATE_FAILED = -2147220726
FDO_E_DATASET_EXTENSION_INIT_FAILED = -2147220725
FDO_E_CANNOT_CREATE_LOW_PREC_DATASET_IN_HIGH_PREC_DB = -2147220724
FDO_E_CANNOT_CREATE_HIGH_PREC_DATASET_IN_LOW_PREC_DB = -2147220723
FDO_E_DATASET_TYPE_NOT_PRESENT = -2147220722
FDO_E_CANNOT_COPY_CLASS_WITHOUT_ALL_CONTROLLERS = -2147220721
FDO_E_DATASET_TYPE_NOT_SUPPORTED_IN_RELEASE = -2147220720
FDO_E_DATASET_INVALID_DEFINITION = -2147220719
FDO_E_DATASET_INVALID_ID = -2147220718
FDO_E_CANNOT_RENAME_WHILE_EDITING = -2147220717
FDO_E_CANNOT_MODIFY_SCHEMA_WHILE_EDITING = -2147220716
FDO_E_INCOMPATIBLE_CLIENT_CANNOT_OPEN_DATASET = -2147220715
FDO_E_TABLE_NOT_FOUND = -2147220655
FDO_E_TABLE_INVALID_NAME = -2147220654
FDO_E_TABLE_ALREADY_EXISTS = -2147220653
FDO_E_TABLE_NO_OID_FIELD = -2147220652
FDO_E_TABLE_INVALID_KEYWORD = -2147220651
FDO_E_TABLE_NOT_VERSIONED = -2147220650
FDO_E_TABLE_DUPLICATE_COLUMN = -2147220649
FDO_E_TABLE_COLUMN_NOT_FOUND = -2147220648
FDO_E_TABLE_IN_USE = -2147220647
FDO_E_TABLE_RECORD_LENGTH_EXCEEDED = -2147220646
FDO_E_TABLE_VERSIONED = -2147220645
FDO_E_TABLE_MOVINGEDITSTOBASE = -2147220644
FDO_E_TABLE_ARCHIVING = -2147220643
FDO_E_TABLE_NOT_ARCHIVING = -2147220642
FDO_E_TABLE_READONLY_HISTORICAL = -2147220641
FDO_E_TABLE_NO_ATTACHMENTS = -2147220640
FDO_E_TABLE_ATTACHMENTS_NOT_SUPPORTED = -2147220639
FDO_E_TABLE_CANNOT_ANALYZE_TABLE_VIEW = -2147220638
FDO_E_TABLE_NO_GLOBALID_FIELD = -2147220637
FDO_E_ATTACHMENTS_ON_ATTACHMENT_TABLE_NOT_SUPPORTED = -2147220636
FDO_E_TABLE_NOT_EMPTY = -2147220635
FDO_E_ATTACHMENTS_ONLY_ON_GEODATABASES = -2147220634
FDO_E_NON_SIMPLE_DATASET_ARCHIVING = -2147220633
FDO_E_FEATURECLASS_NOT_FOUND = -2147220479
FDO_E_FEATURECLASS_BAD_EXTENT = -2147220478
FDO_E_FEATURECLASS_INVALID_NAME = -2147220477
FDO_E_FEATURECLASS_ALREADY_EXISTS = -2147220476
FDO_E_FEATURECLASS_LOAD_MODE = -2147220475
FDO_E_FEATURECLASS_NETWORK_CANNOT_DELETE = -2147220474
FDO_E_FEATURECLASS_BAD_DEFAULT_SUBTYPE_CODE = -2147220473
FDO_E_FEATURECLASS_NO_SUBTYPE_FIELD = -2147220472
FDO_E_FEATURECLASS_NETWORK_CANNOT_RENAME = -2147220471
FDO_E_FEATURECLASS_SUBTYPE_EXISTS = -2147220470
FDO_E_FEATURECLASS_FD_NOT_EDITABLE = -2147220469
FDO_E_FEATURECLASS_SUBTYPE_FIELD_CANNOT_RENAME = -2147220468
FDO_E_SUBTYPE_CODE_INVALID = -2147220467
FDO_E_SUBTYPE_CODE_DOES_NOT_EXIST = -2147220466
FDO_E_SUBTYPE_CODE_IS_NULL = -2147220465
FDO_E_SUBTYPE_CODE_NOT_INTEGER = -2147220464
FDO_E_FEATURECLASS_NO_SHAPE_COLUMN = -2147220463
FDO_E_FEATURECLASS_TOPOLOGY_CANNOT_DELETE = -2147220462
FDO_E_SUBTYPE_CODE_HAS_ASSOCIATED_TOPOLOGY_RULE = -2147220461
FDO_E_SUBTYPE_IN_USE_CANNOT_DELETE = -2147220460
FDO_E_SUBTYPE_CANNOT_ADD = -2147220459
FDO_E_SPATIAL_CACHE_EMPTY_EXTENT = -2147220458
FDO_E_FEATURECLASS_MEMBER_OF_CONTROLLER = -2147220457
FDO_E_FEATURECLASS_CANT_OPEN_GEOMETRICNETWORK = -2147220456
FDO_E_FEATURECLASS_CANT_OPEN_TOPOLOGY = -2147220455
FDO_E_FEATURECLASS_NETWORK_DATASET_CANNOT_DELETE = -2147220454
FDO_E_FEATURECLASS_INSUFFICIENT_PRIVILEGE = -2147220453
FDO_E_PLANARGRAPH_NOT_FOUND = -2147220399
FDO_E_GEOMETRICNETWORK_NOT_FOUND = -2147220223
FDO_E_ADD_FEATURE_TO_NETWORK = -2147220222
FDO_E_CREATE_LOGICAL_NETWORK = -2147220221
FDO_E_GEOMETRICNETWORK_ALREADY_EXISTS = -2147220220
FDO_E_ZERO_LENGTH_EDGE_ELEMENT = -2147220219
FDO_E_GEOMETRICNETWORK_CANNOT_RENAME = -2147220218
FDO_E_GEOMETRICNETWORK_ELEMENT_INCONSISTENCY = -2147220217
FDO_E_NETWORK_FEATURES_HAVE_HOMOGENEOUS_Z_SUPPORT = -2147220216
FDO_E_NO_ASSOCIATED_ERROR_TABLE = -2147220215
FDO_E_FEATURE_ELEMENT_MISSING_POINT_GEOMETRY = -2147220214
FDO_E_NETWORK_FEATURES_HAVE_HOMOGENEOUS_M_SUPPORT = -2147220213
FDO_E_CLASS_EXISTS_WITH_ORPHAN_JUNCTION_CLASS_NAME = -2147220212
FDO_E_GEOMETRICNETWORK_INVALID_NAME = -2147220211
FDO_E_INVALID_FIELD_FOR_WEIGHT_ASSOCIATION = -2147220210
FDO_E_INVALID_CLASS_FOR_WEIGHT_ASSOCIATION = -2147220209
FDO_E_CONNECTED_FEATURE_DOES_NOT_EXIST = -2147220208
FDO_E_OPEN_LOGICAL_NETWORK = -2147220207
FDO_E_NETWORK_ELEMENT_ID_BEYOND_MAX = -2147220206
FDO_E_EDGE_ENDPOINT_NOT_COINCIDENT = -2147220205
FDO_E_CANNOT_DELETE_POPULATED_FEATURE_CLASS = -2147220204
FDO_E_CANNOT_DELETE_ORPHAN_JUNCTION_CLASS = -2147220203
FDO_E_EMPTY_GEOMETRICNETWORK_IS_NOT_ALLOWED = -2147220202
FDO_E_DATASET_UNEDITABLE = -2147220143
FDO_E_START_EDITING = -2147220142
FDO_E_SAVE_EDIT_SESSION = -2147220141
FDO_E_STOP_EDITING_WITH_SAVE = -2147220140
FDO_E_STOP_EDITING_WITH_DISCARD = -2147220139
FDO_E_NOT_ALLOWED_WHILE_EDITING = -2147220138
FDO_E_COULD_NOT_CLEAN_COVERAGE = -2147220137
FDO_E_NO_INTEGRATEABLE_LAYERS = -2147220136
FDO_E_INVALID_TOPOLOGY = -2147220135
FDO_E_NOT_EDITING = -2147220134
FDO_E_COULD_NOT_ENCODE_INFO_ITEM = -2147220133
FDO_E_NODE_NOT_ON_ARC = -2147220132
FDO_E_CANNOT_REMOVE_LAST_LABEL = -2147220131
FDO_E_CANNOT_MOVE_LABEL_OUT_OF_POLYGON = -2147220130
FDO_E_INVALID_POLYGON_LABEL_DELETED = -2147220129
FDO_E_CANNOT_BREAK_TOPOLOGY = -2147220128
FDO_E_CANNOT_CREATE_UNIVERSE_LABEL = -2147220127
FDO_E_CANNOT_MOVE_UNIVERSE_LABELS = -2147220126
FDO_E_INVALID_GEOMETRY = -2147220125
FDO_E_CORUPTED_COVERAGE = -2147220124
FDO_E_DUPLICATE_FIELD_NAMES = -2147220123
FDO_E_CANNOT_EDIT_ZS = -2147220122
FDO_E_NO_POLYGONS_CREATED = -2147220121
FDO_E_ABORT_EDITS_FAILED = -2147220120
FDO_E_FLUSH_EDITS_FAILED = -2147220119
FDO_E_CANNOT_EDIT_TABLE_WITH_UNIQ_USER_INDEX = -2147220118
FDO_E_CANNOT_EDIT_DATASET_WITH_UNIQ_USER_INDEX = -2147220117
FDO_E_CANNOT_REBUILD_POLYGONS = -2147220116
FDO_E_USERTRANSACTION_NOT_ALLOWED = -2147220115
FDO_E_NOT_EDITABLE_EDITSESSIONMODE = -2147220114
FDO_E_CANNOT_EDIT_COMPRESSED_DATASET = -2147220113
FDO_E_CANNOT_UPDATE_COMPRESSED_DATASET = -2147220112
FDO_E_COMPRESSED_DATASET_NOT_SUPPORTED = -2147220111
FDO_E_INVALID_OPERATION_FOR_EDITSESSIONMODE = -2147220110
FDO_E_COMPRESSED_DATASET_NOT_INSTALLED = -2147220109
FDO_E_MODIFIED_GEOMETRY_MUST_BE_COPY = -2147220108
FDO_E_PENDING_BACKGROUND_PROCESSES = -2147220107
FDO_E_PENDING_GEOPROCESSING_INPUT = -2147220106
FDO_E_PROPERTY_NO_SUBTYPE = -2147219967
FDO_E_PROPERTY_NOT_FOUND = -2147219966
FDO_E_FIELD_INVALID = -2147219887
FDO_E_FIELD_INVALID_NAME = -2147219886
FDO_E_FIELD_NOT_FOUND = -2147219885
FDO_E_FIELD_ALREADY_EXISTS = -2147219884
FDO_E_FIELD_INVALID_TYPE = -2147219883
FDO_E_FIELD_UNSUPPORTED_OPERATION = -2147219882
FDO_E_FIELD_INVALID_GEOMETRY_TYPE = -2147219881
FDO_E_FIELD_NOT_EDITABLE = -2147219880
FDO_E_FIELD_NOT_NULLABLE = -2147219879
FDO_E_FIELD_CANNOT_DELETE_WEIGHT_FIELD = -2147219878
FDO_E_FIELD_CANNOT_DELETE_REQUIRED_FIELD = -2147219877
FDO_E_FIELD_CANNOT_DELETE_SUBTYPE_FIELD = -2147219876
FDO_E_FIELD_CANNOT_DELETE_LAST_FIELD = -2147219875
FDO_E_FIELD_IS_KEYWORD = -2147219874
FDO_E_FIELD_CANNOT_DELETE_RELKEY_FIELD = -2147219873
FDO_E_FIELD_MISSING_GEOMETRY_DEF = -2147219872
FDO_E_FIELD_IS_RELKEY_FIELD = -2147219871
FDO_E_FIELD_USED_BY_EDITOR_TRACKING = -2147219870
FDO_E_FIELD_IS_SUBTYPE_FIELD = -2147219869
FDO_E_FIELD_IS_NETWORK_ANCILLARY_FIELD = -2147219868
FDO_E_FIELD_IS_WEIGHT_FIELD = -2147219867
FDO_E_FIELD_IS_ENABLED_FIELD = -2147219866
FDO_E_FIELD_IS_REQUIRED_FIELD = -2147219865
FDO_E_FIELD_ALIAS_EXCEEDS_MAX_LENGTH = -2147219864
FDO_E_FIELD_IS_ASSOCIATED_WITH_DOMAIN = -2147219863
FDO_E_FIELD_HAS_DEFAULT_VALUE = -2147219862
FDO_E_FIELD_IS_ASSOCIATED_WITH_INDEX = -2147219861
FDO_E_FIELDS_INVALID = -2147219711
FDO_E_FIELDS_NOT_FOUND = -2147219710
FDO_E_FIELDS_NO_GEOMETRY = -2147219709
FDO_E_FIELDS_NO_OID = -2147219708
FDO_E_FIELDS_MULTIPLE_OIDS = -2147219707
FDO_E_FIELDS_MULTIPLE_GEOMETRIES = -2147219706
FDO_E_FIELDS_MODEL_NAME_ALREADY_EXISTS = -2147219705
FDO_E_FIELDS_MULTIPLE_RASTERS = -2147219704
FDO_E_FIELDS_MULTIPLE_GLOBALIDS = -2147219703
FDO_E_FIELDS_EMPTY = -2147219702
FDO_E_INDEX_WRONG_TYPE = -2147219631
FDO_E_INDEX_ALREADY_EXISTS = -2147219630
FDO_E_INDEX_NOT_FOUND = -2147219629
FDO_E_INDEX_NOT_ALLOWED = -2147219628
FDO_E_METADATA_TABLE_NOT_FOUND = -2147219455
FDO_E_METADATA_FIELD_NOT_FOUND = -2147219454
FDO_E_METADATA_ADDING_DATASET = -2147219453
FDO_E_METADATA_ADDING_FEATURECLASS = -2147219452
FDO_E_METADATA_BAD_CLSID = -2147219451
FDO_E_SPATIALREL_NOT_SUPPORTED = -2147219375
FDO_E_SPATIALREL_UNKNOWN = -2147219374
FDO_E_FEATURETYPE_NOT_SUPPORTED = -2147219373
FDO_E_FEATURETYPE_UNKNOWN = -2147219372
FDO_E_DATASETTYPE_NOT_SUPPORTED = -2147219371
FDO_E_DATASETTYPE_UNKNOWN = -2147219370
FDO_E_DRAWSTYLE_NOT_SUPPORTED = -2147219369
FDO_E_DRAWSTYLE_UNKNOWN = -2147219368
FDO_E_DRAWPHASE_NOT_SUPPORTED = -2147219367
FDO_E_DRAWPHASE_UNKNOWN = -2147219366
FDO_E_GEOMETRY_TYPE_NOT_SUPPORTED = -2147219199
FDO_E_MULTIPART_EDGE_FEATURE_NOT_SUPPORTED = -2147219198
FDO_E_GEOMETRY_HAS_NO_M_VALUES = -2147219197
FDO_E_GEOMETRY_HAS_NO_Z_VALUES = -2147219196
FDO_E_GEOMETRY_HAS_NULL_Z_VALUES = -2147219195
FDO_E_GEOMETRY_NOT_SIMPLE = -2147219194
FDO_E_GEOMETRY_CANNOT_HAVE_Z_VALUES = -2147219193
FDO_E_GEOMETRY_SPATIAL_REFERENCE = -2147219192
FDO_E_GEOMETRY_MISSING_SPATIAL_REFERENCE = -2147219191
FDO_E_CANT_STORE_VERTICAL_SEGMENT = -2147219190
FDO_E_ROW_NO_SETUPINTERFACE = -2147219119
FDO_E_ROW_NOT_FOUND = -2147219118
FDO_E_ROW_NO_OID = -2147219117
FDO_E_ROW_NO_OBJCLASS = -2147219116
FDO_E_ROW_BAD_VALUE = -2147219115
FDO_E_ROW_ALREADY_EXISTS = -2147219114
FDO_E_COMPARE_TYPE_MISMATCH = -2147219113
FDO_E_CANNOT_STORE_RECYCLED_ROW_IN_EDIT_SESSION = -2147219112
FDO_E_FEATURE_NO_ANNO = -2147217407
FDO_E_FEATURE_BAD_SHAPE = -2147217406
FDO_E_FEATURE_OUTSIDE_SPATIALREF = -2147217405
FDO_E_FEATURE_SHAPE_UPDATE_BLOCKED = -2147217404
FDO_E_FEATURE_AREA_LENGTH_UPDATE_FAILED = -2147217403
FDO_E_ON_DELETE_MESSAGE_FAILED = -2147217402
FDO_E_DELETE_PART_OBJECTS_FAILED = -2147217401
FDO_E_DELETE_RELATIONSHIPS_FAILED = -2147217400
FDO_E_ON_CHANGED_MESSAGE_FAILED = -2147217399
FDO_E_MOVE_RELATED_FEATURES_FAILED = -2147217398
FDO_E_ROTATE_RELATED_FEATURES_FAILED = -2147217397
FDO_E_FEATURE_DELETED = -2147217396
FDO_E_FEATURE_VALUE_TYPE_MISMATCH = -2147217395
FDO_E_CUSTOM_COMPLEX_JUNCTION_NOT_IMPLEMENTED = -2147217394
FDO_E_FEATURE_NOT_FOUND = -2147217393
FDO_E_SPLIT_NOT_SUPPORTED_ON_GEOMETRY_TYPE = -2147217392
FDO_E_SPLITTING_POLYGONS_REQUIRES_POLYLINE = -2147217391
FDO_E_SPLITTING_POLYLINES_REQUIRES_POINT = -2147217390
FDO_E_SPLIT_POINT_YIELDS_ZERO_LENGTH_POLYLINE = -2147217389
FDO_E_CUTTER_YIELDS_ZERO_AREA_POLYGON = -2147217388
FDO_E_FEATURE_NO_GEOMETRY = -2147217387
FDO_E_REQUIRED_INTERFACE_NOT_FOUND = -2147217386
FDO_E_REQUIRED_CONNECTION_POINT_NOT_FOUND = -2147217385
FDO_E_INVALID_CONNECTION_POINT_GEOMETRY = -2147217384
FDO_E_FEATURE_EMPTY_GEOMETRY = -2147217383
FDO_E_CURSOR_WRONG_TYPE = -2147217327
FDO_E_CURSOR_INVALID = -2147217326
FDO_E_CURSOR_FINISHED = -2147217325
FDO_E_CURSOR_LOCKED = -2147217324
FDO_E_CURSOR_INVALIDATED = -2147217323
FDO_E_CURSOR_DIFF_OPENED_IN_FRACTIONAL_SECONDS = -2147217322
FDO_E_VERSION_BAD_NAME = -2147217151
FDO_E_VERSION_UNEDITABLE = -2147217150
FDO_E_VERSION_HAS_CONFLICTS = -2147217149
FDO_E_VERSION_ALREADY_EXISTS = -2147217148
FDO_E_VERSION_REDEFINED = -2147217147
FDO_E_VERSION_NOT_FOUND = -2147217146
FDO_E_VERSION_INVALID_STATE = -2147217145
FDO_E_VERSION_NOT_OWNER = -2147217144
FDO_E_VERSION_HAS_CHILDREN = -2147217143
FDO_E_VERSION_NOT_RECONCILED = -2147217142
FDO_E_VERSION_IS_PROTECTED = -2147217141
FDO_E_VERSION_IN_USE = -2147217140
FDO_E_VERSION_BEING_EDITED = -2147217139
FDO_E_VERSION_BEING_RECONCILED = -2147217138
FDO_E_RECONCILE_VERSION_NOT_AVAILABLE = -2147217137
FDO_E_VERSION_RECONCILE_LOST = -2147217136
FDO_E_FAILED_FILTERING_CONFLICTS = -2147217135
FDO_E_RECONCILE_VERSION_NOT_ANCESTOR = -2147217134
FDO_E_VERSION_CANNOT_BE_RECONCILED = -2147217133
FDO_E_VERSION_NOT_HISTORICAL = -2147217132
FDO_E_VERSION_REQUIRES_PARENT_RECONCILE = -2147217131
FDO_E_DATASOURCE_LOCK_FAILED = -2147217071
FDO_E_DATASOURCE_RELEASELOCK_FAILED = -2147217070
FDO_E_DATASOURCE_INUSE_ELSEWHERE = -2147217069
FDO_E_INVALID_UNITS = -2147216895
FDO_E_INVALID_GRID_SIZE = -2147216894
FDO_E_SPATIALREF_MISMATCH = -2147216893
FDO_E_SPATIALREF_INVALID = -2147216892
FDO_E_INVALID_M_DOMAIN = -2147216891
FDO_E_CANNOT_ALTER_SPATIALREF = -2147216890
FDO_E_NO_SPATIALREF = -2147216889
FDO_E_HIGH_PRECISION_SR_NOT_SUPPORTED = -2147216888
FDO_E_LOW_PRECISION_SR_NOT_SUPPORTED = -2147216887
FDO_E_CANNOT_ALTER_PRECISION = -2147216886
FDO_E_SPATIALREF_PRECISION_MISMATCH = -2147216885
FDO_E_NEGATIVE_RESOLUTION = -2147216884
FDO_E_RESOLUTION_DOES_NOT_MATCH_PERMISSIBLE_VALUE = -2147216883
FDO_E_INVALID_XY_DOMAIN = -2147216882
FDO_E_GRID_SIZE_TOO_SMALL = -2147216881
FDO_E_INVALID_Z_DOMAIN = -2147216880
FDO_E_SPATIALREF_Z_MISMATCH = -2147216879
FDO_E_SPATIALFILTER_INVALID = -2147216815
FDO_E_SPATIALFILTER_INVALID_GEOMETRY = -2147216814
FDO_E_SPATIALFILTER_INVALID_SPATIAL_RELATION = -2147216813
FDO_E_SELECTION_MISMATCH = -2147216639
FDO_E_SELECTION_INVALID_TYPE = -2147216638
FDO_E_SELECTION_NO_SELECTABLE_LAYERS = -2147216637
FDO_E_OBJECTCLASS_COULD_NOT_CREATE_CLASS_INSTANCE = -2147216559
FDO_E_OBJECTCLASS_COULD_NOT_CREATE_CLASS_EXTENSION = -2147216558
FDO_E_OBJECTCLASS_COULD_NOT_INITIALIZE_CLASS_EXTENSION = -2147216557
FDO_E_OBJECTCLASS_REQUIRES_AN_EDIT_SESSION = -2147216556
FDO_E_OBJECTCLASS_MODEL_NAME_ALREADY_EXISTS = -2147216555
FDO_E_CLASS_FD_NOT_EDITABLE = -2147216554
FDO_E_COULD_NOT_LOAD_CLASS_EXTENSION_PROPERTIES = -2147216553
FDO_E_OBJECTCLASS_NOT_REGISTERED = -2147216552
FDO_E_OBJECTCLASS_IN_CONTROLLER_DATASET = -2147216551
FDO_E_SE_FAILURE = -2147216127
FDO_E_SE_INVALID_LAYERINFO_OBJECT = -2147216126
FDO_E_SE_NO_ANNOTATION = -2147216125
FDO_E_SE_FINISHED = -2147216124
FDO_E_SE_SDE_NOT_STARTED = -2147216123
FDO_E_SE_UNCHANGED = -2147216122
FDO_E_SE_CONNECTIONS_EXCEEDED = -2147216120
FDO_E_SE_LOGIN_NOT_ALLOWED = -2147216119
FDO_E_SE_INVALID_USER = -2147216118
FDO_E_SE_NET_FAILURE = -2147216117
FDO_E_SE_NET_TIMEOUT = -2147216116
FDO_E_SE_OUT_OF_SVMEM = -2147216115
FDO_E_SE_OUT_OF_CLMEM = -2147216114
FDO_E_SE_OUT_OF_CONTEXT = -2147216113
FDO_E_SE_NO_ACCESS = -2147216112
FDO_E_SE_TOO_MANY_LAYERS = -2147216111
FDO_E_SE_NO_LAYER_SPECIFIED = -2147216110
FDO_E_SE_LAYER_LOCKED = -2147216109
FDO_E_SE_LAYER_EXISTS = -2147216108
FDO_E_SE_LAYER_NOEXIST = -2147216107
FDO_E_SE_LAYER_INUSE = -2147216106
FDO_E_SE_ROW_NOEXIST = -2147216104
FDO_E_SE_ROW_EXISTS = -2147216102
FDO_E_SE_LAYER_MISMATCH = -2147216101
FDO_E_SE_NO_PERMISSIONS = -2147216100
FDO_E_SE_INVALID_NOT_NULL = -2147216099
FDO_E_SE_INVALID_SHAPE = -2147216098
FDO_E_SE_INVALID_LAYER_NUMBER = -2147216097
FDO_E_SE_INVALID_ENTITY_TYPE = -2147216096
FDO_E_SE_INVALID_SEARCH_METHOD = -2147216095
FDO_E_SE_INVALID_ETYPE_MASK = -2147216094
FDO_E_SE_BIND_CONFLICT = -2147216093
FDO_E_SE_INVALID_GRIDSIZE = -2147216092
FDO_E_SE_INVALID_LOCK_MODE = -2147216091
FDO_E_SE_ETYPE_NOT_ALLOWED = -2147216090
FDO_E_SE_INVALID_NUM_OF_PTS = -2147216088
FDO_E_SE_TABLE_NOEXIST = -2147216087
FDO_E_SE_ATTR_NOEXIST = -2147216086
FDO_E_SE_LICENSE_FAILURE = -2147216085
FDO_E_SE_OUT_OF_LICENSES = -2147216084
FDO_E_SE_INVALID_COLUMN_VALUE = -2147216083
FDO_E_SE_INVALID_SQL = -2147216081
FDO_E_SE_LOG_NOEXIST = -2147216080
FDO_E_SE_LOG_NOACCESS = -2147216079
FDO_E_SE_LOG_NOTOPEN = -2147216078
FDO_E_SE_LOG_IO_ERROR = -2147216077
FDO_E_SE_NO_SHAPES = -2147216076
FDO_E_SE_NO_LOCKS = -2147216075
FDO_E_SE_LOCK_CONFLICT = -2147216074
FDO_E_SE_OUT_OF_LOCKS = -2147216073
FDO_E_SE_DB_IO_ERROR = -2147216072
FDO_E_SE_STREAM_IN_PROGRESS = -2147216071
FDO_E_SE_INVALID_COLUMN_TYPE = -2147216070
FDO_E_SE_TOPO_ERROR = -2147216069
FDO_E_SE_ATTR_CONV_ERROR = -2147216068
FDO_E_SE_INVALID_COLUMN_DEF = -2147216067
FDO_E_SE_INVALID_SHAPE_BUF_SIZE = -2147216066
FDO_E_SE_INVALID_ENVELOPE = -2147216065
FDO_E_SE_TEMP_IO_ERROR = -2147216064
FDO_E_SE_GSIZE_TOO_SMALL = -2147216063
FDO_E_SE_LICENSE_EXPIRED = -2147216062
FDO_E_SE_TABLE_EXISTS = -2147216061
FDO_E_SE_INDEX_EXISTS = -2147216060
FDO_E_SE_INDEX_NOEXIST = -2147216059
FDO_E_SE_INVALID_POINTER = -2147216058
FDO_E_SE_INVALID_PARAM_VALUE = -2147216057
FDO_E_SE_ALL_SLIVERS = -2147216056
FDO_E_SE_TRANS_IN_PROGRESS = -2147216055
FDO_E_SE_IOMGR_NO_DBMS_CONNECT = -2147216054
FDO_E_SE_DUPLICATE_ARC = -2147216053
FDO_E_SE_INVALID_ANNO_OBJECT = -2147216052
FDO_E_SE_PT_NO_EXIST = -2147216051
FDO_E_SE_PTS_NOT_ADJACENT = -2147216050
FDO_E_SE_INVALID_MID_PT = -2147216049
FDO_E_SE_INVALID_END_PT = -2147216048
FDO_E_SE_INVALID_RADIUS = -2147216047
FDO_E_SE_LOAD_ONLY_LAYER = -2147216046
FDO_E_SE_LAYERS_NOT_FOUND = -2147216045
FDO_E_SE_FILE_IO_ERROR = -2147216044
FDO_E_SE_BLOB_SIZE_TOO_LARGE = -2147216043
FDO_E_SE_CORRIDOR_OUT_OF_BOUNDS = -2147216042
FDO_E_SE_SHAPE_INTEGRITY_ERROR = -2147216041
FDO_E_SE_NOT_IMPLEMENTED_YET = -2147216040
FDO_E_SE_CAD_EXISTS = -2147216039
FDO_E_SE_INVALID_TRANSID = -2147216038
FDO_E_SE_INVALID_LAYER_NAME = -2147216037
FDO_E_SE_INVALID_LAYER_KEYWORD = -2147216036
FDO_E_SE_INVALID_RELEASE = -2147216035
FDO_E_SE_VERSION_TBL_EXISTS = -2147216034
FDO_E_SE_COLUMN_NOT_BOUND = -2147216033
FDO_E_SE_INVALID_INDICATOR_VALUE = -2147216032
FDO_E_SE_INVALID_CONNECTION = -2147216031
FDO_E_SE_INVALID_DBA_PASSWORD = -2147216030
FDO_E_SE_PATH_NOT_FOUND = -2147216029
FDO_E_SE_SDEHOME_NOT_SET = -2147216028
FDO_E_SE_NOT_TABLE_OWNER = -2147216027
FDO_E_SE_PROCESS_NOT_FOUND = -2147216026
FDO_E_SE_INVALID_DBMS_LOGIN = -2147216025
FDO_E_SE_PASSWORD_TIMEOUT = -2147216024
FDO_E_SE_INVALID_SERVER = -2147216023
FDO_E_SE_IOMGR_NOT_AVAILABLE = -2147216022
FDO_E_SE_SERVICE_NOT_FOUND = -2147216021
FDO_E_SE_INVALID_STATS_TYPE = -2147216020
FDO_E_SE_INVALID_DISTINCT_TYPE = -2147216019
FDO_E_SE_INVALID_GRANT_REVOKE = -2147216018
FDO_E_SE_INVALID_SDEHOME = -2147216017
FDO_E_SE_INVALID_STREAM = -2147216016
FDO_E_SE_TOO_MANY_STREAMS = -2147216015
FDO_E_SE_OUT_OF_MUTEXES = -2147216014
FDO_E_SE_CONNECTION_LOCKED = -2147216013
FDO_E_SE_CONNECTION_IN_USE = -2147216012
FDO_E_SE_NOT_A_SELECT_STATEMENT = -2147216011
FDO_E_SE_FUNCTION_SEQUENCE_ERROR = -2147216010
FDO_E_SE_WRONG_COLUMN_TYPE = -2147216009
FDO_E_SE_PTABLE_LOCKED = -2147216008
FDO_E_SE_PTABLE_IN_USE = -2147216007
FDO_E_SE_STABLE_LOCKED = -2147216006
FDO_E_SE_STABLE_IN_USE = -2147216005
FDO_E_SE_INVALID_FILTER_TYPE = -2147216004
FDO_E_SE_NO_CAD = -2147216003
FDO_E_SE_INSTANCE_NOT_AVAILABLE = -2147216002
FDO_E_SE_INSTANCE_TOO_EARLY = -2147216001
FDO_E_SE_INVALID_SYSTEM_UNITS = -2147216000
FDO_E_SE_INVALID_UNITS = -2147215999
FDO_E_SE_INVALID_CAD_OBJECT = -2147215998
FDO_E_SE_VERSION_NOEXIST = -2147215997
FDO_E_SE_INVALID_SPATIAL_CONSTRAINT = -2147215996
FDO_E_SE_INVALID_STREAM_TYPE = -2147215995
FDO_E_SE_INVALID_SPATIAL_COLUMN = -2147215994
FDO_E_SE_NO_SPATIAL_MASKS = -2147215993
FDO_E_SE_IOMGR_NOT_FOUND = -2147215992
FDO_E_SE_SYSTEM_IS_CLIENT_ONLY = -2147215991
FDO_E_SE_MULTIPLE_SPATIAL_COLS = -2147215990
FDO_E_SE_INVALID_SHAPE_OBJECT = -2147215989
FDO_E_SE_INVALID_PARTNUM = -2147215988
FDO_E_SE_INCOMPATIBLE_SHAPES = -2147215987
FDO_E_SE_INVALID_PART_OFFSET = -2147215986
FDO_E_SE_INCOMPATIBLE_COORDREFS = -2147215985
FDO_E_SE_COORD_OUT_OF_BOUNDS = -2147215984
FDO_E_SE_LAYER_CACHE_FULL = -2147215983
FDO_E_SE_INVALID_COORDREF_OBJECT = -2147215982
FDO_E_SE_INVALID_COORDSYS_ID = -2147215981
FDO_E_SE_INVALID_COORDSYS_DESC = -2147215980
FDO_E_SE_INVALID_ROW_ID_LAYER = -2147215979
FDO_E_SE_PROJECTION_ERROR = -2147215978
FDO_E_SE_ARRAY_BYTES_EXCEEDED = -2147215977
FDO_E_SE_POLY_SHELLS_OVERLAP = -2147215976
FDO_E_SE_TOO_FEW_POINTS = -2147215975
FDO_E_SE_INVALID_PART_SEPARATOR = -2147215974
FDO_E_SE_INVALID_POLYGON_CLOSURE = -2147215973
FDO_E_SE_INVALID_OUTER_SHELL = -2147215972
FDO_E_SE_ZERO_AREA_POLYGON = -2147215971
FDO_E_SE_POLYGON_HAS_VERTICAL_LINE = -2147215970
FDO_E_SE_OUTER_SHELLS_OVERLAP = -2147215969
FDO_E_SE_SELF_INTERSECTING = -2147215968
FDO_E_SE_INVALID_EXPORT_FILE = -2147215967
FDO_E_SE_READ_ONLY_SHAPE = -2147215966
FDO_E_SE_INVALID_DATA_SOURCE = -2147215965
FDO_E_SE_INVALID_STREAM_SPEC = -2147215964
FDO_E_SE_INVALID_ALTER_OPERATION = -2147215963
FDO_E_SE_INVALID_SPATIAL_COL_NAME = -2147215962
FDO_E_SE_INVALID_DATABASE = -2147215961
FDO_E_SE_SPATIAL_SQL_NOT_INSTALLED = -2147215960
FDO_E_SE_NORM_DIM_INFO_NOT_FOUND = -2147215959
FDO_E_SE_NORM_DIM_TAB_VALUE_NOT_FOUND = -2147215958
FDO_E_SE_UNSUPPORTED_NORMALIZED_OPERATION = -2147215957
FDO_E_SE_INVALID_REGISTERED_LAYER_OPTION = -2147215956
FDO_E_SE_READ_ONLY = -2147215955
FDO_E_SE_NO_SDE_ROWID_COLUMN = -2147215954
FDO_E_SE_READ_ONLY_COLUMN = -2147215953
FDO_E_SE_INVALID_VERSION_NAME = -2147215952
FDO_E_SE_STATE_NOEXIST = -2147215951
FDO_E_SE_INVALID_STATEINFO_OBJECT = -2147215950
FDO_E_SE_VERSION_HAS_MOVED = -2147215949
FDO_E_SE_STATE_HAS_CHILDREN = -2147215948
FDO_E_SE_PARENT_NOT_CLOSED = -2147215947
FDO_E_SE_VERSION_EXISTS = -2147215946
FDO_E_SE_TABLE_NOT_MULTIVERSION = -2147215945
FDO_E_SE_STATE_USED_BY_VERSION = -2147215944
FDO_E_SE_INVALID_VERSIONINFO_OBJECT = -2147215943
FDO_E_SE_INVALID_STATE_ID = -2147215942
FDO_E_SE_SDETRACELOC_NOT_SET = -2147215941
FDO_E_SE_ERROR_LOADING_SSA = -2147215940
FDO_E_SE_TOO_MANY_STATES = -2147215939
FDO_E_SE_STATES_ARE_SAME = -2147215938
FDO_E_SE_NO_ROWID_COLUMN = -2147215937
FDO_E_SE_NO_STATE_SET = -2147215936
FDO_E_SE_SSA_FUNCTION_ERROR = -2147215935
FDO_E_SE_INVALID_REGINFO_OBJECT = -2147215934
FDO_E_SE_NO_COMMON_LINEAGE = -2147215933
FDO_E_SE_STATE_INUSE = -2147215932
FDO_E_SE_STATE_TREE_INUSE = -2147215931
FDO_E_SE_INVALID_RASTER_COLUMN = -2147215930
FDO_E_SE_RASTERCOLUMN_EXISTS = -2147215929
FDO_E_SE_INVALID_MVTABLE_INDEX = -2147215928
FDO_E_SE_INVALID_STORAGE_TYPE = -2147215927
FDO_E_SE_AMBIGUOUS_NIL_SHAPE = -2147215926
FDO_E_SE_INVALID_BYTE_ORDER = -2147215925
FDO_E_SE_INVALID_GEOMETRY_TYPE = -2147215924
FDO_E_SE_INVALID_NUM_MEASURES = -2147215923
FDO_E_SE_INVALID_NUM_PARTS = -2147215922
FDO_E_SE_BINARY_TOO_SMALL = -2147215921
FDO_E_SE_SHAPE_TEXT_TOO_LONG = -2147215920
FDO_E_SE_SHAPE_TEXT_ERROR = -2147215919
FDO_E_SE_TOO_MANY_PARTS = -2147215918
FDO_E_SE_TYPE_MISMATCH = -2147215917
FDO_E_SE_SQL_PARENTHESIS_MISMATCH = -2147215916
FDO_E_SE_NIL_SHAPE_NOT_ALLOWED = -2147215915
FDO_E_SE_INSTANCE_ALREADY_RUNNING = -2147215914
FDO_E_SE_UNSUPPORTED_OPERATION = -2147215913
FDO_E_SE_INVALID_EXTERNAL_LAYER_OPTION = -2147215912
FDO_E_SE_NORMALIZE_VALUE_NOT_FOUND = -2147215911
FDO_E_SE_INVALID_QUERY_TYPE = -2147215910
FDO_E_SE_NO_TRACE_LIBRARY = -2147215909
FDO_E_SE_TRACE_ON = -2147215908
FDO_E_SE_TRACE_OFF = -2147215907
FDO_E_SE_SCL_SYNTAX_ERROR = -2147215906
FDO_E_SE_TABLE_REGISTERED = -2147215905
FDO_E_SE_INVALID_REGISTRATION_ID = -2147215904
FDO_E_SE_TABLE_NOREGISTERED = -2147215903
FDO_E_SE_TOO_MANY_REGISTRATIONS = -2147215902
FDO_E_SE_DELETE_NOT_ALLOWED = -2147215901
FDO_E_SE_RASTERCOLUMN_INUSE = -2147215898
FDO_E_SE_RASTERCOLUMN_NOEXIST = -2147215897
FDO_E_SE_INVALID_RASTERCOLUMN_NUMBER = -2147215896
FDO_E_SE_TOO_MANY_RASTERCOLUMNS = -2147215895
FDO_E_SE_INVALID_RASTER_NUMBER = -2147215894
FDO_E_SE_NO_REQUEST_STATUS = -2147215893
FDO_E_SE_NO_REQUEST_RESULTS = -2147215892
FDO_E_SE_RASTERBAND_EXISTS = -2147215891
FDO_E_SE_RASTERBAND_NOEXIST = -2147215890
FDO_E_SE_RASTER_EXISTS = -2147215889
FDO_E_SE_RASTER_NOEXIST = -2147215888
FDO_E_SE_TOO_MANY_RASTERBANDS = -2147215887
FDO_E_SE_TOO_MANY_RASTERS = -2147215886
FDO_E_SE_VIEW_EXISTS = -2147215885
FDO_E_SE_VIEW_NOEXIST = -2147215884
FDO_E_SE_LOCK_EXISTS = -2147215883
FDO_E_SE_ROWLOCK_MASK_CONFLICT = -2147215882
FDO_E_SE_NOT_IN_RASTER = -2147215881
FDO_E_SE_INVALID_RASBANDINFO_OBJECT = -2147215880
FDO_E_SE_INVALID_RASCOLINFO_OBJECT = -2147215879
FDO_E_SE_INVALID_RASTERINFO_OBJECT = -2147215878
FDO_E_SE_INVALID_RASTERBAND_NUMBER = -2147215877
FDO_E_SE_MULTIPLE_RASTER_COLS = -2147215876
FDO_E_SE_TABLE_SCHEMA_IS_LOCKED = -2147215875
FDO_E_SE_INVALID_LOGINFO_OBJECT = -2147215874
FDO_E_SE_SQL_TOO_LONG = -2147215873
FDO_E_SE_UNSUPPORTED_ON_VIEW = -2147215872
FDO_E_SE_LOG_EXISTS = -2147215871
FDO_E_SE_SDE_WARNING = -2147215870
FDO_E_SE_ETYPE_CHANGED = -2147215869
FDO_E_SE_NO_ROWS_DELETED = -2147215868
FDO_E_SE_TOO_MANY_DISTINCTS = -2147215867
FDO_E_SE_NULL_VALUE = -2147215866
FDO_E_SE_NO_ROWS_UPDATED = -2147215865
FDO_E_SE_NO_CPGCVT = -2147215864
FDO_E_SE_NO_CPGHOME = -2147215863
FDO_E_SE_DBMS_DOES_NOT_SUPPORT = -2147215862
FDO_E_SE_ROWLOCKING_ENABLED = -2147215861
FDO_E_SE_ROWLOCKING_NOT_ENABLED = -2147215860
FDO_E_SE_LOG_IS_OPEN = -2147215859
FDO_E_SE_SPATIALREF_EXISTS = -2147215858
FDO_E_SE_SPATIALREF_NOEXIST = -2147215857
FDO_E_SE_SPATIALREF_IN_USE = -2147215856
FDO_E_SE_INVALID_SPATIALREFINFO_OBJECT = -2147215855
FDO_E_SE_INVALID_FUNCTION_ID = -2147215854
FDO_E_SE_MOSAIC_NOT_ALLOWED = -2147215853
FDO_E_SE_PASSWORD_EXPIRED = -2147215852
FDO_E_SE_NO_ARCSDE_LICENSE = -2147215851
FDO_E_SE_NO_ARCSDE_LICENSE_NO_PERMISSION = -2147215850
FDO_E_SE_NO_ARCSDE_LICENSE_SQLEXPRESS = -2147215849
FDO_E_DEFAULT_VALUE_NOT_NULLABLE = -2147215359
FDO_E_DEFAULT_VALUE_INVALID = -2147215358
FDO_E_OBJECT_IN_ANOTHER_FEATUREDATASET = -2147215279
FDO_E_ONLY_SIMPLE_FEATURES_SUPPORTED = -2147215278
FDO_E_XML_PARSE_ERROR = -2147215103
FDO_E_TOPOLOGY_ILLEGAL_RESHAPE = -2147215023
FDO_E_TOPOLOGY_ALREADY_EXISTS = -2147215022
FDO_E_TOPOLOGY_NOT_FOUND = -2147215021
FDO_E_TOPOLOGY_CANNOT_RENAME = -2147215020
FDO_E_INVALID_FEATURE_TYPE_FOR_TOPOLOGY = -2147215019
FDO_E_INVALID_GEOMETRY_TYPE_FOR_TOPOLOGY = -2147215018
FDO_E_INVALID_TOPOLOGY_RULE = -2147215017
FDO_E_TOPOLOGY_WORKSPACE_EXTENSION_NOT_FOUND = -2147215016
FDO_E_CANNOT_RESET_CLUSTER_TOLERANCE = -2147215015
FDO_E_TOPOLOGIES_NOT_SUPPORTED_IN_RELEASE = -2147215014
FDO_E_TOPOLOGY_INVALID_WEIGHT = -2147215013
FDO_E_CANNOT_MODIFY_TOPOLOGY_ERROR_FEATURE = -2147215012
FDO_E_TOPOCLASSES_SYSTEM_TABLE_INCONSISTENCY = -2147215011
FDO_E_INVALID_CLUSTER_TOLERANCE = -2147215010
FDO_E_INVALID_GEOMETRY_TYPE_FOR_TOPOLOGY_RULE = -2147215009
FDO_E_NOT_SUPPORTED_ON_TOPOLOGY_ERROR_FEATURE = -2147215008
FDO_E_CANNOT_MODIFY_SYSTEM_MANAGED_TABLES = -2147215007
FDO_E_TOPOLOGY_EDGE_NOT_SELECTABLE = -2147215006
FDO_E_CLASS_ALREADY_MEMBER_OF_TOPOLOGY = -2147215005
FDO_E_EMPTY_ENVELOPE_FOR_CLEAN = -2147215004
FDO_E_INVALID_TOPOLOGY_ID = -2147215003
FDO_E_TOPOLOGY_ENGINE_FAILURE = -2147215002
FDO_E_TOPOLOGY_ENGINE_OVERPROC_FAILURE = -2147215001
FDO_E_INVALID_TOPOLOGY_RULE_TYPE = -2147215000
FDO_E_NO_PARTIAL_REBUILD = -2147214999
FDO_E_CANNOT_ADD_REGISTERED_CLASS_TO_TOPOLOGY = -2147214998
FDO_E_TOPOLOGY_ERROR_OVERFLOW = -2147214997
FDO_E_NETWORK_CANNOT_RENAME = -2147214996
FDO_E_NETWORK_INVALID_TYPE = -2147214995
FDO_E_NETWORK_ALREADY_EXISTS = -2147214994
FDO_E_NETWORK_INVALID_GEOMETRY_TYPE = -2147214993
FDO_E_NETWORK_NOT_FOUND = -2147214992
FDO_E_VERSIONING_NOT_SUPPORTED = -2147214991
FDO_E_CLASS_NOT_IN_TOPOLOGIES_FEATURE_DATASET = -2147214990
FDO_E_TOPOLOGY_HAS_NO_CLASSES = -2147214989
FDO_E_TOPOLOGY_INVALID_RANK = -2147214988
FDO_E_OUT_OF_PHYSICAL_MEMORY = -2147214987
FDO_E_TOPOLOGY_OPERATION_CANCELLED = -2147214986
FDO_E_CLASS_NOT_IN_TOPOLOGY = -2147214985
FDO_E_MODIFY_EDGE_ENDPOINT = -2147214984
FDO_E_CANNOT_ADD_STANDALONE_CLASS_TO_TOPOLOGY = -2147214983
FDO_E_CLASS_IN_TOPOLOGY_REQUIRES_EDIT_SESSION = -2147214982
FDO_E_CANNOT_ADD_RULE_TO_VERSIONED_TOPOLOGY = -2147214981
FDO_E_TOPOLOGY_SCHEMA_LOCK_CONFLICT = -2147214980
FDO_E_DIRTY_AREA_OUTSIDE_SPATIAL_DOMAIN = -2147214979
FDO_E_TOPOLOGY_INVALID_NAME = -2147214978
FDO_E_TOPOLOGY_ENGINE_TEMP_SPACE_EXHAUSTED = -2147214977
FDO_E_INCONSISTENT_TOPOLOGY_RULE = -2147214976
FDO_E_UNSUPPORTED_TOPOLOGY_RULE = -2147214975
FDO_E_INVALID_TOPOLOGY_RULE_CLASS_ASSIGNMENT = -2147214974
FDO_E_OPERATION_NOT_SUPPORTED_IN_EDIT_SESSION = -2147214973
FDO_E_TOPOLOGY_EMPTY_GEOMETRY = -2147214972
FDO_E_TOPOLOGY_EXTENT_TOO_LARGE = -2147214971
FDO_E_Z_CLUSTER_TOLERANCE_NOT_SUPPORTED_IN_RELEASE = -2147214970
FDO_E_OPERATION_REQUIRES_EDIT_SESSION = -2147214969
FDO_E_OPERATION_NOT_SUPPORTED_IN_EDIT_OPERATION = -2147214968
FDO_E_TOPOGRAPH_NOT_BUILT = -2147214967
FDO_E_TOPOGRAPH_CORRUPT = -2147214966
FDO_E_CANT_MERGE_VERTICALEDGES = -2147214965
FDO_E_INCONSISTANT_MERGE_PARENTS = -2147214964
FDO_E_EDGE_SET_NOT_CONNECTED = -2147214963
FDO_E_TOPOLOGY_RULE_NOT_SUPPORTED_IN_RELEASE = -2147214962
FDO_E_CANT_MERGE_BRANCHINGEDGES = -2147214961
FDO_E_NOT_PSEUDONODE = -2147214960
FDO_E_CLASS_IN_NETWORK_REQUIRES_EDIT_SESSION = -2147214959
FDO_E_CANNOT_ADD_VERSIONED_CLASS_TO_NON_VERSIONED_TOPOLOGY = -2147214958
FDO_E_CANNOT_ADD_NON_VERSIONED_CLASS_TO_VERSIONED_TOPOLOGY = -2147214957
FDO_E_TOPOLOGIES_SCHEMA_CHANGES_NOT_SUPPORTED_IN_RELEASE = -2147214956
FDO_E_TERRAIN_NOT_FOUND = -2147214955
FDO_E_NAME_STRING_SYNTAX = -2147213231
FDO_E_INVALID_IMPORT_XML = -2147213055
FDO_E_REQUIRED_XML_ELEMENT_NOT_FOUND = -2147213054
FDO_E_XML_EXPORT_DATASET_NOT_FOUND = -2147213053
FDO_E_CLASS_NOT_REPLICABLE = -2147212975
FDO_E_SYNCHRONIZATION_CONFLICTS = -2147212974
FDO_E_CANNOT_SYNCHRONIZE = -2147212973
FDO_E_REPLICA_NOT_FOUND = -2147212972
FDO_E_RECONCILE_FAILED = -2147212971
FDO_E_INVALID_REPLICA = -2147212970
FDO_E_GENERATION_OUT_OF_ORDER = -2147212969
FDO_E_SYNCHRONIZATION_HAS_CONFLICTS = -2147212968
FDO_E_REPLICATION_NOT_SUPPORTED_IN_RELEASE = -2147212967
FDO_E_REPLICATION_NOT_SUPPORTED = -2147212966
FDO_E_MISSING_ACKNOWLEDGEMENT = -2147212965
FDO_E_CANNOT_SEND_TRANSMISSION = -2147212964
FDO_E_REPLICA_LOCKED = -2147212963
FDO_E_RELATED_DATASET_IS_REFERENCED_BY_REPLICA = -2147212962
FDO_E_READONLY_REPLICA = -2147212961
FDO_E_OLD_MESSAGE = -2147212960
FDO_E_REPLICA_IN_SENDING_DATA_STATE = -2147212959
FDO_E_REPLICA_CAN_ONLY_IMPORT_ACKNOWLEDGMENT = -2147212958
FDO_E_REPLICA_NO_UNACKNOWLEDGED_GENERATIONS = -2147212957
FDO_E_MULTIGEN_REPLICAS_NOT_SUPPORTED_IN_WORKSPACE = -2147212956
FDO_E_CHECKOUTS_CANNOT_REEXPORT_CHANGES = -2147212955
FDO_E_REPLICA_RECEIVER_CANNOT_REEXPORT_CHANGES = -2147212954
FDO_E_REPLICA_RECEIVER_CANNOT_EXPORT_CHANGES = -2147212953
FDO_E_CANNOT_CHECKOUT_HIGH_PREC_DATA_IN_LOW_PREC_DATASET = -2147212952
FDO_E_CANNOT_REPLICATE_LOW_PRECISION_DATA = -2147212951
FDO_E_REPLICA_INVALID_OUTPUT_XML_FILE = -2147212950
FDO_NO_MATCH_DATASETS_FOUND_FOR_REGISTER_REPLICAS = -2147212949
FDO_E_NON_SIMPLE_DATASET_CANNOT_BE_REGISTERED_BY_REPLICA = -2147212948
FDO_E_INVALID_REPLICA_NAME = -2147212947
FDO_E_REPLICA_OLD_ACK = -2147212946
FDO_E_REPLICA_SCHEMA_CHANGES_WRONG_DIRECTION = -2147212945
FDO_E_CANNOT_CREATE_EMPTY_REPLICA = -2147212944
FDO_E_INVALID_DATA_FOR_THIS_OPERATION = -2147212943
FDO_E_REPLICA_SYNC_VERSION_NOT_YET_POSTED = -2147212942
FDO_E_CHILD_REPLICA_CANNOT_BE_CREATED_IN_PARENTDB = -2147212941
FDO_E_GLOBALID_FIELD_REFERENCED_BY_REPLICA_CANNOT_BE_DELETED = -2147212940
FDO_E_MUST_BE_REPLICA_OWNER = -2147212939
FDO_E_REPLICA_NAME_ALEARDY_EXISTS = -2147212938
FDO_E_CANNOT_REGISTER_EMPTY_REPLICA = -2147212937
FDO_UNREGISTER_GLOBALID_NOT_SUPPORTED = -2147212936
FDO_REGISTER_NULLABLE_GLOBALID_NOT_SUPPORTED = -2147212935
FDO_REGISTER_VERSIONED_GLOBALID_NOT_SUPPORTED = -2147212934
FDO_ONEWAY_REPLICA_USING_ARCHIVING_NOT_SUPPORTED_IN_NAMED_VERSIONS = -2147212933
FDO_ONEWAY_REPLICA_PARENT_READONLY_NOT_SUPPORTED_IN_LOCAL_CHILD_WORKSPACES = -2147212932
FDO_E_MUST_BE_VERSION_OWNER_TO_SYNC = -2147212931
FDO_DATA_CANNOT_BE_REGISTERED_AS_REPLICAS_IN_TRANSPORT_FGDB = -2147212930
FDO_E_CHILD_PARENT_REPLICA_CANNOT_EXIST_IN_SAME_GEODATABASE = -2147212929
FDO_E_FAILED_TO_SET_TARGET_NAME = -2147212928
FDO_E_PERSONAL_GEODATABASE_NOT_SUPPORTED_ON_SERVER = -2147212927
FDO_E_FAILED_TO_CREATE_DELTA_WORKSPACE = -2147212926
FDO_E_NO_DEFAULT_TURN_EVALUATOR = -2147212719
FDO_E_FEATURE_DATASET_CONTAINERS_NOT_SUPPORTED = -2147212718
FDO_E_NETWORK_DATASET_INVALID_NAME = -2147212717
FDO_E_INVALID_NETWORK_ATTRIBUTE_NAME = -2147212716
FDO_E_INVALID_NETWORK_SOURCE_FOR_EVALUATOR = -2147212715
FDO_E_INVALID_EXPRESSION_FOR_EVALUATOR = -2147212714
FDO_E_INVALID_CONSTANT_FOR_NETWORK_ATTRIBUTE = -2147212713
FDO_E_SUBTYPES_REQUIRED = -2147212712
FDO_E_INVALID_NETWORK_DATASET_SCHEMA = -2147212711
FDO_E_NETWORK_OBJECT_EVALUATOR_ERROR = -2147212710
FDO_E_NETWORK_BAD_EDGE_ORIENTATION = -2147212709
FDO_E_NETWORK_DATASET_INVALID_ACCESS = -2147212708
FDO_E_NO_DEFAULT_JUNCTION_EVALUATOR = -2147212707
FDO_E_NO_DEFAULT_EDGE_EVALUATOR = -2147212706
FDO_E_NETWORK_DATASET_NOTURNS = -2147212705
FDO_E_NETWORK_ELEMENT_EVALUATOR_ERROR = -2147212704
FDO_E_NETWORK_SOURCE_DATASET_NOT_FOUND = -2147212703
FDO_E_INVALID_NETWORK_SOURCE = -2147212702
FDO_E_INVALID_NETWORK_ATTRIBUTE = -2147212701
FDO_E_INVALID_CONNECTIVITY_GROUP_NAME = -2147212700
FDO_E_SUBTYPES_NOT_IN_USE = -2147212699
FDO_E_NETWORK_DATASETS_NOT_SUPPORTED_IN_RELEASE = -2147212698
FDO_E_NETWORK_DATASET_ALREADY_EXISTS = -2147212697
FDO_E_SUBTYPES_UNSPECIFIED_CONN_GROUP = -2147212696
FDO_E_SUBTYPES_UNSPECIFIED_CONN_POLICY = -2147212695
FDO_E_INVALID_NETWORK_SOURCE_GEOMETRY_TYPE = -2147212694
FDO_E_INVALID_NETWORK_SOURCE_FEATURE_TYPE = -2147212693
FDO_E_FSTAR_INVALID_FROM_EDGE = -2147212692
FDO_E_EVALUATOR_CREATE = -2147212691
FDO_E_EVALUATOR_INITIALIZE_DATA = -2147212690
FDO_E_EVALUATOR_INITIALIZE_QUERY = -2147212689
FDO_E_EVALUATOR_QUERY = -2147212688
FDO_E_INVALID_NETWORK_ELEMENT_ID = -2147212687
FDO_E_INVALID_NETWORK_EDGE_DIRECTION = -2147212686
FDO_E_INVALID_NETWORK_TURN_TYPE = -2147212685
FDO_E_TURN_NOT_PRESENT = -2147212684
FDO_E_BUILD_NOT_SUPPORTED = -2147212683
FDO_E_OPERATION_NOT_SUPPORTED_ON_BUILDABLE_NETWORK = -2147212682
FDO_E_NETWORK_SOURCE_INVALID_NAME = -2147212681
FDO_E_NETWORK_SOURCE_INVALID_ELEMENT_TYPE = -2147212680
FDO_E_NO_SYSTEM_JUNCTION_SOURCE = -2147212679
FDO_E_BAD_SYSTEM_JUNCTION_SOURCE = -2147212678
FDO_E_NETWORK_ELEMENT_NOT_INITIALIZED = -2147212677
FDO_E_ATTRIBUTES_WITHOUT_SOURCES = -2147212676
FDO_E_INVALID_HIERARCHY_RANGES = -2147212675
FDO_E_CANNOT_DELETE_NETWORK_ATTRIBUTES = -2147212674
FDO_E_SOURCE_DIRECTIONS_NOT_SUPPORTED = -2147212673
FDO_E_NETWORK_SOURCE_ALREADY_EXISTS = -2147212672
FDO_E_NETWORK_SOURCE_NAME_DOESNT_EXIST = -2147212671
FDO_E_EVALUATOR_CANNOT_BE_DEFAULT_EVALUATOR = -2147212670
FDO_E_INVALID_NETWORK_ATTRIBUTE_FOR_EVALUATOR = -2147212669
FDO_E_EVALUATOR_NOT_VALIDATED = -2147212668
FDO_E_EVALUATOR_NOT_VALID = -2147212667
FDO_E_EVALUATOR_NOT_INITIALIZED = -2147212666
FDO_E_EVALUATOR_SYNTAX_ERROR = -2147212665
FDO_E_FIELD_EVALUATOR_FIELD_NOT_FOUND = -2147212664
FDO_E_INVALID_NETWORK_ATTRIBUTE_ID = -2147212663
FDO_E_NETWORK_SOURCE_INVALID_FULLNAME = -2147212662
FDO_E_NOT_CONSTANT_EVALUATOR = -2147212661
FDO_E_DIRECTIONAL_EVALUATOR_WITH_JUNCTION_SOURCE = -2147212660
FDO_E_INCORRECT_DATA_ELEMENT_TYPE = -2147212659
FDO_E_INVALID_SOURCES_FOR_SHAPEFILE_NETWORK_DATASET = -2147212658
FDO_E_NETWORK_SOURCE_INCONSISTENT_ELEVATION_SPECIFICATION = -2147212657
FDO_E_TURN_NO_NETWORK = -2147212656
FDO_E_TURN_GEOM_TOO_MANY_VERTICES = -2147212655
FDO_E_TURN_NOT_VALID = -2147212654
FDO_E_TURN_GEOM_NOT_POLYLINE = -2147212653
FDO_E_TURN_GEOM_NOT_ENOUGH_VERTICES = -2147212652
FDO_E_TURN_GEOM_MULTIPART = -2147212651
FDO_E_TURN_GEOM_NO_FIRST_FEATURE = -2147212650
FDO_E_TURN_GEOM_NO_LAST_FEATURE = -2147212649
FDO_E_TURN_GEOM_NO_FEATURES = -2147212648
FDO_E_TURN_GEOM_DISCONNECTED_FEATURES = -2147212647
FDO_E_TURN_GEOM_INVALID_SEQUENCE = -2147212646
FDO_E_TURN_NOT_ENOUGH_PARTS = -2147212645
FDO_E_TURN_NDS_INTERIOR_EXTERIOR_CONFLICT = -2147212644
FDO_E_TURN_NDS_EXTERIOR_LOOP = -2147212643
FDO_E_TURN_NO_EDGE_SOURCES = -2147212642
FDO_E_TURN_INVALID_EDGE1END = -2147212641
FDO_E_TURN_GEOM_AMBIGUOUS_FEATURES = -2147212640
FDO_E_NETWORK_MISSING_SOURCE = -2147212639
FDO_E_DIRECTIONAL_EVALUATOR_WITH_TURN_SOURCE = -2147212638
FDO_E_NETWORK_SOURCE_MISSING_FEATURE_CLASS = -2147212637
FDO_E_NETWORK_SOURCE_NOT_SIMPLE_FEATURE_CLASS = -2147212636
FDO_E_NETWORK_SOURCE_IN_MULTIPLE_NETWORKS = -2147212635
FDO_E_NETWORK_EVALUATOR_CREATE_FAILED = -2147212634
FDO_E_FIELD_EVALUATOR_AS_DEFAULT_EVALUATOR = -2147212633
FDO_E_NODIRECTIONAL_EVALUATOR_WITH_EDGE_SOURCE = -2147212632
FDO_E_MISSING_NETWORK_SOURCE_FOR_EVALUATOR = -2147212631
FDO_E_TURN_ILLEGAL_START_END_POS = -2147212630
FDO_E_CANNOT_DELETE_SYSTEM_JUNCTION_SOURCE = -2147212629
FDO_E_TURN_INVALID_EDGE_DESCRIPTOR = -2147212628
FDO_E_TURN_CANNOT_CHANGE_SUPPORT = -2147212627
FDO_E_ID_OVERFLOW = -2147212626
FDO_E_TURN_INVALID_MAX_EDGES = -2147212625
FDO_E_TURN_INVALID_CUR_MAX_EDGES = -2147212624
FDO_E_NO_SCRIPT_CONTROL = -2147212623
FDO_E_TURN_MISSING_EDGE = -2147212622
FDO_E_MISSING_SYSTEM_JUNCTION_CLASS_ELEV_FIELD = -2147212621
FDO_E_BAD_TYPE_SYSTEM_JUNCTION_CLASS_ELEV_FIELD = -2147212620
FDO_E_INVALID_SCHEMA_UPDATE = -2147212619
FDO_E_USE_BY_DEFAULT_NOT_SUPPORTED = -2147212618
FDO_E_SIGNPOSTS_NOT_SUPPORTED = -2147212617
FDO_E_NETWORK_ATTRIBUTE_ALREADY_EXISTS = -2147212616
FDO_E_INVALID_DIRECTIONS_LENGTH_UNIT = -2147212615
FDO_E_OVERLAPPING_NETWORK_GLOBAL_TURN_DELAY_CATEGORIES = -2147212614
FDO_E_NETWORK_ATTRIBUTE_NOT_COST_USAGE = -2147212613
FDO_E_NETWORK_ATTRIBUTE_NOT_TIME_UNITS = -2147212612
FDO_E_NETWORK_ATTRIBUTE_REFERENCES_SELF = -2147212611
FDO_E_NETWORK_FUNCTION_EVALUATOR_OPERATOR_NOT_SUPPORTED = -2147212610
FDO_E_NETWORK_FUNCTION_EVALUATOR_ARGUMENT1_INVALID = -2147212609
FDO_E_NETWORK_FUNCTION_EVALUATOR_ARGUMENT2_INVALID = -2147212608
FDO_E_NETWORK_FUNCTION_EVALUATOR_PARAMETER_MISSING = -2147212607
FDO_E_NETWORK_FUNCTION_EVALUATOR_PARAMETER_NOT_NUMERIC = -2147212606
FDO_E_NETWORK_FUNCTION_EVALUATOR_OVERFLOW = -2147212605
FDO_E_NETWORK_FUNCTION_EVALUATOR_MISSING_REFERENCED_NETWORK_ATTRIBUTE = -2147212604
FDO_E_NETWORK_FUNCTION_EVALUATOR_REFERENCED_NETWORK_ATTRIBUTE_NOT_NUMERIC = -2147212603
FDO_E_EVALUATOR_NOT_SUPPORTED = -2147212602
FDO_E_FORWARDSTAR_ADD_CACHED_ATTRIBUTE_DEPRECATED = -2147212601
FDO_E_FORWARDSTAR_REMOVE_CACHED_ATTRIBUTES_DEPRECATED = -2147212600
FDO_E_INVALID_NETWORK_ATTRIBUTE_USAGE_TYPE = -2147212599
FDO_E_INVALID_NETWORK_EDGE_ATTRIBUTE_ADJUSTMENT = -2147212598
FDO_E_INVALID_NETWORK_ATTRIBUTE_ADJUSTMENT_VALUE = -2147212597
FDO_E_INVALID_POSITION_RANGE = -2147212596
FDO_E_NETWORK_ELEVATION_MODEL_CANNOT_CHANGE = -2147212595
FDO_E_ZCOORDINATES_NOT_SUPPORTED_IN_RELEASE = -2147212594
FDO_E_NETWORK_SOURCE_INVALID_ELAVATION_MODEL = -2147212593
FDO_E_NETWORK_COVERING_HYPEREDGE_DOES_NOT_EXIST = -2147212592
FDO_E_INVALID_EVALUATOR_FOR_SHAPEFILE_NETWORK_DATASET = -2147212591
FDO_E_INVALID_USAGE_OR_UNIT_TYPE_FOR_EVALUATOR = -2147212590
FDO_E_INVALID_TRAFFIC_DATA = -2147212589
FDO_E_INVALID_TIME_SLICE_FIELD_NAME = -2147212588
FDO_E_HISTORICAL_TRAFFIC_DATA_CANNOT_CHANGE = -2147212587
FDO_E_TRAFFIC_DATA_NOT_SUPPORTED = -2147212586
FDO_E_TRAFFIC_DATA_ATTRIBUTE_MISSING = -2147212585
FDO_E_NETWORK_DATASET_NO_TIME_ZONE = -2147212584
FDO_E_SIGNPOST_TABLE_NOT_REGISTERED = -2147212583
FDO_E_BUILD_INSIDE_EDIT_SESSION = -2147212582
FDO_E_BUILDNETWORK_ALREADYBUILD = -2147212581
FDO_E_FSTAR_INVALID_FROM_EDGE_FORWARD = -2147212580
FDO_E_FSTAR_INVALID_FROM_EDGE_BACKWARD = -2147212579
FDO_E_NO_ATTRIBUTE_RECORD = -2147212578
FDO_E_NETWORK_DATASET_NEEDS_UPGRADE = -2147212577
FDO_E_NETWORK_DATASET_ALREADY_UPGRADED = -2147212576
FDO_E_INVALID_TIME_VALUE = -2147212575
FDO_E_INVALID_NETWORK_TIME_USAGE_TYPE = -2147212574
FDO_E_INVALID_TIME_ZONE_OBJECTID = -2147212573
FDO_E_INVALID_TIME_ZONE_NAME = -2147212572
FDO_E_TRAFFIC_DATA_LENGTH_ATTRIBUTE_MISSING = -2147212571
FDO_E_INVALID_TIME_SLICE_ARRAY = -2147212570
FDO_E_NETWORK_SCHEMA_CHANGES_NOT_SUPPORTED = -2147212569
FDO_E_INVALID_NETWORK_LANDMARK_SOURCE = -2147212568
FDO_E_INVALID_NETWORK_LANDMARK_SOURCE_GEOMETRY_TYPE = -2147212567
FDO_E_INVALID_NETWORK_LANDMARK_SOURCE_FIELD = -2147212566
FDO_E_TIME_ZONE_ATTRIBUTE_IS_REQUIRED = -2147212565
FDO_E_CADASTRAL_FABRIC_INVALID_NAME = -2147212287
FDO_E_CADASTRAL_FABRICS_NOT_SUPPORTED_IN_RELEASE = -2147212286
FDO_E_CADASTRAL_FABRIC_ALREADY_EXISTS = -2147212285
FDO_E_CADASTRAL_FABRIC_JOB_ALREADY_EXISTS = -2147212284
FDO_E_CADASTRAL_FABRIC_JOB_INVALID_STATUS = -2147212283
FDO_E_CADASTRAL_FABRIC_SCHEMA_CORRUPTION = -2147212282
FDO_E_CADASTRAL_FABRIC_JOB_LOCK_ALREADY_EXISTS = -2147212281
FDO_E_CADASTRAL_FABRIC_MISSING_SYSTEM_TABLE = -2147212280
FDO_E_CADASTRAL_FABRIC_DATA_CORRUPTION = -2147212279
FDO_E_CADASTRAL_FABRIC_JOB_ALREADY_COMMITTED = -2147212278
FDO_E_CADASTRAL_FABRIC_JOB_NOT_FOUND = -2147212277
FDO_E_CADASTRAL_FABRIC_PACKET_LOAD_FAILED = -2147212276
FDO_E_CADASTRAL_FABRIC_PACKET_MISSING_DATA = -2147212275
FDO_E_JOB_DOES_NOT_BELONG_TO_FABRIC = -2147212274
FDO_E_CADASTRAL_FABRIC_PACKET_POST_REQUIRES_EDIT_SESSION = -2147212273
FDO_E_JOB_UNJOINED_PARCEL_PRESENT = -2147212272
FDO_E_CADASTRAL_FABRIC_XML_PARSER_NOT_FOUND = -2147212271
FDO_E_CADASTRAL_FABRIC_OBJECT_ALREADY_MODIFIED = -2147212270
FDO_E_CADASTRAL_FABRIC_JOB_CURRENTLY_EDITED = -2147212269
FDO_E_CADASTRAL_FABRIC_DATUM_MISMATCH = -2147212268
FDO_E_CADASTRAL_FABRIC_ILLEGAL_RECONCILE = -2147212267
FDO_E_CADASTRAL_FABRIC_COMMIT_NO_NAME = -2147212266
FDO_E_CADASTRAL_FABRIC_COMMIT_NOT_DEFAULT = -2147212265
FDO_E_CADASTRAL_FABRIC_COMMIT_JOB_LOCKED = -2147212264
FDO_E_CADASTRAL_FABRIC_JOB_NOT_COMMITTED = -2147212263
FDO_E_CADASTRAL_FABRIC_COPY_WITH_TOPOLOGY_NOT_SUPPORTED_IN_RELEASE = -2147212262
FDO_E_CADASTRAL_FABRIC_OPERATION_CANCELLED = -2147212261
FDO_E_CADASTRAL_FABRIC_ALREADY_UPGRADED = -2147212260
FDO_E_PERSONAL_SDE_ONE_EDITOR = -2147212031
FDO_E_CANNOT_CONNECT_TO_SERVER = -2147212030
FDO_E_ITEM_NOT_FOUND = -2147211775
FDO_E_ITEM_WITH_PATH_EXISTS = -2147211774
FDO_E_ITEM_DOES_NOT_HAVE_DEFINITION = -2147211773
FDO_E_INVALID_CATALOG_PATH = -2147211772
FDO_E_ITEM_RELATIONSHIP_EXISTS = -2147211771
FDO_E_CANNOT_CHANGE_ITEM_VISIBILITY = -2147211770
FDO_E_RELATIONSHIP_VISIBILITY_INVALID = -2147211769
FDO_E_CANNOT_CHANGE_ITEM_PROPERTY = -2147211768
FDO_E_RELATIONSHIP_ATTRIBUTES_INVALID = -2147211767
FDO_E_OTHER_ACTIVE_CONNECTIONS = -2147211766
FDO_E_USER_DOES_NOT_HAVE_UPGRADE_PRIVILIGES = -2147211765
FDO_E_INSTANCE_IS_NOT_UPGRADABLE = -2147211764
FDO_E_INSTANCE_DOES_NOT_SUPPORT_XML_TYPE = -2147211763
FDO_E_ITEM_RELATIONSHIP_NOT_FOUND = -2147211762
FDO_E_ITEM_RELATIONSHIP_ITEM_NOT_FOUND = -2147211761
FDO_E_DEFINITION_MISSING_CONTROLLER_MEMBERSHIP = -2147211760
FDO_E_UNKNOWN_CATALOG_TYPE = -2147211759
FDO_E_DOES_NOT_SUPPORT_UNMANAGED_RASTER_CATALOG = -2147211519
FDO_E_QUERYDESCRIPTION_NOSPATIALCOLUMN = -2147211263
FDO_E_QUERYDESCRIPTION_INVALIDCOLUMN = -2147211262
FDO_E_QUERYDESCRIPTION_OIDNOTMAPPEDCOLUMN = -2147211261
FDO_E_QUERYDESCRIPTION_COLUMNEXISTS = -2147211260
FDO_E_QUERYDESCRIPTION_INVALIDFIELDTYPE = -2147211259
FDO_E_QUERYTABLE_OIDMAPPEDCOLUMNHASNULL = -2147211258
FDO_E_QUERYDESCRIPTION_OUTOFSYNC = -2147211257
FDO_E_QUERYDESCRIPTION_OIDFIELDSMISSING = -2147211256
FDO_E_QUERYDESCRIPTION_INVALIDGEOMETRYTYPE = -2147211255
FDO_E_QUERYCLASS_INVALIDWHERE = -2147211254
FDO_E_QUERYCLASS_OIDUNKNOWN = -2147211253
FDO_E_QUERYTABLE_QUERYMISSING = -2147211252
FDO_E_QUERYTABLE_WORKSPACEMISSING = -2147211251
FDO_E_QUERYTABLE_OIDCOLUMNHASNULL = -2147211250
FDO_E_QUERYCLASS_NULLGEOMETRYTYPE = -2147211249
FDO_E_QUERYCLASS_INVALIDSRID = -2147211248
FDO_E_QUERYCLASS_INVALIDSPATIALREFERENCE = -2147211247
FDO_E_QUERYCLASS_INVALIDNAME = -2147211246
FDO_E_RELCLASS_COULD_NOT_GET_ORIG_PRIM_KEY = -2147211183
FDO_E_RELCLASS_COULD_NOT_GET_ORIG_FOR_KEY = -2147211182
FDO_E_RELCLASS_COULD_NOT_GET_DEST_PRIM_KEY = -2147211181
FDO_E_RELCLASS_COULD_NOT_GET_DEST_FOR_KEY = -2147211180
FDO_E_RELCLASS_INCOMPATIBLE_WITH_EXISTING_RELCLASS = -2147211179
FDO_E_RELCLASS_CANNOT_RESET_FKEYS = -2147211178
FDO_E_RELCLASS_INVALID_FKEY = -2147211177
FDO_E_RELCLASS_INVALID_CURSOR = -2147211176
FDO_E_RELATIONSHIPCLASS_NOT_FOUND = -2147211175
FDO_E_RELATIONSHIPCLASS_INVALID_NAME = -2147211174
FDO_E_RELATIONSHIPCLASS_ALREADY_EXISTS = -2147211173
FDO_E_RELATIONSHIPCLASS_INVALID_SPEC = -2147211172
FDO_E_RELATIONSHIPCLASS_ORIGIN_DEST_NOT_FOUND = -2147211171
FDO_E_MISSING_ORIGIN_OR_DESTINATION_OBJECT = -2147211170
FDO_E_INVALID_CONNECTIVITY_RULE = -2147211007
FDO_E_VALIDATION_NOT_SUPPORTED = -2147211006
FDO_E_INVALID_CARDINALITY = -2147211005
FDO_E_DEFAULT_JUNCTIONS_NOT_SUPPORTED_IN_RELEASE = -2147211004
FDO_E_ALTERING_RULE_NOT_SUPPORTED = -2147211003
FDO_E_CONNECTIVITY_RULES_NOT_SUPPORTED = -2147211002
FDO_E_CANNOT_ALTER_NON_EXISTANT_RULE = -2147211001
FDO_E_RULE_NOT_FOUND = -2147211000
FDO_E_ZERO_LENGTH_POLYLINE = -2147210927
FDO_E_CLOSED_POLYLINE = -2147210926
FDO_E_NO_NETWORK_ANCILLARY_ROLE = -2147210925
FDO_E_FLIPPED_POLYLINE = -2147210924
FDO_E_CANNOT_SPLIT_JUNCTION = -2147210923
FDO_E_INVALID_NETWORK_ANCILLARY_ROLE = -2147210922
FDO_E_CANNOT_ADD_ORPHAN_JUNCTION_ON_EXISTING_JUNCTION = -2147210921
FDO_E_INVALID_JUNCTION_INDEX = -2147210920
FDO_E_CANNOT_SET_ENABLED_FIELD = -2147210919
FDO_E_CANNOT_SET_WEIGHT_FIELD = -2147210918
FDO_E_INVALID_GEOMETRY_FOR_COMPLEX_JUNCTION = -2147210917
FDO_E_INVALID_GEOMETRY_TYPE_FOR_NETWORK_FEATURE_CLASS = -2147210916
FDO_E_NO_ASSOCIATED_NETWORK_ELEMENT = -2147210915
FDO_E_IDENTICAL_FROM_TO_JUNCTIONS = -2147210914
FDO_E_EDGE_MISSING_ENDPOINT_JUNCTION = -2147210913
FDO_E_CONNECTED_EDGE_INVALID_CONNECTIVITY = -2147210912
FDO_E_INVALID_CONNECTIVITY_CANNOT_BE_CORRECTED = -2147210911
FDO_E_INVALID_NETWORK_FEATURE_CLASS = -2147210910
FDO_E_DOMAIN_NOT_FOUND = -2147209215
FDO_E_DOMAIN_USED_BY_ATTRIBUTE_RULE = -2147209214
FDO_E_DOMAIN_USED_AS_DEFAULT_DOMAIN = -2147209213
FDO_E_DOMAIN_NAME_ALREADY_EXISTS = -2147209212
FDO_E_DOMAIN_VALUE_EXCEEDS_FIELD_LENGTH = -2147209211
FDO_E_DOMAIN_OWNER_DOESNT_MATCH = -2147209210
FDO_E_DOMAIN_FIELD_TYPE_DOESNT_MATCH = -2147209209
FDO_E_DOMAIN_TYPE_NOT_SUPPORTED = -2147209208
FDO_E_CODED_VALUE_DOMAIN_VALUE_ALREADY_EXISTS = -2147209207
FDO_E_CANNOT_LOCK_COCREATED_DOMAIN = -2147209206
FDO_E_DOMAIN_USED_BY_OTHER_WORKSPACE = -2147209205
FDO_E_DOMAIN_FIELD_TYPE_MISMATCH = -2147209204
FDO_E_CANNOT_LOCK_DOMAIN_AS_NOT_OWNER = -2147209203
FDO_E_DEFAULT_DOMAIN_NOT_FOUND = -2147209202
FDO_E_DOMAIN_RECORD_NOT_FOUND = -2147209201
FDO_E_DOMAIN_TYPE_DOESNT_MATCH = -2147209200
FDO_E_CODED_VALUE_DOMAIN_NAME_EMPTY = -2147209199
FDO_E_CODED_VALUE_DOMAIN_VALUE_NOT_COMPATIBLE = -2147209198
FDO_E_CODED_VALUE_DOMAIN_VALUE_INCONSISTENT = -2147209197
FDO_E_CODED_VALUE_DOMAIN_FIELD_TYPE_NOT_COMPATIBLE = -2147209196
FDO_E_CANNOT_DELETE_DOMAIN = -2147209195
FDO_E_DOMAIN_INVALID_NAME = -2147209194
FDO_E_DOMAIN_DOES_NOT_MATCH_WORKSPACE = -2147209193
FDO_E_DOMAIN_INCOMPATIBLE_WITH_DEFAULT_VALUE = -2147209192
FDO_E_TRAFFIC_DOWNLOAD_TIMEOUT = -2147209191
FDO_E_REFRESH_DYNAMIC_TRAFFIC_ERROR = -2147209190
FDO_E_INVALID_NAME_OBJECT = -2147209135
fdoError = c_int # enum
class ISchemaLockInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that supply schema lock information.'
    _iid_ = GUID('{A67958D8-226E-11D3-80B2-00C04F686238}')
    _idlflags_ = ['oleautomation']
IEnumSchemaLockInfo._methods_ = [
    COMMETHOD([helpstring(u'The next schema lock info object.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(ISchemaLockInfo)), 'info' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumSchemaLockInfo implementation
##class IEnumSchemaLockInfo_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'The next schema lock info object.'
##        #return info
##

IGPChoiceList._methods_ = [
    COMMETHOD([helpstring(u'Creates a coded value domain from an array of geoprocessing value objects.')], HRESULT, 'MakeChoiceList',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'Value' ),
              ( ['in'], POINTER(IGPDomain), 'Domain' ),
              ( ['retval', 'out'], POINTER(POINTER(IGPCodedValueDomain)), 'codeValueDomain' )),
]
################################################################
## code template for IGPChoiceList implementation
##class IGPChoiceList_Impl(object):
##    def MakeChoiceList(self, Value, Domain):
##        u'Creates a coded value domain from an array of geoprocessing value objects.'
##        #return codeValueDomain
##

IDEGdbTable2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the associate versioned view, if any.')], HRESULT, 'VersionedViewName',
              ( ['retval', 'out'], POINTER(BSTR), 'VersionedViewName' )),
    COMMETHOD(['propput', helpstring(u'The name of the associate versioned view, if any.')], HRESULT, 'VersionedViewName',
              ( ['in'], BSTR, 'VersionedViewName' )),
]
################################################################
## code template for IDEGdbTable2 implementation
##class IDEGdbTable2_Impl(object):
##    def _get(self):
##        u'The name of the associate versioned view, if any.'
##        #return VersionedViewName
##    def _set(self, VersionedViewName):
##        u'The name of the associate versioned view, if any.'
##    VersionedViewName = property(_get, _set, doc = _set.__doc__)
##

IRelationship._methods_ = [
    COMMETHOD(['propget', helpstring(u'The relationship class to which this relationship belongs.')], HRESULT, 'RelationshipClass',
              ( ['retval', 'out'], POINTER(POINTER(IRelationshipClass)), 'RelationshipClass' )),
    COMMETHOD(['propget', helpstring(u'The origin object.')], HRESULT, 'OriginObject',
              ( ['retval', 'out'], POINTER(POINTER(IObject)), 'OriginObject' )),
    COMMETHOD(['propget', helpstring(u'The destination object.')], HRESULT, 'DestinationObject',
              ( ['retval', 'out'], POINTER(POINTER(IObject)), 'DestinationObject' )),
]
################################################################
## code template for IRelationship implementation
##class IRelationship_Impl(object):
##    @property
##    def RelationshipClass(self):
##        u'The relationship class to which this relationship belongs.'
##        #return RelationshipClass
##
##    @property
##    def DestinationObject(self):
##        u'The destination object.'
##        #return DestinationObject
##
##    @property
##    def OriginObject(self):
##        u'The origin object.'
##        #return OriginObject
##

ISchemaLockInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'The schema lock type.')], HRESULT, 'SchemaLockType',
              ( ['retval', 'out'], POINTER(esriSchemaLock), 'SchemaLockType' )),
    COMMETHOD(['propget', helpstring(u'The user name who has the schema lock.')], HRESULT, 'UserName',
              ( ['retval', 'out'], POINTER(BSTR), 'UserName' )),
    COMMETHOD(['propget', helpstring(u'The name of the table with the schema lock.')], HRESULT, 'TableName',
              ( ['retval', 'out'], POINTER(BSTR), 'TableName' )),
]
################################################################
## code template for ISchemaLockInfo implementation
##class ISchemaLockInfo_Impl(object):
##    @property
##    def UserName(self):
##        u'The user name who has the schema lock.'
##        #return UserName
##
##    @property
##    def SchemaLockType(self):
##        u'The schema lock type.'
##        #return SchemaLockType
##
##    @property
##    def TableName(self):
##        u'The name of the table with the schema lock.'
##        #return TableName
##

class IGPToolTip(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that return Geoprocesssing value tool tip.'
    _iid_ = GUID('{4D95BFA9-AA3F-416A-A4A9-6B6B2CF66F2B}')
    _idlflags_ = ['oleautomation']
IGPToolTip._methods_ = [
    COMMETHOD([helpstring(u'Creates a tool tip string for the value.')], HRESULT, 'GetToolTip',
              ( ['retval', 'out'], POINTER(BSTR), 'toolTip' )),
]
################################################################
## code template for IGPToolTip implementation
##class IGPToolTip_Impl(object):
##    def GetToolTip(self):
##        u'Creates a tool tip string for the value.'
##        #return toolTip
##

INetworkWorkspace2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The count of valid format numbers.')], HRESULT, 'FormatNumberCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The specified format number.')], HRESULT, 'FormatNumber',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(c_int), 'formatNum' )),
    COMMETHOD([helpstring(u'Returns the maximum storable feature class ID for the given format number.')], HRESULT, 'GetMaxStorableClassID',
              ( ['in'], c_int, 'formatNum' ),
              ( ['retval', 'out'], POINTER(c_int), 'maxClassID' )),
    COMMETHOD([helpstring(u'Creates a logical network based on the specified configuration keyword.')], HRESULT, 'CreateNetworkEx',
              ( ['in'], BSTR, 'NetworkName' ),
              ( ['in'], esriNetworkType, 'NetworkType' ),
              ( ['in'], VARIANT_BOOL, 'buildNormalizedTables' ),
              ( ['in'], BSTR, 'ConfigKeyword' ),
              ( ['in'], c_int, 'formatNum' ),
              ( ['retval', 'out'], POINTER(POINTER(INetwork)), 'Network' )),
]
################################################################
## code template for INetworkWorkspace2 implementation
##class INetworkWorkspace2_Impl(object):
##    @property
##    def FormatNumberCount(self):
##        u'The count of valid format numbers.'
##        #return Count
##
##    def CreateNetworkEx(self, NetworkName, NetworkType, buildNormalizedTables, ConfigKeyword, formatNum):
##        u'Creates a logical network based on the specified configuration keyword.'
##        #return Network
##
##    @property
##    def FormatNumber(self, Index):
##        u'The specified format number.'
##        #return formatNum
##
##    def GetMaxStorableClassID(self, formatNum):
##        u'Returns the maximum storable feature class ID for the given format number.'
##        #return maxClassID
##

class IWorkspaceProperties2(IWorkspaceProperties):
    _case_insensitive_ = True
    u'Provides access to members that control the workspace properties.'
    _iid_ = GUID('{6F249DED-59D3-423F-A850-5BC75066AE27}')
    _idlflags_ = ['oleautomation']
IWorkspaceProperties2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Information about this particular property.')], HRESULT, 'CategoryPrefix',
              ( ['retval', 'out'], POINTER(BSTR), 'prefix' )),
]
################################################################
## code template for IWorkspaceProperties2 implementation
##class IWorkspaceProperties2_Impl(object):
##    @property
##    def CategoryPrefix(self):
##        u'Information about this particular property.'
##        #return prefix
##

IRasterDatasetName._methods_ = [
    COMMETHOD(['propget', helpstring(u'The band names in the RasterDataset.')], HRESULT, 'RasterBandNames',
              ( ['retval', 'out'], POINTER(POINTER(IEnumDatasetName)), 'RasterBandNames' )),
]
################################################################
## code template for IRasterDatasetName implementation
##class IRasterDatasetName_Impl(object):
##    @property
##    def RasterBandNames(self):
##        u'The band names in the RasterDataset.'
##        #return RasterBandNames
##

IStreetNetwork._methods_ = [
]
################################################################
## code template for IStreetNetwork implementation
##class IStreetNetwork_Impl(object):


# values for enumeration 'esriRasterSdeCompressionTypeEnum'
esriRasterSdeCompressionTypeUncompressed = 0
esriRasterSdeCompressionTypeRunLength = 1
esriRasterSdeCompressionTypeJPEG = 2
esriRasterSdeCompressionTypeJPEG2000 = 3
esriRasterSdeCompressionTypeEnum = c_int # enum
INetSchema._methods_ = [
    COMMETHOD(['propget', helpstring(u'Number of element classes in the network.')], HRESULT, 'ElementClassCount',
              ( ['retval', 'out'], POINTER(c_int), 'ElementClassCount' )),
    COMMETHOD(['propget', helpstring(u'Element class by index.')], HRESULT, 'ElementClass',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(INetElementClass)), 'NetElementClass' )),
    COMMETHOD(['propget', helpstring(u'Element class corresponding to the specified user class ID.')], HRESULT, 'ElementClassByUserID',
              ( ['in'], c_int, 'elementclassUserID' ),
              ( ['retval', 'out'], POINTER(POINTER(INetElementClass)), 'NetElementClass' )),
    COMMETHOD(['propget', helpstring(u'Number of weights in the network.')], HRESULT, 'WeightCount',
              ( ['retval', 'out'], POINTER(c_int), 'WeightCount' )),
    COMMETHOD(['propget', helpstring(u'Network weight corresponding to the specified weight internal ID.')], HRESULT, 'Weight',
              ( ['in'], c_int, 'weightInternalID' ),
              ( ['retval', 'out'], POINTER(POINTER(INetWeight)), 'networkWeight' )),
    COMMETHOD(['propget', helpstring(u'Network weight corresponding to the specified name.')], HRESULT, 'WeightByName',
              ( ['in'], BSTR, 'WeightName' ),
              ( ['retval', 'out'], POINTER(POINTER(INetWeight)), 'networkWeight' )),
    COMMETHOD(['propget', helpstring(u'Network weight associations corresponding to the specified weight internal ID.')], HRESULT, 'WeightAssociations',
              ( ['in'], c_int, 'weightInternalID' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumNetWeightAssociation)), 'netWeightAssociations' )),
    COMMETHOD(['propget', helpstring(u'Network weight associations corresponding to the specified table name.')], HRESULT, 'WeightAssociationsByTableName',
              ( ['in'], BSTR, 'TableName' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumNetWeightAssociation)), 'netWeightAssociations' )),
    COMMETHOD([helpstring(u'Returns the ancillary role type and the name of the field containing the ancillary role information.')], HRESULT, 'GetAncillaryRole',
              ( ['in'], c_int, 'UserClassID' ),
              ( ['out'], POINTER(esriNetworkClassAncillaryRole), 'ancillaryRole' ),
              ( ['out'], POINTER(BSTR), 'AncillaryRoleFieldName' )),
    COMMETHOD([helpstring(u'Returns the name of the filed containing the enabled/disabled information for the specified user class.')], HRESULT, 'GetEnabledDisabledFieldName',
              ( ['in'], c_int, 'UserClassID' ),
              ( ['retval', 'out'], POINTER(BSTR), 'enabledDisabledFieldName' )),
]
################################################################
## code template for INetSchema implementation
##class INetSchema_Impl(object):
##    @property
##    def Weight(self, weightInternalID):
##        u'Network weight corresponding to the specified weight internal ID.'
##        #return networkWeight
##
##    @property
##    def WeightByName(self, WeightName):
##        u'Network weight corresponding to the specified name.'
##        #return networkWeight
##
##    @property
##    def ElementClassByUserID(self, elementclassUserID):
##        u'Element class corresponding to the specified user class ID.'
##        #return NetElementClass
##
##    @property
##    def ElementClass(self, Index):
##        u'Element class by index.'
##        #return NetElementClass
##
##    @property
##    def WeightCount(self):
##        u'Number of weights in the network.'
##        #return WeightCount
##
##    @property
##    def ElementClassCount(self):
##        u'Number of element classes in the network.'
##        #return ElementClassCount
##
##    def GetAncillaryRole(self, UserClassID):
##        u'Returns the ancillary role type and the name of the field containing the ancillary role information.'
##        #return ancillaryRole, AncillaryRoleFieldName
##
##    @property
##    def WeightAssociationsByTableName(self, TableName):
##        u'Network weight associations corresponding to the specified table name.'
##        #return netWeightAssociations
##
##    @property
##    def WeightAssociations(self, weightInternalID):
##        u'Network weight associations corresponding to the specified weight internal ID.'
##        #return netWeightAssociations
##
##    def GetEnabledDisabledFieldName(self, UserClassID):
##        u'Returns the name of the filed containing the enabled/disabled information for the specified user class.'
##        #return enabledDisabledFieldName
##

class MemoryRelationshipClassFactory(CoClass):
    u'Object used to create memory relationship class objects.'
    _reg_clsid_ = GUID('{2FC5C57B-EB92-4A61-BBC5-434E388BF3B9}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
MemoryRelationshipClassFactory._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IMemoryRelationshipClassFactory]

INetworkUpdate._methods_ = [
    COMMETHOD([helpstring(u'Starts a session for updating the schema of the network.')], HRESULT, 'StartSchemaUpdating'),
    COMMETHOD([helpstring(u'Ends the session for updating the schema for the network.')], HRESULT, 'StopSchemaUpdating'),
    COMMETHOD(['propget', helpstring(u'Indicates if the schema of the network is currently being updated.')], HRESULT, 'IsSchemaBeingUpdated',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'bIsSchemaBeingUpdated' )),
    COMMETHOD([helpstring(u'Starts a session for updating the topology of the network.')], HRESULT, 'StartTopologyUpdating'),
    COMMETHOD([helpstring(u'Ends the session for updating the topology of the network.')], HRESULT, 'StopTopologyUpdating'),
    COMMETHOD(['propget', helpstring(u'Indicates if the topology of the network is currently being updated.')], HRESULT, 'IsTopologyBeingUpdated',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'bIsTopologyBeingUpdated' )),
    COMMETHOD([helpstring(u'Starts a session for updating the attributes of the network.')], HRESULT, 'StartAttributesUpdating'),
    COMMETHOD([helpstring(u'Ends the session for updating the attributes of the network.')], HRESULT, 'StopAttributesUpdating'),
    COMMETHOD(['propget', helpstring(u'Indicates if the attributes of the network are currently being updated.')], HRESULT, 'IsAttributesBeingUpdated',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'bIsAttributesBeingUpdated' )),
]
################################################################
## code template for INetworkUpdate implementation
##class INetworkUpdate_Impl(object):
##    def StopTopologyUpdating(self):
##        u'Ends the session for updating the topology of the network.'
##        #return 
##
##    def StartAttributesUpdating(self):
##        u'Starts a session for updating the attributes of the network.'
##        #return 
##
##    @property
##    def IsTopologyBeingUpdated(self):
##        u'Indicates if the topology of the network is currently being updated.'
##        #return bIsTopologyBeingUpdated
##
##    @property
##    def IsSchemaBeingUpdated(self):
##        u'Indicates if the schema of the network is currently being updated.'
##        #return bIsSchemaBeingUpdated
##
##    def StartSchemaUpdating(self):
##        u'Starts a session for updating the schema of the network.'
##        #return 
##
##    @property
##    def IsAttributesBeingUpdated(self):
##        u'Indicates if the attributes of the network are currently being updated.'
##        #return bIsAttributesBeingUpdated
##
##    def StopAttributesUpdating(self):
##        u'Ends the session for updating the attributes of the network.'
##        #return 
##
##    def StopSchemaUpdating(self):
##        u'Ends the session for updating the schema for the network.'
##        #return 
##
##    def StartTopologyUpdating(self):
##        u'Starts a session for updating the topology of the network.'
##        #return 
##

class IRasterBandName(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that maintain name information about a raster dataset.'
    _iid_ = GUID('{BC25E121-168B-11D2-8D25-0000F8780535}')
    _idlflags_ = ['oleautomation']
IRasterBandName._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the RasterDataset.')], HRESULT, 'RasterDatasetName',
              ( ['retval', 'out'], POINTER(POINTER(IDatasetName)), 'RasterDatasetName' )),
    COMMETHOD(['propputref', helpstring(u'The name of the RasterDataset.')], HRESULT, 'RasterDatasetName',
              ( ['in'], POINTER(IDatasetName), 'RasterDatasetName' )),
    COMMETHOD(['propput', helpstring(u'The name of the RasterDataset as a string.')], HRESULT, 'NameString',
              ( ['in'], BSTR, 'RasterDatasetName' )),
    COMMETHOD(['propget', helpstring(u'The name of the RasterDataset as a string.')], HRESULT, 'NameString',
              ( ['retval', 'out'], POINTER(BSTR), 'RasterDatasetName' )),
]
################################################################
## code template for IRasterBandName implementation
##class IRasterBandName_Impl(object):
##    def _get(self):
##        u'The name of the RasterDataset as a string.'
##        #return RasterDatasetName
##    def _set(self, RasterDatasetName):
##        u'The name of the RasterDataset as a string.'
##    NameString = property(_get, _set, doc = _set.__doc__)
##
##    def RasterDatasetName(self, RasterDatasetName):
##        u'The name of the RasterDataset.'
##        #return 
##

INetAttributesEdit._methods_ = [
    COMMETHOD([helpstring(u'Sets the disabled state of the specified network element.')], HRESULT, 'SetDisabledState',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], esriElementType, 'ElementType' ),
              ( ['in'], VARIANT_BOOL, 'disableState' )),
    COMMETHOD([helpstring(u'Sets the weight value of the specified network element for the specified weight.')], HRESULT, 'SetWeightValue',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], esriElementType, 'ElementType' ),
              ( ['in'], c_int, 'weightInternalID' ),
              ( ['in'], VARIANT, 'weightValue' )),
]
################################################################
## code template for INetAttributesEdit implementation
##class INetAttributesEdit_Impl(object):
##    def SetWeightValue(self, EID, ElementType, weightInternalID, weightValue):
##        u'Sets the weight value of the specified network element for the specified weight.'
##        #return 
##
##    def SetDisabledState(self, EID, ElementType, disableState):
##        u'Sets the disabled state of the specified network element.'
##        #return 
##

IEnumRelationship._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next relationship in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IRelationship)), 'Relationship' )),
    COMMETHOD([helpstring(u'Resets enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumRelationship implementation
##class IEnumRelationship_Impl(object):
##    def Reset(self):
##        u'Resets enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next relationship in the enumeration sequence.'
##        #return Relationship
##

IDEFeatureClass._methods_ = [
    COMMETHOD(['propget', helpstring(u'The geometry type of the feature class.')], HRESULT, 'ShapeType',
              ( ['retval', 'out'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType), 'GeometryType' )),
    COMMETHOD(['propput', helpstring(u'The geometry type of the feature class.')], HRESULT, 'ShapeType',
              ( ['in'], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType, 'GeometryType' )),
    COMMETHOD(['propget', helpstring(u'The feature type of the feature class.')], HRESULT, 'FeatureType',
              ( ['retval', 'out'], POINTER(esriFeatureType), 'FeatureType' )),
    COMMETHOD(['propput', helpstring(u'The feature type of the feature class.')], HRESULT, 'FeatureType',
              ( ['in'], esriFeatureType, 'FeatureType' )),
    COMMETHOD(['propget', helpstring(u'The shape field name of the feature class.')], HRESULT, 'ShapeFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'ShapeFieldName' )),
    COMMETHOD(['propput', helpstring(u'The shape field name of the feature class.')], HRESULT, 'ShapeFieldName',
              ( ['in'], BSTR, 'ShapeFieldName' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the feature class has a spatial index.')], HRESULT, 'HasSpatialIndex',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasSpatialIndex' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the feature class has a spatial index.')], HRESULT, 'HasSpatialIndex',
              ( ['in'], VARIANT_BOOL, 'HasSpatialIndex' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the feature class supports Zs.')], HRESULT, 'HasZ',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasZ' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the feature class supports Zs.')], HRESULT, 'HasZ',
              ( ['in'], VARIANT_BOOL, 'HasZ' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the feature class supports Ms.')], HRESULT, 'HasM',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasM' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the feature class supports Ms.')], HRESULT, 'HasM',
              ( ['in'], VARIANT_BOOL, 'HasM' )),
]
################################################################
## code template for IDEFeatureClass implementation
##class IDEFeatureClass_Impl(object):
##    def _get(self):
##        u'The feature type of the feature class.'
##        #return FeatureType
##    def _set(self, FeatureType):
##        u'The feature type of the feature class.'
##    FeatureType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The shape field name of the feature class.'
##        #return ShapeFieldName
##    def _set(self, ShapeFieldName):
##        u'The shape field name of the feature class.'
##    ShapeFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The geometry type of the feature class.'
##        #return GeometryType
##    def _set(self, GeometryType):
##        u'The geometry type of the feature class.'
##    ShapeType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the feature class supports Ms.'
##        #return HasM
##    def _set(self, HasM):
##        u'Indicates if the feature class supports Ms.'
##    HasM = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the feature class has a spatial index.'
##        #return HasSpatialIndex
##    def _set(self, HasSpatialIndex):
##        u'Indicates if the feature class has a spatial index.'
##    HasSpatialIndex = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the feature class supports Zs.'
##        #return HasZ
##    def _set(self, HasZ):
##        u'Indicates if the feature class supports Zs.'
##    HasZ = property(_get, _set, doc = _set.__doc__)
##

IRasterColormap._methods_ = [
    COMMETHOD(['propget', helpstring(u'Array of red ratios as doubles between 0.0 and 1.0.')], HRESULT, 'RedValues',
              ( ['retval', 'out'], POINTER(VARIANT), 'val' )),
    COMMETHOD(['propput', helpstring(u'Array of red ratios as doubles between 0.0 and 1.0.')], HRESULT, 'RedValues',
              ( ['in'], VARIANT, 'val' )),
    COMMETHOD(['propget', helpstring(u'Array of green ratios as doubles between 0.0 and 1.0.')], HRESULT, 'GreenValues',
              ( ['retval', 'out'], POINTER(VARIANT), 'val' )),
    COMMETHOD(['propput', helpstring(u'Array of green ratios as doubles between 0.0 and 1.0.')], HRESULT, 'GreenValues',
              ( ['in'], VARIANT, 'val' )),
    COMMETHOD(['propget', helpstring(u'Array of blue ratios as doubles between 0.0 and 1.0.')], HRESULT, 'BlueValues',
              ( ['retval', 'out'], POINTER(VARIANT), 'val' )),
    COMMETHOD(['propput', helpstring(u'Array of blue ratios as doubles between 0.0 and 1.0.')], HRESULT, 'BlueValues',
              ( ['in'], VARIANT, 'val' )),
    COMMETHOD(['propget', helpstring(u'Array of colors as OLE_COLORs.')], HRESULT, 'Colors',
              ( ['retval', 'out'], POINTER(VARIANT), 'val' )),
    COMMETHOD(['propput', helpstring(u'Array of colors as OLE_COLORs.')], HRESULT, 'Colors',
              ( ['in'], VARIANT, 'val' )),
    COMMETHOD([helpstring(u'Translates pixel values into integers to index them into the colormap.')], HRESULT, 'Bin',
              ( ['in'], c_double, 'pixval' ),
              ( ['retval', 'out'], POINTER(c_int), 'Bin' )),
]
################################################################
## code template for IRasterColormap implementation
##class IRasterColormap_Impl(object):
##    def _get(self):
##        u'Array of green ratios as doubles between 0.0 and 1.0.'
##        #return val
##    def _set(self, val):
##        u'Array of green ratios as doubles between 0.0 and 1.0.'
##    GreenValues = property(_get, _set, doc = _set.__doc__)
##
##    def Bin(self, pixval):
##        u'Translates pixel values into integers to index them into the colormap.'
##        #return Bin
##
##    def _get(self):
##        u'Array of colors as OLE_COLORs.'
##        #return val
##    def _set(self, val):
##        u'Array of colors as OLE_COLORs.'
##    Colors = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Array of blue ratios as doubles between 0.0 and 1.0.'
##        #return val
##    def _set(self, val):
##        u'Array of blue ratios as doubles between 0.0 and 1.0.'
##    BlueValues = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Array of red ratios as doubles between 0.0 and 1.0.'
##        #return val
##    def _set(self, val):
##        u'Array of red ratios as doubles between 0.0 and 1.0.'
##    RedValues = property(_get, _set, doc = _set.__doc__)
##

IDEGdbFeatureClass._methods_ = [
    COMMETHOD(['propget', helpstring(u'The geometry area field.')], HRESULT, 'AreaFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propput', helpstring(u'The geometry area field.')], HRESULT, 'AreaFieldName',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'The geometry length field.')], HRESULT, 'LengthFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propput', helpstring(u'The geometry length field.')], HRESULT, 'LengthFieldName',
              ( ['in'], BSTR, 'FieldName' )),
]
################################################################
## code template for IDEGdbFeatureClass implementation
##class IDEGdbFeatureClass_Impl(object):
##    def _get(self):
##        u'The geometry area field.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The geometry area field.'
##    AreaFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The geometry length field.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The geometry length field.'
##    LengthFieldName = property(_get, _set, doc = _set.__doc__)
##

IUtilityNetworkGEN._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the flow direction is valid for this utility network.')], HRESULT, 'ValidFlowDirection',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pValidFlowDirection' )),
    COMMETHOD([helpstring(u'Returns the flow direction of the specified edge element.')], HRESULT, 'GetFlowDirection',
              ( ['in'], c_int, 'edgeEID' ),
              ( ['retval', 'out'], POINTER(esriFlowDirection), 'flowDirection' )),
    COMMETHOD([helpstring(u'Sets the flow direction for the specified edge element.')], HRESULT, 'SetFlowDirection',
              ( ['in'], c_int, 'edgeEID' ),
              ( ['in'], esriFlowDirection, 'flowDirection' )),
    COMMETHOD([helpstring(u'Sets the flow direction of all edge elements based on the placement of sources and sinks.')], HRESULT, 'EstablishFlowDirection',
              ( ['in'], POINTER(_midlSAFEARRAY(c_int)), 'sourceEIDs' ),
              ( ['in'], POINTER(_midlSAFEARRAY(c_int)), 'sinkEIDs' )),
    COMMETHOD([helpstring(u'Sets the flow direction of all reachable edge elements based on the placement of sources and sinks.')], HRESULT, 'PartialEstablishFlowDirection',
              ( ['in'], POINTER(_midlSAFEARRAY(c_int)), 'sourceEIDs' ),
              ( ['in'], POINTER(_midlSAFEARRAY(c_int)), 'sinkEIDs' )),
]
################################################################
## code template for IUtilityNetworkGEN implementation
##class IUtilityNetworkGEN_Impl(object):
##    def SetFlowDirection(self, edgeEID, flowDirection):
##        u'Sets the flow direction for the specified edge element.'
##        #return 
##
##    @property
##    def ValidFlowDirection(self):
##        u'Indicates if the flow direction is valid for this utility network.'
##        #return pValidFlowDirection
##
##    def EstablishFlowDirection(self, sourceEIDs, sinkEIDs):
##        u'Sets the flow direction of all edge elements based on the placement of sources and sinks.'
##        #return 
##
##    def PartialEstablishFlowDirection(self, sourceEIDs, sinkEIDs):
##        u'Sets the flow direction of all reachable edge elements based on the placement of sources and sinks.'
##        #return 
##
##    def GetFlowDirection(self, edgeEID):
##        u'Returns the flow direction of the specified edge element.'
##        #return flowDirection
##

IIndex._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the index.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the index is unique.')], HRESULT, 'IsUnique',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsUnique' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the index is based on ascending order.')], HRESULT, 'IsAscending',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsAscending' )),
    COMMETHOD(['propget', helpstring(u'The fields collection for this index.')], HRESULT, 'Fields',
              ( ['retval', 'out'], POINTER(POINTER(IFields)), 'Fields' )),
]
################################################################
## code template for IIndex implementation
##class IIndex_Impl(object):
##    @property
##    def IsAscending(self):
##        u'Indicates if the index is based on ascending order.'
##        #return IsAscending
##
##    @property
##    def Fields(self):
##        u'The fields collection for this index.'
##        #return Fields
##
##    @property
##    def Name(self):
##        u'The name of the index.'
##        #return Name
##
##    @property
##    def IsUnique(self):
##        u'Indicates if the index is unique.'
##        #return IsUnique
##

class SimpleJunctionFeature(CoClass):
    u'Esri Geometric network simple junction feature object.'
    _reg_clsid_ = GUID('{CEE8D6B8-55FE-11D1-AE55-0000F80372B4}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
SimpleJunctionFeature._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRow, IRowBuffer, IRowEvents, IRowSubtypes, IRowChanges, IRowCompare, IFeature, IFeatureBuffer, IFeatureEvents, IFeatureChanges, IFeatureDraw, INetworkFeature, INetworkFeatureEvents, ISimpleNetworkFeature, IJunctionFeature, ISimpleJunctionFeature, IRowEdit, IFeatureEdit, IFeatureEdit2, IFeatureSimplify, IFeatureSimplify2, IValidate, IRelatedObjectEvents, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, IFeatureProject]

class ICompressionInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that indicate the compression status of FileGDB datasets.'
    _iid_ = GUID('{94D5BD59-176B-44EC-B595-0F423F9DC827}')
    _idlflags_ = ['oleautomation']
ICompressionInfo._methods_ = [
    COMMETHOD(['propput', helpstring(u'Indicates if the dataset is compressed.')], HRESULT, 'IsCompressed',
              ( ['in'], VARIANT_BOOL, 'IsCompressed' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the dataset is compressed.')], HRESULT, 'IsCompressed',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsCompressed' )),
]
################################################################
## code template for ICompressionInfo implementation
##class ICompressionInfo_Impl(object):
##    def _get(self):
##        u'Indicates if the dataset is compressed.'
##        #return IsCompressed
##    def _set(self, IsCompressed):
##        u'Indicates if the dataset is compressed.'
##    IsCompressed = property(_get, _set, doc = _set.__doc__)
##

IEnumRule._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next Rule in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IRule)), 'Rule' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumRule implementation
##class IEnumRule_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next Rule in the enumeration sequence.'
##        #return Rule
##

INetSchemaEdit._methods_ = [
    COMMETHOD([helpstring(u'Adds a new element class to the network.')], HRESULT, 'AddElementClass',
              ( ['in'], c_int, 'UserClassID' ),
              ( ['retval', 'out'], POINTER(POINTER(INetElementClass)), 'ElementClass' )),
    COMMETHOD([helpstring(u'Adds a new weight to the network.')], HRESULT, 'AddWeight',
              ( ['in'], POINTER(INetWeight), 'networkWeight' )),
    COMMETHOD([helpstring(u'Adds a new weight association to the network.')], HRESULT, 'AddWeightAssociation',
              ( ['in'], POINTER(INetWeightAssociation), 'weightSource' )),
    COMMETHOD([helpstring(u'Sets the ancillary role type and the name of the field containing the ancillary role information for the specified user class.')], HRESULT, 'PutAncillaryRole',
              ( ['in'], c_int, 'UserClassID' ),
              ( ['in'], esriNetworkClassAncillaryRole, 'ancillaryRole' ),
              ( [], BSTR, 'AncillaryRoleFieldName' )),
    COMMETHOD([helpstring(u'Sets the name of the field containing the enabled/disabled information for the specified user class.')], HRESULT, 'PutEnabledDisabledFieldName',
              ( ['in'], c_int, 'UserClassID' ),
              ( ['in'], BSTR, 'enabledDisabledRoleFieldName' )),
]
################################################################
## code template for INetSchemaEdit implementation
##class INetSchemaEdit_Impl(object):
##    def PutAncillaryRole(self, UserClassID, ancillaryRole, AncillaryRoleFieldName):
##        u'Sets the ancillary role type and the name of the field containing the ancillary role information for the specified user class.'
##        #return 
##
##    def AddElementClass(self, UserClassID):
##        u'Adds a new element class to the network.'
##        #return ElementClass
##
##    def AddWeight(self, networkWeight):
##        u'Adds a new weight to the network.'
##        #return 
##
##    def AddWeightAssociation(self, weightSource):
##        u'Adds a new weight association to the network.'
##        #return 
##
##    def PutEnabledDisabledFieldName(self, UserClassID, enabledDisabledRoleFieldName):
##        u'Sets the name of the field containing the enabled/disabled information for the specified user class.'
##        #return 
##

IDERelationshipClassEx2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the relationship class represents a table attachment.')], HRESULT, 'IsAttachmentRelationship',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Attachment' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the relationship class represents a table attachment.')], HRESULT, 'IsAttachmentRelationship',
              ( ['in'], VARIANT_BOOL, 'Attachment' )),
]
################################################################
## code template for IDERelationshipClassEx2 implementation
##class IDERelationshipClassEx2_Impl(object):
##    def _get(self):
##        u'Indicates if the relationship class represents a table attachment.'
##        #return Attachment
##    def _set(self, Attachment):
##        u'Indicates if the relationship class represents a table attachment.'
##    IsAttachmentRelationship = property(_get, _set, doc = _set.__doc__)
##


# values for enumeration 'esriSQLPrivilege'
esriSelectPrivilege = 1
esriUpdatePrivilege = 2
esriInsertPrivilege = 4
esriDeletePrivilege = 8
esriSQLPrivilege = c_int # enum
class XMLIndexTemplate(CoClass):
    u'XML Index Template Object.'
    _reg_clsid_ = GUID('{E44E541B-B0AF-45BC-86E8-D7C53451E225}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
XMLIndexTemplate._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IXMLIndexTemplate]

class TinEdgeArray(CoClass):
    u'The Esri TinEdgeArray component.'
    _reg_clsid_ = GUID('{A72FE99F-C4C4-4EA9-A6B8-FD77BA0DE025}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinEdgeArray._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITinEdgeArray]

class TableNameSet(CoClass):
    u'A set of table names.'
    _reg_clsid_ = GUID('{54019669-0DC7-4A1B-9583-230185C8BA7E}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TableNameSet._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITableNameSet]

class TinTriangleArray(CoClass):
    u'The Esri TinTriangleArray component.'
    _reg_clsid_ = GUID('{2D594880-7FDB-490F-B139-88A82DD639E1}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinTriangleArray._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITinTriangleArray]

class EnumHistoricalMarker(CoClass):
    _reg_clsid_ = GUID('{CD1A42AE-D13C-489D-8DC4-008F9F14E312}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
EnumHistoricalMarker._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IEnumHistoricalMarker]

class ArchiveRegistrationInfo(CoClass):
    _reg_clsid_ = GUID('{1623B8E8-EB09-4A49-91E0-32A6ED2E0356}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
ArchiveRegistrationInfo._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IArchiveRegistrationInfo]

class TinEdge(CoClass):
    u'The Esri TinEdge component.'
    _reg_clsid_ = GUID('{9A2A4B77-11CF-11D2-A556-0000F8774F0F}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinEdge._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITinElement, ITinEdge, ITinFeatureSeed, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class TinTriangle(CoClass):
    u'The Esri TinTriangle component.'
    _reg_clsid_ = GUID('{9A2A4B78-11CF-11D2-A556-0000F8774F0F}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinTriangle._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITinElement, ITinTriangle, ITinFeatureSeed, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

INetWeightAssociationEdit._methods_ = [
    COMMETHOD(['propput', helpstring(u'Name of the table to be associated in this weight association.')], HRESULT, 'TableName',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Name of the field that contains the values for this associated weight.')], HRESULT, 'FieldName',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Weight internal ID of the weight to be associated in this weight assocation.')], HRESULT, 'WeightID',
              ( ['in'], c_int, 'rhs' )),
]
################################################################
## code template for INetWeightAssociationEdit implementation
##class INetWeightAssociationEdit_Impl(object):
##    def _set(self, rhs):
##        u'Name of the field that contains the values for this associated weight.'
##    FieldName = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Name of the table to be associated in this weight association.'
##    TableName = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Weight internal ID of the weight to be associated in this weight assocation.'
##    WeightID = property(fset = _set, doc = _set.__doc__)
##

class TinNode(CoClass):
    u'The Esri TinNode component.'
    _reg_clsid_ = GUID('{9A2A4B76-11CF-11D2-A556-0000F8774F0F}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinNode._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITinElement, ITinNode, ITinNode2, ITinFeatureSeed, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]


# values for enumeration 'esriNetworkErrors'
NETWORK_E_INVALID_FEATURE_WORKSPACE = -2147205119
NETWORK_E_INVALID_NETWORK_NAME = -2147205118
NETWORK_E_UNKNOWN_NETWORK_TYPE = -2147205117
NETWORK_E_CANNOT_OPEN_TABLE = -2147205116
NETWORK_E_CANNOT_CREATE_TABLE = -2147205115
NETWORK_E_INVALID_ELEMENT_CLASSES = -2147205114
NETWORK_E_INVALID_WEIGHT_DEFINITIONS = -2147205113
NETWORK_E_INVALID_WEIGHT_ASSOCIATION = -2147205112
NETWORK_E_INVALID_NETWORK_ACCESS = -2147205111
NETWORK_E_INVALID_FORMAT_NUMBER = -2147205110
NETWORK_E_OLD_WORKSPACE_VERSION = -2147205109
NETWORK_E_CANNOT_CLOSE_TABLE = -2147205108
NETWORK_E_CANNOT_DELETE_TABLE = -2147205107
NETWORK_E_UNKNOWN_ERROR = -2147205106
NETWORK_E_REACHED_MEMORY_QUOTA = -2147205105
NETWORK_E_INVALID_ENGINE_CONNECTION = -2147205104
NETWORK_E_INVALID_ENGINE = -2147205103
NETWORK_E_INVALID_ENGINE_FSTAR = -2147205102
NETWORK_E_UNKNOWN_ENGINE_ERROR = -2147205101
NETWORK_E_INVALID_NETWORK = -2147205100
NETWORK_E_NETWORK_ALREADY_EXISTS = -2147205099
NETWORK_E_INVALID_USER_CLASS_ID = -2147205098
NETWORK_E_INVALID_WEIGHT_NAME = -2147205097
NETWORK_E_READ_ONLY_NETWORK = -2147205096
NETWORK_E_EDIT_SESSION_IN_PROGRESS = -2147205095
NETWORK_E_UPDATE_SESSION_IN_PROGRESS = -2147205094
NETWORK_E_NO_EDIT_SESSION_IN_PROGRESS = -2147205093
NETWORK_E_NO_UPDATE_SESSION_IN_PROGRESS = -2147205092
NETWORK_E_PROPERTY_IS_ALREADY_SET = -2147205091
NETWORK_E_INVALID_ELEMENT_TYPE = -2147205090
NETWORK_E_INVALID_WEIGHT_TYPE = -2147205089
NETWORK_E_INVALID_ELEMENT_ID = -2147205088
NETWORK_E_INVALID_USER_ID = -2147205087
NETWORK_E_INVALID_USER_SUB_ID = -2147205086
NETWORK_E_OVERFLOW_USER_CLASS_ID = -2147205085
NETWORK_E_OVERFLOW_USER_ID = -2147205084
NETWORK_E_OVERFLOW_USER_SUB_ID = -2147205083
NETWORK_E_OVERFLOW_ELEMENT_ID = -2147205082
NETWORK_E_INVALID_WEIGHT_ID = -2147205081
NETWORK_E_COPY_OVERFLOW_USER_CLASS_ID = -2147205080
NETWORK_E_INVALID_WEIGHT_VALUE = -2147205079
NETWORK_E_NO_EDIT_OPERATION_IN_PROGRESS = -2147205078
NETWORK_E_EDIT_OPERATION_IN_PROGRESS = -2147205077
NETWORK_E_LOOP_EDGE_CHAIN = -2147205076
NETWORK_E_CANNOT_READ_TABLE = -2147205075
NETWORK_E_CANNOT_WRITE_TABLE = -2147205074
NETWORK_E_CORRUPT_DATA = -2147205073
NETWORK_E_INVALID_WEIGHT_ELEMENT_TYPES = -2147205072
NETWORK_E_INVALID_BITGATE_SIZE = -2147205071
NETWORK_E_ELEMENT_TYPE_MISMATCH = -2147205070
NETWORK_E_INVALID_TABLE_NAME = -2147205069
NETWORK_E_INVALID_FIELD_NAME = -2147205068
NETWORK_E_OLD_NETWORK_VERSION = -2147205067
NETWORK_E_DUPLICATE_TURN = -2147205066
NETWORK_E_BAD_TURN_INTERIOR_EXTERIOR_CONFLICT = -2147205065
NETWORK_E_BAD_TURN_DUPLICATED_FIRST_LAST_EDGES = -2147205064
NETWORK_E_BAD_TURN_SELF_LOOP = -2147205063
NETWORK_E_BAD_TURN_UNCONNECTED_ANCHOR = -2147205062
NETWORK_E_BAD_TURN_UNCONNECTED_EDGES = -2147205061
NETWORK_E_ADD_WEIGHT_HAS_ELEMENTS = -2147205060
NETWORK_E_DELETE_WEIGHT_HAS_ASSOCIATIONS = -2147205059
NETWORK_E_DUPLICATE_PROPERTY = -2147205058
NETWORK_E_UNDEFINED_PROPERTY = -2147205057
NETWORK_E_MISSING_PROPERTY = -2147205056
NETWORK_E_CANNOT_OPEN_LOGICAL_NETWORK = -2147205055
esriNetworkErrors = c_int # enum
class TinValueFilter(CoClass):
    u'The Esri TinValueFilter component.'
    _reg_clsid_ = GUID('{3C132C0E-FE5D-11D2-9F88-00C04F8ECE27}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinValueFilter._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITinDynamicFilter, ITinValueFilter, ITinValueFilter2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class TinEdgeTypeFilter(CoClass):
    u'The Esri TinEdgeTypeFilter component.'
    _reg_clsid_ = GUID('{8369A822-A9A6-11D3-AB4B-0008C73FD50C}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinEdgeTypeFilter._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITinDynamicFilter, ITinEdgeTypeFilter, ITinEdgeTypeFilter2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class TinTriangleFilter(CoClass):
    u'The Esri TinTriangleFilter component.'
    _reg_clsid_ = GUID('{927A94C0-01E1-11D3-AE19-000000000000}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinTriangleFilter._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITinDynamicFilter, ITinTriangleFilter, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class TinNativeType(CoClass):
    u'The Esri TinNativeType component.'
    _reg_clsid_ = GUID('{E378E871-F24F-4332-B1E6-339C7ACEB25C}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinNativeType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, INativeType]

class TinDataElementFilter(CoClass):
    u'The Esri TinDataElementFilter component.'
    _reg_clsid_ = GUID('{E21A9CAE-FABF-11D3-AB5A-0008C73FD50C}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinDataElementFilter._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITinFilter, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

IFeatureDatasetExtensionContainer._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of feature dataset extensions.')], HRESULT, 'ExtensionCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'Provides access to a feature dataset extension.')], HRESULT, 'Extension',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureDatasetExtension)), 'Extension' )),
    COMMETHOD([helpstring(u'Provides access to the feature dataset extension that supports the specified dataset type.')], HRESULT, 'FindExtension',
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureDatasetExtension)), 'Extension' )),
]
################################################################
## code template for IFeatureDatasetExtensionContainer implementation
##class IFeatureDatasetExtensionContainer_Impl(object):
##    def FindExtension(self, Type):
##        u'Provides access to the feature dataset extension that supports the specified dataset type.'
##        #return Extension
##
##    @property
##    def ExtensionCount(self):
##        u'The number of feature dataset extensions.'
##        #return Count
##
##    @property
##    def Extension(self, Index):
##        u'Provides access to a feature dataset extension.'
##        #return Extension
##

IDETopology._methods_ = [
    COMMETHOD(['propget', helpstring(u'The cluster tolerance of the topology.')], HRESULT, 'ClusterTolerance',
              ( ['retval', 'out'], POINTER(c_double), 'clusterTol' )),
    COMMETHOD(['propput', helpstring(u'The cluster tolerance of the topology.')], HRESULT, 'ClusterTolerance',
              ( ['in'], c_double, 'clusterTol' )),
    COMMETHOD(['propget', helpstring(u'The z cluster tolerance of the topology.')], HRESULT, 'ZClusterTolerance',
              ( ['retval', 'out'], POINTER(c_double), 'clusterTol' )),
    COMMETHOD(['propput', helpstring(u'The z cluster tolerance of the topology.')], HRESULT, 'ZClusterTolerance',
              ( ['in'], c_double, 'clusterTol' )),
    COMMETHOD(['propget', helpstring(u'The maximum number of errors to generate when validating a topology.')], HRESULT, 'MaximumGeneratedErrorCount',
              ( ['retval', 'out'], POINTER(c_int), 'maxErrorCount' )),
    COMMETHOD(['propput', helpstring(u'The maximum number of errors to generate when validating a topology.')], HRESULT, 'MaximumGeneratedErrorCount',
              ( ['in'], c_int, 'maxErrorCount' )),
    COMMETHOD(['propget', helpstring(u'The topology rules.')], HRESULT, 'Rules',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'Rules' )),
    COMMETHOD(['propputref', helpstring(u'The topology rules.')], HRESULT, 'Rules',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'Rules' )),
    COMMETHOD(['propget', helpstring(u'The feature classes involved in the topology.')], HRESULT, 'FeatureClassNames',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'FeatureClassNames' )),
    COMMETHOD(['propputref', helpstring(u'The feature classes involved in the topology.')], HRESULT, 'FeatureClassNames',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'FeatureClassNames' )),
]
################################################################
## code template for IDETopology implementation
##class IDETopology_Impl(object):
##    def _get(self):
##        u'The maximum number of errors to generate when validating a topology.'
##        #return maxErrorCount
##    def _set(self, maxErrorCount):
##        u'The maximum number of errors to generate when validating a topology.'
##    MaximumGeneratedErrorCount = property(_get, _set, doc = _set.__doc__)
##
##    def Rules(self, Rules):
##        u'The topology rules.'
##        #return 
##
##    def FeatureClassNames(self, FeatureClassNames):
##        u'The feature classes involved in the topology.'
##        #return 
##
##    def _get(self):
##        u'The z cluster tolerance of the topology.'
##        #return clusterTol
##    def _set(self, clusterTol):
##        u'The z cluster tolerance of the topology.'
##    ZClusterTolerance = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The cluster tolerance of the topology.'
##        #return clusterTol
##    def _set(self, clusterTol):
##        u'The cluster tolerance of the topology.'
##    ClusterTolerance = property(_get, _set, doc = _set.__doc__)
##


# values for enumeration 'esriVersionAccess'
esriVersionAccessPrivate = 0
esriVersionAccessPublic = 1
esriVersionAccessProtected = 2
esriVersionAccess = c_int # enum
IGPVersionInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u"The version's name.")], HRESULT, 'VersionName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u"The version's name.")], HRESULT, 'VersionName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u"The version's description.")], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'Description' )),
    COMMETHOD(['propput', helpstring(u"The version's description.")], HRESULT, 'Description',
              ( ['in'], BSTR, 'Description' )),
    COMMETHOD(['propget', helpstring(u"The version's access permission.")], HRESULT, 'Access',
              ( ['retval', 'out'], POINTER(esriVersionAccess), 'Access' )),
    COMMETHOD(['propput', helpstring(u"The version's access permission.")], HRESULT, 'Access',
              ( ['in'], esriVersionAccess, 'Access' )),
    COMMETHOD(['propget', helpstring(u'The date and time the version was created.')], HRESULT, 'Created',
              ( ['retval', 'out'], POINTER(VARIANT), 'date' )),
    COMMETHOD(['propput', helpstring(u'The date and time the version was created.')], HRESULT, 'Created',
              ( ['in'], VARIANT, 'date' )),
    COMMETHOD(['propget', helpstring(u'The date and time the version was last modified.')], HRESULT, 'Modified',
              ( ['retval', 'out'], POINTER(VARIANT), 'date' )),
    COMMETHOD(['propput', helpstring(u'The date and time the version was last modified.')], HRESULT, 'Modified',
              ( ['in'], VARIANT, 'date' )),
    COMMETHOD(['propget', helpstring(u'The name of the parent version.')], HRESULT, 'ParentName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the parent version.')], HRESULT, 'ParentName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The names of the child versions.')], HRESULT, 'ChildrenNames',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'Names' )),
    COMMETHOD(['propputref', helpstring(u'The names of the child versions.')], HRESULT, 'ChildrenNames',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'Names' )),
    COMMETHOD(['propget', helpstring(u'The names of the ancestor versions.')], HRESULT, 'AncestorNames',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'Names' )),
    COMMETHOD(['propputref', helpstring(u'The names of the ancestor versions.')], HRESULT, 'AncestorNames',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'Names' )),
]
################################################################
## code template for IGPVersionInfo implementation
##class IGPVersionInfo_Impl(object):
##    def ChildrenNames(self, Names):
##        u'The names of the child versions.'
##        #return 
##
##    def _get(self):
##        u"The version's description."
##        #return Description
##    def _set(self, Description):
##        u"The version's description."
##    Description = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The date and time the version was created.'
##        #return date
##    def _set(self, date):
##        u'The date and time the version was created.'
##    Created = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the parent version.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the parent version.'
##    ParentName = property(_get, _set, doc = _set.__doc__)
##
##    def AncestorNames(self, Names):
##        u'The names of the ancestor versions.'
##        #return 
##
##    def _get(self):
##        u'The date and time the version was last modified.'
##        #return date
##    def _set(self, date):
##        u'The date and time the version was last modified.'
##    Modified = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u"The version's access permission."
##        #return Access
##    def _set(self, Access):
##        u"The version's access permission."
##    Access = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u"The version's name."
##        #return Name
##    def _set(self, Name):
##        u"The version's name."
##    VersionName = property(_get, _set, doc = _set.__doc__)
##

class INetTopologyEditGEN(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that add and delete network elements from the logical network.  INetTopologyEditGEN is generic version of INetTopologyEdit.'
    _iid_ = GUID('{B39696F9-2D4A-4C54-AF81-F37F237D3CAC}')
    _idlflags_ = ['oleautomation']
INetTopologyEditGEN._methods_ = [
    COMMETHOD([helpstring(u'Returns the network element IDs of the junctions adjacent to the specified edge.')], HRESULT, 'GetFromToJunctionEIDs',
              ( ['in'], c_int, 'edgeEID' ),
              ( ['out'], POINTER(c_int), 'FromJunctionEID' ),
              ( ['out'], POINTER(c_int), 'ToJunctionEID' )),
    COMMETHOD([helpstring(u'Returns the number of edges adjacent to the specified junction.')], HRESULT, 'GetAdjacentEdgeCount',
              ( ['in'], c_int, 'AtJunctionEID' ),
              ( ['retval', 'out'], POINTER(c_int), 'adjacentEdgesCount' )),
    COMMETHOD([helpstring(u"Returns the network element ID of the index'th adjacent edge to the specified junction.")], HRESULT, 'GetAdjacentEdge',
              ( ['in'], c_int, 'AtJunctionEID' ),
              ( ['in'], c_int, 'Index' ),
              ( ['out'], POINTER(c_int), 'adjacentEdge' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'reverseOrientation' )),
    COMMETHOD(['hidden', helpstring(u'Returns the network element IDs of all the edges adjacent to the specified junction.')], HRESULT, 'GetAdjacentEdges',
              ( ['in'], c_int, 'AtJunctionEID' ),
              ( ['in', 'out'], POINTER(_midlSAFEARRAY(c_int)), 'adjacentEdges' ),
              ( ['in', 'out'], POINTER(_midlSAFEARRAY(VARIANT_BOOL)), 'reverseOrientation' )),
    COMMETHOD([helpstring(u'Adds a junction element to the logical network.')], HRESULT, 'AddJunction',
              ( ['in'], POINTER(INetElementDescription), 'junctionDescription' ),
              ( ['retval', 'out'], POINTER(c_int), 'junctionEID' )),
    COMMETHOD([helpstring(u'Adds an edge element to the logical network between the specified junction elements.')], HRESULT, 'AddEdgeByEndEIDs',
              ( ['in'], POINTER(INetElementDescription), 'edgeDescription' ),
              ( ['in'], c_int, 'FromJunctionEID' ),
              ( ['in'], c_int, 'ToJunctionEID' ),
              ( ['retval', 'out'], POINTER(c_int), 'edgeEID' )),
    COMMETHOD([helpstring(u'Deletes the specified network element from the logical network.')], HRESULT, 'DeleteByID',
              ( ['in'], c_int, 'UserClassID' ),
              ( ['in'], c_int, 'UserID' ),
              ( ['in'], c_int, 'UserSubID' ),
              ( ['in'], esriElementType, 'ElementType' )),
    COMMETHOD([helpstring(u'Deletes the specified network element from the logical network.')], HRESULT, 'DeleteByEID',
              ( ['in'], c_int, 'EID' ),
              ( ['in'], esriElementType, 'ElementType' )),
    COMMETHOD(['hidden', helpstring(u'Deletes the specified network elements from the logical network.')], HRESULT, 'DeleteByEIDs',
              ( ['in'], esriElementType, 'ElementType' ),
              ( ['in'], POINTER(_midlSAFEARRAY(c_int)), 'elementEIDs' )),
]
################################################################
## code template for INetTopologyEditGEN implementation
##class INetTopologyEditGEN_Impl(object):
##    def DeleteByID(self, UserClassID, UserID, UserSubID, ElementType):
##        u'Deletes the specified network element from the logical network.'
##        #return 
##
##    def GetAdjacentEdge(self, AtJunctionEID, Index):
##        u"Returns the network element ID of the index'th adjacent edge to the specified junction."
##        #return adjacentEdge, reverseOrientation
##
##    def GetAdjacentEdges(self, AtJunctionEID):
##        u'Returns the network element IDs of all the edges adjacent to the specified junction.'
##        #return adjacentEdges, reverseOrientation
##
##    def AddEdgeByEndEIDs(self, edgeDescription, FromJunctionEID, ToJunctionEID):
##        u'Adds an edge element to the logical network between the specified junction elements.'
##        #return edgeEID
##
##    def AddJunction(self, junctionDescription):
##        u'Adds a junction element to the logical network.'
##        #return junctionEID
##
##    def DeleteByEID(self, EID, ElementType):
##        u'Deletes the specified network element from the logical network.'
##        #return 
##
##    def DeleteByEIDs(self, ElementType, elementEIDs):
##        u'Deletes the specified network elements from the logical network.'
##        #return 
##
##    def GetAdjacentEdgeCount(self, AtJunctionEID):
##        u'Returns the number of edges adjacent to the specified junction.'
##        #return adjacentEdgesCount
##
##    def GetFromToJunctionEIDs(self, edgeEID):
##        u'Returns the network element IDs of the junctions adjacent to the specified edge.'
##        #return FromJunctionEID, ToJunctionEID
##

class TinImporter(CoClass):
    u'The Esri TinImporter component.'
    _reg_clsid_ = GUID('{89F42218-3268-4550-A8BC-F08F8D4AB822}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
TinImporter._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, ITinImporter]

ITinFeatureSeed._methods_ = [
    COMMETHOD(['propget', helpstring(u"The element's index number.")], HRESULT, 'Index',
              ( ['retval', 'out'], POINTER(c_int), 'pIndex' )),
    COMMETHOD(['propget', helpstring(u"The element's tag value.")], HRESULT, 'TagValue',
              ( ['retval', 'out'], POINTER(c_int), 'pValue' )),
    COMMETHOD(['propget', helpstring(u'Indicates whether tag value (if true) or edge type (if false) should be used to define the feature, in case the seed is an edge.')], HRESULT, 'UseTagValue',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pbUseTagValue' )),
    COMMETHOD(['propput', helpstring(u'Indicates whether tag value (if true) or edge type (if false) should be used to define the feature, in case the seed is an edge.')], HRESULT, 'UseTagValue',
              ( ['in'], VARIANT_BOOL, 'pbUseTagValue' )),
]
################################################################
## code template for ITinFeatureSeed implementation
##class ITinFeatureSeed_Impl(object):
##    @property
##    def Index(self):
##        u"The element's index number."
##        #return pIndex
##
##    @property
##    def TagValue(self):
##        u"The element's tag value."
##        #return pValue
##
##    def _get(self):
##        u'Indicates whether tag value (if true) or edge type (if false) should be used to define the feature, in case the seed is an edge.'
##        #return pbUseTagValue
##    def _set(self, pbUseTagValue):
##        u'Indicates whether tag value (if true) or edge type (if false) should be used to define the feature, in case the seed is an edge.'
##    UseTagValue = property(_get, _set, doc = _set.__doc__)
##

IDEServerObjectType._methods_ = [
]
################################################################
## code template for IDEServerObjectType implementation
##class IDEServerObjectType_Impl(object):

IDETopologyType._methods_ = [
]
################################################################
## code template for IDETopologyType implementation
##class IDETopologyType_Impl(object):

IXYEventSource._methods_ = [
    COMMETHOD(['propget', helpstring(u'Table used to initialize the XYEventSource.')], HRESULT, 'EventTable',
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'aTable' )),
    COMMETHOD(['propget', helpstring(u'Property object used to define the X, Y and Z location fields.')], HRESULT, 'EventProperties',
              ( ['retval', 'out'], POINTER(POINTER(IXYEventProperties)), 'xyProperties' )),
    COMMETHOD([helpstring(u'Resets the extent of the XYEventSource layer.')], HRESULT, 'RefreshExtent'),
]
################################################################
## code template for IXYEventSource implementation
##class IXYEventSource_Impl(object):
##    @property
##    def EventProperties(self):
##        u'Property object used to define the X, Y and Z location fields.'
##        #return xyProperties
##
##    def RefreshExtent(self):
##        u'Resets the extent of the XYEventSource layer.'
##        #return 
##
##    @property
##    def EventTable(self):
##        u'Table used to initialize the XYEventSource.'
##        #return aTable
##

IDERasterCatalogType._methods_ = [
]
################################################################
## code template for IDERasterCatalogType implementation
##class IDERasterCatalogType_Impl(object):

IDEMapServerType._methods_ = [
]
################################################################
## code template for IDEMapServerType implementation
##class IDEMapServerType_Impl(object):

IXYEvent2FieldsProperties._methods_ = [
    COMMETHOD(['propput', helpstring(u'The name of the X field.')], HRESULT, 'XFieldName',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'The name of the X field.')], HRESULT, 'XFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propput', helpstring(u'The name of the Y field.')], HRESULT, 'YFieldName',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'The name of the Y field.')], HRESULT, 'YFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propput', helpstring(u'The name of the Z field (optional).')], HRESULT, 'ZFieldName',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'The name of the Z field (optional).')], HRESULT, 'ZFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
]
################################################################
## code template for IXYEvent2FieldsProperties implementation
##class IXYEvent2FieldsProperties_Impl(object):
##    def _get(self):
##        u'The name of the Y field.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The name of the Y field.'
##    YFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the Z field (optional).'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The name of the Z field (optional).'
##    ZFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The name of the X field.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The name of the X field.'
##    XFieldName = property(_get, _set, doc = _set.__doc__)
##

class IEnumConfigurationParameter(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members to enumerate configuration parameters.'
    _iid_ = GUID('{75B1CCA3-EE77-4A5F-8FCD-1775D6F9497B}')
    _idlflags_ = ['oleautomation']
IConfigurationKeyword._methods_ = [
    COMMETHOD(['propget', helpstring(u'The type of the keyword.')], HRESULT, 'KeywordType',
              ( ['retval', 'out'], POINTER(esriConfigurationKeywordType), 'KeywordType' )),
    COMMETHOD(['propget', helpstring(u'The name of the keyword.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The description of the keyword.')], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'desc' )),
    COMMETHOD(['propget', helpstring(u'Any additional comments about the keyword.')], HRESULT, 'Comments',
              ( ['retval', 'out'], POINTER(BSTR), 'Comments' )),
    COMMETHOD(['propget', helpstring(u'Configuration parameters included in this keyword.')], HRESULT, 'ConfigurationParameters',
              ( ['retval', 'out'], POINTER(POINTER(IEnumConfigurationParameter)), 'params' )),
]
################################################################
## code template for IConfigurationKeyword implementation
##class IConfigurationKeyword_Impl(object):
##    @property
##    def ConfigurationParameters(self):
##        u'Configuration parameters included in this keyword.'
##        #return params
##
##    @property
##    def KeywordType(self):
##        u'The type of the keyword.'
##        #return KeywordType
##
##    @property
##    def Name(self):
##        u'The name of the keyword.'
##        #return Name
##
##    @property
##    def Comments(self):
##        u'Any additional comments about the keyword.'
##        #return Comments
##
##    @property
##    def Description(self):
##        u'The description of the keyword.'
##        #return desc
##

class ThumbnailInfo(CoClass):
    u'Provides access to ThumbnailInfo object.'
    _reg_clsid_ = GUID('{90578C48-5D05-4EFA-8AD8-783B8464B7A7}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
ThumbnailInfo._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IThumbnailInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist]

class IIdentityXform(IGeodataXform):
    _case_insensitive_ = True
    u'Provides access to members that control an identity transform.'
    _iid_ = GUID('{476EA691-0668-4A2D-B575-9B1FA74455E4}')
    _idlflags_ = ['oleautomation']
IIdentityXform._methods_ = [
]
################################################################
## code template for IIdentityXform implementation
##class IIdentityXform_Impl(object):

IMosaicDatasetName._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if this is a referenced mosaic dataset.')], HRESULT, 'Referenced',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pReferenced' )),
    COMMETHOD(['propput', helpstring(u'Indicates if this is a referenced mosaic dataset.')], HRESULT, 'Referenced',
              ( ['in'], VARIANT_BOOL, 'pReferenced' )),
]
################################################################
## code template for IMosaicDatasetName implementation
##class IMosaicDatasetName_Impl(object):
##    def _get(self):
##        u'Indicates if this is a referenced mosaic dataset.'
##        #return pReferenced
##    def _set(self, pReferenced):
##        u'Indicates if this is a referenced mosaic dataset.'
##    Referenced = property(_get, _set, doc = _set.__doc__)
##

IMosaicDatasetName2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The mosaic dataset table names.')], HRESULT, 'ChildrenNames',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'ppNames' )),
    COMMETHOD(['propputref', helpstring(u'The mosaic dataset table names.')], HRESULT, 'ChildrenNames',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'ppNames' )),
]
################################################################
## code template for IMosaicDatasetName2 implementation
##class IMosaicDatasetName2_Impl(object):
##    def ChildrenNames(self, ppNames):
##        u'The mosaic dataset table names.'
##        #return 
##

IDataElement._methods_ = [
    COMMETHOD(['propget', helpstring(u'The type of the element.')], HRESULT, 'Type',
              ( ['retval', 'out'], POINTER(BSTR), 'Type' )),
    COMMETHOD(['propput', helpstring(u'The type of the element.')], HRESULT, 'Type',
              ( ['in'], BSTR, 'Type' )),
    COMMETHOD(['propget', helpstring(u'The user assigned name for the element.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The user assigned name for the element.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u'The string used to retrieve the element.')], HRESULT, 'CatalogPath',
              ( ['retval', 'out'], POINTER(BSTR), 'Path' )),
    COMMETHOD(['propput', helpstring(u'The string used to retrieve the element.')], HRESULT, 'CatalogPath',
              ( ['in'], BSTR, 'Path' )),
    COMMETHOD(['propget', helpstring(u'The list of sub-elements.')], HRESULT, 'Children',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'DataElements' )),
    COMMETHOD(['propputref', helpstring(u'The list of sub-elements.')], HRESULT, 'Children',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'DataElements' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the children have been expanded.')], HRESULT, 'ChildrenExpanded',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'ChildrenExpanded' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the children have been expanded.')], HRESULT, 'ChildrenExpanded',
              ( ['in'], VARIANT_BOOL, 'ChildrenExpanded' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the metadata has been retrieved.')], HRESULT, 'MetadataRetrieved',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'MetadataRetrieved' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the metadata has been retrieved.')], HRESULT, 'MetadataRetrieved',
              ( ['in'], VARIANT_BOOL, 'MetadataRetrieved' )),
    COMMETHOD(['propget', helpstring(u'Indicates if full properties have been retrieved.')], HRESULT, 'FullPropsRetrieved',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'FullPropsRetrieved' )),
    COMMETHOD(['propput', helpstring(u'Indicates if full properties have been retrieved.')], HRESULT, 'FullPropsRetrieved',
              ( ['in'], VARIANT_BOOL, 'FullPropsRetrieved' )),
    COMMETHOD([helpstring(u'File path.')], HRESULT, 'GetPath',
              ( ['retval', 'out'], POINTER(BSTR), 'Path' )),
    COMMETHOD([helpstring(u'File name.')], HRESULT, 'GetFile',
              ( ['retval', 'out'], POINTER(BSTR), 'file' )),
    COMMETHOD([helpstring(u'File base name.')], HRESULT, 'GetBaseName',
              ( ['retval', 'out'], POINTER(BSTR), 'baseName' )),
    COMMETHOD([helpstring(u'File extension.')], HRESULT, 'GetExtension',
              ( ['retval', 'out'], POINTER(BSTR), 'Extension' )),
]
################################################################
## code template for IDataElement implementation
##class IDataElement_Impl(object):
##    def _get(self):
##        u'The user assigned name for the element.'
##        #return Name
##    def _set(self, Name):
##        u'The user assigned name for the element.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the children have been expanded.'
##        #return ChildrenExpanded
##    def _set(self, ChildrenExpanded):
##        u'Indicates if the children have been expanded.'
##    ChildrenExpanded = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the metadata has been retrieved.'
##        #return MetadataRetrieved
##    def _set(self, MetadataRetrieved):
##        u'Indicates if the metadata has been retrieved.'
##    MetadataRetrieved = property(_get, _set, doc = _set.__doc__)
##
##    def GetBaseName(self):
##        u'File base name.'
##        #return baseName
##
##    def GetPath(self):
##        u'File path.'
##        #return Path
##
##    def _get(self):
##        u'The string used to retrieve the element.'
##        #return Path
##    def _set(self, Path):
##        u'The string used to retrieve the element.'
##    CatalogPath = property(_get, _set, doc = _set.__doc__)
##
##    def GetExtension(self):
##        u'File extension.'
##        #return Extension
##
##    def GetFile(self):
##        u'File name.'
##        #return file
##
##    def _get(self):
##        u'Indicates if full properties have been retrieved.'
##        #return FullPropsRetrieved
##    def _set(self, FullPropsRetrieved):
##        u'Indicates if full properties have been retrieved.'
##    FullPropsRetrieved = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The type of the element.'
##        #return Type
##    def _set(self, Type):
##        u'The type of the element.'
##    Type = property(_get, _set, doc = _set.__doc__)
##
##    def Children(self, DataElements):
##        u'The list of sub-elements.'
##        #return 
##

class IRasterDatasetInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a raster dataset information.'
    _iid_ = GUID('{681DCDF0-A80B-402F-842A-DE2421B82C2C}')
    _idlflags_ = []
IRasterDatasetInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'The GeoDatabase raster storage definition.')], HRESULT, 'StorageDef',
              ( ['retval', 'out'], POINTER(POINTER(IRasterStorageDef)), 'StorageDef' )),
    COMMETHOD(['propget', helpstring(u'The list of files associated with this dataset.')], HRESULT, 'FileList',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'pFileList' )),
]
################################################################
## code template for IRasterDatasetInfo implementation
##class IRasterDatasetInfo_Impl(object):
##    @property
##    def StorageDef(self):
##        u'The GeoDatabase raster storage definition.'
##        #return StorageDef
##
##    @property
##    def FileList(self):
##        u'The list of files associated with this dataset.'
##        #return pFileList
##

class IConfigurationKeyword2(IConfigurationKeyword):
    _case_insensitive_ = True
    u'Provides access to members to supply information about configuration keywords.'
    _iid_ = GUID('{BBE02ADF-AE75-4EA4-BE73-FBA83CC3EE10}')
    _idlflags_ = ['oleautomation']
IConfigurationKeyword2._methods_ = [
    COMMETHOD(['propput', helpstring(u'The type of the keyword.')], HRESULT, 'KeywordType',
              ( ['in'], esriConfigurationKeywordType, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The name of the keyword.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The description of the keyword.')], HRESULT, 'Description',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Any additional comments about the keyword.')], HRESULT, 'Comments',
              ( ['in'], BSTR, 'rhs' )),
]
################################################################
## code template for IConfigurationKeyword2 implementation
##class IConfigurationKeyword2_Impl(object):
##    def _set(self, rhs):
##        u'The type of the keyword.'
##    KeywordType = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The name of the keyword.'
##    Name = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Any additional comments about the keyword.'
##    Comments = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The description of the keyword.'
##    Description = property(fset = _set, doc = _set.__doc__)
##

IEnumConfigurationParameter._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next configuration parameter in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IConfigurationParameter)), 'param' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumConfigurationParameter implementation
##class IEnumConfigurationParameter_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next configuration parameter in the enumeration sequence.'
##        #return param
##

IFeatureSimplify._methods_ = [
    COMMETHOD([helpstring(u'Simplifies the input geometry using the rules appropriate for this feature.')], HRESULT, 'SimplifyGeometry',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'Geometry' )),
]
################################################################
## code template for IFeatureSimplify implementation
##class IFeatureSimplify_Impl(object):
##    def SimplifyGeometry(self, Geometry):
##        u'Simplifies the input geometry using the rules appropriate for this feature.'
##        #return 
##

class RasterStorageDef(CoClass):
    u'Raster Value Storage Definition Class.'
    _reg_clsid_ = GUID('{82ABC602-67F9-4042-BEE1-645B0139FD70}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
RasterStorageDef._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRasterStorageDef, IRasterStorageDef2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize]

class RasterDef(CoClass):
    u'Raster Column Definition Class.'
    _reg_clsid_ = GUID('{A8386192-3659-4525-984F-5D643A40EE8C}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
RasterDef._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRasterDef, IRasterDef2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize]

IConfigurationParameter._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the parameter.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The configuration string defined by the parameter.')], HRESULT, 'ConfigurationString',
              ( ['retval', 'out'], POINTER(BSTR), 'str' )),
]
################################################################
## code template for IConfigurationParameter implementation
##class IConfigurationParameter_Impl(object):
##    @property
##    def ConfigurationString(self):
##        u'The configuration string defined by the parameter.'
##        #return str
##
##    @property
##    def Name(self):
##        u'The name of the parameter.'
##        #return Name
##

class EdgeConnectivityRule(CoClass):
    u'Esri Edge-Edge NetworkConnectivity rule object.'
    _reg_clsid_ = GUID('{F290D9E0-58E5-11D2-AB26-000000000000}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
EdgeConnectivityRule._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRule, IConnectivityRule, IEdgeConnectivityRule, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream]

IRasterDatasetContainerName._methods_ = [
]
################################################################
## code template for IRasterDatasetContainerName implementation
##class IRasterDatasetContainerName_Impl(object):

IEnumConfigurationKeyword._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next configuration keyword in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IConfigurationKeyword)), 'keyword' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumConfigurationKeyword implementation
##class IEnumConfigurationKeyword_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next configuration keyword in the enumeration sequence.'
##        #return keyword
##

class IConfigurationParameter2(IConfigurationParameter):
    _case_insensitive_ = True
    u'Provides access to members to supply information about configuration paramters.'
    _iid_ = GUID('{4EAC0CF1-EE2A-405C-A18A-C588DC53A0E7}')
    _idlflags_ = ['oleautomation']
IConfigurationParameter2._methods_ = [
    COMMETHOD(['propput', helpstring(u'The name of the parameter.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'The configuration string defined by the parameter.')], HRESULT, 'ConfigurationString',
              ( ['in'], BSTR, 'rhs' )),
]
################################################################
## code template for IConfigurationParameter2 implementation
##class IConfigurationParameter2_Impl(object):
##    def _set(self, rhs):
##        u'The configuration string defined by the parameter.'
##    ConfigurationString = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'The name of the parameter.'
##    Name = property(fset = _set, doc = _set.__doc__)
##

class RasterCatalogItem(CoClass):
    u'Raster Catalog Feature Class.'
    _reg_clsid_ = GUID('{3EAA2478-5332-40F8-8FA8-62382390A3BA}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
RasterCatalogItem._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRasterCatalogItem, IFeature, IFeatureBuffer, IFeatureChanges, IFeatureDraw, IFeatureEdit, IFeatureEvents, IFeatureSimplify, IFeatureSimplify2, IRelatedObjectEvents, IRowChanges, IRowCompare, IRowEdit, IRowEvents, IRowSubtypes, IValidate, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo, IFeatureProject]

class IRasterWorkspace4(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to additional members that control a raster workspace.'
    _iid_ = GUID('{2EEB0761-2D5A-459B-8B71-C19A810FB896}')
    _idlflags_ = ['oleautomation']
IRasterWorkspace4._methods_ = [
    COMMETHOD([helpstring(u'Creates a RasterDataset in the workspace given its name.')], HRESULT, 'CreateRasterDataset',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], BSTR, 'Format' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pOrigin' ),
              ( ['in'], c_int, 'nCols' ),
              ( ['in'], c_int, 'nRows' ),
              ( ['in'], c_double, 'dx' ),
              ( ['in'], c_double, 'dy' ),
              ( ['in'], c_int, 'nBands' ),
              ( ['in'], rstPixelType, 'PixelType' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference' ),
              ( ['in'], VARIANT_BOOL, 'Permanent' ),
              ( ['in'], POINTER(IRasterStorageDef), 'pStorageDef' ),
              ( ['in'], BSTR, 'ConfigKeyword' ),
              ( ['retval', 'out'], POINTER(POINTER(IRasterDataset)), 'ppRasterDataset' )),
]
################################################################
## code template for IRasterWorkspace4 implementation
##class IRasterWorkspace4_Impl(object):
##    def CreateRasterDataset(self, Name, Format, pOrigin, nCols, nRows, dx, dy, nBands, PixelType, SpatialReference, Permanent, pStorageDef, ConfigKeyword):
##        u'Creates a RasterDataset in the workspace given its name.'
##        #return ppRasterDataset
##

IEnumObjectClass._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next feature class in the enumeration sequence.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IObjectClass)), 'ObjectClass' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumObjectClass implementation
##class IEnumObjectClass_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next feature class in the enumeration sequence.'
##        #return ObjectClass
##

class RasterCatalog(CoClass):
    u'A collection of raster datasets in a Geodatabase table.'
    _reg_clsid_ = GUID('{55E13E7E-52BD-4145-9ADF-9CF8B776C346}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
RasterCatalog._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDataset, IDatasetEdit, IDatasetEditInfo, IDatasetAnalyze, ISchemaLock, IClass, ITable, IObjectClass, IClassSchemaEdit, IClassSchemaEdit2, IModelInfo, IObjectClassInfo, IObjectClassInfo2, IFeatureClass, IGeoDataset, IFeatureClassWrite, IFeatureClassLoad, ITableCapabilities, IFeatureClassManage, IRasterCatalog]

class IRouteEventProperties2(IRouteEventProperties):
    _case_insensitive_ = True
    u'Provides access to the properties of an event table.'
    _iid_ = GUID('{5AE87432-A9C0-42C4-8DFA-03E5C93785E9}')
    _idlflags_ = ['oleautomation']
IRouteEventProperties2._methods_ = [
    COMMETHOD(['propput', helpstring(u'Indicates if the error field should be added to the field set.')], HRESULT, 'AddErrorField',
              ( ['in'], VARIANT_BOOL, 'Value' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the error field should be added to the field set.')], HRESULT, 'AddErrorField',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Value' )),
    COMMETHOD(['propput', helpstring(u'Name of the error field name.')], HRESULT, 'ErrorFieldName',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'Name of the error field name.')], HRESULT, 'ErrorFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the offset should based onthe M direction or the digitized direction.')], HRESULT, 'MDirectionOffsetting',
              ( ['in'], VARIANT_BOOL, 'Value' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the offset should based onthe M direction or the digitized direction.')], HRESULT, 'MDirectionOffsetting',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Value' )),
]
################################################################
## code template for IRouteEventProperties2 implementation
##class IRouteEventProperties2_Impl(object):
##    def _get(self):
##        u'Indicates if the error field should be added to the field set.'
##        #return Value
##    def _set(self, Value):
##        u'Indicates if the error field should be added to the field set.'
##    AddErrorField = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Name of the error field name.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'Name of the error field name.'
##    ErrorFieldName = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the offset should based onthe M direction or the digitized direction.'
##        #return Value
##    def _set(self, Value):
##        u'Indicates if the offset should based onthe M direction or the digitized direction.'
##    MDirectionOffsetting = property(_get, _set, doc = _set.__doc__)
##

class IEnumHierarchyRange(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to a container for accessing network dataset hierarchy ranges.'
    _iid_ = GUID('{F41FF50C-6AA3-4D41-8953-E7C4E3986438}')
    _idlflags_ = ['oleautomation']
IEnumHierarchyRange._methods_ = [
    COMMETHOD([helpstring(u'Forces the enumerator pointing before first range; a subsequent next gives the first range in the enumeration.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Moves the enumerator forward and returns the hierarchy range pointed by the enumerator.')], HRESULT, 'Next',
              ( ['out'], POINTER(c_int), 'Index' ),
              ( ['out'], POINTER(c_int), 'lowRange' ),
              ( ['out'], POINTER(c_int), 'highRange' )),
]
################################################################
## code template for IEnumHierarchyRange implementation
##class IEnumHierarchyRange_Impl(object):
##    def Reset(self):
##        u'Forces the enumerator pointing before first range; a subsequent next gives the first range in the enumeration.'
##        #return 
##
##    def Next(self):
##        u'Moves the enumerator forward and returns the hierarchy range pointed by the enumerator.'
##        #return Index, lowRange, highRange
##

IFeatureSimplify2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Returns true if the input geometry is simple according to the rules appropriate for this feature.')], HRESULT, 'IsSimpleGeometry',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'Geometry' ),
              ( ['out'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriNonSimpleReasonEnum), 'reason' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsSimpleGeometry' )),
]
################################################################
## code template for IFeatureSimplify2 implementation
##class IFeatureSimplify2_Impl(object):
##    @property
##    def IsSimpleGeometry(self, Geometry):
##        u'Returns true if the input geometry is simple according to the rules appropriate for this feature.'
##        #return reason, IsSimpleGeometry
##

IFeatureElement._methods_ = [
    COMMETHOD(['propget', helpstring(u'The Feature that owns the Feature Element.')], HRESULT, 'Owner',
              ( ['retval', 'out'], POINTER(POINTER(IFeature)), 'Feature' )),
    COMMETHOD(['propget', helpstring(u'The Type of Feature Element.')], HRESULT, 'ElementType',
              ( ['retval', 'out'], POINTER(esriFeatureElementType), 'Type' )),
    COMMETHOD(['propget', helpstring(u'The Geometry of the Feature Element.')], HRESULT, 'Geometry',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'Geometry' )),
    COMMETHOD(['propget', helpstring(u'The Parent of the Feature Element.')], HRESULT, 'Parent',
              ( ['retval', 'out'], POINTER(POINTER(IFeatureElement)), 'Parent' )),
]
################################################################
## code template for IFeatureElement implementation
##class IFeatureElement_Impl(object):
##    @property
##    def Owner(self):
##        u'The Feature that owns the Feature Element.'
##        #return Feature
##
##    @property
##    def Geometry(self):
##        u'The Geometry of the Feature Element.'
##        #return Geometry
##
##    @property
##    def ElementType(self):
##        u'The Type of Feature Element.'
##        #return Type
##
##    @property
##    def Parent(self):
##        u'The Parent of the Feature Element.'
##        #return Parent
##

class RasterBandName(CoClass):
    u'A container for name information about a raster band.'
    _reg_clsid_ = GUID('{BC25E113-168B-11D2-8D25-0000F8780535}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
RasterBandName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IRasterBandName, IMetadata, IMetadataEdit, INativeTypeInfo]

class RasterCatalogName(CoClass):
    u'Esri RasterCatalog Name object.'
    _reg_clsid_ = GUID('{33FF62FC-D7D6-48E8-82D9-77C0AADBF5D1}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
RasterCatalogName._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IRasterCatalogName, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName, IDatasetName, ITableName, IObjectClassName, IFeatureClassName, IModelInfo, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IMetadata, IMetadataEdit, INativeTypeInfo, ITopologyClassName]

IFeatureConnect._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of connection points associated with the Feature.')], HRESULT, 'ConnectionPointCount',
              ( ['retval', 'out'], POINTER(c_int), 'numPoints' )),
    COMMETHOD(['propget', helpstring(u'The specified connection point.')], HRESULT, 'ConnectionPoint',
              ( ['in'], c_int, 'connectionPointIndex' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureElement)), 'ConnectionPoint' )),
    COMMETHOD(['propget', helpstring(u'The name of the specified connection point.')], HRESULT, 'ConnectionPointName',
              ( ['in'], c_int, 'connectionPointIndex' ),
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The specified named connection point.')], HRESULT, 'ConnectionPointByName',
              ( ['in'], BSTR, 'ConnectionPointName' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureElement)), 'ConnectionPoint' )),
]
################################################################
## code template for IFeatureConnect implementation
##class IFeatureConnect_Impl(object):
##    @property
##    def ConnectionPointByName(self, ConnectionPointName):
##        u'The specified named connection point.'
##        #return ConnectionPoint
##
##    @property
##    def ConnectionPointCount(self):
##        u'The number of connection points associated with the Feature.'
##        #return numPoints
##
##    @property
##    def ConnectionPointName(self, connectionPointIndex):
##        u'The name of the specified connection point.'
##        #return Name
##
##    @property
##    def ConnectionPoint(self, connectionPointIndex):
##        u'The specified connection point.'
##        #return ConnectionPoint
##

IXMLIndexTemplate._methods_ = [
    COMMETHOD(['propget', helpstring(u'A user defineable name which must be globally unique to the Geodatabase instance.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'templateName' )),
    COMMETHOD(['propput', helpstring(u'A user defineable name which must be globally unique to the Geodatabase instance.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'templateName' )),
    COMMETHOD(['propget', helpstring(u'The set of tags to be used for the IncludedTags property of an XML Index.')], HRESULT, 'IncludedTags',
              ( ['retval', 'out'], POINTER(POINTER(IXMLIndexTags)), 'Tags' )),
    COMMETHOD(['propputref', helpstring(u'The set of tags to be used for the IncludedTags property of an XML Index.')], HRESULT, 'IncludedTags',
              ( ['in'], POINTER(IXMLIndexTags), 'Tags' )),
    COMMETHOD(['propget', helpstring(u'The set of tags to be used for the ExcludedTags property of an XML Index.')], HRESULT, 'ExcludedTags',
              ( ['retval', 'out'], POINTER(POINTER(IXMLIndexTags)), 'Tags' )),
    COMMETHOD(['propputref', helpstring(u'The set of tags to be used for the ExcludedTags property of an XML Index.')], HRESULT, 'ExcludedTags',
              ( ['in'], POINTER(IXMLIndexTags), 'Tags' )),
    COMMETHOD(['propget', helpstring(u'A textual description of the template.')], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'templateDescription' )),
    COMMETHOD(['propput', helpstring(u'A textual description of the template.')], HRESULT, 'Description',
              ( ['in'], BSTR, 'templateDescription' )),
]
################################################################
## code template for IXMLIndexTemplate implementation
##class IXMLIndexTemplate_Impl(object):
##    def _get(self):
##        u'A textual description of the template.'
##        #return templateDescription
##    def _set(self, templateDescription):
##        u'A textual description of the template.'
##    Description = property(_get, _set, doc = _set.__doc__)
##
##    def ExcludedTags(self, Tags):
##        u'The set of tags to be used for the ExcludedTags property of an XML Index.'
##        #return 
##
##    def _get(self):
##        u'A user defineable name which must be globally unique to the Geodatabase instance.'
##        #return templateName
##    def _set(self, templateName):
##        u'A user defineable name which must be globally unique to the Geodatabase instance.'
##    Name = property(_get, _set, doc = _set.__doc__)
##
##    def IncludedTags(self, Tags):
##        u'The set of tags to be used for the IncludedTags property of an XML Index.'
##        #return 
##

INetworkJunction2._methods_ = [
    COMMETHOD([dispid(1610874880), helpstring(u'Value of this network element for the given network attribute ID and local time.'), 'propget'], HRESULT, 'AttributeValueAtTime',
              ( ['in'], c_int, 'AttributeID' ),
              ( ['in'], c_double, 'localTime' ),
              ( ['in'], esriNetworkTimeUsage, 'timeUsage' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'AttributeValue' )),
]
################################################################
## code template for INetworkJunction2 implementation
##class INetworkJunction2_Impl(object):
##    @property
##    def AttributeValueAtTime(self, AttributeID, localTime, timeUsage):
##        u'Value of this network element for the given network attribute ID and local time.'
##        #return AttributeValue
##

IEnumLocator._methods_ = [
    COMMETHOD([helpstring(u'Returns the next locator or locator style.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(ILocator)), 'outLocator' )),
    COMMETHOD([helpstring(u'Returns the previous locator or locator style.')], HRESULT, 'Previous',
              ( ['retval', 'out'], POINTER(POINTER(ILocator)), 'outLocator' )),
    COMMETHOD([helpstring(u'Resets the enumeration.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Creates a copy of the enumeration.')], HRESULT, 'Clone',
              ( ['retval', 'out'], POINTER(POINTER(IEnumLocator)), 'outEnumerator' )),
    COMMETHOD(['propget', helpstring(u'Number of locators in the enumeration.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
]
################################################################
## code template for IEnumLocator implementation
##class IEnumLocator_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration.'
##        #return 
##
##    @property
##    def Count(self):
##        u'Number of locators in the enumeration.'
##        #return Count
##
##    def Clone(self):
##        u'Creates a copy of the enumeration.'
##        #return outEnumerator
##
##    def Previous(self):
##        u'Returns the previous locator or locator style.'
##        #return outLocator
##
##    def Next(self):
##        u'Returns the next locator or locator style.'
##        #return outLocator
##

class GPNetworkDatasetMembership(CoClass):
    u'The Network Dataset Membership object.'
    _reg_clsid_ = GUID('{2AAE84D4-417C-4E61-946C-B3A20AAA80B8}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
GPNetworkDatasetMembership._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IGPControllerMembership, IGPNetworkDatasetMembership, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDocumentVersionSupportGEN]

ILocator._methods_ = [
    COMMETHOD(['propget', helpstring(u'Name of the locator.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'Description of the locator.')], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'Description' )),
    COMMETHOD(['propput', helpstring(u'Description of the locator.')], HRESULT, 'Description',
              ( ['in'], BSTR, 'Description' )),
    COMMETHOD(['propget', helpstring(u'Category of the locator.')], HRESULT, 'Category',
              ( ['retval', 'out'], POINTER(BSTR), 'Category' )),
    COMMETHOD(['propget', helpstring(u'User interface for the locator.')], HRESULT, 'UserInterface',
              ( ['retval', 'out'], POINTER(POINTER(ILocatorUI)), 'outLocatorUI' )),
]
################################################################
## code template for ILocator implementation
##class ILocator_Impl(object):
##    @property
##    def Category(self):
##        u'Category of the locator.'
##        #return Category
##
##    @property
##    def UserInterface(self):
##        u'User interface for the locator.'
##        #return outLocatorUI
##
##    @property
##    def Name(self):
##        u'Name of the locator.'
##        #return Name
##
##    def _get(self):
##        u'Description of the locator.'
##        #return Description
##    def _set(self, Description):
##        u'Description of the locator.'
##    Description = property(_get, _set, doc = _set.__doc__)
##

INetworkFieldEvaluator._methods_ = [
    COMMETHOD([helpstring(u'Sets the VBScript calculator expression and pre-logic used to derive the values for this network evaluator.')], HRESULT, 'SetExpression',
              ( ['in'], BSTR, 'Expression' ),
              ( ['in'], BSTR, 'preLogic' )),
    COMMETHOD([helpstring(u'Gets the VBScript calculator expression and pre-logic used to derive the values for this network evaluator.')], HRESULT, 'GetExpression',
              ( ['in', 'out'], POINTER(BSTR), 'Expression' ),
              ( ['in', 'out'], POINTER(BSTR), 'preLogic' )),
]
################################################################
## code template for INetworkFieldEvaluator implementation
##class INetworkFieldEvaluator_Impl(object):
##    def SetExpression(self, Expression, preLogic):
##        u'Sets the VBScript calculator expression and pre-logic used to derive the values for this network evaluator.'
##        #return 
##
##    def GetExpression(self):
##        u'Gets the VBScript calculator expression and pre-logic used to derive the values for this network evaluator.'
##        #return Expression, preLogic
##

ISelectionSet2._methods_ = [
    COMMETHOD([helpstring(u'Returns a cursor that can be used to update the objects specified by a query over this selection set.')], HRESULT, 'Update',
              ( ['in'], POINTER(IQueryFilter), 'QueryFilter' ),
              ( ['in'], VARIANT_BOOL, 'Recycling' ),
              ( ['out'], POINTER(POINTER(ICursor)), 'Cursor' )),
]
################################################################
## code template for ISelectionSet2 implementation
##class ISelectionSet2_Impl(object):
##    def Update(self, QueryFilter, Recycling):
##        u'Returns a cursor that can be used to update the objects specified by a query over this selection set.'
##        #return Cursor
##

ITinEditErrorLog._methods_ = [
    COMMETHOD([helpstring(u'Clears existing error log contents.')], HRESULT, 'ClearEditErrorLog'),
    COMMETHOD([helpstring(u'Saves error log contents to a file.')], HRESULT, 'SaveEditErrorLog',
              ( ['in'], BSTR, 'fileName' )),
    COMMETHOD(['propget', helpstring(u'The number of errors.')], HRESULT, 'EditErrorCount',
              ( ['retval', 'out'], POINTER(c_int), 'pcErrors' )),
    COMMETHOD(['propput', helpstring(u'Name representing a group of shapes to be added/edited.')], HRESULT, 'CurrentObjectClassName',
              ( ['in'], BSTR, 'pName' )),
    COMMETHOD(['propget', helpstring(u'Name representing a group of shapes to be added/edited.')], HRESULT, 'CurrentObjectClassName',
              ( ['retval', 'out'], POINTER(BSTR), 'pName' )),
    COMMETHOD(['propput', helpstring(u'ID of the shape to be added/edited.')], HRESULT, 'CurrentObjectID',
              ( ['in'], c_int, 'pID' )),
    COMMETHOD(['propget', helpstring(u'ID of the shape to be added/edited.')], HRESULT, 'CurrentObjectID',
              ( ['retval', 'out'], POINTER(c_int), 'pID' )),
]
################################################################
## code template for ITinEditErrorLog implementation
##class ITinEditErrorLog_Impl(object):
##    def _get(self):
##        u'ID of the shape to be added/edited.'
##        #return pID
##    def _set(self, pID):
##        u'ID of the shape to be added/edited.'
##    CurrentObjectID = property(_get, _set, doc = _set.__doc__)
##
##    def ClearEditErrorLog(self):
##        u'Clears existing error log contents.'
##        #return 
##
##    def SaveEditErrorLog(self, fileName):
##        u'Saves error log contents to a file.'
##        #return 
##
##    @property
##    def EditErrorCount(self):
##        u'The number of errors.'
##        #return pcErrors
##
##    def _get(self):
##        u'Name representing a group of shapes to be added/edited.'
##        #return pName
##    def _set(self, pName):
##        u'Name representing a group of shapes to be added/edited.'
##    CurrentObjectClassName = property(_get, _set, doc = _set.__doc__)
##

INetworkFeatureEvents._methods_ = [
    COMMETHOD([helpstring(u'Preparation for connecting a NetworkFeature to another.')], HRESULT, 'OnConnect'),
    COMMETHOD([helpstring(u'Preparation for disconnecting a NetworkFeature from another.')], HRESULT, 'OnDisconnect'),
]
################################################################
## code template for INetworkFeatureEvents implementation
##class INetworkFeatureEvents_Impl(object):
##    def OnDisconnect(self):
##        u'Preparation for disconnecting a NetworkFeature from another.'
##        #return 
##
##    def OnConnect(self):
##        u'Preparation for connecting a NetworkFeature to another.'
##        #return 
##

IRelQueryTableSelectionSet._methods_ = [
    COMMETHOD(['propget', helpstring(u'Base table of the inner SelectionSet.')], HRESULT, 'BaseTableSelectionSet',
              ( ['retval', 'out'], POINTER(POINTER(ISelectionSet)), 'SelectionSet' )),
]
################################################################
## code template for IRelQueryTableSelectionSet implementation
##class IRelQueryTableSelectionSet_Impl(object):
##    @property
##    def BaseTableSelectionSet(self):
##        u'Base table of the inner SelectionSet.'
##        #return SelectionSet
##

INetworkFieldEvaluator2._methods_ = [
    COMMETHOD([helpstring(u'Sets the script language')], HRESULT, 'SetLanguage',
              ( ['in'], BSTR, 'language' )),
    COMMETHOD([helpstring(u'Gets the script language')], HRESULT, 'GetLanguage',
              ( ['in', 'out'], POINTER(BSTR), 'language' )),
]
################################################################
## code template for INetworkFieldEvaluator2 implementation
##class INetworkFieldEvaluator2_Impl(object):
##    def GetLanguage(self):
##        u'Gets the script language'
##        #return language
##
##    def SetLanguage(self, language):
##        u'Sets the script language'
##        #return 
##

INetworkScriptEvaluator._methods_ = [
    COMMETHOD([helpstring(u'Sets the VBScript calculator expression and pre-logic used to derive the values for this network evaluator.')], HRESULT, 'SetExpression',
              ( ['in'], BSTR, 'Expression' ),
              ( ['in'], BSTR, 'preLogic' )),
    COMMETHOD([helpstring(u'Gets the VBScript calculator expression and pre-logic used to derive the values for this network evaluator.')], HRESULT, 'GetExpression',
              ( ['in', 'out'], POINTER(BSTR), 'Expression' ),
              ( ['in', 'out'], POINTER(BSTR), 'preLogic' )),
]
################################################################
## code template for INetworkScriptEvaluator implementation
##class INetworkScriptEvaluator_Impl(object):
##    def SetExpression(self, Expression, preLogic):
##        u'Sets the VBScript calculator expression and pre-logic used to derive the values for this network evaluator.'
##        #return 
##
##    def GetExpression(self):
##        u'Gets the VBScript calculator expression and pre-logic used to derive the values for this network evaluator.'
##        #return Expression, preLogic
##

IClassHelper._methods_ = [
    COMMETHOD(['propget', helpstring(u'The class for this class helper.')], HRESULT, 'Class',
              ( ['retval', 'out'], POINTER(POINTER(IClass)), 'ObjectClass' )),
]
################################################################
## code template for IClassHelper implementation
##class IClassHelper_Impl(object):
##    @property
##    def Class(self):
##        u'The class for this class helper.'
##        #return ObjectClass
##

INetworkScriptEvaluator2._methods_ = [
    COMMETHOD([helpstring(u'Sets the script language')], HRESULT, 'SetLanguage',
              ( ['in'], BSTR, 'language' )),
    COMMETHOD([helpstring(u'Gets the script language')], HRESULT, 'GetLanguage',
              ( ['in', 'out'], POINTER(BSTR), 'language' )),
]
################################################################
## code template for INetworkScriptEvaluator2 implementation
##class INetworkScriptEvaluator2_Impl(object):
##    def GetLanguage(self):
##        u'Gets the script language'
##        #return language
##
##    def SetLanguage(self, language):
##        u'Sets the script language'
##        #return 
##

class IClassExtension(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that initialize and shutdown the class extension.'
    _iid_ = GUID('{1C014E3D-A1E1-11D3-9F97-00C04F6BDF0C}')
    _idlflags_ = ['oleautomation']
IClassExtension._methods_ = [
    COMMETHOD([helpstring(u'Initializes the  extension, passing in a reference to its class helper.')], HRESULT, 'Init',
              ( ['in'], POINTER(IClassHelper), 'ClassHelper' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'ExtensionProperties' )),
    COMMETHOD([helpstring(u'Informs the extension that its class helper is going away.')], HRESULT, 'Shutdown'),
]
################################################################
## code template for IClassExtension implementation
##class IClassExtension_Impl(object):
##    def Init(self, ClassHelper, ExtensionProperties):
##        u'Initializes the  extension, passing in a reference to its class helper.'
##        #return 
##
##    def Shutdown(self):
##        u'Informs the extension that its class helper is going away.'
##        #return 
##

INetworkGlobalTurnDelayCategory._methods_ = [
    COMMETHOD([helpstring(u'Initializes the seconds and specifies the referenced category of global turns.')], HRESULT, 'Initialize',
              ( ['in'], c_double, 'Seconds' ),
              ( ['in'], esriNetworkTurnAngleCategory, 'AngleCategory' ),
              ( ['in'], esriNetworkRoadCategory, 'FromRoadCategory' ),
              ( ['in'], esriNetworkRoadCategory, 'ToRoadCategory' ),
              ( ['in'], esriNetworkRoadCategory, 'CrossRoadCategory' )),
    COMMETHOD(['propget', helpstring(u'The expected traversal time in seconds of turns associated with this turn delay category (matching angle, from road, to road, and cross road categories).')], HRESULT, 'Seconds',
              ( ['retval', 'out'], POINTER(c_double), 'Seconds' )),
    COMMETHOD(['propput', helpstring(u'The expected traversal time in seconds of turns associated with this turn delay category (matching angle, from road, to road, and cross road categories).')], HRESULT, 'Seconds',
              ( ['in'], c_double, 'Seconds' )),
    COMMETHOD(['propget', helpstring(u'The turn angle category (straight, reverse, right, or left) of turns in this turn delay category.')], HRESULT, 'AngleCategory',
              ( ['retval', 'out'], POINTER(esriNetworkTurnAngleCategory), 'AngleCategory' )),
    COMMETHOD(['propget', helpstring(u'The road category of the from road of turns in this turn delay category.')], HRESULT, 'FromRoadCategory',
              ( ['retval', 'out'], POINTER(esriNetworkRoadCategory), 'FromRoadCategory' )),
    COMMETHOD(['propget', helpstring(u'The road category of the to road of turns in this turn delay category.')], HRESULT, 'ToRoadCategory',
              ( ['retval', 'out'], POINTER(esriNetworkRoadCategory), 'ToRoadCategory' )),
    COMMETHOD(['propget', helpstring(u'The road category of the most major cross road of turns in this turn delay category.')], HRESULT, 'CrossRoadCategory',
              ( ['retval', 'out'], POINTER(esriNetworkRoadCategory), 'CrossRoadCategory' )),
]
################################################################
## code template for INetworkGlobalTurnDelayCategory implementation
##class INetworkGlobalTurnDelayCategory_Impl(object):
##    @property
##    def AngleCategory(self):
##        u'The turn angle category (straight, reverse, right, or left) of turns in this turn delay category.'
##        #return AngleCategory
##
##    def _get(self):
##        u'The expected traversal time in seconds of turns associated with this turn delay category (matching angle, from road, to road, and cross road categories).'
##        #return Seconds
##    def _set(self, Seconds):
##        u'The expected traversal time in seconds of turns associated with this turn delay category (matching angle, from road, to road, and cross road categories).'
##    Seconds = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def CrossRoadCategory(self):
##        u'The road category of the most major cross road of turns in this turn delay category.'
##        #return CrossRoadCategory
##
##    @property
##    def ToRoadCategory(self):
##        u'The road category of the to road of turns in this turn delay category.'
##        #return ToRoadCategory
##
##    @property
##    def FromRoadCategory(self):
##        u'The road category of the from road of turns in this turn delay category.'
##        #return FromRoadCategory
##
##    def Initialize(self, Seconds, AngleCategory, FromRoadCategory, ToRoadCategory, CrossRoadCategory):
##        u'Initializes the seconds and specifies the referenced category of global turns.'
##        #return 
##

IObjectClassInfo2._methods_ = [
    COMMETHOD([helpstring(u'Indicates if updates to objects can bypass the Store method and OnChange notifications for efficiency.')], HRESULT, 'CanBypassStoreMethod',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'canBypassStore' )),
    COMMETHOD([helpstring(u'Indicates if updates to objects can be safely made outside of an edit session.')], HRESULT, 'CanBypassEditSession',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'CanBypassEditSession' )),
]
################################################################
## code template for IObjectClassInfo2 implementation
##class IObjectClassInfo2_Impl(object):
##    def CanBypassEditSession(self):
##        u'Indicates if updates to objects can be safely made outside of an edit session.'
##        #return CanBypassEditSession
##
##    def CanBypassStoreMethod(self):
##        u'Indicates if updates to objects can bypass the Store method and OnChange notifications for efficiency.'
##        #return canBypassStore
##

IValidation._methods_ = [
    COMMETHOD(['propget', helpstring(u'The rules associated with the class.')], HRESULT, 'Rules',
              ( ['retval', 'out'], POINTER(POINTER(IEnumRule)), 'Rules' )),
    COMMETHOD(['propget', helpstring(u'The rules associated with the attribute.')], HRESULT, 'RulesByField',
              ( ['in'], BSTR, 'FieldName' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumRule)), 'Rules' )),
    COMMETHOD(['propget', helpstring(u'The rules associated with the subtype.')], HRESULT, 'RulesBySubtypeCode',
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumRule)), 'Rules' )),
    COMMETHOD([helpstring(u'Adds the rule to the set of associated rules.')], HRESULT, 'AddRule',
              ( ['in'], POINTER(IRule), 'Rule' )),
    COMMETHOD([helpstring(u'Deletes the rule from the set of associated rules.')], HRESULT, 'DeleteRule',
              ( ['in'], POINTER(IRule), 'Rule' )),
    COMMETHOD([helpstring(u'Validates the selection.')], HRESULT, 'Validate',
              ( ['in'], POINTER(IQueryFilter), 'Selection' ),
              ( ['in'], POINTER(IWorkspace), 'Workspace' ),
              ( ['retval', 'out'], POINTER(POINTER(ISelectionSet)), 'invalidSet' )),
    COMMETHOD([helpstring(u'Validates the selection.')], HRESULT, 'ValidateSelection',
              ( ['in'], POINTER(ISelectionSet), 'Selection' ),
              ( ['in'], POINTER(IWorkspace), 'Workspace' ),
              ( ['retval', 'out'], POINTER(POINTER(ISelectionSet)), 'invalidSet' )),
    COMMETHOD([helpstring(u'Validates the set.')], HRESULT, 'ValidateSet',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet), 'Selection' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISet)), 'invalidSet' )),
]
################################################################
## code template for IValidation implementation
##class IValidation_Impl(object):
##    def ValidateSet(self, Selection):
##        u'Validates the set.'
##        #return invalidSet
##
##    def ValidateSelection(self, Selection, Workspace):
##        u'Validates the selection.'
##        #return invalidSet
##
##    @property
##    def Rules(self):
##        u'The rules associated with the class.'
##        #return Rules
##
##    @property
##    def RulesBySubtypeCode(self, SubtypeCode):
##        u'The rules associated with the subtype.'
##        #return Rules
##
##    def DeleteRule(self, Rule):
##        u'Deletes the rule from the set of associated rules.'
##        #return 
##
##    def AddRule(self, Rule):
##        u'Adds the rule to the set of associated rules.'
##        #return 
##
##    def Validate(self, Selection, Workspace):
##        u'Validates the selection.'
##        #return invalidSet
##
##    @property
##    def RulesByField(self, FieldName):
##        u'The rules associated with the attribute.'
##        #return Rules
##

INetworkGlobalTurnDelayEvaluator._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates whether to use custom road category ranges.')], HRESULT, 'UseCustomRoadCategoryRanges',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'Flag' )),
    COMMETHOD(['propput', helpstring(u'Indicates whether to use custom road category ranges.')], HRESULT, 'UseCustomRoadCategoryRanges',
              ( ['in'], VARIANT_BOOL, 'Flag' )),
    COMMETHOD([helpstring(u'Set custom road category maximum values.')], HRESULT, 'SetCustomRoadCategoryMaxValues',
              ( ['in'], c_int, 'maxPrimaryRoadValue' ),
              ( ['in'], c_int, 'maxSecondaryRoadValue' )),
    COMMETHOD(['propget', helpstring(u'Custom Primary road category maximum value.')], HRESULT, 'CustomPrimaryRoadCategoryMaxValue',
              ( ['retval', 'out'], POINTER(c_int), 'MaxValue' )),
    COMMETHOD(['propget', helpstring(u'Custom Secondary road category maximum value.')], HRESULT, 'CustomSecondaryRoadCategoryMaxValue',
              ( ['retval', 'out'], POINTER(c_int), 'MaxValue' )),
    COMMETHOD(['propget', helpstring(u'Default traversal time in seconds (for undefined turn delay categories).')], HRESULT, 'DefaultSeconds',
              ( ['retval', 'out'], POINTER(c_double), 'Seconds' )),
    COMMETHOD(['propput', helpstring(u'Default traversal time in seconds (for undefined turn delay categories).')], HRESULT, 'DefaultSeconds',
              ( ['in'], c_double, 'Seconds' )),
    COMMETHOD(['propget', helpstring(u'Array of global turn delay categories in this evaluator.')], HRESULT, 'TurnDelayCategories',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray)), 'categories' )),
    COMMETHOD(['propputref', helpstring(u'Array of global turn delay categories in this evaluator.')], HRESULT, 'TurnDelayCategories',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IArray), 'categories' )),
    COMMETHOD(['propget', helpstring(u'The maximum deviation from a pure straight turn to be classified as a straight turn.')], HRESULT, 'MaxStraightTurnDeflectionAngle',
              ( ['retval', 'out'], POINTER(c_int), 'maxDeflectionAngle' )),
    COMMETHOD(['propput', helpstring(u'The maximum deviation from a pure straight turn to be classified as a straight turn.')], HRESULT, 'MaxStraightTurnDeflectionAngle',
              ( ['in'], c_int, 'maxDeflectionAngle' )),
    COMMETHOD(['propget', helpstring(u'The maximum deviation from a pure reverse turn to be classified as a reverse turn.')], HRESULT, 'MaxReverseTurnDeflectionAngle',
              ( ['retval', 'out'], POINTER(c_int), 'maxDeflectionAngle' )),
    COMMETHOD(['propput', helpstring(u'The maximum deviation from a pure reverse turn to be classified as a reverse turn.')], HRESULT, 'MaxReverseTurnDeflectionAngle',
              ( ['in'], c_int, 'maxDeflectionAngle' )),
]
################################################################
## code template for INetworkGlobalTurnDelayEvaluator implementation
##class INetworkGlobalTurnDelayEvaluator_Impl(object):
##    def SetCustomRoadCategoryMaxValues(self, maxPrimaryRoadValue, maxSecondaryRoadValue):
##        u'Set custom road category maximum values.'
##        #return 
##
##    def TurnDelayCategories(self, categories):
##        u'Array of global turn delay categories in this evaluator.'
##        #return 
##
##    def _get(self):
##        u'The maximum deviation from a pure straight turn to be classified as a straight turn.'
##        #return maxDeflectionAngle
##    def _set(self, maxDeflectionAngle):
##        u'The maximum deviation from a pure straight turn to be classified as a straight turn.'
##    MaxStraightTurnDeflectionAngle = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def CustomPrimaryRoadCategoryMaxValue(self):
##        u'Custom Primary road category maximum value.'
##        #return MaxValue
##
##    @property
##    def CustomSecondaryRoadCategoryMaxValue(self):
##        u'Custom Secondary road category maximum value.'
##        #return MaxValue
##
##    def _get(self):
##        u'Default traversal time in seconds (for undefined turn delay categories).'
##        #return Seconds
##    def _set(self, Seconds):
##        u'Default traversal time in seconds (for undefined turn delay categories).'
##    DefaultSeconds = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates whether to use custom road category ranges.'
##        #return Flag
##    def _set(self, Flag):
##        u'Indicates whether to use custom road category ranges.'
##    UseCustomRoadCategoryRanges = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The maximum deviation from a pure reverse turn to be classified as a reverse turn.'
##        #return maxDeflectionAngle
##    def _set(self, maxDeflectionAngle):
##        u'The maximum deviation from a pure reverse turn to be classified as a reverse turn.'
##    MaxReverseTurnDeflectionAngle = property(_get, _set, doc = _set.__doc__)
##

IRowSubtypes._methods_ = [
    COMMETHOD(['propget', helpstring(u'The subtype for the row.')], HRESULT, 'SubtypeCode',
              ( ['retval', 'out'], POINTER(c_int), 'SubtypeCode' )),
    COMMETHOD(['propput', helpstring(u'The subtype for the row.')], HRESULT, 'SubtypeCode',
              ( ['in'], c_int, 'SubtypeCode' )),
    COMMETHOD([helpstring(u'The default values of the row.')], HRESULT, 'InitDefaultValues'),
]
################################################################
## code template for IRowSubtypes implementation
##class IRowSubtypes_Impl(object):
##    def InitDefaultValues(self):
##        u'The default values of the row.'
##        #return 
##
##    def _get(self):
##        u'The subtype for the row.'
##        #return SubtypeCode
##    def _set(self, SubtypeCode):
##        u'The subtype for the row.'
##    SubtypeCode = property(_get, _set, doc = _set.__doc__)
##

class IObjectClassExtension(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Indicator interface for object class extensions.'
    _iid_ = GUID('{01B7E2D1-E2EE-11D2-8A56-000000000000}')
    _idlflags_ = ['oleautomation']
IObjectClassExtension._methods_ = [
]
################################################################
## code template for IObjectClassExtension implementation
##class IObjectClassExtension_Impl(object):

IConflictClass._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the conflict class contains conflicts.')], HRESULT, 'HasConflicts',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasConflicts' )),
    COMMETHOD(['propget', helpstring(u'The selection set of all the objects which are update/delete conflicts.')], HRESULT, 'UpdateDeletes',
              ( ['retval', 'out'], POINTER(POINTER(ISelectionSet)), 'updateDeleteSet' )),
    COMMETHOD(['propget', helpstring(u'The selection set of all the objects which are delete/update conflicts.')], HRESULT, 'DeleteUpdates',
              ( ['retval', 'out'], POINTER(POINTER(ISelectionSet)), 'deleteUpdateSet' )),
    COMMETHOD(['propget', helpstring(u'The selection set of all the objects which are update/update conflicts.')], HRESULT, 'UpdateUpdates',
              ( ['retval', 'out'], POINTER(POINTER(ISelectionSet)), 'updateUpdateSet' )),
    COMMETHOD([helpstring(u'Restores the row from either the reconcile version or the prereconcile version.')], HRESULT, 'RestoreRow',
              ( ['in'], c_int, 'rowID' ),
              ( ['retval', 'out'], POINTER(POINTER(IRow)), 'Row' )),
]
################################################################
## code template for IConflictClass implementation
##class IConflictClass_Impl(object):
##    @property
##    def UpdateDeletes(self):
##        u'The selection set of all the objects which are update/delete conflicts.'
##        #return updateDeleteSet
##
##    def RestoreRow(self, rowID):
##        u'Restores the row from either the reconcile version or the prereconcile version.'
##        #return Row
##
##    @property
##    def DeleteUpdates(self):
##        u'The selection set of all the objects which are delete/update conflicts.'
##        #return deleteUpdateSet
##
##    @property
##    def HasConflicts(self):
##        u'Indicates if the conflict class contains conflicts.'
##        #return HasConflicts
##
##    @property
##    def UpdateUpdates(self):
##        u'The selection set of all the objects which are update/update conflicts.'
##        #return updateUpdateSet
##

IMemoryRelationshipClassName._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name object for the origin table of the memory relationship.')], HRESULT, 'OriginName',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'OriginName' )),
    COMMETHOD(['propputref', helpstring(u'The name object for the origin table of the memory relationship.')], HRESULT, 'OriginName',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'OriginName' )),
    COMMETHOD(['propget', helpstring(u'The name object of the destination class of the memory relationship.')], HRESULT, 'DestinationName',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'DestinationName' )),
    COMMETHOD(['propputref', helpstring(u'The name object of the destination class of the memory relationship.')], HRESULT, 'DestinationName',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'DestinationName' )),
    COMMETHOD(['propget', helpstring(u'The forward label of the relationship.')], HRESULT, 'ForwardPathLabel',
              ( ['retval', 'out'], POINTER(BSTR), 'ForwardLabel' )),
    COMMETHOD(['propput', helpstring(u'The forward label of the relationship.')], HRESULT, 'ForwardPathLabel',
              ( ['in'], BSTR, 'ForwardLabel' )),
    COMMETHOD(['propget', helpstring(u'The back label of the relationship.')], HRESULT, 'BackwardPathLabel',
              ( ['retval', 'out'], POINTER(BSTR), 'backLabel' )),
    COMMETHOD(['propput', helpstring(u'The back label of the relationship.')], HRESULT, 'BackwardPathLabel',
              ( ['in'], BSTR, 'backLabel' )),
    COMMETHOD(['propget', helpstring(u'Origin primary key field name.')], HRESULT, 'OriginPrimaryKey',
              ( ['retval', 'out'], POINTER(BSTR), 'OriginPrimaryKey' )),
    COMMETHOD(['propput', helpstring(u'Origin primary key field name.')], HRESULT, 'OriginPrimaryKey',
              ( ['in'], BSTR, 'OriginPrimaryKey' )),
    COMMETHOD(['propget', helpstring(u'Origin foreign key field name.')], HRESULT, 'OriginForeignKey',
              ( ['retval', 'out'], POINTER(BSTR), 'OriginPrimaryKey' )),
    COMMETHOD(['propput', helpstring(u'Origin foreign key field name.')], HRESULT, 'OriginForeignKey',
              ( ['in'], BSTR, 'OriginPrimaryKey' )),
]
################################################################
## code template for IMemoryRelationshipClassName implementation
##class IMemoryRelationshipClassName_Impl(object):
##    def _get(self):
##        u'Origin primary key field name.'
##        #return OriginPrimaryKey
##    def _set(self, OriginPrimaryKey):
##        u'Origin primary key field name.'
##    OriginPrimaryKey = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The back label of the relationship.'
##        #return backLabel
##    def _set(self, backLabel):
##        u'The back label of the relationship.'
##    BackwardPathLabel = property(_get, _set, doc = _set.__doc__)
##
##    def DestinationName(self, DestinationName):
##        u'The name object of the destination class of the memory relationship.'
##        #return 
##
##    def _get(self):
##        u'Origin foreign key field name.'
##        #return OriginPrimaryKey
##    def _set(self, OriginPrimaryKey):
##        u'Origin foreign key field name.'
##    OriginForeignKey = property(_get, _set, doc = _set.__doc__)
##
##    def OriginName(self, OriginName):
##        u'The name object for the origin table of the memory relationship.'
##        #return 
##
##    def _get(self):
##        u'The forward label of the relationship.'
##        #return ForwardLabel
##    def _set(self, ForwardLabel):
##        u'The forward label of the relationship.'
##    ForwardPathLabel = property(_get, _set, doc = _set.__doc__)
##

INetworkDatasetName._methods_ = [
    COMMETHOD(['propget', helpstring(u'Name of feature dataset containing the network dataset.')], HRESULT, 'FeatureDatasetName',
              ( ['retval', 'out'], POINTER(POINTER(IDatasetName)), 'Name' )),
    COMMETHOD(['propputref', helpstring(u'Name of feature dataset containing the network dataset.')], HRESULT, 'FeatureDatasetName',
              ( ['in'], POINTER(IDatasetName), 'Name' )),
]
################################################################
## code template for INetworkDatasetName implementation
##class INetworkDatasetName_Impl(object):
##    def FeatureDatasetName(self, Name):
##        u'Name of feature dataset containing the network dataset.'
##        #return 
##

IRelationshipClassName._methods_ = [
    COMMETHOD(['propget', helpstring(u'The Feature Dataset Name object.')], HRESULT, 'FeatureDatasetName',
              ( ['retval', 'out'], POINTER(POINTER(IDatasetName)), 'FeatureDatasetName' )),
    COMMETHOD(['propputref', helpstring(u'The Feature Dataset Name object.')], HRESULT, 'FeatureDatasetName',
              ( ['in'], POINTER(IDatasetName), 'FeatureDatasetName' )),
    COMMETHOD(['propget', helpstring(u'The Cardinality.')], HRESULT, 'Cardinality',
              ( ['retval', 'out'], POINTER(esriRelCardinality), 'Cardinality' )),
    COMMETHOD(['propput', helpstring(u'The Cardinality.')], HRESULT, 'Cardinality',
              ( ['in'], esriRelCardinality, 'Cardinality' )),
    COMMETHOD(['propget', helpstring(u'The Notification.')], HRESULT, 'Notification',
              ( ['retval', 'out'], POINTER(esriRelNotification), 'Notification' )),
    COMMETHOD(['propput', helpstring(u'The Notification.')], HRESULT, 'Notification',
              ( ['in'], esriRelNotification, 'Notification' )),
    COMMETHOD(['propget', helpstring(u'Indicates if Composite.')], HRESULT, 'IsComposite',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsComposite' )),
    COMMETHOD(['propput', helpstring(u'Indicates if Composite.')], HRESULT, 'IsComposite',
              ( ['in'], VARIANT_BOOL, 'IsComposite' )),
    COMMETHOD(['propget', helpstring(u'Indicates if Attributed.')], HRESULT, 'IsAttributed',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsAttributed' )),
    COMMETHOD(['propput', helpstring(u'Indicates if Attributed.')], HRESULT, 'IsAttributed',
              ( ['in'], VARIANT_BOOL, 'IsAttributed' )),
]
################################################################
## code template for IRelationshipClassName implementation
##class IRelationshipClassName_Impl(object):
##    def _get(self):
##        u'Indicates if Attributed.'
##        #return IsAttributed
##    def _set(self, IsAttributed):
##        u'Indicates if Attributed.'
##    IsAttributed = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The Notification.'
##        #return Notification
##    def _set(self, Notification):
##        u'The Notification.'
##    Notification = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if Composite.'
##        #return IsComposite
##    def _set(self, IsComposite):
##        u'Indicates if Composite.'
##    IsComposite = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The Cardinality.'
##        #return Cardinality
##    def _set(self, Cardinality):
##        u'The Cardinality.'
##    Cardinality = property(_get, _set, doc = _set.__doc__)
##
##    def FeatureDatasetName(self, FeatureDatasetName):
##        u'The Feature Dataset Name object.'
##        #return 
##

class ILocatorDataset(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members for retrieving objects associated with the Locator.'
    _iid_ = GUID('{FDADFAE4-939D-11D3-9F6B-00C04F6BDF06}')
    _idlflags_ = ['oleautomation']
ILocatorDataset._methods_ = [
    COMMETHOD(['propget', helpstring(u'The Name object for the locator.')], HRESULT, 'FullName',
              ( ['retval', 'out'], POINTER(POINTER(ILocatorName)), 'ppLocName' )),
    COMMETHOD(['propget', helpstring(u'The locator workspace that contains the locator.')], HRESULT, 'LocatorWorkspace',
              ( ['retval', 'out'], POINTER(POINTER(ILocatorWorkspace)), 'LocatorWorkspace' )),
]
################################################################
## code template for ILocatorDataset implementation
##class ILocatorDataset_Impl(object):
##    @property
##    def LocatorWorkspace(self):
##        u'The locator workspace that contains the locator.'
##        #return LocatorWorkspace
##
##    @property
##    def FullName(self):
##        u'The Name object for the locator.'
##        #return ppLocName
##

class IEnumSubtype(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate subtypes.'
    _iid_ = GUID('{F6289406-8952-11D2-AABC-00C04FA37B82}')
    _idlflags_ = ['oleautomation']
ISubtypes._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the table has subtypes.')], HRESULT, 'HasSubtype',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasSubtype' )),
    COMMETHOD(['propget', helpstring(u'The default subtype associated with the class.')], HRESULT, 'DefaultSubtypeCode',
              ( ['retval', 'out'], POINTER(c_int), 'SubtypeCode' )),
    COMMETHOD(['propput', helpstring(u'The default subtype associated with the class.')], HRESULT, 'DefaultSubtypeCode',
              ( ['in'], c_int, 'SubtypeCode' )),
    COMMETHOD(['propget', helpstring(u'The default value for the associated attribute.')], HRESULT, 'DefaultValue',
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['in'], BSTR, 'FieldName' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'Value' )),
    COMMETHOD(['propput', helpstring(u'The default value for the associated attribute.')], HRESULT, 'DefaultValue',
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['in'], BSTR, 'FieldName' ),
              ( ['in'], VARIANT, 'Value' )),
    COMMETHOD(['propget', helpstring(u'The domain given the subtype and field.')], HRESULT, 'Domain',
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['in'], BSTR, 'FieldName' ),
              ( ['retval', 'out'], POINTER(POINTER(IDomain)), 'Domain' )),
    COMMETHOD(['propputref', helpstring(u'The domain given the subtype and field.')], HRESULT, 'Domain',
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['in'], BSTR, 'FieldName' ),
              ( ['in'], POINTER(IDomain), 'Domain' )),
    COMMETHOD(['propget', helpstring(u'The subtype field name.')], HRESULT, 'SubtypeFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'FieldName' )),
    COMMETHOD(['propput', helpstring(u'The subtype field name.')], HRESULT, 'SubtypeFieldName',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD(['propget', helpstring(u'The subtype field index.')], HRESULT, 'SubtypeFieldIndex',
              ( ['retval', 'out'], POINTER(c_int), 'Index' )),
    COMMETHOD(['propget', helpstring(u'The subtype name.')], HRESULT, 'SubtypeName',
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['retval', 'out'], POINTER(BSTR), 'SubtypeName' )),
    COMMETHOD(['propget', helpstring(u'The subtypes associated with the class.')], HRESULT, 'Subtypes',
              ( ['retval', 'out'], POINTER(POINTER(IEnumSubtype)), 'Subtypes' )),
    COMMETHOD([helpstring(u'Adds the subtype to the set of associated subtypes.')], HRESULT, 'AddSubtype',
              ( ['in'], c_int, 'SubtypeCode' ),
              ( ['in'], BSTR, 'SubtypeName' )),
    COMMETHOD([helpstring(u'Deletes the subtype from the set of associated subtypes.')], HRESULT, 'DeleteSubtype',
              ( ['in'], c_int, 'SubtypeCode' )),
]
################################################################
## code template for ISubtypes implementation
##class ISubtypes_Impl(object):
##    def DeleteSubtype(self, SubtypeCode):
##        u'Deletes the subtype from the set of associated subtypes.'
##        #return 
##
##    def Domain(self, SubtypeCode, FieldName, Domain):
##        u'The domain given the subtype and field.'
##        #return 
##
##    @property
##    def HasSubtype(self):
##        u'Indicates if the table has subtypes.'
##        #return HasSubtype
##
##    @property
##    def SubtypeName(self, SubtypeCode):
##        u'The subtype name.'
##        #return SubtypeName
##
##    def _get(self, SubtypeCode, FieldName):
##        u'The default value for the associated attribute.'
##        #return Value
##    def _set(self, SubtypeCode, FieldName, Value):
##        u'The default value for the associated attribute.'
##    DefaultValue = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The default subtype associated with the class.'
##        #return SubtypeCode
##    def _set(self, SubtypeCode):
##        u'The default subtype associated with the class.'
##    DefaultSubtypeCode = property(_get, _set, doc = _set.__doc__)
##
##    def AddSubtype(self, SubtypeCode, SubtypeName):
##        u'Adds the subtype to the set of associated subtypes.'
##        #return 
##
##    def _get(self):
##        u'The subtype field name.'
##        #return FieldName
##    def _set(self, FieldName):
##        u'The subtype field name.'
##    SubtypeFieldName = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def Subtypes(self):
##        u'The subtypes associated with the class.'
##        #return Subtypes
##
##    @property
##    def SubtypeFieldIndex(self):
##        u'The subtype field index.'
##        #return Index
##

IEnumSubtype._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next Subtype in the enumeration sequence.')], HRESULT, 'Next',
              ( ['out'], POINTER(c_int), 'SubtypeCode' ),
              ( ['retval', 'out'], POINTER(BSTR), 'SubtypeName' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumSubtype implementation
##class IEnumSubtype_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next Subtype in the enumeration sequence.'
##        #return SubtypeCode, SubtypeName
##

IEnumDatasetType._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next dataset type in the set.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(esriDatasetType), 'Type' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumDatasetType implementation
##class IEnumDatasetType_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next dataset type in the set.'
##        #return Type
##

IJunctionConnectivityRule2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the junction corresponds to the default junction.')], HRESULT, 'DefaultJunction',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isDefaultJunction' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the junction corresponds to the default junction.')], HRESULT, 'DefaultJunction',
              ( ['in'], VARIANT_BOOL, 'isDefaultJunction' )),
]
################################################################
## code template for IJunctionConnectivityRule2 implementation
##class IJunctionConnectivityRule2_Impl(object):
##    def _get(self):
##        u'Indicates if the junction corresponds to the default junction.'
##        #return isDefaultJunction
##    def _set(self, isDefaultJunction):
##        u'Indicates if the junction corresponds to the default junction.'
##    DefaultJunction = property(_get, _set, doc = _set.__doc__)
##

class IEventSourceErrors(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that deal with event source errors.'
    _iid_ = GUID('{A9EB56E1-7452-11D4-9FE4-00C04F6BDF06}')
    _idlflags_ = ['oleautomation']
IEventSourceErrors._methods_ = [
    COMMETHOD([helpstring(u'The enumerator of the event source errors.')], HRESULT, 'GetErrors',
              ( ['retval', 'out'], POINTER(POINTER(IEnumEventError)), 'eventErrors' )),
    COMMETHOD([helpstring(u'The cursor of the events with locating errors.')], HRESULT, 'GetErrorCursor',
              ( ['in'], POINTER(IQueryFilter), 'filter' ),
              ( ['retval', 'out'], POINTER(POINTER(ICursor)), 'Cursor' )),
    COMMETHOD([helpstring(u"The locating error associated with an event's OID.")], HRESULT, 'GetLocatingErrorOID',
              ( ['in'], c_int, 'OID' ),
              ( ['retval', 'out'], POINTER(esriLocatingError), 'locatingError' )),
    COMMETHOD([helpstring(u'The locating error associated with a row.')], HRESULT, 'GetLocatingErrorRow',
              ( ['in'], POINTER(IRow), 'Row' ),
              ( ['retval', 'out'], POINTER(esriLocatingError), 'locatingError' )),
]
################################################################
## code template for IEventSourceErrors implementation
##class IEventSourceErrors_Impl(object):
##    def GetErrors(self):
##        u'The enumerator of the event source errors.'
##        #return eventErrors
##
##    def GetLocatingErrorOID(self, OID):
##        u"The locating error associated with an event's OID."
##        #return locatingError
##
##    def GetLocatingErrorRow(self, Row):
##        u'The locating error associated with a row.'
##        #return locatingError
##
##    def GetErrorCursor(self, filter):
##        u'The cursor of the events with locating errors.'
##        #return Cursor
##

IValidation2._methods_ = [
    COMMETHOD([helpstring(u'Alter the existing validation rule.')], HRESULT, 'AlterRule',
              ( ['in'], POINTER(IRule), 'Rule' )),
]
################################################################
## code template for IValidation2 implementation
##class IValidation2_Impl(object):
##    def AlterRule(self, Rule):
##        u'Alter the existing validation rule.'
##        #return 
##

IEnumGeometryBind._methods_ = [
    COMMETHOD([helpstring(u'Bind the source of the geometry to the enumeration.')], HRESULT, 'BindGeometrySource',
              ( [], POINTER(IQueryFilter), 'OutputFilter' ),
              ( ['in'], POINTER(IUnknown), 'collectionSource' )),
    COMMETHOD(['propget', helpstring(u'The geometry source - either a feature class or a selection set.')], HRESULT, 'GeometrySource',
              ( [], POINTER(POINTER(IUnknown)), 'GeometrySource' )),
    COMMETHOD(['propget', helpstring(u'The query filter that was used to bind the geometry source.')], HRESULT, 'OutputFilter',
              ( [], POINTER(POINTER(IQueryFilter)), 'OutputFilter' )),
]
################################################################
## code template for IEnumGeometryBind implementation
##class IEnumGeometryBind_Impl(object):
##    @property
##    def GeometrySource(self, GeometrySource):
##        u'The geometry source - either a feature class or a selection set.'
##        #return 
##
##    def BindGeometrySource(self, OutputFilter, collectionSource):
##        u'Bind the source of the geometry to the enumeration.'
##        #return 
##
##    @property
##    def OutputFilter(self, OutputFilter):
##        u'The query filter that was used to bind the geometry source.'
##        #return 
##

class IFeatureClassDraw(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that set customized drawing properties.'
    _iid_ = GUID('{AE0603C6-A98B-11D2-AADA-00C04FA37B82}')
    _idlflags_ = ['oleautomation']
IFeatureClassDraw._methods_ = [
    COMMETHOD(['propget', helpstring(u'The required fields for drawing a Feature.')], HRESULT, 'RequiredFieldsForDraw',
              ( ['retval', 'out'], POINTER(POINTER(IFields)), 'Fields' )),
    COMMETHOD([helpstring(u'Indicates whether the FeatureClass does custom drawing.')], HRESULT, 'DoesCustomDrawing',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'doesDrawing' )),
    COMMETHOD(['propget', helpstring(u'The custom renderer for the FeatureClass.')], HRESULT, 'CustomRenderer',
              ( ['retval', 'out'], POINTER(VARIANT), 'rendererIUnk' )),
    COMMETHOD(['propget', helpstring(u"The custom renderer's property page CLSID.")], HRESULT, 'CustomRendererPropPageCLSID',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'CLSID' )),
    COMMETHOD(['propget', helpstring(u'Indicates whether the custom renderer is exclusive or not.')], HRESULT, 'ExclusiveCustomRenderer',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isExclusive' )),
    COMMETHOD([helpstring(u'Indicates whether the feature class has a custom renderer.')], HRESULT, 'HasCustomRenderer',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'hasRenderer' )),
]
################################################################
## code template for IFeatureClassDraw implementation
##class IFeatureClassDraw_Impl(object):
##    @property
##    def ExclusiveCustomRenderer(self):
##        u'Indicates whether the custom renderer is exclusive or not.'
##        #return isExclusive
##
##    @property
##    def CustomRenderer(self):
##        u'The custom renderer for the FeatureClass.'
##        #return rendererIUnk
##
##    def DoesCustomDrawing(self):
##        u'Indicates whether the FeatureClass does custom drawing.'
##        #return doesDrawing
##
##    @property
##    def CustomRendererPropPageCLSID(self):
##        u"The custom renderer's property page CLSID."
##        #return CLSID
##
##    def HasCustomRenderer(self):
##        u'Indicates whether the feature class has a custom renderer.'
##        #return hasRenderer
##
##    @property
##    def RequiredFieldsForDraw(self):
##        u'The required fields for drawing a Feature.'
##        #return Fields
##

ITinAdvanced3._methods_ = [
    COMMETHOD(['propget', helpstring(u'Returns the version number of the TIN dataset.')], HRESULT, 'TinVersion',
              ( ['retval', 'out'], POINTER(esriTinVersion), 'pVersion' )),
    COMMETHOD([helpstring(u'Gets previous edge index in triangle.')], HRESULT, 'GetPreviousEdgeIndexInTriangle',
              ( ['in'], c_int, 'edgeIndex' ),
              ( ['retval', 'out'], POINTER(c_int), 'pIndex' )),
    COMMETHOD([helpstring(u'Gets next edge index in triangle.')], HRESULT, 'GetNextEdgeIndexInTriangle',
              ( ['in'], c_int, 'edgeIndex' ),
              ( ['retval', 'out'], POINTER(c_int), 'pIndex' )),
    COMMETHOD([helpstring(u'Gets next clockwise edge index.')], HRESULT, 'GetNextCWEdgeIndex',
              ( ['in'], c_int, 'edgeIndex' ),
              ( ['retval', 'out'], POINTER(c_int), 'pIndex' )),
    COMMETHOD([helpstring(u'Gets next counter clockwise edge index.')], HRESULT, 'GetNextCCWEdgeIndex',
              ( ['in'], c_int, 'edgeIndex' ),
              ( ['retval', 'out'], POINTER(c_int), 'pIndex' )),
    COMMETHOD([helpstring(u'Returns the indices of all elements connected to the specified node.')], HRESULT, 'QueryElementIndicesAroundNode',
              ( ['in'], esriTinElementType, 'Type' ),
              ( ['in'], c_int, 'localNodeIndex' ),
              ( ['in'], c_int, 'triangleIndex' ),
              ( [], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ILongArray), 'pIndices' )),
]
################################################################
## code template for ITinAdvanced3 implementation
##class ITinAdvanced3_Impl(object):
##    def GetNextEdgeIndexInTriangle(self, edgeIndex):
##        u'Gets next edge index in triangle.'
##        #return pIndex
##
##    @property
##    def TinVersion(self):
##        u'Returns the version number of the TIN dataset.'
##        #return pVersion
##
##    def GetNextCWEdgeIndex(self, edgeIndex):
##        u'Gets next clockwise edge index.'
##        #return pIndex
##
##    def GetPreviousEdgeIndexInTriangle(self, edgeIndex):
##        u'Gets previous edge index in triangle.'
##        #return pIndex
##
##    def QueryElementIndicesAroundNode(self, Type, localNodeIndex, triangleIndex, pIndices):
##        u'Returns the indices of all elements connected to the specified node.'
##        #return 
##
##    def GetNextCCWEdgeIndex(self, edgeIndex):
##        u'Gets next counter clockwise edge index.'
##        #return pIndex
##

IGPReplicaOptions._methods_ = [
    COMMETHOD(['propput', helpstring(u'Indicates if the child replica will be the first sender.')], HRESULT, 'IsChildFirstSender',
              ( ['in'], VARIANT_BOOL, 'childIsFirstSender' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the child replica will be the first sender.')], HRESULT, 'IsChildFirstSender',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'childIsFirstSender' )),
    COMMETHOD(['propput', helpstring(u'The replica access type.')], HRESULT, 'AccessType',
              ( ['in'], esriReplicaAccessType, 'AccessType' )),
    COMMETHOD(['propget', helpstring(u'The replica access type.')], HRESULT, 'AccessType',
              ( ['retval', 'out'], POINTER(esriReplicaAccessType), 'AccessType' )),
    COMMETHOD(['propput', helpstring(u'The childs replica reconcile property.')], HRESULT, 'ChildReconcilePolicy',
              ( ['in'], esriReplicaReconcilePolicyType, 'childPolicy' )),
    COMMETHOD(['propget', helpstring(u'The childs replica reconcile property.')], HRESULT, 'ChildReconcilePolicy',
              ( ['retval', 'out'], POINTER(esriReplicaReconcilePolicyType), 'childPolicy' )),
    COMMETHOD(['propput', helpstring(u'The parents replica reconcile policy.')], HRESULT, 'ParentReconcilePolicy',
              ( ['in'], esriReplicaReconcilePolicyType, 'parentPolicy' )),
    COMMETHOD(['propget', helpstring(u'The parents replica reconcile policy.')], HRESULT, 'ParentReconcilePolicy',
              ( ['retval', 'out'], POINTER(esriReplicaReconcilePolicyType), 'parentPolicy' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the replica will be created using the register existing data only option.')], HRESULT, 'RegisterReplicaOnly',
              ( ['in'], VARIANT_BOOL, 'registerReplicaData' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the replica will be created using the register existing data only option.')], HRESULT, 'RegisterReplicaOnly',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'registerReplicaData' )),
    COMMETHOD(['propput', helpstring(u'The connection string for the child geodatabase.')], HRESULT, 'ChildConnectionString',
              ( ['in'], BSTR, 'ChildConnectionString' )),
    COMMETHOD(['propget', helpstring(u'The connection string for the child geodatabase.')], HRESULT, 'ChildConnectionString',
              ( ['retval', 'out'], POINTER(BSTR), 'ChildConnectionString' )),
    COMMETHOD(['propput', helpstring(u'The connection string for the parent geodatabase.')], HRESULT, 'ParentConnectionString',
              ( ['in'], BSTR, 'ParentConnectionString' )),
    COMMETHOD(['propget', helpstring(u'The connection string for the parent geodatabase.')], HRESULT, 'ParentConnectionString',
              ( ['retval', 'out'], POINTER(BSTR), 'ParentConnectionString' )),
]
################################################################
## code template for IGPReplicaOptions implementation
##class IGPReplicaOptions_Impl(object):
##    def _get(self):
##        u'The childs replica reconcile property.'
##        #return childPolicy
##    def _set(self, childPolicy):
##        u'The childs replica reconcile property.'
##    ChildReconcilePolicy = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The replica access type.'
##        #return AccessType
##    def _set(self, AccessType):
##        u'The replica access type.'
##    AccessType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the replica will be created using the register existing data only option.'
##        #return registerReplicaData
##    def _set(self, registerReplicaData):
##        u'Indicates if the replica will be created using the register existing data only option.'
##    RegisterReplicaOnly = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The connection string for the parent geodatabase.'
##        #return ParentConnectionString
##    def _set(self, ParentConnectionString):
##        u'The connection string for the parent geodatabase.'
##    ParentConnectionString = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The parents replica reconcile policy.'
##        #return parentPolicy
##    def _set(self, parentPolicy):
##        u'The parents replica reconcile policy.'
##    ParentReconcilePolicy = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if the child replica will be the first sender.'
##        #return childIsFirstSender
##    def _set(self, childIsFirstSender):
##        u'Indicates if the child replica will be the first sender.'
##    IsChildFirstSender = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'The connection string for the child geodatabase.'
##        #return ChildConnectionString
##    def _set(self, ChildConnectionString):
##        u'The connection string for the child geodatabase.'
##    ChildConnectionString = property(_get, _set, doc = _set.__doc__)
##

class IFeatureClassEdit(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to information about feature class editing properties.'
    _iid_ = GUID('{A5D5E364-FEA9-11D3-A052-00C04F6BDD84}')
    _idlflags_ = ['oleautomation']
IFeatureClassEdit._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the associated feature class can be edited in projected spaces.')], HRESULT, 'CanEditWithProjection',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsEditable' )),
    COMMETHOD([helpstring(u'True if the feature class has a custom split policy for handling relationships.')], HRESULT, 'HasCustomSplitPolicyForRelationship',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'hasCustomPolicy' )),
    COMMETHOD(['propget', helpstring(u'The custom split policy for handling relationships.')], HRESULT, 'CustomSplitPolicyForRelationship',
              ( ['in'], POINTER(IRow), 'Row' ),
              ( ['in'], POINTER(IRelationshipClass), 'relClass' ),
              ( ['retval', 'out'], POINTER(esriRelationshipSplitPolicy), 'policy' )),
]
################################################################
## code template for IFeatureClassEdit implementation
##class IFeatureClassEdit_Impl(object):
##    @property
##    def CanEditWithProjection(self):
##        u'Indicates if the associated feature class can be edited in projected spaces.'
##        #return IsEditable
##
##    @property
##    def CustomSplitPolicyForRelationship(self, Row, relClass):
##        u'The custom split policy for handling relationships.'
##        #return policy
##
##    def HasCustomSplitPolicyForRelationship(self):
##        u'True if the feature class has a custom split policy for handling relationships.'
##        #return hasCustomPolicy
##

IEnumNetEIDBuilderGEN._methods_ = [
    COMMETHOD(['propputref', helpstring(u'Network from which these elements came.')], HRESULT, 'Network',
              ( ['in'], POINTER(INetwork), 'rhs' )),
    COMMETHOD([helpstring(u'Adds an element to this EID enumeration.')], HRESULT, 'Add',
              ( ['in'], c_int, 'EID' )),
    COMMETHOD(['propput', helpstring(u'Type of network elements to be in this enumeration.')], HRESULT, 'ElementType',
              ( ['in'], esriElementType, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Array of EIDs in this enumeration.')], HRESULT, 'EIDs',
              ( ['in'], POINTER(_midlSAFEARRAY(c_int)), 'rhs' )),
]
################################################################
## code template for IEnumNetEIDBuilderGEN implementation
##class IEnumNetEIDBuilderGEN_Impl(object):
##    def Add(self, EID):
##        u'Adds an element to this EID enumeration.'
##        #return 
##
##    def _set(self, rhs):
##        u'Type of network elements to be in this enumeration.'
##    ElementType = property(fset = _set, doc = _set.__doc__)
##
##    def Network(self, rhs):
##        u'Network from which these elements came.'
##        #return 
##
##    def _set(self, rhs):
##        u'Array of EIDs in this enumeration.'
##    EIDs = property(fset = _set, doc = _set.__doc__)
##

class IWorkspaceExtension3(IWorkspaceExtension2):
    _case_insensitive_ = True
    u'Provides access to members that supply workspace extension information.'
    _iid_ = GUID('{5353322D-0CF1-4963-84D4-DAD544AC5A0C}')
    _idlflags_ = ['oleautomation']
IWorkspaceExtension3._methods_ = [
    COMMETHOD(['propget', helpstring(u'Datasets that own tables in the list.')], HRESULT, 'PrivateTableAndOwnerNames',
              ( ['out'], POINTER(POINTER(IEnumDatasetName)), 'privateTables' ),
              ( ['out'], POINTER(POINTER(IEnumDatasetName)), 'owningDatasets' )),
]
################################################################
## code template for IWorkspaceExtension3 implementation
##class IWorkspaceExtension3_Impl(object):
##    @property
##    def PrivateTableAndOwnerNames(self):
##        u'Datasets that own tables in the list.'
##        #return privateTables, owningDatasets
##

class IRelationshipChanges(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that manage differences in relationships.'
    _iid_ = GUID('{92365B91-2779-11D3-8A72-000000000000}')
    _idlflags_ = []
IRelationshipChanges._methods_ = [
    COMMETHOD([helpstring(u'Starts the relationship propagation process.')], HRESULT, 'InitResolveProcess',
              ( ['in'], VARIANT_BOOL, 'isPulling' )),
    COMMETHOD([helpstring(u'Starts the object difference augmentation process.')], HRESULT, 'InitObjectDifferenceAugmentation'),
    COMMETHOD([helpstring(u'Propagates the relationship changes to the associated object classes.')], HRESULT, 'AugumentObjectDifferences'),
    COMMETHOD([helpstring(u'Starts the object difference augmentation process.')], HRESULT, 'EndObjectDifferenceAugmentation'),
    COMMETHOD([helpstring(u'Propagates the relationship changes.')], HRESULT, 'PropagateChangesToRelatedObjects',
              ( ['in'], c_int, 'ObjectClassID' ),
              ( ['in'], c_int, 'oidCount' ),
              ( ['in'], POINTER(c_int), 'oids' )),
    COMMETHOD([helpstring(u'Copies the relationship changes from the conflict to edit state.')], HRESULT, 'CopyRelationshipChanges'),
    COMMETHOD([helpstring(u'Stops the relationship propagation process.')], HRESULT, 'EndResolveProcess'),
]
################################################################
## code template for IRelationshipChanges implementation
##class IRelationshipChanges_Impl(object):
##    def AugumentObjectDifferences(self):
##        u'Propagates the relationship changes to the associated object classes.'
##        #return 
##
##    def InitResolveProcess(self, isPulling):
##        u'Starts the relationship propagation process.'
##        #return 
##
##    def PropagateChangesToRelatedObjects(self, ObjectClassID, oidCount, oids):
##        u'Propagates the relationship changes.'
##        #return 
##
##    def InitObjectDifferenceAugmentation(self):
##        u'Starts the object difference augmentation process.'
##        #return 
##
##    def CopyRelationshipChanges(self):
##        u'Copies the relationship changes from the conflict to edit state.'
##        #return 
##
##    def EndResolveProcess(self):
##        u'Stops the relationship propagation process.'
##        #return 
##
##    def EndObjectDifferenceAugmentation(self):
##        u'Starts the object difference augmentation process.'
##        #return 
##

class IItemInfoImpl(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members of item info.'
    _iid_ = GUID('{3C0BEE38-3036-4909-A1B5-36FD883D6346}')
    _idlflags_ = []
IItemInfoImpl._methods_ = [
    COMMETHOD([helpstring(u'Load ItemInfo from a XML file.')], HRESULT, 'LoadFromXmlFile',
              ( ['in'], BSTR, 'xmlFilePath' )),
    COMMETHOD([helpstring(u'Save the ItemInfo to a XML file.')], HRESULT, 'SaveToXmlFile',
              ( ['in'], BSTR, 'xmlFilePath' )),
    COMMETHOD([helpstring(u'Read ItemInfo from JSON.')], HRESULT, 'ReadFromJSON',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IJSONObject), 'pJObject' )),
    COMMETHOD([helpstring(u'Save the ItemInfo to a XML file.')], HRESULT, 'SaveToJSON',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IJSONObject)), 'ppJObject' )),
    COMMETHOD([helpstring(u'Load thumbnail from file.')], HRESULT, 'LoadThumbnailFromFile',
              ( ['in'], BSTR, 'thumbnailFilePath' )),
    COMMETHOD([helpstring(u'Save the thumbmail to a file.')], HRESULT, 'SaveThumbnailToFile',
              ( ['in'], BSTR, 'thumbnailFilePath' )),
    COMMETHOD([helpstring(u'Convert StringArray to comma sperated string.')], HRESULT, 'StringArrayToString',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'pSA' ),
              ( ['retval', 'out'], POINTER(BSTR), 'pStr' )),
    COMMETHOD([helpstring(u'Convert comma sperated strin to StringArray.')], HRESULT, 'StringToStringArray',
              ( ['in'], BSTR, 'str' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray)), 'ppSA' )),
]
################################################################
## code template for IItemInfoImpl implementation
##class IItemInfoImpl_Impl(object):
##    def SaveThumbnailToFile(self, thumbnailFilePath):
##        u'Save the thumbmail to a file.'
##        #return 
##
##    def LoadThumbnailFromFile(self, thumbnailFilePath):
##        u'Load thumbnail from file.'
##        #return 
##
##    def SaveToJSON(self):
##        u'Save the ItemInfo to a XML file.'
##        #return ppJObject
##
##    def SaveToXmlFile(self, xmlFilePath):
##        u'Save the ItemInfo to a XML file.'
##        #return 
##
##    def StringArrayToString(self, pSA):
##        u'Convert StringArray to comma sperated string.'
##        #return pStr
##
##    def ReadFromJSON(self, pJObject):
##        u'Read ItemInfo from JSON.'
##        #return 
##
##    def StringToStringArray(self, str):
##        u'Convert comma sperated strin to StringArray.'
##        #return ppSA
##
##    def LoadFromXmlFile(self, xmlFilePath):
##        u'Load ItemInfo from a XML file.'
##        #return 
##

class ReplicaDataset(CoClass):
    u'Esri Replica Dataset object.'
    _reg_clsid_ = GUID('{27036541-B2E8-4862-8CEA-1CF49BC37266}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
ReplicaDataset._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IReplicaDataset, IReplicaDataset2, IReplicaDatasetEdit]

IJSONConverterGdb._methods_ = [
    COMMETHOD([helpstring(u'Reads RecordSet object from IJSONReader.')], HRESULT, 'ReadRecordSet',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IJSONReader), 'pReader' ),
              ( ['in'], POINTER(IFields), 'pDefaultSchema' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'pConversionProps' ),
              ( ['out'], POINTER(POINTER(IRecordSet)), 'ppRecordset' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'ppOriginalToNewFieldMap' )),
    COMMETHOD([helpstring(u"Reads RecordSet object from IJSONObject. pDefaultSchema is used only when input JSON has no 'fields' attribute. Pass NULL if not needed. Also, sometimes field names are corrected by the GeoDatabase, use ppOriginalToNewFieldMap to find new field names.")], HRESULT, 'ToRecordSet',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IJSONObject), 'pObj' ),
              ( ['in'], POINTER(IFields), 'pDefaultSchema' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'pConversionProps' ),
              ( ['out'], POINTER(POINTER(IRecordSet)), 'ppRecordset' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet)), 'ppOriginalToNewFieldMap' )),
    COMMETHOD([helpstring(u'Writes RecordSet to IJSONWriter. Writes closing bracked if bWriteEndOfObj is VARIANT_TRUE. Set bWriteEndOfObj to VARIANT_FALSE if you want to append additional JSON before closing object.')], HRESULT, 'WriteRecordSet',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IJSONWriter), 'pWriter' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IJSONConverterGeometry), 'pGeomConv' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'pProps' ),
              ( ['in'], BSTR, 'propname' ),
              ( ['in'], POINTER(IRecordSet), 'pRecordset' ),
              ( ['in'], POINTER(IGeometryResultOptions), 'pGeomOpt' ),
              ( ['in'], VARIANT_BOOL, 'bWriteEndOfObj' )),
    COMMETHOD([helpstring(u'Query domain info from IDomain and populate IJSONObject.')], HRESULT, 'QueryJSONDomain',
              ( ['in'], POINTER(IDomain), 'pDomain' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IJSONObject), 'pDomainJO' )),
]
################################################################
## code template for IJSONConverterGdb implementation
##class IJSONConverterGdb_Impl(object):
##    def ReadRecordSet(self, pReader, pDefaultSchema, pConversionProps):
##        u'Reads RecordSet object from IJSONReader.'
##        #return ppRecordset, ppOriginalToNewFieldMap
##
##    def QueryJSONDomain(self, pDomain, pDomainJO):
##        u'Query domain info from IDomain and populate IJSONObject.'
##        #return 
##
##    def ToRecordSet(self, pObj, pDefaultSchema, pConversionProps):
##        u"Reads RecordSet object from IJSONObject. pDefaultSchema is used only when input JSON has no 'fields' attribute. Pass NULL if not needed. Also, sometimes field names are corrected by the GeoDatabase, use ppOriginalToNewFieldMap to find new field names."
##        #return ppRecordset, ppOriginalToNewFieldMap
##
##    def WriteRecordSet(self, pWriter, pGeomConv, pProps, propname, pRecordset, pGeomOpt, bWriteEndOfObj):
##        u'Writes RecordSet to IJSONWriter. Writes closing bracked if bWriteEndOfObj is VARIANT_TRUE. Set bWriteEndOfObj to VARIANT_FALSE if you want to append additional JSON before closing object.'
##        #return 
##

class DEFeatureDatasetType(CoClass):
    u'Feature Dataset Data Element object Type.'
    _reg_clsid_ = GUID('{B073022C-969E-4E42-BCB4-8CE637CA2332}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DEFeatureDatasetType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDEFeatureDatasetType, IDEGeoDatasetType, IDEDatasetType, IGxFilterInfo, IDataElementType, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

class ReplicaDescriptionExtension(CoClass):
    u'Esri Replica Description Extension object.'
    _reg_clsid_ = GUID('{F964B93C-BC66-4982-B415-3051465B5DA4}')
    _idlflags_ = ['noncreatable']
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
ReplicaDescriptionExtension._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IReplicaDescriptionExtension]

IClassSchemaEdit2._methods_ = [
    COMMETHOD([helpstring(u'Changes the class extension properties associated with this object class.')], HRESULT, 'AlterClassExtensionProperties',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPropertySet), 'classExtensionProperties' )),
]
################################################################
## code template for IClassSchemaEdit2 implementation
##class IClassSchemaEdit2_Impl(object):
##    def AlterClassExtensionProperties(self, classExtensionProperties):
##        u'Changes the class extension properties associated with this object class.'
##        #return 
##

class IThumbnailInfoImpl(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members of IThumbnailInfoImpl interface.'
    _iid_ = GUID('{1001DCBA-AEE2-4A00-BC37-9E40220C92D6}')
    _idlflags_ = []
IThumbnailInfoImpl._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates whether the thumbnail has been modified.')], HRESULT, 'Modified',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'pModified' )),
    COMMETHOD(['propput', helpstring(u'Indicates whether the thumbnail has been modified.')], HRESULT, 'Modified',
              ( ['in'], VARIANT_BOOL, 'pModified' )),
]
################################################################
## code template for IThumbnailInfoImpl implementation
##class IThumbnailInfoImpl_Impl(object):
##    def _get(self):
##        u'Indicates whether the thumbnail has been modified.'
##        #return pModified
##    def _set(self, pModified):
##        u'Indicates whether the thumbnail has been modified.'
##    Modified = property(_get, _set, doc = _set.__doc__)
##

IClassSchemaEdit3._methods_ = [
    COMMETHOD([helpstring(u'Adds a global ID column to a class and populates it with GUIDs.')], HRESULT, 'AddGlobalID',
              ( ['in'], BSTR, 'FieldName' )),
    COMMETHOD([helpstring(u'Deletes the global ID column.')], HRESULT, 'DeleteGlobalID'),
]
################################################################
## code template for IClassSchemaEdit3 implementation
##class IClassSchemaEdit3_Impl(object):
##    def DeleteGlobalID(self):
##        u'Deletes the global ID column.'
##        #return 
##
##    def AddGlobalID(self, FieldName):
##        u'Adds a global ID column to a class and populates it with GUIDs.'
##        #return 
##

class IExternalSerializerGdb2(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides high-level serialization methods for AMF and JSON formats.'
    _iid_ = GUID('{BD834841-484F-4903-AAAE-0FA26E5206CD}')
    _idlflags_ = []
IExternalSerializerGdb2._methods_ = [
    COMMETHOD([helpstring(u'Writes spatial reference object. Pass NULL as propname to write standalone JSON object.')], HRESULT, 'WriteSpatialReference',
              ( ['in'], BSTR, 'propname' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'pSR' )),
    COMMETHOD([helpstring(u'Writes geometry object.')], HRESULT, 'WriteGeometry',
              ( ['in'], BSTR, 'propname' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry), 'pGeom' )),
    COMMETHOD([helpstring(u'Writes feature row object')], HRESULT, 'WriteRow',
              ( ['in'], BSTR, 'propname' ),
              ( ['in'], POINTER(IRow), 'pRow' ),
              ( ['in'], POINTER(IFields), 'pFields' ),
              ( ['in'], _midlSAFEARRAY(c_int), 'rowFieldIndexes' ),
              ( ['in'], POINTER(IGeometryResultOptions), 'pGeomOpt' )),
    COMMETHOD([helpstring(u'Writes feature recordset.')], HRESULT, 'WriteRecordSet',
              ( ['in'], BSTR, 'propname' ),
              ( ['in'], POINTER(IRecordSet), 'pRecordset' ),
              ( ['in'], POINTER(IGeometryResultOptions), 'pGeomOpt' )),
    COMMETHOD([helpstring(u'Writes error object.')], HRESULT, 'WriteErrorObject',
              ( ['in'], BSTR, 'propname' ),
              ( ['in'], c_int, 'Code' ),
              ( ['in'], BSTR, 'Message' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'details' )),
    COMMETHOD([helpstring(u'Convenience method. Creates and returns error object as byte SAFEARRAY.')], HRESULT, 'GetErrorObject',
              ( ['in'], BSTR, 'propname' ),
              ( ['in'], c_int, 'Code' ),
              ( ['in'], BSTR, 'Message' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IStringArray), 'details' ),
              ( ['retval', 'out'], POINTER(_midlSAFEARRAY(c_ubyte)), 'ppReturnBytes' )),
    COMMETHOD([helpstring(u'Writes feature recordset and returns number of records serialized.')], HRESULT, 'WriteRecordSetEx',
              ( ['in'], BSTR, 'propname' ),
              ( ['in'], POINTER(IRecordSet), 'pRecordset' ),
              ( ['in'], POINTER(IGeometryResultOptions), 'pGeomOpt' ),
              ( ['out'], POINTER(c_int), 'recordsSerialized' )),
]
################################################################
## code template for IExternalSerializerGdb2 implementation
##class IExternalSerializerGdb2_Impl(object):
##    def WriteGeometry(self, propname, pGeom):
##        u'Writes geometry object.'
##        #return 
##
##    def WriteSpatialReference(self, propname, pSR):
##        u'Writes spatial reference object. Pass NULL as propname to write standalone JSON object.'
##        #return 
##
##    def WriteErrorObject(self, propname, Code, Message, details):
##        u'Writes error object.'
##        #return 
##
##    def WriteRow(self, propname, pRow, pFields, rowFieldIndexes, pGeomOpt):
##        u'Writes feature row object'
##        #return 
##
##    def GetErrorObject(self, propname, Code, Message, details):
##        u'Convenience method. Creates and returns error object as byte SAFEARRAY.'
##        #return ppReturnBytes
##
##    def WriteRecordSetEx(self, propname, pRecordset, pGeomOpt):
##        u'Writes feature recordset and returns number of records serialized.'
##        #return recordsSerialized
##
##    def WriteRecordSet(self, propname, pRecordset, pGeomOpt):
##        u'Writes feature recordset.'
##        #return 
##

class IGeoDatasetSchemaEdit2(IGeoDatasetSchemaEdit):
    _case_insensitive_ = True
    u'Provides access to members that change the geodata transformation of a GeoDataset.'
    _iid_ = GUID('{0A6A2FAA-047D-4792-8732-D766D496BECA}')
    _idlflags_ = ['oleautomation']
IGeoDatasetSchemaEdit2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the geodata transformation of the dataset can be altered.')], HRESULT, 'CanAlterGeodataXform',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'canAlter' )),
    COMMETHOD([helpstring(u'Alters the geodata transformation of the dataset (does not transform the data).')], HRESULT, 'AlterGeodataXform',
              ( ['in'], POINTER(IGeodataXform), 'xform' )),
    COMMETHOD([helpstring(u'Alters the resolution of the dataset and rebuilds the spatial indexes.')], HRESULT, 'AlterResolution',
              ( ['in'], c_double, 'xyResolution' ),
              ( ['in'], c_double, 'zResolution' ),
              ( ['in'], c_double, 'mResolution' )),
    COMMETHOD([helpstring(u'Returns a list of possible resolutions (precisions) and the doubling factors that produce them from the specified low precision spatial reference. The zeroth returned element is the current precision of the spatial reference.')], HRESULT, 'ConstructResolutions',
              ( [], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference' ),
              ( [], c_int, 'numberRequested' ),
              ( ['out'], POINTER(c_int), 'defaultXYResolutionIndex' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDoubleArray)), 'xyResolutions' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDoubleArray)), 'zResolutions' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IDoubleArray)), 'mResolutions' )),
]
################################################################
## code template for IGeoDatasetSchemaEdit2 implementation
##class IGeoDatasetSchemaEdit2_Impl(object):
##    def ConstructResolutions(self, SpatialReference, numberRequested):
##        u'Returns a list of possible resolutions (precisions) and the doubling factors that produce them from the specified low precision spatial reference. The zeroth returned element is the current precision of the spatial reference.'
##        #return defaultXYResolutionIndex, xyResolutions, zResolutions, mResolutions
##
##    def AlterResolution(self, xyResolution, zResolution, mResolution):
##        u'Alters the resolution of the dataset and rebuilds the spatial indexes.'
##        #return 
##
##    @property
##    def CanAlterGeodataXform(self):
##        u'Indicates if the geodata transformation of the dataset can be altered.'
##        #return canAlter
##
##    def AlterGeodataXform(self, xform):
##        u'Alters the geodata transformation of the dataset (does not transform the data).'
##        #return 
##

IClassSchemaEdit4._methods_ = [
    COMMETHOD(['propput', helpstring(u'Changes the field name for recording the editor for Editor Tracking on this object class.')], HRESULT, 'EditorFieldName',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Changes the field name for recording the creator for Editor Tracking on this object class.')], HRESULT, 'CreatorFieldName',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Changes the field name for recording the edit time for Editor Tracking on this object class.')], HRESULT, 'EditedAtFieldName',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Changes the field name for recording the creation time for Editor Tracking on this object class.')], HRESULT, 'CreatedAtFieldName',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Change the property to determine Editor Tracking times are recorded in UTC.')], HRESULT, 'IsTimeInUTC',
              ( ['in'], VARIANT_BOOL, 'rhs' )),
    COMMETHOD([helpstring(u'Alter the name of the object class field.')], HRESULT, 'AlterFieldName',
              ( ['in'], BSTR, 'FieldName' ),
              ( ['in'], BSTR, 'newFieldName' )),
]
################################################################
## code template for IClassSchemaEdit4 implementation
##class IClassSchemaEdit4_Impl(object):
##    def _set(self, rhs):
##        u'Change the property to determine Editor Tracking times are recorded in UTC.'
##    IsTimeInUTC = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Changes the field name for recording the edit time for Editor Tracking on this object class.'
##    EditedAtFieldName = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Changes the field name for recording the editor for Editor Tracking on this object class.'
##    EditorFieldName = property(fset = _set, doc = _set.__doc__)
##
##    def AlterFieldName(self, FieldName, newFieldName):
##        u'Alter the name of the object class field.'
##        #return 
##
##    def _set(self, rhs):
##        u'Changes the field name for recording the creator for Editor Tracking on this object class.'
##    CreatorFieldName = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Changes the field name for recording the creation time for Editor Tracking on this object class.'
##    CreatedAtFieldName = property(fset = _set, doc = _set.__doc__)
##

IClassSchemaEditEx._methods_ = [
    COMMETHOD([helpstring(u'Registers this column as an Global ID with the database.')], HRESULT, 'RegisterGlobalIDColumn',
              ( ['in'], BSTR, 'columnName' )),
    COMMETHOD([helpstring(u'Unregisters this column as an OID with the database.')], HRESULT, 'UnregisterGlobalIDColumn',
              ( ['in'], BSTR, 'columnName' )),
]
################################################################
## code template for IClassSchemaEditEx implementation
##class IClassSchemaEditEx_Impl(object):
##    def RegisterGlobalIDColumn(self, columnName):
##        u'Registers this column as an Global ID with the database.'
##        #return 
##
##    def UnregisterGlobalIDColumn(self, columnName):
##        u'Unregisters this column as an OID with the database.'
##        #return 
##

class IDatasetFileStat2(IDatasetFileStat):
    _case_insensitive_ = True
    u'Provides access to members that control Dataset file-based statistics.'
    _iid_ = GUID('{F76D8BBB-2384-4419-948E-57FF98C77681}')
    _idlflags_ = ['oleautomation']
IDatasetFileStat2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The size. 64 bit value')], HRESULT, 'StatSize64',
              ( ['retval', 'out'], POINTER(c_ulonglong), 'Size64' )),
    COMMETHOD([helpstring(u'Refresh the file-based statistics')], HRESULT, 'RefreshStats'),
]
################################################################
## code template for IDatasetFileStat2 implementation
##class IDatasetFileStat2_Impl(object):
##    @property
##    def StatSize64(self):
##        u'The size. 64 bit value'
##        #return Size64
##
##    def RefreshStats(self):
##        u'Refresh the file-based statistics'
##        #return 
##

class DERelationshipClassType(CoClass):
    u'RelationshipClass Class Data Element object Type.'
    _reg_clsid_ = GUID('{7693BF47-9E32-40A3-B643-0B093C2A6CFC}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DERelationshipClassType._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDERelationshipClassType, IDETableType, IDEDatasetType, IGxFilterInfo, IDataElementType, IGPDataType, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone]

IVersionInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u"The version's name.")], HRESULT, 'VersionName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u"The version's description.")], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'Description' )),
    COMMETHOD(['propget', helpstring(u"The version's access permission.")], HRESULT, 'Access',
              ( ['retval', 'out'], POINTER(esriVersionAccess), 'Access' )),
    COMMETHOD(['propget', helpstring(u'The date and time the version was created.')], HRESULT, 'Created',
              ( ['retval', 'out'], POINTER(VARIANT), 'date' )),
    COMMETHOD(['propget', helpstring(u'The date and time the version was last modified.')], HRESULT, 'Modified',
              ( ['retval', 'out'], POINTER(VARIANT), 'date' )),
    COMMETHOD(['propget', helpstring(u"The version's parent.")], HRESULT, 'Parent',
              ( ['retval', 'out'], POINTER(POINTER(IVersionInfo)), 'Parent' )),
    COMMETHOD(['propget', helpstring(u"The version's children.")], HRESULT, 'Children',
              ( ['retval', 'out'], POINTER(POINTER(IEnumVersionInfo)), 'Children' )),
    COMMETHOD(['propget', helpstring(u"The version's ancestors.")], HRESULT, 'Ancestors',
              ( ['retval', 'out'], POINTER(POINTER(IEnumVersionInfo)), 'Ancestors' )),
    COMMETHOD([helpstring(u'True if the current connected user is the owner of this version.')], HRESULT, 'IsOwner',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsOwner' )),
]
################################################################
## code template for IVersionInfo implementation
##class IVersionInfo_Impl(object):
##    @property
##    def Ancestors(self):
##        u"The version's ancestors."
##        #return Ancestors
##
##    @property
##    def Description(self):
##        u"The version's description."
##        #return Description
##
##    @property
##    def Parent(self):
##        u"The version's parent."
##        #return Parent
##
##    @property
##    def Created(self):
##        u'The date and time the version was created.'
##        #return date
##
##    @property
##    def Modified(self):
##        u'The date and time the version was last modified.'
##        #return date
##
##    @property
##    def Access(self):
##        u"The version's access permission."
##        #return Access
##
##    def IsOwner(self):
##        u'True if the current connected user is the owner of this version.'
##        #return IsOwner
##
##    @property
##    def VersionName(self):
##        u"The version's name."
##        #return Name
##
##    @property
##    def Children(self):
##        u"The version's children."
##        #return Children
##

IVersionInfo2._methods_ = [
    COMMETHOD(['propget', helpstring(u"The name of the version's parent.")], HRESULT, 'ParentName',
              ( ['retval', 'out'], POINTER(BSTR), 'ParentName' )),
    COMMETHOD(['propget', helpstring(u'Does this version block compress of DEFAULT')], HRESULT, 'BlocksCompress',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'blocks' )),
]
################################################################
## code template for IVersionInfo2 implementation
##class IVersionInfo2_Impl(object):
##    @property
##    def ParentName(self):
##        u"The name of the version's parent."
##        #return ParentName
##
##    @property
##    def BlocksCompress(self):
##        u'Does this version block compress of DEFAULT'
##        #return blocks
##

IVirtualTable._methods_ = [
]
################################################################
## code template for IVirtualTable implementation
##class IVirtualTable_Impl(object):

IGPReplica2._methods_ = [
    COMMETHOD(['propput', helpstring(u'Use archiving instead of versions to track changes in one way replicas.')], HRESULT, 'UseArchiving',
              ( ['in'], VARIANT_BOOL, 'UseArchiving' )),
    COMMETHOD(['propget', helpstring(u'Use archiving instead of versions to track changes in one way replicas.')], HRESULT, 'UseArchiving',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'UseArchiving' )),
    COMMETHOD(['propget'], HRESULT, 'MyTime',
              ( ['retval', 'out'], POINTER(VARIANT), 'MyTime' )),
    COMMETHOD(['propput'], HRESULT, 'MyTime',
              ( ['in'], VARIANT, 'MyTime' )),
    COMMETHOD(['propget'], HRESULT, 'SibTime',
              ( ['retval', 'out'], POINTER(VARIANT), 'SibTime' )),
    COMMETHOD(['propput'], HRESULT, 'SibTime',
              ( ['in'], VARIANT, 'SibTime' )),
    COMMETHOD(['propget'], HRESULT, 'SibMyTime',
              ( ['retval', 'out'], POINTER(VARIANT), 'SibMyTime' )),
    COMMETHOD(['propput'], HRESULT, 'SibMyTime',
              ( ['in'], VARIANT, 'SibMyTime' )),
    COMMETHOD(['propput'], HRESULT, 'InTransportFile',
              ( ['in'], VARIANT_BOOL, 'InTransportFile' )),
    COMMETHOD(['propget'], HRESULT, 'InTransportFile',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'InTransportFile' )),
    COMMETHOD(['propput', helpstring(u'Resolve dataset name conflicts when creating replicas.')], HRESULT, 'ResolveDatasetNameConflicts',
              ( ['in'], VARIANT_BOOL, 'ResolveDatasetNameConflicts' )),
    COMMETHOD(['propget', helpstring(u'Resolve dataset name conflicts when creating replicas.')], HRESULT, 'ResolveDatasetNameConflicts',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'ResolveDatasetNameConflicts' )),
]
################################################################
## code template for IGPReplica2 implementation
##class IGPReplica2_Impl(object):
##    def _get(self):
##        '-no docstring-'
##        #return SibTime
##    def _set(self, SibTime):
##        '-no docstring-'
##    SibTime = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Resolve dataset name conflicts when creating replicas.'
##        #return ResolveDatasetNameConflicts
##    def _set(self, ResolveDatasetNameConflicts):
##        u'Resolve dataset name conflicts when creating replicas.'
##    ResolveDatasetNameConflicts = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        '-no docstring-'
##        #return MyTime
##    def _set(self, MyTime):
##        '-no docstring-'
##    MyTime = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        '-no docstring-'
##        #return InTransportFile
##    def _set(self, InTransportFile):
##        '-no docstring-'
##    InTransportFile = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        '-no docstring-'
##        #return SibMyTime
##    def _set(self, SibMyTime):
##        '-no docstring-'
##    SibMyTime = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Use archiving instead of versions to track changes in one way replicas.'
##        #return UseArchiving
##    def _set(self, UseArchiving):
##        u'Use archiving instead of versions to track changes in one way replicas.'
##    UseArchiving = property(_get, _set, doc = _set.__doc__)
##

IRelClassSchemaEdit._methods_ = [
    COMMETHOD([helpstring(u'Changes the forward path label for this relationship class.')], HRESULT, 'AlterForwardPathLabel',
              ( ['in'], BSTR, 'ForwardLabel' )),
    COMMETHOD([helpstring(u'Changes the backward path label for this relationship class.')], HRESULT, 'AlterBackwardPathLabel',
              ( ['in'], BSTR, 'BackwardLabel' )),
    COMMETHOD([helpstring(u'Changes the type of this relationship class.')], HRESULT, 'AlterIsComposite',
              ( ['in'], VARIANT_BOOL, 'IsComposite' )),
]
################################################################
## code template for IRelClassSchemaEdit implementation
##class IRelClassSchemaEdit_Impl(object):
##    def AlterForwardPathLabel(self, ForwardLabel):
##        u'Changes the forward path label for this relationship class.'
##        #return 
##
##    def AlterBackwardPathLabel(self, BackwardLabel):
##        u'Changes the backward path label for this relationship class.'
##        #return 
##
##    def AlterIsComposite(self, IsComposite):
##        u'Changes the type of this relationship class.'
##        #return 
##

class IEnumVersionInfo2(IEnumVersionInfo):
    _case_insensitive_ = True
    u'Provides access to members that enumerate version information.'
    _iid_ = GUID('{EEA4DFDD-A91D-44E2-A419-DCFE016EFAF3}')
    _idlflags_ = ['oleautomation']
IEnumVersionInfo._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next version info.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IVersionInfo)), 'info' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumVersionInfo implementation
##class IEnumVersionInfo_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next version info.'
##        #return info
##

IEnumVersionInfo2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of versions in the enumeration.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
]
################################################################
## code template for IEnumVersionInfo2 implementation
##class IEnumVersionInfo2_Impl(object):
##    @property
##    def Count(self):
##        u'The number of versions in the enumeration.'
##        #return Count
##

IRelQueryTable._methods_ = [
    COMMETHOD(['propget', helpstring(u'The fields that appear on the left side of the join belong to the source table.')], HRESULT, 'SourceTable',
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'SourceTable' )),
    COMMETHOD(['propget', helpstring(u'The fields that appear on the right side of the join belong to the destination table.')], HRESULT, 'DestinationTable',
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'desinationTable' )),
    COMMETHOD(['propget', helpstring(u'Relationship class used in the table join.')], HRESULT, 'RelationshipClass',
              ( ['retval', 'out'], POINTER(POINTER(IRelationshipClass)), 'RelationshipClass' )),
]
################################################################
## code template for IRelQueryTable implementation
##class IRelQueryTable_Impl(object):
##    @property
##    def RelationshipClass(self):
##        u'Relationship class used in the table join.'
##        #return RelationshipClass
##
##    @property
##    def DestinationTable(self):
##        u'The fields that appear on the right side of the join belong to the destination table.'
##        #return desinationTable
##
##    @property
##    def SourceTable(self):
##        u'The fields that appear on the left side of the join belong to the source table.'
##        #return SourceTable
##

IVersionedWorkspace2._methods_ = [
    COMMETHOD(['propget', helpstring(u'An ordered list of versions that can be used to optimize reconciliation against the default version.')], HRESULT, 'RecommendedReconcileOrder',
              ( ['retval', 'out'], POINTER(POINTER(IEnumVersionInfo)), 'infoEnum' )),
]
################################################################
## code template for IVersionedWorkspace2 implementation
##class IVersionedWorkspace2_Impl(object):
##    @property
##    def RecommendedReconcileOrder(self):
##        u'An ordered list of versions that can be used to optimize reconciliation against the default version.'
##        #return infoEnum
##

class IVersion3(IVersion2):
    _case_insensitive_ = True
    u'Provides access to members for managing a version.'
    _iid_ = GUID('{D17C7F63-6C94-4C61-8702-A06F631567AD}')
    _idlflags_ = ['oleautomation']
class IEnumLockInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that enumerate lock information.'
    _iid_ = GUID('{0F2E4F13-93B2-11D3-9F62-00C04F6BDDD9}')
    _idlflags_ = ['oleautomation']
IVersion._methods_ = [
    COMMETHOD(['propget', helpstring(u"This version's locks.")], HRESULT, 'VersionLocks',
              ( ['retval', 'out'], POINTER(POINTER(IEnumLockInfo)), 'locks' )),
    COMMETHOD(['propget', helpstring(u"This version's information.")], HRESULT, 'VersionInfo',
              ( ['retval', 'out'], POINTER(POINTER(IVersionInfo)), 'info' )),
    COMMETHOD(['propget', helpstring(u'The name of the version.')], HRESULT, 'VersionName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propput', helpstring(u'The name of the version.')], HRESULT, 'VersionName',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD(['propget', helpstring(u"The version's description.")], HRESULT, 'Description',
              ( ['retval', 'out'], POINTER(BSTR), 'Description' )),
    COMMETHOD(['propput', helpstring(u"The version's description.")], HRESULT, 'Description',
              ( ['in'], BSTR, 'Description' )),
    COMMETHOD(['propget', helpstring(u"The version's access permission.")], HRESULT, 'Access',
              ( ['retval', 'out'], POINTER(esriVersionAccess), 'Access' )),
    COMMETHOD(['propput', helpstring(u"The version's access permission.")], HRESULT, 'Access',
              ( ['in'], esriVersionAccess, 'Access' )),
    COMMETHOD([helpstring(u'True if this version have a parent version.')], HRESULT, 'HasParent',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'HasParent' )),
    COMMETHOD([helpstring(u'Permanently deletes the version from the database.')], HRESULT, 'Delete'),
    COMMETHOD([helpstring(u'Refreshes the version with the corresponding database state.')], HRESULT, 'RefreshVersion'),
    COMMETHOD([helpstring(u'Creates a new version equivalent to this version.')], HRESULT, 'CreateVersion',
              ( ['in'], BSTR, 'newName' ),
              ( ['retval', 'out'], POINTER(POINTER(IVersion)), 'newVersion' )),
]
################################################################
## code template for IVersion implementation
##class IVersion_Impl(object):
##    def HasParent(self):
##        u'True if this version have a parent version.'
##        #return HasParent
##
##    def _get(self):
##        u"The version's description."
##        #return Description
##    def _set(self, Description):
##        u"The version's description."
##    Description = property(_get, _set, doc = _set.__doc__)
##
##    def RefreshVersion(self):
##        u'Refreshes the version with the corresponding database state.'
##        #return 
##
##    @property
##    def VersionLocks(self):
##        u"This version's locks."
##        #return locks
##
##    def _get(self):
##        u"The version's access permission."
##        #return Access
##    def _set(self, Access):
##        u"The version's access permission."
##    Access = property(_get, _set, doc = _set.__doc__)
##
##    def CreateVersion(self, newName):
##        u'Creates a new version equivalent to this version.'
##        #return newVersion
##
##    def _get(self):
##        u'The name of the version.'
##        #return Name
##    def _set(self, Name):
##        u'The name of the version.'
##    VersionName = property(_get, _set, doc = _set.__doc__)
##
##    @property
##    def VersionInfo(self):
##        u"This version's information."
##        #return info
##
##    def Delete(self):
##        u'Permanently deletes the version from the database.'
##        #return 
##

IVersion2._methods_ = [
    COMMETHOD([helpstring(u'Finds common ancestor version.')], HRESULT, 'GetCommonAncestor',
              ( ['in'], POINTER(IVersion), 'otherVersion' ),
              ( ['retval', 'out'], POINTER(POINTER(IVersion)), 'CommonAncestorVersion' )),
    COMMETHOD([helpstring(u'Creates a new child version of this version whose initial state is the current state of pInitialStateVersion.')], HRESULT, 'CreateChild',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(IVersion), 'initialStateVersion' ),
              ( ['retval', 'out'], POINTER(POINTER(IVersion)), 'newChildVersion' )),
    COMMETHOD(['propget', helpstring(u'Determines whether the state of the version corresponding to this version object has been redefined in the database.')], HRESULT, 'IsRedefined',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'isRedef' )),
]
################################################################
## code template for IVersion2 implementation
##class IVersion2_Impl(object):
##    def GetCommonAncestor(self, otherVersion):
##        u'Finds common ancestor version.'
##        #return CommonAncestorVersion
##
##    def CreateChild(self, Name, initialStateVersion):
##        u'Creates a new child version of this version whose initial state is the current state of pInitialStateVersion.'
##        #return newChildVersion
##
##    @property
##    def IsRedefined(self):
##        u'Determines whether the state of the version corresponding to this version object has been redefined in the database.'
##        #return isRedef
##

IVersion3._methods_ = [
    COMMETHOD([helpstring(u"Permanently deletes the version and all it's children from the database.")], HRESULT, 'DeleteWithChildren'),
]
################################################################
## code template for IVersion3 implementation
##class IVersion3_Impl(object):
##    def DeleteWithChildren(self):
##        u"Permanently deletes the version and all it's children from the database."
##        #return 
##

IVersionedWorkspace3._methods_ = [
    COMMETHOD(['propget', helpstring(u'An ordered list of replicas that need to be synchronized in order to optimize reconciliation against the default version.')], HRESULT, 'RecommendedSyncOrder',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IEnumBSTR)), 'ReplicaNameEnum' )),
]
################################################################
## code template for IVersionedWorkspace3 implementation
##class IVersionedWorkspace3_Impl(object):
##    @property
##    def RecommendedSyncOrder(self):
##        u'An ordered list of replicas that need to be synchronized in order to optimize reconciliation against the default version.'
##        #return ReplicaNameEnum
##

IRelQueryTableInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'Type of table join.')], HRESULT, 'JoinType',
              ( ['retval', 'out'], POINTER(esriJoinType), 'JoinType' )),
    COMMETHOD(['propget', helpstring(u'QueryDef used to create the join. This property will be null if the join is done on the client.')], HRESULT, 'QueryDef',
              ( ['retval', 'out'], POINTER(POINTER(IQueryDef)), 'QueryDef' )),
    COMMETHOD([helpstring(u'Returns the base table for a particular field.')], HRESULT, 'GetBaseTableOfField',
              ( ['in'], BSTR, 'column' ),
              ( ['retval', 'out'], POINTER(POINTER(ITable)), 'Table' )),
    COMMETHOD(['propget', helpstring(u'Indicates if direct access lookup is used by a RelQueryTable to match records between the source and destination tables.')], HRESULT, 'HasDirectAccessLookup',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'directAccess' )),
]
################################################################
## code template for IRelQueryTableInfo implementation
##class IRelQueryTableInfo_Impl(object):
##    @property
##    def JoinType(self):
##        u'Type of table join.'
##        #return JoinType
##
##    @property
##    def QueryDef(self):
##        u'QueryDef used to create the join. This property will be null if the join is done on the client.'
##        #return QueryDef
##
##    def GetBaseTableOfField(self, column):
##        u'Returns the base table for a particular field.'
##        #return Table
##
##    @property
##    def HasDirectAccessLookup(self):
##        u'Indicates if direct access lookup is used by a RelQueryTable to match records between the source and destination tables.'
##        #return directAccess
##

IXMLIndexTags._methods_ = [
    COMMETHOD(['propget', helpstring(u'The number of tags in the collection.')], HRESULT, 'TagCount',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'A tag by position in the collection.')], HRESULT, 'Tag',
              ( ['in'], c_int, 'tagIndex' ),
              ( ['retval', 'out'], POINTER(POINTER(IXMLIndexTag)), 'Tag' )),
    COMMETHOD([helpstring(u'Find a tag in the collection by name.')], HRESULT, 'Find',
              ( ['in'], BSTR, 'tagName' ),
              ( ['out'], POINTER(c_int), 'tagIndex' )),
    COMMETHOD([helpstring(u'Add a tag to the collection.')], HRESULT, 'Add',
              ( ['in'], POINTER(IXMLIndexTag), 'Tag' )),
    COMMETHOD([helpstring(u'Remove a tag from the collection.')], HRESULT, 'Remove',
              ( ['in'], POINTER(IXMLIndexTag), 'Tag' )),
    COMMETHOD([helpstring(u'Remove all tags from the collection.')], HRESULT, 'RemoveAll'),
]
################################################################
## code template for IXMLIndexTags implementation
##class IXMLIndexTags_Impl(object):
##    def Remove(self, Tag):
##        u'Remove a tag from the collection.'
##        #return 
##
##    def Find(self, tagName):
##        u'Find a tag in the collection by name.'
##        #return tagIndex
##
##    def RemoveAll(self):
##        u'Remove all tags from the collection.'
##        #return 
##
##    def Add(self, Tag):
##        u'Add a tag to the collection.'
##        #return 
##
##    @property
##    def Tag(self, tagIndex):
##        u'A tag by position in the collection.'
##        #return Tag
##
##    @property
##    def TagCount(self):
##        u'The number of tags in the collection.'
##        #return Count
##

IDEBrowseOptions._methods_ = [
    COMMETHOD(['propget', helpstring(u'Data element expand type - none, immediate children or all descendants.')], HRESULT, 'ExpandType',
              ( ['retval', 'out'], POINTER(esriDEExpandType), 'ExpandType' )),
    COMMETHOD(['propput', helpstring(u'Data element expand type - none, immediate children or all descendants.')], HRESULT, 'ExpandType',
              ( ['in'], esriDEExpandType, 'ExpandType' )),
    COMMETHOD(['propget', helpstring(u'Indicates if full properties of a data element should be fetched (heavy-weight properties that involve opening the underlying dataset).')], HRESULT, 'RetrieveFullProperties',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'fullProp' )),
    COMMETHOD(['propput', helpstring(u'Indicates if full properties of a data element should be fetched (heavy-weight properties that involve opening the underlying dataset).')], HRESULT, 'RetrieveFullProperties',
              ( ['in'], VARIANT_BOOL, 'fullProp' )),
    COMMETHOD(['propget', helpstring(u"Indicates if the data element's metadata should be fetched.")], HRESULT, 'RetrieveMetadata',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'fullProp' )),
    COMMETHOD(['propput', helpstring(u"Indicates if the data element's metadata should be fetched.")], HRESULT, 'RetrieveMetadata',
              ( ['in'], VARIANT_BOOL, 'fullProp' )),
]
################################################################
## code template for IDEBrowseOptions implementation
##class IDEBrowseOptions_Impl(object):
##    def _get(self):
##        u'Data element expand type - none, immediate children or all descendants.'
##        #return ExpandType
##    def _set(self, ExpandType):
##        u'Data element expand type - none, immediate children or all descendants.'
##    ExpandType = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u"Indicates if the data element's metadata should be fetched."
##        #return fullProp
##    def _set(self, fullProp):
##        u"Indicates if the data element's metadata should be fetched."
##    RetrieveMetadata = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Indicates if full properties of a data element should be fetched (heavy-weight properties that involve opening the underlying dataset).'
##        #return fullProp
##    def _set(self, fullProp):
##        u'Indicates if full properties of a data element should be fetched (heavy-weight properties that involve opening the underlying dataset).'
##    RetrieveFullProperties = property(_get, _set, doc = _set.__doc__)
##

IGeoDatabaseBridge._methods_ = [
    COMMETHOD([helpstring(u'Get a cursor of Rows given a set of object ids.')], HRESULT, 'GetFeatures',
              ( ['in'], POINTER(IFeatureClass), 'pFeatureClass' ),
              ( ['in'], POINTER(_midlSAFEARRAY(c_int)), 'fids' ),
              ( ['in'], VARIANT_BOOL, 'Recycling' ),
              ( ['retval', 'out'], POINTER(POINTER(IFeatureCursor)), 'Cursor' )),
]
################################################################
## code template for IGeoDatabaseBridge implementation
##class IGeoDatabaseBridge_Impl(object):
##    def GetFeatures(self, pFeatureClass, fids, Recycling):
##        u'Get a cursor of Rows given a set of object ids.'
##        #return Cursor
##

class IWorkspaceDataElements2(IWorkspaceDataElements):
    _case_insensitive_ = True
    u'Provides access to members that return name objects objects for data elements.'
    _iid_ = GUID('{8C205305-1F0E-4133-8419-845DE172CD7A}')
    _idlflags_ = ['oleautomation']
IWorkspaceDataElements2._methods_ = [
    COMMETHOD([helpstring(u'Returns a name object for the data element.')], HRESULT, 'GetNameObject',
              ( ['in'], POINTER(IDataElement), 'DataElement' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'nameObject' )),
]
################################################################
## code template for IWorkspaceDataElements2 implementation
##class IWorkspaceDataElements2_Impl(object):
##    def GetNameObject(self, DataElement):
##        u'Returns a name object for the data element.'
##        #return nameObject
##

IHistoricalMarker._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the historical marker.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The timestamp of the historical marker.')], HRESULT, 'TimeStamp',
              ( ['retval', 'out'], POINTER(VARIANT), 'tstamp' )),
]
################################################################
## code template for IHistoricalMarker implementation
##class IHistoricalMarker_Impl(object):
##    @property
##    def TimeStamp(self):
##        u'The timestamp of the historical marker.'
##        #return tstamp
##
##    @property
##    def Name(self):
##        u'The name of the historical marker.'
##        #return Name
##

class IFeatureDatasetExtension2(IFeatureDatasetExtension):
    _case_insensitive_ = True
    u'Provides access to standard functionality found in all feature dataset extensions.'
    _iid_ = GUID('{F0A333BF-B864-4B71-8FF5-086DA66851D9}')
    _idlflags_ = ['oleautomation']
IFeatureDatasetExtension2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Indicates if the contained feature classes in the dataset extension can participate in another dataset of the specified type.')], HRESULT, 'CanParticipateInDataset',
              ( ['in'], esriDatasetType, 'Type' ),
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'canParticipate' )),
]
################################################################
## code template for IFeatureDatasetExtension2 implementation
##class IFeatureDatasetExtension2_Impl(object):
##    @property
##    def CanParticipateInDataset(self, Type):
##        u'Indicates if the contained feature classes in the dataset extension can participate in another dataset of the specified type.'
##        #return canParticipate
##

class IVersionedWorkspace4(IVersionedWorkspace3):
    _case_insensitive_ = True
    u'Provides access to members that manage versions.'
    _iid_ = GUID('{A86A6E1B-702A-453F-8FAF-BD2100B439B3}')
    _idlflags_ = ['oleautomation']
IVersionedWorkspace4._methods_ = [
    COMMETHOD(['propget', helpstring(u'A list of descendant versions of a version that can be sorted to optimize reconcile and post.')], HRESULT, 'DescendantVersions',
              ( ['in'], BSTR, 'Version' ),
              ( ['in'], VARIANT_BOOL, 'orderForReconcileAndPost' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumVersionInfo)), 'infoEnum' )),
    COMMETHOD(['propget', helpstring(u'A list of versions that have child versions.')], HRESULT, 'ParentVersions',
              ( ['retval', 'out'], POINTER(POINTER(IEnumVersionInfo)), 'infoEnum' )),
]
################################################################
## code template for IVersionedWorkspace4 implementation
##class IVersionedWorkspace4_Impl(object):
##    @property
##    def DescendantVersions(self, Version, orderForReconcileAndPost):
##        u'A list of descendant versions of a version that can be sorted to optimize reconcile and post.'
##        #return infoEnum
##
##    @property
##    def ParentVersions(self):
##        u'A list of versions that have child versions.'
##        #return infoEnum
##

IGPReplicas._methods_ = [
    COMMETHOD(['propget', helpstring(u'The GPReplica count.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD(['propget', helpstring(u'The GPReplica at the specified position.')], HRESULT, 'Element',
              ( ['in'], c_int, 'Index' ),
              ( ['retval', 'out'], POINTER(POINTER(IGPReplica)), 'Replica' )),
    COMMETHOD([helpstring(u'Removes the GPReplica at the specified position.')], HRESULT, 'Remove',
              ( ['in'], c_int, 'Index' )),
    COMMETHOD([helpstring(u'Removes all GPReplicas.')], HRESULT, 'RemoveAll'),
    COMMETHOD([helpstring(u'Adds a version info.')], HRESULT, 'Add',
              ( ['in'], POINTER(IGPReplica), 'Replica' )),
    COMMETHOD([helpstring(u'Adds a GPReplica at the specified position.')], HRESULT, 'Insert',
              ( ['in'], c_int, 'Index' ),
              ( ['in'], POINTER(IGPReplica), 'Replica' )),
]
################################################################
## code template for IGPReplicas implementation
##class IGPReplicas_Impl(object):
##    @property
##    def Count(self):
##        u'The GPReplica count.'
##        #return Count
##
##    def Insert(self, Index, Replica):
##        u'Adds a GPReplica at the specified position.'
##        #return 
##
##    def Remove(self, Index):
##        u'Removes the GPReplica at the specified position.'
##        #return 
##
##    @property
##    def Element(self, Index):
##        u'The GPReplica at the specified position.'
##        #return Replica
##
##    def RemoveAll(self):
##        u'Removes all GPReplicas.'
##        #return 
##
##    def Add(self, Replica):
##        u'Adds a version info.'
##        #return 
##

class ILocatorWorkspace2(ILocatorWorkspace):
    _case_insensitive_ = True
    u'Provides access to members for managing the locators in the locator workspace.'
    _iid_ = GUID('{3238F288-F52C-45F0-A4C4-CB9E7D2488F2}')
    _idlflags_ = ['oleautomation']
ILocatorWorkspace2._methods_ = [
    COMMETHOD([helpstring(u'Rebuilds a locator.')], HRESULT, 'RebuildLocator',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ITrackCancel), 'CancelTracker' )),
]
################################################################
## code template for ILocatorWorkspace2 implementation
##class ILocatorWorkspace2_Impl(object):
##    def RebuildLocator(self, Name, CancelTracker):
##        u'Rebuilds a locator.'
##        #return 
##

IHistoricalVersion._methods_ = [
    COMMETHOD(['propget', helpstring(u'The timestamp this historical versions refers to.')], HRESULT, 'TimeStamp',
              ( ['retval', 'out'], POINTER(VARIANT), 'tstamp' )),
]
################################################################
## code template for IHistoricalVersion implementation
##class IHistoricalVersion_Impl(object):
##    @property
##    def TimeStamp(self):
##        u'The timestamp this historical versions refers to.'
##        #return tstamp
##

class WorkspaceDefinition(CoClass):
    u'The Workspace Definition Object.'
    _reg_clsid_ = GUID('{BADE4285-63ED-495C-AC57-435DD4687B31}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
WorkspaceDefinition._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IWorkspaceDefinition, IWorkspaceDefinition2, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, IMetadata]

IGeoDatabaseBridge2._methods_ = [
    COMMETHOD([helpstring(u"Adds a list of  object id's to the selection set.")], HRESULT, 'AddList',
              ( ['in'], POINTER(ISelectionSet), 'SelectionSet' ),
              ( ['in'], POINTER(_midlSAFEARRAY(c_int)), 'OIDList' )),
    COMMETHOD([helpstring(u"Removes a list of  object id's from the selection set.")], HRESULT, 'RemoveList',
              ( ['in'], POINTER(ISelectionSet), 'SelectionSet' ),
              ( ['in'], POINTER(_midlSAFEARRAY(c_int)), 'OIDList' )),
    COMMETHOD([helpstring(u'The polygon based on the specified triangle and input bounds. For pRegion, pass in an array with at least 5 WKSPointZs.')], HRESULT, 'QueryElevationBand',
              ( ['in'], POINTER(ITinTriangle), 'pTinTriangle' ),
              ( ['in'], c_double, 'zLowerBound' ),
              ( ['in'], c_double, 'zUpperBound' ),
              ( ['out'], POINTER(c_int), 'pCount' ),
              ( ['in', 'out'], POINTER(_midlSAFEARRAY(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.WKSPointZ)), 'pRegion' )),
    COMMETHOD([helpstring(u'Derives slope, aspect, hillshade, or elevation from the input surface and writes the result to the provided PixelBlock.')], HRESULT, 'QueryPixelBlock',
              ( ['in'], POINTER(ISurface), 'pSurface' ),
              ( ['in'], c_double, 'xOrigin' ),
              ( ['in'], c_double, 'yOrigin' ),
              ( ['in'], c_double, 'xPixelSize' ),
              ( ['in'], c_double, 'yPixelSize' ),
              ( ['in'], esriRasterizationType, 'Type' ),
              ( ['in'], VARIANT, 'valueForNoData' ),
              ( ['in', 'out'], POINTER(VARIANT), 'block' )),
    COMMETHOD([helpstring(u'Returns a line-of-site indicator interpolated from the TIN based on an input polyline.')], HRESULT, 'GetLineOfSight',
              ( ['in'], POINTER(ISurface), 'pSurface' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pObserver' ),
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint), 'pTarget' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPoint)), 'ppObstruction' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolyline)), 'ppVisibleLines' ),
              ( ['out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IPolyline)), 'ppInvisibleLines' ),
              ( ['out'], POINTER(VARIANT_BOOL), 'pbIsVisible' ),
              ( ['in'], VARIANT_BOOL, 'bApplyCurvature' ),
              ( ['in'], VARIANT_BOOL, 'bApplyRefraction' ),
              ( ['in', 'optional'], POINTER(VARIANT), 'pRefractionFactor' )),
]
################################################################
## code template for IGeoDatabaseBridge2 implementation
##class IGeoDatabaseBridge2_Impl(object):
##    def QueryPixelBlock(self, pSurface, xOrigin, yOrigin, xPixelSize, yPixelSize, Type, valueForNoData):
##        u'Derives slope, aspect, hillshade, or elevation from the input surface and writes the result to the provided PixelBlock.'
##        #return block
##
##    def RemoveList(self, SelectionSet, OIDList):
##        u"Removes a list of  object id's from the selection set."
##        #return 
##
##    def GetLineOfSight(self, pSurface, pObserver, pTarget, bApplyCurvature, bApplyRefraction, pRefractionFactor):
##        u'Returns a line-of-site indicator interpolated from the TIN based on an input polyline.'
##        #return ppObstruction, ppVisibleLines, ppInvisibleLines, pbIsVisible
##
##    def QueryElevationBand(self, pTinTriangle, zLowerBound, zUpperBound):
##        u'The polygon based on the specified triangle and input bounds. For pRegion, pass in an array with at least 5 WKSPointZs.'
##        #return pCount, pRegion
##
##    def AddList(self, SelectionSet, OIDList):
##        u"Adds a list of  object id's to the selection set."
##        #return 
##

IGPReplicaOptions2._methods_ = [
    COMMETHOD(['propput', helpstring(u'Use archiving instead of versions to track changes in one way replicas.')], HRESULT, 'UseArchiving',
              ( ['in'], VARIANT_BOOL, 'UseArchiving' )),
    COMMETHOD(['propget', helpstring(u'Use archiving instead of versions to track changes in one way replicas.')], HRESULT, 'UseArchiving',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'UseArchiving' )),
    COMMETHOD(['propput'], HRESULT, 'IncludeMapLayers',
              ( ['in'], VARIANT_BOOL, 'IncludeMapLayers' )),
    COMMETHOD(['propget'], HRESULT, 'IncludeMapLayers',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IncludeMapLayers' )),
    COMMETHOD(['propput', helpstring(u'Return all datasets including feature datasets, topologies, and geometric networks when expanding.')], HRESULT, 'ReturnAllExpandedDatasets',
              ( ['in'], VARIANT_BOOL, 'ReturnAllExpandedDatasets' )),
    COMMETHOD(['propget', helpstring(u'Return all datasets including feature datasets, topologies, and geometric networks when expanding.')], HRESULT, 'ReturnAllExpandedDatasets',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'ReturnAllExpandedDatasets' )),
    COMMETHOD(['propput', helpstring(u'Resolve dataset name conflicts when creating replicas.')], HRESULT, 'ResolveDatasetNameConflicts',
              ( ['in'], VARIANT_BOOL, 'ResolveNameConflicts' )),
    COMMETHOD(['propget', helpstring(u'Resolve dataset name conflicts when creating replicas.')], HRESULT, 'ResolveDatasetNameConflicts',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'ResolveNameConflicts' )),
]
################################################################
## code template for IGPReplicaOptions2 implementation
##class IGPReplicaOptions2_Impl(object):
##    def _get(self):
##        u'Use archiving instead of versions to track changes in one way replicas.'
##        #return UseArchiving
##    def _set(self, UseArchiving):
##        u'Use archiving instead of versions to track changes in one way replicas.'
##    UseArchiving = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Return all datasets including feature datasets, topologies, and geometric networks when expanding.'
##        #return ReturnAllExpandedDatasets
##    def _set(self, ReturnAllExpandedDatasets):
##        u'Return all datasets including feature datasets, topologies, and geometric networks when expanding.'
##    ReturnAllExpandedDatasets = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        '-no docstring-'
##        #return IncludeMapLayers
##    def _set(self, IncludeMapLayers):
##        '-no docstring-'
##    IncludeMapLayers = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'Resolve dataset name conflicts when creating replicas.'
##        #return ResolveNameConflicts
##    def _set(self, ResolveNameConflicts):
##        u'Resolve dataset name conflicts when creating replicas.'
##    ResolveDatasetNameConflicts = property(_get, _set, doc = _set.__doc__)
##

IDatasetComponent2._methods_ = [
    COMMETHOD(['propget', helpstring(u'The data element corresponding to the dataset component.')], HRESULT, 'ID',
              ( ['retval', 'out'], POINTER(c_int), 'datasetComponentID' )),
]
################################################################
## code template for IDatasetComponent2 implementation
##class IDatasetComponent2_Impl(object):
##    @property
##    def ID(self):
##        u'The data element corresponding to the dataset component.'
##        #return datasetComponentID
##

IRasterCatalog._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the default Raster field.')], HRESULT, 'RasterFieldName',
              ( ['retval', 'out'], POINTER(BSTR), 'Name' )),
    COMMETHOD(['propget', helpstring(u'The index of the default Raster field.')], HRESULT, 'RasterFieldIndex',
              ( ['retval', 'out'], POINTER(c_int), 'Index' )),
    COMMETHOD(['propget', helpstring(u'The index of Name field.')], HRESULT, 'NameFieldIndex',
              ( ['retval', 'out'], POINTER(c_int), 'Index' )),
    COMMETHOD(['propget', helpstring(u'The default Raster field spatial reference.')], HRESULT, 'RasterSpatialReference',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference)), 'SpatialReference' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the default Raster field spatial reference can be altered.')], HRESULT, 'CanAlterRasterSpatialReference',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'canAlter' )),
    COMMETHOD([helpstring(u'Alters the default Raster field spatial reference.')], HRESULT, 'AlterRasterSpatialReference',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference' )),
    COMMETHOD(['propget', helpstring(u'Indicates if this is a RasterDataset (a special one-row RasterCatalog).')], HRESULT, 'IsRasterDataset',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsRasterDataset' )),
]
################################################################
## code template for IRasterCatalog implementation
##class IRasterCatalog_Impl(object):
##    @property
##    def IsRasterDataset(self):
##        u'Indicates if this is a RasterDataset (a special one-row RasterCatalog).'
##        #return IsRasterDataset
##
##    def AlterRasterSpatialReference(self, SpatialReference):
##        u'Alters the default Raster field spatial reference.'
##        #return 
##
##    @property
##    def CanAlterRasterSpatialReference(self):
##        u'Indicates if the default Raster field spatial reference can be altered.'
##        #return canAlter
##
##    @property
##    def NameFieldIndex(self):
##        u'The index of Name field.'
##        #return Index
##
##    @property
##    def RasterFieldName(self):
##        u'The name of the default Raster field.'
##        #return Name
##
##    @property
##    def RasterFieldIndex(self):
##        u'The index of the default Raster field.'
##        #return Index
##
##    @property
##    def RasterSpatialReference(self):
##        u'The default Raster field spatial reference.'
##        #return SpatialReference
##

class DataElements(CoClass):
    u'A collection of DataElement objects.'
    _reg_clsid_ = GUID('{796A16FE-2F8F-4971-B14B-E42F041F6703}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DataElements._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDataElements, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersist, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLVersionSupport]

class ISqlInvalidCharacterDictionary(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to the field checker validate property which describes the invalid characters for field names for a workspace.'
    _iid_ = GUID('{B9F1CFD7-2C2F-11D3-BBAC-000000000000}')
    _idlflags_ = ['oleautomation']
ISqlInvalidCharacterDictionary._methods_ = [
    COMMETHOD(['propput', helpstring(u'String containing all of the invalid characters for field names.')], HRESULT, 'InvalidChars',
              ( ['in'], BSTR, 'InvalidChars' )),
    COMMETHOD(['propget', helpstring(u'String containing all of the invalid characters for field names.')], HRESULT, 'InvalidChars',
              ( ['retval', 'out'], POINTER(BSTR), 'InvalidChars' )),
    COMMETHOD(['propput', helpstring(u'String containing all of the characters that cannot be the first character in a field name.')], HRESULT, 'InvalidStartingChars',
              ( ['in'], BSTR, 'InvalidChars' )),
    COMMETHOD(['propget', helpstring(u'String containing all of the characters that cannot be the first character in a field name.')], HRESULT, 'InvalidStartingChars',
              ( ['retval', 'out'], POINTER(BSTR), 'InvalidChars' )),
]
################################################################
## code template for ISqlInvalidCharacterDictionary implementation
##class ISqlInvalidCharacterDictionary_Impl(object):
##    def _get(self):
##        u'String containing all of the characters that cannot be the first character in a field name.'
##        #return InvalidChars
##    def _set(self, InvalidChars):
##        u'String containing all of the characters that cannot be the first character in a field name.'
##    InvalidStartingChars = property(_get, _set, doc = _set.__doc__)
##
##    def _get(self):
##        u'String containing all of the invalid characters for field names.'
##        #return InvalidChars
##    def _set(self, InvalidChars):
##        u'String containing all of the invalid characters for field names.'
##    InvalidChars = property(_get, _set, doc = _set.__doc__)
##

IEnumIndex._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next index in the set.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(IIndex)), 'Index' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumIndex implementation
##class IEnumIndex_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next index in the set.'
##        #return Index
##

IReplicaDescriptionExtension._methods_ = [
    COMMETHOD(['propget', helpstring(u'The Name for this replica description extension.')], HRESULT, 'Name',
              ( ['retval', 'out'], POINTER(BSTR), 'rdeName' )),
    COMMETHOD(['propget', helpstring(u'The GUID that identifies the replica description extension.')], HRESULT, 'GUID',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IUID)), 'rdeGUID' )),
]
################################################################
## code template for IReplicaDescriptionExtension implementation
##class IReplicaDescriptionExtension_Impl(object):
##    @property
##    def GUID(self):
##        u'The GUID that identifies the replica description extension.'
##        #return rdeGUID
##
##    @property
##    def Name(self):
##        u'The Name for this replica description extension.'
##        #return rdeName
##

IExternalDeserializerGdb._methods_ = [
    COMMETHOD([helpstring(u'Reads spatial reference object.')], HRESULT, 'ReadSpatialReference',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference)), 'ppSR' )),
    COMMETHOD([helpstring(u'Reads geometry object.')], HRESULT, 'ReadGeometry',
              ( ['in'], comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.esriGeometryType, 'geomType' ),
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.IGeometry)), 'ppGeom' )),
]
################################################################
## code template for IExternalDeserializerGdb implementation
##class IExternalDeserializerGdb_Impl(object):
##    def ReadGeometry(self, geomType):
##        u'Reads geometry object.'
##        #return ppGeom
##
##    def ReadSpatialReference(self):
##        u'Reads spatial reference object.'
##        #return ppSR
##

IEnumTopologyNode._methods_ = [
    COMMETHOD([helpstring(u'Resets the enumerator.')], HRESULT, 'Reset'),
    COMMETHOD([helpstring(u'Returns the next topology node.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(ITopologyNode)), 'Node' )),
    COMMETHOD(['propget', helpstring(u'The number of topology nodes in the enumerator.')], HRESULT, 'Count',
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
]
################################################################
## code template for IEnumTopologyNode implementation
##class IEnumTopologyNode_Impl(object):
##    def Reset(self):
##        u'Resets the enumerator.'
##        #return 
##
##    @property
##    def Count(self):
##        u'The number of topology nodes in the enumerator.'
##        #return Count
##
##    def Next(self):
##        u'Returns the next topology node.'
##        #return Node
##

class JSONSerializerGdb(CoClass):
    u'High-level object serializer into JSON coclass.'
    _reg_clsid_ = GUID('{69BFD577-1F8A-44AE-9EF0-FDD580C01A62}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
JSONSerializerGdb._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IJSONSerializer, IExternalSerializerGdb, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

class JSONDeserializerGdb(CoClass):
    u'High-level object deserializer from JSON.'
    _reg_clsid_ = GUID('{2F106F25-6BDE-45AE-A7C5-9B1820E498C5}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
JSONDeserializerGdb._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IJSONDeserializer, IExternalDeserializerGdb, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.ISupportErrorInfo]

IIndexEdit._methods_ = [
    COMMETHOD(['propput', helpstring(u'The name of the index.')], HRESULT, 'Name',
              ( ['in'], BSTR, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the index is to be unique.')], HRESULT, 'IsUnique',
              ( ['in'], VARIANT_BOOL, 'rhs' )),
    COMMETHOD(['propput', helpstring(u'Indicates if the index is to be ascending.')], HRESULT, 'IsAscending',
              ( ['in'], VARIANT_BOOL, 'rhs' )),
    COMMETHOD(['propputref', helpstring(u'The fields collection for this index.')], HRESULT, 'Fields',
              ( ['in'], POINTER(IFields), 'rhs' )),
]
################################################################
## code template for IIndexEdit implementation
##class IIndexEdit_Impl(object):
##    def _set(self, rhs):
##        u'Indicates if the index is to be ascending.'
##    IsAscending = property(fset = _set, doc = _set.__doc__)
##
##    def Fields(self, rhs):
##        u'The fields collection for this index.'
##        #return 
##
##    def _set(self, rhs):
##        u'The name of the index.'
##    Name = property(fset = _set, doc = _set.__doc__)
##
##    def _set(self, rhs):
##        u'Indicates if the index is to be unique.'
##    IsUnique = property(fset = _set, doc = _set.__doc__)
##

class ILockInfo(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Provides access to members that supply lock information.'
    _iid_ = GUID('{751AD693-93B2-11D3-9F62-00C04F6BDDD9}')
    _idlflags_ = ['oleautomation']
IEnumLockInfo._methods_ = [
    COMMETHOD([helpstring(u'Retrieves the next lock.')], HRESULT, 'Next',
              ( ['retval', 'out'], POINTER(POINTER(ILockInfo)), 'lock' )),
    COMMETHOD([helpstring(u'Resets the enumeration sequence to the beginning.')], HRESULT, 'Reset'),
]
################################################################
## code template for IEnumLockInfo implementation
##class IEnumLockInfo_Impl(object):
##    def Reset(self):
##        u'Resets the enumeration sequence to the beginning.'
##        #return 
##
##    def Next(self):
##        u'Retrieves the next lock.'
##        #return lock
##

IXmlPropertySet2._methods_ = [
    COMMETHOD(['propget', helpstring(u'Number of occurrances of an element in the metadata.')], HRESULT, 'CountX',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(c_int), 'Count' )),
    COMMETHOD([helpstring(u'Returns the set of names and values for elements which have the specified attribute value.')], HRESULT, 'GetPropertiesByAttribute',
              ( ['in'], BSTR, 'Attribute' ),
              ( ['in'], BSTR, 'Value' ),
              ( ['in'], VARIANT_BOOL, 'noValues' ),
              ( ['out'], POINTER(VARIANT), 'Tags' ),
              ( ['out'], POINTER(VARIANT), 'values' )),
    COMMETHOD([helpstring(u'Sets the value of the specified element.')], HRESULT, 'SetPropertyX',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], VARIANT, 'Value' ),
              ( ['in'], esriXmlPropertyType, 'propType' ),
              ( ['in'], esriXmlSetPropertyAction, 'action' ),
              ( [], VARIANT_BOOL, 'syncing' )),
    COMMETHOD([helpstring(u'Deletes the specified elements.')], HRESULT, 'DeleteProperty',
              ( ['in'], BSTR, 'Name' )),
    COMMETHOD([helpstring(u'Deletes the elements which have the specified attribute value.')], HRESULT, 'DeletePropertyByAttribute',
              ( ['in'], BSTR, 'Attribute' ),
              ( ['in'], BSTR, 'Value' ),
              ( ['in'], VARIANT_BOOL, 'deleteParent' )),
    COMMETHOD(['hidden', helpstring(u'The values of the specified property.')], HRESULT, 'SimpleGetProperty',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(BSTR), 'Value' )),
    COMMETHOD([helpstring(u'Transforms the metadata using an XSL stylesheet if specified, writes out the header if specified, and saves it in a file.')], HRESULT, 'SaveAsFile',
              ( ['in'], BSTR, 'xslPath' ),
              ( ['in'], BSTR, 'header' ),
              ( ['in'], VARIANT_BOOL, 'outputANSI' ),
              ( ['in', 'out'], POINTER(BSTR), 'outPath' )),
    COMMETHOD(['propget', helpstring(u'Indicates if a new XmlPropertySet was created on retrieving the metadata.')], HRESULT, 'IsNew',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'IsNew' )),
    COMMETHOD([helpstring(u'Sets the attribute of the specified element.')], HRESULT, 'SetAttribute',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], BSTR, 'Attribute' ),
              ( ['in'], VARIANT, 'Value' ),
              ( ['in'], esriXmlSetPropertyAction, 'action' )),
    COMMETHOD([helpstring(u'Transforms encoded thumbnail and image enclosures to files and links them into the metadata.')], HRESULT, 'TransformImages',
              ( ['in'], BSTR, 'Path' ),
              ( ['out'], POINTER(VARIANT), 'fileNames' )),
    COMMETHOD([helpstring(u'Initializes an XmlPropertySet and adds the Esri group of elements.')], HRESULT, 'InitExisting'),
    COMMETHOD([helpstring(u'Initializes an XmlPropertySet without adding the Esri group of elements.')], HRESULT, 'InitGeneric',
              ( ['in'], BSTR, 'rootName' )),
    COMMETHOD([helpstring(u'Returns the XML corresponding to the specified element as a string.')], HRESULT, 'GetXml',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(BSTR), 'xml' )),
    COMMETHOD([helpstring(u'Replaces existing metadata with the content defined in the XML.')], HRESULT, 'SetXml',
              ( ['in'], BSTR, 'xml' )),
    COMMETHOD([helpstring(u'Deletes the specified elements which have the specified attribute value.')], HRESULT, 'DeletePropertyByNameAndAttribute',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], BSTR, 'Attribute' ),
              ( ['in'], BSTR, 'Value' ),
              ( ['in'], VARIANT_BOOL, 'deleteParent' )),
    COMMETHOD([helpstring(u'Returns the set of values for the specified attribute from the specified elements.')], HRESULT, 'GetAttribute',
              ( ['in'], BSTR, 'Name' ),
              ( ['in'], BSTR, 'Attribute' ),
              ( ['out'], POINTER(VARIANT), 'Value' )),
    COMMETHOD(['propput', helpstring(u"Indicates if the Sync attribute will be ignored when setting an element's value.")], HRESULT, 'OverwriteSyncAttribute',
              ( ['in'], VARIANT_BOOL, 'overwriteSyncAttributes' )),
    COMMETHOD(['propget', helpstring(u"Indicates if the Sync attribute will be ignored when setting an element's value.")], HRESULT, 'OverwriteSyncAttribute',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'overwriteSyncAttributes' )),
]
################################################################
## code template for IXmlPropertySet2 implementation
##class IXmlPropertySet2_Impl(object):
##    def SimpleGetProperty(self, Name):
##        u'The values of the specified property.'
##        #return Value
##
##    def DeletePropertyByNameAndAttribute(self, Name, Attribute, Value, deleteParent):
##        u'Deletes the specified elements which have the specified attribute value.'
##        #return 
##
##    def InitGeneric(self, rootName):
##        u'Initializes an XmlPropertySet without adding the Esri group of elements.'
##        #return 
##
##    def TransformImages(self, Path):
##        u'Transforms encoded thumbnail and image enclosures to files and links them into the metadata.'
##        #return fileNames
##
##    @property
##    def IsNew(self):
##        u'Indicates if a new XmlPropertySet was created on retrieving the metadata.'
##        #return IsNew
##
##    def GetAttribute(self, Name, Attribute):
##        u'Returns the set of values for the specified attribute from the specified elements.'
##        #return Value
##
##    def SetAttribute(self, Name, Attribute, Value, action):
##        u'Sets the attribute of the specified element.'
##        #return 
##
##    def SetPropertyX(self, Name, Value, propType, action, syncing):
##        u'Sets the value of the specified element.'
##        #return 
##
##    def InitExisting(self):
##        u'Initializes an XmlPropertySet and adds the Esri group of elements.'
##        #return 
##
##    @property
##    def CountX(self, Name):
##        u'Number of occurrances of an element in the metadata.'
##        #return Count
##
##    def DeletePropertyByAttribute(self, Attribute, Value, deleteParent):
##        u'Deletes the elements which have the specified attribute value.'
##        #return 
##
##    def _get(self):
##        u"Indicates if the Sync attribute will be ignored when setting an element's value."
##        #return overwriteSyncAttributes
##    def _set(self, overwriteSyncAttributes):
##        u"Indicates if the Sync attribute will be ignored when setting an element's value."
##    OverwriteSyncAttribute = property(_get, _set, doc = _set.__doc__)
##
##    def GetPropertiesByAttribute(self, Attribute, Value, noValues):
##        u'Returns the set of names and values for elements which have the specified attribute value.'
##        #return Tags, values
##
##    def GetXml(self, Name):
##        u'Returns the XML corresponding to the specified element as a string.'
##        #return xml
##
##    def SaveAsFile(self, xslPath, header, outputANSI):
##        u'Transforms the metadata using an XSL stylesheet if specified, writes out the header if specified, and saves it in a file.'
##        #return outPath
##
##    def DeleteProperty(self, Name):
##        u'Deletes the specified elements.'
##        #return 
##
##    def SetXml(self, xml):
##        u'Replaces existing metadata with the content defined in the XML.'
##        #return 
##

ICursor._methods_ = [
    COMMETHOD([helpstring(u'The index of the field with the specified name.')], HRESULT, 'FindField',
              ( ['in'], BSTR, 'Name' ),
              ( ['retval', 'out'], POINTER(c_int), 'FieldIndex' )),
    COMMETHOD(['propget', helpstring(u'The Fields Collection for this cursor.')], HRESULT, 'Fields',
              ( ['retval', 'out'], POINTER(POINTER(IFields)), 'Fields' )),
    COMMETHOD([helpstring(u'Advance the position of the cursor by one and return the Row object at that position.')], HRESULT, 'NextRow',
              ( ['retval', 'out'], POINTER(POINTER(IRow)), 'Row' )),
    COMMETHOD([helpstring(u'Update the existing Row in the database corresponding to the current position of the cursor.')], HRESULT, 'UpdateRow',
              ( ['in'], POINTER(IRow), 'Row' )),
    COMMETHOD([helpstring(u'Delete the existing Row in the database corresponding to the current position of the cursor.')], HRESULT, 'DeleteRow'),
    COMMETHOD([helpstring(u'Insert a new Row into the database using the property values in the input buffer. The object ID of the new Row, if there is one, is returned.')], HRESULT, 'InsertRow',
              ( ['in'], POINTER(IRowBuffer), 'buffer' ),
              ( ['retval', 'out'], POINTER(VARIANT), 'OID' )),
    COMMETHOD([helpstring(u'Flush any outstanding buffered writes to the database.')], HRESULT, 'Flush'),
]
################################################################
## code template for ICursor implementation
##class ICursor_Impl(object):
##    @property
##    def Fields(self):
##        u'The Fields Collection for this cursor.'
##        #return Fields
##
##    def DeleteRow(self):
##        u'Delete the existing Row in the database corresponding to the current position of the cursor.'
##        #return 
##
##    def FindField(self, Name):
##        u'The index of the field with the specified name.'
##        #return FieldIndex
##
##    def InsertRow(self, buffer):
##        u'Insert a new Row into the database using the property values in the input buffer. The object ID of the new Row, if there is one, is returned.'
##        #return OID
##
##    def NextRow(self):
##        u'Advance the position of the cursor by one and return the Row object at that position.'
##        #return Row
##
##    def Flush(self):
##        u'Flush any outstanding buffered writes to the database.'
##        #return 
##
##    def UpdateRow(self, Row):
##        u'Update the existing Row in the database corresponding to the current position of the cursor.'
##        #return 
##

IDEFeatureDataset._methods_ = [
]
################################################################
## code template for IDEFeatureDataset implementation
##class IDEFeatureDataset_Impl(object):

class DETable(CoClass):
    u'Table Data Element object.'
    _reg_clsid_ = GUID('{9C8405DB-BB87-4BD6-932D-7FFB35B04BA0}')
    _idlflags_ = []
    _typelib_path_ = typelib_path
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)
DETable._com_interfaces_ = [comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown, IDETable, IDEGdbTable2, IDEEditorTracking, IDEDataset2, IDataElement, IMetadata, IGPValue, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IXMLSerialize, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IClone, comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IPersistStream, IGPDescribe]


# values for enumeration 'esriLockType'
esriLockTypeShared = 1
esriLockTypeExclusive = 2
esriLockType = c_int # enum
ILockInfo._methods_ = [
    COMMETHOD(['propget', helpstring(u'The name of the user that acquired the lock.')], HRESULT, 'UserName',
              ( ['retval', 'out'], POINTER(BSTR), 'user' )),
    COMMETHOD(['propget', helpstring(u'The type of lock the user acquired.')], HRESULT, 'LockType',
              ( ['retval', 'out'], POINTER(esriLockType), 'LockType' )),
]
################################################################
## code template for ILockInfo implementation
##class ILockInfo_Impl(object):
##    @property
##    def UserName(self):
##        u'The name of the user that acquired the lock.'
##        #return user
##
##    @property
##    def LockType(self):
##        u'The type of lock the user acquired.'
##        #return LockType
##

IWorkspaceFactory2._methods_ = [
    COMMETHOD([helpstring(u'Opens the workspace specified by a connection string.')], HRESULT, 'OpenFromString',
              ( ['in'], BSTR, 'connectStr' ),
              ( ['in'], comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.OLE_HANDLE, 'hWnd' ),
              ( ['retval', 'out'], POINTER(POINTER(IWorkspace)), 'Workspace' )),
]
################################################################
## code template for IWorkspaceFactory2 implementation
##class IWorkspaceFactory2_Impl(object):
##    def OpenFromString(self, connectStr, hWnd):
##        u'Opens the workspace specified by a connection string.'
##        #return Workspace
##

IXYEventSourceName._methods_ = [
    COMMETHOD(['propputref', helpstring(u'The name object for the XY event table.')], HRESULT, 'EventTableName',
              ( ['in'], POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName), 'aName' )),
    COMMETHOD(['propget', helpstring(u'The name object for the XY event table.')], HRESULT, 'EventTableName',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._5E1F7BC3_67C5_4AEE_8EC6_C4B73AAC42ED_0_10_2.IName)), 'aName' )),
    COMMETHOD(['propputref', helpstring(u'The XY event properties.')], HRESULT, 'EventProperties',
              ( ['in'], POINTER(IXYEventProperties), 'xyProperties' )),
    COMMETHOD(['propget', helpstring(u'The XY event properties.')], HRESULT, 'EventProperties',
              ( ['retval', 'out'], POINTER(POINTER(IXYEventProperties)), 'xyProperties' )),
    COMMETHOD(['propputref', helpstring(u'The spatial reference of the XYEventSource.')], HRESULT, 'SpatialReference',
              ( ['in'], POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference), 'SpatialReference' )),
    COMMETHOD(['propget', helpstring(u'The spatial reference of the XYEventSource.')], HRESULT, 'SpatialReference',
              ( ['retval', 'out'], POINTER(POINTER(comtypes.gen._C4B094C2_FF32_4FA1_ABCB_7820F8D6FB68_0_10_2.ISpatialReference)), 'SpatialReference' )),
]
################################################################
## code template for IXYEventSourceName implementation
##class IXYEventSourceName_Impl(object):
##    @property
##    def EventProperties(self, xyProperties):
##        u'The XY event properties.'
##        #return 
##
##    @property
##    def EventTableName(self, aName):
##        u'The name object for the XY event table.'
##        #return 
##
##    @property
##    def SpatialReference(self, SpatialReference):
##        u'The spatial reference of the XYEventSource.'
##        #return 
##

class Library(object):
    u'Esri GeoDatabase Object Library 10.2'
    name = u'esriGeoDatabase'
    _reg_typelib_ = ('{0475BDB1-E5B2-4CA2-9127-B4B1683E70C2}', 10, 2)

class INetworkProtectNames(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{27BA2CDD-B683-11D5-A007-00C04F68E627}')
    _idlflags_ = ['hidden']
INetworkProtectNames._methods_ = [
    COMMETHOD([], HRESULT, 'JunctionWeight'),
    COMMETHOD([], HRESULT, 'FromToEdgeWeight'),
    COMMETHOD([], HRESULT, 'ToFromEdgeWeight'),
    COMMETHOD([], HRESULT, 'NetworkID'),
]
################################################################
## code template for INetworkProtectNames implementation
##class INetworkProtectNames_Impl(object):
##    def FromToEdgeWeight(self):
##        '-no docstring-'
##        #return 
##
##    def ToFromEdgeWeight(self):
##        '-no docstring-'
##        #return 
##
##    def JunctionWeight(self):
##        '-no docstring-'
##        #return 
##
##    def NetworkID(self):
##        '-no docstring-'
##        #return 
##

class IGeoDBProtectNames(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{C2697CBC-3D8A-4888-AE34-5C35180181A6}')
    _idlflags_ = ['hidden']
IGeoDBProtectNames._methods_ = [
    COMMETHOD([], HRESULT, 'Role'),
    COMMETHOD([], HRESULT, 'DatasetType'),
    COMMETHOD([], HRESULT, 'SelectionIDs'),
    COMMETHOD([], HRESULT, 'DefQuery'),
    COMMETHOD([], HRESULT, 'ModelType'),
    COMMETHOD([], HRESULT, 'Rule'),
    COMMETHOD([], HRESULT, 'EnumNameMapping'),
    COMMETHOD([], HRESULT, 'InvalidArea'),
    COMMETHOD([], HRESULT, 'EventNotificationOnValidate'),
    COMMETHOD([], HRESULT, 'Topology'),
    COMMETHOD([], HRESULT, 'XYRank'),
    COMMETHOD([], HRESULT, 'ZRank'),
    COMMETHOD([], HRESULT, 'EdgeCount'),
    COMMETHOD([], HRESULT, 'Classes'),
    COMMETHOD([], HRESULT, 'ElementID'),
    COMMETHOD([], HRESULT, 'ConfigKeyword'),
    COMMETHOD([], HRESULT, 'CopyDataset'),
    COMMETHOD([], HRESULT, 'ReplicaName'),
    COMMETHOD([], HRESULT, 'DeltaFile'),
]
################################################################
## code template for IGeoDBProtectNames implementation
##class IGeoDBProtectNames_Impl(object):
##    def EdgeCount(self):
##        '-no docstring-'
##        #return 
##
##    def CopyDataset(self):
##        '-no docstring-'
##        #return 
##
##    def Rule(self):
##        '-no docstring-'
##        #return 
##
##    def EventNotificationOnValidate(self):
##        '-no docstring-'
##        #return 
##
##    def Topology(self):
##        '-no docstring-'
##        #return 
##
##    def ConfigKeyword(self):
##        '-no docstring-'
##        #return 
##
##    def Classes(self):
##        '-no docstring-'
##        #return 
##
##    def Role(self):
##        '-no docstring-'
##        #return 
##
##    def ModelType(self):
##        '-no docstring-'
##        #return 
##
##    def ReplicaName(self):
##        '-no docstring-'
##        #return 
##
##    def DefQuery(self):
##        '-no docstring-'
##        #return 
##
##    def DeltaFile(self):
##        '-no docstring-'
##        #return 
##
##    def InvalidArea(self):
##        '-no docstring-'
##        #return 
##
##    def XYRank(self):
##        '-no docstring-'
##        #return 
##
##    def DatasetType(self):
##        '-no docstring-'
##        #return 
##
##    def SelectionIDs(self):
##        '-no docstring-'
##        #return 
##
##    def ZRank(self):
##        '-no docstring-'
##        #return 
##
##    def ElementID(self):
##        '-no docstring-'
##        #return 
##
##    def EnumNameMapping(self):
##        '-no docstring-'
##        #return 
##


# values for enumeration 'esriSQLPredicates'
esriSQL_EQ = 1
esriSQL_NOT_EQ = 2
esriSQL_LT = 4
esriSQL_GT = 8
esriSQL_LE = 16
esriSQL_GE = 32
esriSQL_BETWEEN = 64
esriSQL_NOT_BETWEEN = 128
esriSQL_IN = 256
esriSQL_NOT_IN = 512
esriSQL_LIKE = 1024
esriSQL_NOT_LIKE = 2048
esriSQL_IS_NULL = 4096
esriSQL_IS_NOT_NULL = 8192
esriSQL_EXISTS = 16384
esriSQL_NOT_EXISTS = 32768
esriSQL_SIMILAR_TO = 65536
esriSQL_NOT_SIMILAR_TO = 131072
esriSQLPredicates = c_int # enum
class IRemoteDatabaseWorkspace(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    u'Indicator interface that identifies a remote datasbase workspace.'
    _iid_ = GUID('{AB4A2D79-055B-11D2-AA97-00C04FA33A15}')
    _idlflags_ = ['oleautomation']
IRemoteDatabaseWorkspace._methods_ = [
]
################################################################
## code template for IRemoteDatabaseWorkspace implementation
##class IRemoteDatabaseWorkspace_Impl(object):

class INetworkDatasetProtectNames(comtypes.gen._00020430_0000_0000_C000_000000000046_0_2_0.IUnknown):
    _case_insensitive_ = True
    _iid_ = GUID('{6FA57161-133D-4DAE-88F4-A910D53D7A04}')
    _idlflags_ = ['hidden']
INetworkDatasetProtectNames._methods_ = [
    COMMETHOD([], HRESULT, 'MaxEID'),
    COMMETHOD([], HRESULT, 'FromAzimuth'),
    COMMETHOD([], HRESULT, 'ToAzimuth'),
    COMMETHOD([], HRESULT, 'FromPercent'),
    COMMETHOD([], HRESULT, 'ToPercent'),
    COMMETHOD([], HRESULT, 'FromJunction'),
    COMMETHOD([], HRESULT, 'ToJunction'),
    COMMETHOD([], HRESULT, 'Source'),
    COMMETHOD([], HRESULT, 'AttributeValue'),
    COMMETHOD([], HRESULT, 'DataType'),
    COMMETHOD([], HRESULT, 'DataElement'),
    COMMETHOD([], HRESULT, 'SubnetNames'),
    COMMETHOD([], HRESULT, 'AttributeName'),
    COMMETHOD([], HRESULT, 'Evaluator'),
    COMMETHOD([], HRESULT, 'Junction'),
    COMMETHOD([], HRESULT, 'Turn'),
    COMMETHOD([], HRESULT, 'Edge'),
    COMMETHOD([], HRESULT, 'HasTurnRestriction'),
    COMMETHOD([], HRESULT, 'SchemaState'),
    COMMETHOD([], HRESULT, 'SourceCount'),
    COMMETHOD([], HRESULT, 'FirstEdgeEID'),
    COMMETHOD([], HRESULT, 'LastEdgeEID'),
    COMMETHOD([], HRESULT, 'AtJunctionEID'),
    COMMETHOD([], HRESULT, 'NetworkDataset'),
    COMMETHOD([], HRESULT, 'IsDefault'),
    COMMETHOD([], HRESULT, 'SourceName'),
    COMMETHOD([], HRESULT, 'StorageType'),
    COMMETHOD([], HRESULT, 'Sources'),
    COMMETHOD([], HRESULT, 'SourceType'),
    COMMETHOD([], HRESULT, 'AttributeID'),
    COMMETHOD([], HRESULT, 'NumComplexTurns'),
    COMMETHOD([], HRESULT, 'Data'),
    COMMETHOD([], HRESULT, 'IsFiltered'),
    COMMETHOD([], HRESULT, 'NewIndex'),
    COMMETHOD([], HRESULT, 'SourceOID'),
    COMMETHOD([], HRESULT, 'LastModified'),
    COMMETHOD([], HRESULT, 'NetworkSource'),
    COMMETHOD([], HRESULT, 'NetworkAttribute'),
]
################################################################
## code template for INetworkDatasetProtectNames implementation
##class INetworkDatasetProtectNames_Impl(object):
##    def FromPercent(self):
##        '-no docstring-'
##        #return 
##
##    def HasTurnRestriction(self):
##        '-no docstring-'
##        #return 
##
##    def LastModified(self):
##        '-no docstring-'
##        #return 
##
##    def SchemaState(self):
##        '-no docstring-'
##        #return 
##
##    def Source(self):
##        '-no docstring-'
##        #return 
##
##    def LastEdgeEID(self):
##        '-no docstring-'
##        #return 
##
##    def FromJunction(self):
##        '-no docstring-'
##        #return 
##
##    def Junction(self):
##        '-no docstring-'
##        #return 
##
##    def Sources(self):
##        '-no docstring-'
##        #return 
##
##    def SourceName(self):
##        '-no docstring-'
##        #return 
##
##    def ToJunction(self):
##        '-no docstring-'
##        #return 
##
##    def ToPercent(self):
##        '-no docstring-'
##        #return 
##
##    def ToAzimuth(self):
##        '-no docstring-'
##        #return 
##
##    def AttributeID(self):
##        '-no docstring-'
##        #return 
##
##    def NetworkAttribute(self):
##        '-no docstring-'
##        #return 
##
##    def Evaluator(self):
##        '-no docstring-'
##        #return 
##
##    def Data(self):
##        '-no docstring-'
##        #return 
##
##    def NewIndex(self):
##        '-no docstring-'
##        #return 
##
##    def SourceCount(self):
##        '-no docstring-'
##        #return 
##
##    def SourceOID(self):
##        '-no docstring-'
##        #return 
##
##    def AtJunctionEID(self):
##        '-no docstring-'
##        #return 
##
##    def SubnetNames(self):
##        '-no docstring-'
##        #return 
##
##    def Turn(self):
##        '-no docstring-'
##        #return 
##
##    def Edge(self):
##        '-no docstring-'
##        #return 
##
##    def NetworkSource(self):
##        '-no docstring-'
##        #return 
##
##    def FromAzimuth(self):
##        '-no docstring-'
##        #return 
##
##    def IsDefault(self):
##        '-no docstring-'
##        #return 
##
##    def SourceType(self):
##        '-no docstring-'
##        #return 
##
##    def AttributeValue(self):
##        '-no docstring-'
##        #return 
##
##    def DataType(self):
##        '-no docstring-'
##        #return 
##
##    def MaxEID(self):
##        '-no docstring-'
##        #return 
##
##    def DataElement(self):
##        '-no docstring-'
##        #return 
##
##    def AttributeName(self):
##        '-no docstring-'
##        #return 
##
##    def StorageType(self):
##        '-no docstring-'
##        #return 
##
##    def IsFiltered(self):
##        '-no docstring-'
##        #return 
##
##    def NetworkDataset(self):
##        '-no docstring-'
##        #return 
##
##    def FirstEdgeEID(self):
##        '-no docstring-'
##        #return 
##
##    def NumComplexTurns(self):
##        '-no docstring-'
##        #return 
##

ITopologyNode._methods_ = [
    COMMETHOD(['propget', helpstring(u'The set of topological edges incident on this node.')], HRESULT, 'Edges',
              ( [], VARIANT_BOOL, 'clockwise' ),
              ( ['retval', 'out'], POINTER(POINTER(IEnumNodeEdge)), 'Edges' )),
    COMMETHOD(['propget', helpstring(u'The number of edges entering and leaving this node. Closed edges are counted twice.')], HRESULT, 'Degree',
              ( ['retval', 'out'], POINTER(c_int), 'Degree' )),
    COMMETHOD(['propget', helpstring(u'Indicates if the degree of this node is known. Nodes constructed from edges that are partially outside the build extent have unknown degrees.')], HRESULT, 'IsDegreeKnown',
              ( ['retval', 'out'], POINTER(VARIANT_BOOL), 'degreeKnown' )),
]
################################################################
## code template for ITopologyNode implementation
##class ITopologyNode_Impl(object):
##    @property
##    def IsDegreeKnown(self):
##        u'Indicates if the degree of this node is known. Nodes constructed from edges that are partially outside the build extent have unknown degrees.'
##        #return degreeKnown
##
##    @property
##    def Edges(self, clockwise):
##        u'The set of topological edges incident on this node.'
##        #return Edges
##
##    @property
##    def Degree(self):
##        u'The number of edges entering and leaving this node. Closed edges are counted twice.'
##        #return Degree
##

__all__ = ['NETWORK_E_CANNOT_READ_TABLE', 'esriGeometryStorageST',
           'VersionEvents2', 'esriRelClassCodeType',
           'FDO_E_SE_DUPLICATE_ARC',
           'FDO_E_CLASS_IN_TOPOLOGY_REQUIRES_EDIT_SESSION',
           'FDO_E_WORKSPACE_NO_KEYSETTABLE', 'IDatasetNameFileSize',
           'esriLocatorWorkspaceType', 'E_TIN_ZERO_VALUE',
           'FDO_E_SE_LOG_NOTOPEN', 'esriNJCPHonor',
           'FDO_E_INVALID_NAME_OBJECT',
           'FDO_E_FEATURECLASS_NOT_FOUND', 'esriNAUMillimeters',
           'IGPReplicaDataset', 'IJunctionConnectivityRule2',
           'esriNetworkJunctionConnectivityPolicy',
           'E_TIN_ALREADY_INITIALIZED',
           'FDO_E_INVALID_NETWORK_DATASET_SCHEMA', 'INetElementClass',
           'esriDTTerrain', 'esriSelectionType',
           'IJunctionFeatureSource', 'EditorTrackingInfo',
           'FDO_E_ID_OVERFLOW',
           'FDO_E_ITEM_RELATIONSHIP_ITEM_NOT_FOUND',
           'FDO_E_REPLICATION_NOT_SUPPORTED_IN_RELEASE',
           'esriTinZLessHardClip', 'IXMLIndexTemplate',
           'E_TIN_WORKSPACE_NOT_CONNECTED',
           'FDO_E_TOPOLOGY_ILLEGAL_RESHAPE',
           'esriTablePropMaxFieldNameLength', 'esriNADTInteger',
           'FDO_E_MOVE_RELATED_FEATURES_FAILED',
           'esriSurfaceConversionType',
           'NETWORK_E_INVALID_FIELD_NAME',
           'IRepairConnectivityProgress', 'ITinEditErrorLog',
           'esriRelKeyTypeSingle', 'TrafficDataManager',
           'esriNSInvalidName', 'IEnumObjectClass',
           'FDO_E_NETWORK_FUNCTION_EVALUATOR_MISSING_REFERENCED_NETWORK_ATTRIBUTE',
           'RasterCatalog', 'esriNADTBoolean',
           'FDO_E_FEATURE_OUTSIDE_SPATIALREF',
           'esriXmlSetPropertyAction', 'esriSQL_LE',
           'FDO_E_INSTANCE_IS_NOT_UPGRADABLE', 'esriDTTopology',
           'esriTinSurfaceArea', 'FDO_E_REPLICA_OLD_ACK',
           'DEWorkspace', 'IPersistStreamInit', 'esriUpdatePrivilege',
           'FDO_E_FIELDS_MULTIPLE_OIDS',
           'E_DATACONVERTER_OPENCURSORFAILED', 'esriNAUDays',
           'esriDSValid', 'IObjectClassContainer',
           'IEdgeConnectivityRule',
           'FDO_E_CANNOT_MODIFY_SCHEMA_WHILE_EDITING',
           'esriTRTPointProperlyInsideArea',
           'FDO_E_FEATURECLASS_NETWORK_CANNOT_RENAME',
           'FDO_E_DOMAIN_INCOMPATIBLE_WITH_DEFAULT_VALUE',
           'IComplexNetworkFeature', 'FDO_E_SUBTYPES_NOT_IN_USE',
           'NETWORK_E_EDIT_OPERATION_IN_PROGRESS',
           'esriDBMS_PostgreSQL',
           'FDO_E_SE_NORMALIZE_VALUE_NOT_FOUND',
           'esriNSInvalidConnection', 'esriInvalidFieldNameLength',
           'IFieldError', 'FDO_E_IDENTICAL_FROM_TO_JUNCTIONS',
           'esriWCSDown', 'IWorkspaceConfiguration', 'AttributeRule',
           'NETWORK_E_BAD_TURN_INTERIOR_EXTERIOR_CONFLICT',
           'esriSQL_MOD', 'esriRelCardinalityManyToMany',
           'FDO_E_INVALID_TOPOLOGY', 'esriRowsTypeNone',
           'FDO_E_SE_TOPO_ERROR', 'IEnumNetEIDBuilderGEN',
           'FDO_E_INVALID_CONNECTIVITY_RULE',
           'FDO_E_CADASTRAL_FABRIC_MISSING_SYSTEM_TABLE',
           'INetworkDataset', 'FDO_E_NETWORK_ELEMENT_ID_BEYOND_MAX',
           'esriXmlPropertyType', 'IRelationship', 'esriFeatureTable',
           'esriNETConnectivity', 'esriNDTSDC',
           'IPlugInFastQueryValues', 'DEWorkspaceType', 'IShields',
           'IDERasterBandType', 'IWorkspaceExtension',
           'FDO_E_CANNOT_STORE_RECYCLED_ROW_IN_EDIT_SESSION',
           'esriConfigurationKeywordTerrain',
           'esriXMLIndexTypeDefined', 'FDO_E_SE_OUT_OF_CLMEM',
           'IEnumNetEIDBuilder', 'esriNETMissingAnyElements',
           'esriNAReadWrite', 'esriSQL_WildcardManyMatch',
           'esriRSPDeleteRelationship', 'esriFieldTypeString',
           'esriTinZLessSoftErase', 'E_TIN_WRONG_DATASET_TYPE',
           'NetworkAttribute', 'FDO_E_SE_INVALID_RADIUS',
           'esriDBMS_SQLServer', 'esriMSANotCreated',
           'IDataConvertProcess', 'esriSQL_IN',
           'IDEGeometricNetworkType', 'IEnumFeatureClass',
           'FDO_E_SE_LICENSE_EXPIRED', 'FDO_E_SE_LAYERS_NOT_FOUND',
           'esriPercentageSlopeAsRaster', 'IRasterCatalogItem',
           'esriRelRoleOrigin', 'FDO_E_NOT_CONSTANT_EVALUATOR',
           'FDO_E_TABLE_NO_GLOBALID_FIELD',
           'FDO_E_SE_NO_LAYER_SPECIFIED',
           'NETWORK_E_ELEMENT_TYPE_MISMATCH', 'E_TIN_WRONG_SEED_TYPE',
           'esriRasterResamplingClosest', 'esriRCRamp',
           'DEFeatureDataset', 'IXMLIndexTemplateManage',
           'FDO_E_INVALID_NETWORK_LANDMARK_SOURCE_GEOMETRY_TYPE',
           'INetworkProtectNames', 'FDO_E_SE_NOT_IMPLEMENTED_YET',
           'esriDBMS_Oracle', 'E_TIN_CANCELLED',
           'FDO_E_SE_DB_IO_ERROR', 'Tin',
           'FDO_E_FORWARDSTAR_REMOVE_CACHED_ATTRIBUTES_DEPRECATED',
           'FDO_E_SE_POLY_SHELLS_OVERLAP',
           'FDO_E_SE_ARRAY_BYTES_EXCEEDED', 'esriNAUTCost',
           'FDO_E_CHILD_REPLICA_CANNOT_BE_CREATED_IN_PARENTDB',
           'esriGeodatabaseVersion', 'IEnumReplica',
           'esriNSUnknownStatus', 'NetworkAttributeParameter',
           'IFeatureDataset', 'IJSONConverterGdb', 'IDEMapServerType',
           'FDO_E_TOPOLOGY_NOT_FOUND', 'esriTinSelectionSubtract',
           'IDatabaseConnectionInfo', 'TinSurfaceElement',
           'esriServerClassEnterprise', 'esriSQL_NULLIF',
           'IIndexesEdit', 'esriGeodatabaseVersion10',
           'FDO_E_SPLITTING_POLYGONS_REQUIRES_POLYLINE',
           'FDO_E_INVALID_TIME_ZONE_OBJECTID', 'IDEFeatureDataset',
           'IRebuildIndexes', 'esriTopoDirection',
           'E_DATACONVERTER_MATCHINPUTFIELDSETFAILED', 'IDataElement',
           'esriTinArea', 'IRelQueryTable',
           'FDO_E_SE_INVALID_RASBANDINFO_OBJECT',
           'FDO_E_USE_BY_DEFAULT_NOT_SUPPORTED',
           'XYEVENT_E_INVALID_Z_TYPE', 'esriTinElementType',
           'IPlugInRowCount', 'esriDTNetworkDataset',
           'esriHillShadeAsRaster', 'esriSpatialRelRelation',
           'IDatasetAnalyze',
           'FDO_E_WORKSPACE_EXTENSION_CREATE_FAILED',
           'esriConfigurationKeywordGeneral',
           'esriWorkspaceConnectionStatus', 'FDO_E_SE_LAYER_MISMATCH',
           'esriSQL_NOT_LIKE', 'IComplexEdgeFeature',
           'esriSearchOrder', 'NETWORK_E_INVALID_TABLE_NAME',
           'FDO_E_FIELD_CANNOT_DELETE_RELKEY_FIELD',
           'NETWORK_E_INVALID_WEIGHT_ELEMENT_TYPES',
           'ObjectClassEvents',
           'FDO_E_CODED_VALUE_DOMAIN_FIELD_TYPE_NOT_COMPATIBLE',
           'FDO_E_SE_LAYER_LOCKED', 'esriXYEventError', 'esriDTStyle',
           'IPlugInDatasetHelper3', 'IPlugInDatasetHelper2',
           'FDO_E_RELCLASS_COULD_NOT_GET_DEST_FOR_KEY',
           'FDO_E_DOMAIN_USED_BY_OTHER_WORKSPACE', 'DEGPServerType',
           'DddServerEnvironment', 'IGPReplicaDataset2',
           'ITinSurface', 'FDO_E_FIELD_IS_KEYWORD',
           'FDO_E_FIELD_HAS_DEFAULT_VALUE', 'esriElementType',
           'FDO_E_SE_INVALID_LOCK_MODE', 'IDatasetNameFileStat2',
           'esriEditDataChangesWithinOperation', 'INetworkQuery2',
           'FDO_E_FEATURECLASS_ALREADY_EXISTS',
           'IWorkspaceEditEvents2',
           'FDO_E_NETWORK_BAD_EDGE_ORIENTATION', 'DETable',
           'esriReplicaStateSendingAcknowledgment',
           'FDO_E_TOPOLOGY_ENGINE_TEMP_SPACE_EXHAUSTED',
           'FDO_E_WORKSPACE_EXTENSION_DATASET_CREATE_FAILED',
           'RasterStorageDef', 'StreetNetwork',
           'FDO_E_DOMAIN_TYPE_DOESNT_MATCH', 'IReplicaLog',
           'FDO_E_DUPLICATE_FIELD_NAMES',
           'IGeometricNetworkConnectivity',
           'esriGeoDatabaseServerMessageCode_WarningMessage',
           'FDO_E_DATASOURCE_LOCK_FAILED', 'ILocatorWorkspaceName',
           'FDO_E_OPERATION_NOT_SUPPORTED_ON_BUILDABLE_NETWORK',
           'esriDrawStyle', 'esriSQL_LIKE',
           'IWorkspaceFactoryLockControl', 'IClassHelper',
           'FDO_E_CADASTRAL_FABRIC_JOB_ALREADY_COMMITTED',
           'IRecordNumberSet', 'FDO_E_SE_SERVICE_NOT_FOUND',
           'esriNADTDouble', 'esriSetDifference',
           'IRouteEventSourceName', 'RasterCatalogItem',
           'IXmlPropertySet2', 'FDO_E_TOPOLOGY_EXTENT_TOO_LARGE',
           'esriReplicaChildReadOnly', 'SelectionSet',
           'IAttachmentDataArray', 'esriTransformType',
           'IWorkspaceEditInfo', 'PT_CHAR', 'IPlugInCreateWorkspace',
           'esriSQL_GROUP_BY',
           'FDO_E_CANNOT_MODIFY_SYSTEM_MANAGED_TABLES',
           'ITinNodeInfo', 'esriTRTAreaContainPoint',
           'esriDataCheckOut', 'IWorkspace2', 'INetworkCollection2',
           'IMemoryRelationshipClassName', 'RelationshipClassEvents',
           'FDO_E_SE_INVALID_LAYER_KEYWORD',
           'FDO_E_SE_INVALID_TRANSID', 'esriDTToolbox',
           'esriNetworkAttributeUsageType', 'FDO_E_TABLE_NOT_EMPTY',
           'FDO_E_NOT_ALLOWED_WHILE_EDITING', 'esriTinDegreeAspect',
           'FDO_E_FLUSH_EDITS_FAILED', 'esriSQL_COALESCE',
           'IRelationshipClassInfo', 'ITinElement',
           'ObjectClassSchemaEvents', 'IEnumNodeEdge',
           'esriDTLasDataset', 'ITimeAwareEvaluator',
           'esriGPMessageSeverityInformative',
           'esriRasterCompressionCCITTG4', 'E_TIN_WRONG_TOPOLOGY',
           'FDO_E_SYNCHRONIZATION_CONFLICTS', 'esriRSPDeleteParts',
           'IFieldType', 'esriRasterCompressionCCITTG3',
           'FDO_E_DIRTY_AREA_OUTSIDE_SPATIAL_DOMAIN',
           'IPlugInDatasetHelper', 'IRelatedObjectClassEvents',
           'FDO_E_CANNOT_EDIT_COMPRESSED_DATASET', 'Cursor',
           'esriNECPAnyVertex', 'INetworkFieldEvaluator2',
           'IGeometryDef', 'FDO_E_METADATA_FIELD_NOT_FOUND',
           'esriTinSoftLine', 'FDO_E_RULE_NOT_FOUND',
           'TinValueFilter', 'esriNTACLeft',
           'FDO_E_SE_UNSUPPORTED_OPERATION', 'ICopyHelper',
           'FDO_E_SE_NET_FAILURE', 'IGeoDBDataTransfer',
           'esriDTRasterDataset', 'IGPSubtype',
           'TinDataElementFilter', 'IDEGPServerType',
           'NETWORK_E_INVALID_WEIGHT_NAME', 'IFeatureWorkspaceManage',
           'ITableWrite', 'IExtractionUtilities', 'PT_COMPLEX',
           'esriEditSearchOption', 'E_TIN_FDS_FATAL',
           'REP_E_INVALID_LICENSE', 'E_TIN_INVALID_LANDXML_FILE',
           'IEnumDomain', 'TableNameSet', 'esriReplicaRoleChild',
           'esriTinHardValueFill', 'esriRelKeyRoleOriginPrimary',
           'FDO_E_INVALID_TRAFFIC_DATA', 'FDO_E_SE_RASTERBAND_EXISTS',
           'E_TIN_FAILED_TO_OVER_WRITE', 'esriMCTConnectivityPolicy',
           'FDO_E_COMPRESSED_DATASET_NOT_INSTALLED', 'esriDTText',
           'esriDSUnknown', 'FDO_E_SE_CAD_EXISTS',
           'FDO_E_DOES_NOT_SUPPORT_UNMANAGED_RASTER_CATALOG',
           'FDO_E_TURN_INVALID_EDGE1END', 'FDO_E_FEATURE_NOT_FOUND',
           'FDO_E_DATASOURCE_RELEASELOCK_FAILED',
           'IRelatedObjectEvents', 'esriRelNotification',
           'FDO_E_NEGATIVE_FID', 'FDO_E_SE_TOO_MANY_REGISTRATIONS',
           'FDO_E_NO_DEFAULT_TURN_EVALUATOR',
           'IWorkspaceReplicasAdmin', 'esriNFARSource',
           'esriHasInvalidStartingCharacter', 'IEnumHistoricalMarker',
           'IObjectClassSchemaEvents', 'INetworkDirections2',
           'IEnumConfigurationParameter',
           'FDO_E_SE_SDETRACELOC_NOT_SET',
           'FDO_E_TOPOLOGY_EDGE_NOT_SELECTABLE',
           'IAttachmentInfoArray', 'FDO_E_NO_ASSOCIATED_ERROR_TABLE',
           'FDO_E_FIELDS_NO_GEOMETRY', 'RelationshipRule',
           'esriSQL_CONCAT', 'esriReplicaDetectConflicts',
           'FDO_E_INVALID_NETWORK_ATTRIBUTE_FOR_EVALUATOR',
           'FDO_E_SE_INVALID_REGISTRATION_ID',
           'esriNETAssociatedWithSameFromToJunction',
           'esriNAUTHierarchy', 'IGPReplica', 'IGeoDataset2',
           'esriArcGISServerLocatorWorkspace',
           'FDO_E_SE_INVALID_GRIDSIZE', 'IUtilityNetwork',
           'IRasterStorageDef2', 'IRasterStorageDef3',
           'esriNAATReplace', 'IRasterDatasetInfo',
           'FDO_E_SE_INVALID_COLUMN_DEF',
           'FDO_E_INVALID_NETWORK_TURN_TYPE',
           'esriRasterCompressionUnknown', 'esriMSAAlways',
           'FDO_E_VERSION_HAS_CHILDREN', 'IRasterColormap',
           'FDO_E_VERSION_HAS_CONFLICTS',
           'esriTablePropCanDeleteIndex', 'esriNetworkErrors',
           'esriRasterCompressionCCITTRLE', 'IEnumDataset',
           'FDO_E_SE_RASTERCOLUMN_EXISTS', 'REP_E_OBJECT_IS_DELETED',
           'esriNAUKilometersPerHour', 'esriDegreeSlopeAsRaster',
           'ITableAttachments', 'esriSQL_TRIM', 'esriNAUSeconds',
           'IItemInfos', 'FDO_E_WORKSPACE_READONLY', 'TinPolyline',
           'esriRelKeyType', 'NETWORK_E_UNKNOWN_ENGINE_ERROR',
           'FDO_E_SE_INVALID_EXPORT_FILE',
           'FDO_E_OBJECT_IN_ANOTHER_FEATUREDATASET',
           'esriDeletePrivilege', 'FDO_E_SE_CONNECTIONS_EXCEEDED',
           'FDO_E_DATASOURCE_INUSE_ELSEWHERE', 'IArchivableClass',
           'TopologyClassEvents', 'FDO_E_SE_NO_COMMON_LINEAGE',
           'TinName', 'IScratchWorkspaceFactory2', 'esriSQL_STDDEV',
           'IFeatureClass', 'FDO_E_DOMAIN_INVALID_NAME',
           'FDO_E_NETWORK_FUNCTION_EVALUATOR_ARGUMENT1_INVALID',
           'esriWTDouble', 'FDO_E_SE_INVALID_COORDSYS_ID',
           'esriXPTImage', 'IReplicaDataset', 'E_TIN_INTERNAL_ERROR',
           'esriSQL_ACOS', 'esriLocatorStyle', 'IRowBuffer',
           'IGPDatasetExtension', 'FDO_E_SE_COORD_OUT_OF_BOUNDS',
           'PT_ULONG', 'IDEWorkspaceType',
           'FDO_E_EMPTY_GEOMETRICNETWORK_IS_NOT_ALLOWED', 'Table',
           'IQueryName', 'FDO_E_REFRESH_DYNAMIC_TRAFFIC_ERROR',
           'FDO_E_FIELD_USED_BY_EDITOR_TRACKING',
           'FDO_E_FEATURETYPE_NOT_SUPPORTED',
           'IPlugInWorkspaceFactoryHelper2',
           'esriRasterCompressionLZW',
           'FDO_E_TURN_GEOM_DISCONNECTED_FEATURES',
           'NETWORK_E_OVERFLOW_USER_CLASS_ID', 'IRaster',
           'ITopologyGraph', 'esriEditSearchDeletedBasicOnly',
           'IFeatureConstruction', 'EdgeFeatureSource',
           'IArchiveRegistrationInfo', 'IGPDescribe',
           'esriTRTPointDisjoint', 'NetworkDirections',
           'esriNetworkAccess', 'NetworkDatasetWorkspaceExtension',
           'FDO_E_MUST_BE_OWNER', 'esriTRTLineNoOverlap',
           'FDO_E_FIELDS_MULTIPLE_RASTERS',
           'esriNETStandaloneJunction', 'esriTRTLineNoOverlapLine',
           'ITinTriangle',
           'FDO_E_TRAFFIC_DATA_LENGTH_ATTRIBUTE_MISSING',
           'IFIDSetOperator', 'TrafficFeedGPService', 'PT_DOUBLE',
           'INetWeight', 'FDO_E_PROPERTY_NOT_FOUND',
           'FDO_E_SE_CONNECTION_IN_USE', 'IRelationshipClass',
           'esriDataXMLExtraction', 'IDatasetFileStat',
           'esriTRTLineNoPseudos', 'esriDBMS_Informix',
           'FDO_E_SUBTYPE_IN_USE_CANNOT_DELETE',
           'FDO_E_SE_INVALID_USER', 'InvalidObjectInfo',
           'FDO_E_START_EDITING', 'esriRelKeyRole',
           'FDO_E_QUERYDESCRIPTION_INVALIDCOLUMN',
           'FDO_E_CONNECTED_EDGE_INVALID_CONNECTIVITY',
           'FDO_E_TRAFFIC_DATA_ATTRIBUTE_MISSING',
           'FDO_E_SE_INDEX_NOEXIST', 'esriTopologyEdge',
           'FDO_E_INVALID_ENVELOPE', 'IEnumTopologyErrorFeature',
           'FDO_E_NETWORK_SOURCE_IN_MULTIPLE_NETWORKS',
           'esriHasInvalidCharacter', 'IRasterLODInfos',
           'FDO_E_REPLICA_RECEIVER_CANNOT_EXPORT_CHANGES',
           'REP_E_REP_IS_FREE_GRAPHICS', 'IVersionInfo',
           'FDO_E_OLEDB_NOT_SUPPORTED_ON_LINUX', 'esriNetworkStatus',
           'GeoDatabaseHelper',
           'FDO_E_SE_NO_ARCSDE_LICENSE_NO_PERMISSION',
           'esriWorkspacePropMaxWhereClauseLength',
           'FDO_E_FIELD_EVALUATOR_FIELD_NOT_FOUND',
           'FDO_E_SE_SPATIAL_SQL_NOT_INSTALLED', 'DEBrowseOptions',
           'esriSQL_COS', 'IRasterCatalogName', 'esriSQL_ASIN',
           'E_TIN_NODE_SHARED', 'esriNFARSink',
           'FDO_E_SE_INVALID_DBMS_LOGIN',
           'FDO_E_SE_MULTIPLE_RASTER_COLS',
           'FDO_E_SE_TOO_MANY_STREAMS', 'IGeometryDefEdit',
           'FDO_E_TABLE_ATTACHMENTS_NOT_SUPPORTED', 'Indexes',
           'IDETableType',
           'FDO_E_Z_CLUSTER_TOLERANCE_NOT_SUPPORTED_IN_RELEASE',
           'IFeatureEdit2', 'IStreetNameFields2', 'IRasterWorkspace2',
           'esriJoinType', 'IRasterWorkspace4', 'IGeoDataset',
           'esriTinNodesWithNonZeroTag', 'IInvalidArea',
           'FDO_E_CANNOT_LOCK_COCREATED_DOMAIN', 'esriNetworkType',
           'NetworkScriptEvaluatorFunctions', 'esriRasterStorageST',
           'IPixelBlock', 'FDO_E_FIELDS_MODEL_NAME_ALREADY_EXISTS',
           'esriDBMS_Netezza', 'LOCATING_E_TO_PARTIAL_MATCH',
           'IWorkspace', 'esriNetworkDatasetState',
           'FDO_E_NODE_NOT_ON_ARC', 'FDO_E_SE_STATE_NOEXIST',
           'IWorkspaceExtension3', 'IWorkspaceExtension2',
           'FDO_E_SAVE_EDIT_SESSION', 'IDifferenceCursorEx',
           'FDO_E_INDEX_WRONG_TYPE', 'esriConnectionDBMS',
           'esriRSPPreserveOnSmallest', 'IGPChoiceList',
           'FDO_E_SE_NO_ACCESS', 'NETWORK_E_OLD_NETWORK_VERSION',
           'ITinValueFilter', 'FDO_E_NEW_SCHEMA_REQUIRED',
           'FDO_E_DATE_CONVERSION', 'IGPDataTypeFactory',
           'IRecordSetInit', 'esriRowsTypeFilter', 'ISignposts',
           'esriSpatialRelTouches',
           'FDO_E_RELCLASS_COULD_NOT_GET_ORIG_PRIM_KEY',
           'FDO_E_DRAWSTYLE_UNKNOWN', 'FDO_E_SE_INVALID_ROW_ID_LAYER',
           'IWorkspaceReplicas', 'FeatureDataConverter',
           'XYEvent2FieldsProperties', 'esriNAPUTGeneral',
           'esriInsertPrivilege', 'esriSQL_DelimitedIdentifierSuffix',
           'ITopologyEdge', 'E_TIN_INDEX_OUT_OF_RANGE', 'ITinNode',
           'IItemInfo2', 'FDO_E_ROW_NO_OID', 'esriNSValidNetwork',
           'esriRCRoundabout', 'ITinEdit',
           'FDO_E_VERSION_BEING_EDITED', 'esriSQL_AVG',
           'FDO_E_SE_PATH_NOT_FOUND', 'FDO_E_SECURED_DATA_NO_ACCESS',
           'NetworkConstantEvaluator', 'esriNSTTurnFeature',
           'FDO_E_OBJECTCLASS_COULD_NOT_CREATE_CLASS_EXTENSION',
           'INetSchemaEdit', 'esriRCFerry', 'esriSQL_STDDEV_POP',
           'IRouteLocatorName', 'FDO_E_DOMAIN_TYPE_NOT_SUPPORTED',
           'Topology', 'IEnumLockInfo', 'IScratchWorkspaceFactory',
           'esriSQL_BITLENGTH', 'esriTRTAreaBoundaryCoveredByLine',
           'esriDataReplication', 'esriSQL_CURRENTTIMESTAMP',
           'FDO_E_USERTRANSACTION_NOT_ALLOWED', 'esriSQL_CEILING',
           'FDO_E_NAME_STRING_SYNTAX', 'esriSQLInfo',
           'FDO_E_SE_NO_PERMISSIONS', 'FDO_E_CLASS_NOT_IN_TOPOLOGY',
           'FDO_E_DATASET_CANNOT_RENAME',
           'FDO_E_SUBTYPES_UNSPECIFIED_CONN_GROUP',
           'FDO_E_INVALID_TIME_SLICE_ARRAY',
           'FDO_E_NETWORK_DATASET_ALREADY_UPGRADED',
           'esriRelKeyRoleDestinationPrimary', 'esriRasterStorageSDO',
           'RelQueryTable', 'esriDBMS_SQLite',
           'FDO_E_ZERO_LENGTH_POLYLINE', 'IRasterDef',
           'ISimpleDataConverter2', 'esriTinOriginal',
           'esriRTAttribute', 'ObjectClassValidator', 'IEnumIDs',
           'esriNetworkTurnAngleCategory', 'IHistoricalWorkspace',
           'ITable', 'Shields', 'TinTriangleEnumerator',
           'FDO_E_SE_INVALID_RASTER_COLUMN',
           'E_TIN_OPERATION_NOT_SUPPORTED',
           'NETWORK_E_NO_UPDATE_SESSION_IN_PROGRESS',
           'esriTinMassPoint', 'E_TIN_FAILED_TO_DELETE',
           'FDO_E_DATABASE_NOT_FOUND', 'ITinEdge',
           'FDO_E_NETWORK_MISSING_SOURCE', 'esriSelectionTypeIDSet',
           'esriFlowDirection', 'INetworkAttributeParameter',
           'esriMCTAddRule', 'esriDTCodedValue',
           'esriSpatialRelUndefined',
           'FDO_E_CANNOT_CHANGE_ITEM_VISIBILITY',
           'esriSQLFunctionName', 'IRepairConnectivityProgressEvents',
           'FDO_E_CANNOT_REBUILD_POLYGONS', 'IDatasetEdit',
           'FDO_E_INVALID_SQLQUERY',
           'E_DATACONVERTER_OPENINSERTCURSORFAILED',
           'FDO_E_BUILDNETWORK_ALREADYBUILD',
           'FDO_E_EDGE_MISSING_ENDPOINT_JUNCTION',
           'esriGeometryStorage', 'IDEGdbUtilities2', 'TopologyEdge',
           'esriRelExtractDirectionBackward', 'esriFTComplexEdge',
           'NetworkDatasetName', 'FDO_E_ITEM_NOT_FOUND',
           'FDO_E_PLANARGRAPH_NOT_FOUND', 'esriDEExpandChildren',
           'SQLCheck', 'EnumXMLIndexTemplate',
           'esriTablePropRowCountIsCalculated', 'esriDifferenceType',
           'FDO_E_GEOMETRY_SPATIAL_REFERENCE',
           'FDO_E_CADASTRAL_FABRIC_INVALID_NAME', 'esriTinPerimeter',
           'FDO_E_SE_STATE_TREE_INUSE',
           'FDO_E_WORKSPACE_NOT_COMPATIBLE', 'esriTinSoftErase',
           'IEnumNetWeightAssociation', 'FDO_E_DEFAULT_VALUE_INVALID',
           'esriSQL_Timestamp', 'FDO_E_INDEX_ALREADY_EXISTS',
           'esriFTSimple', 'esriTinZLessHardErase',
           'esriReplicaResolveConflictsInFavorOfDatabaseChanges',
           'FDO_E_TURN_NO_NETWORK',
           'FDO_E_ATTACHMENTS_ON_ATTACHMENT_TABLE_NOT_SUPPORTED',
           'NETWORK_E_LOOP_EDGE_CHAIN', 'esriNTUAfterTraversal',
           'FDO_E_SE_OUT_OF_SVMEM', 'RSP_BilinearGaussBlurPlus',
           'IRelQueryTableFactory', 'ITinFeatureEdit',
           'IEdgeFeatureSource', 'esriSetSymDifference',
           'FDO_E_SE_INVALID_UNITS', 'IEnumTopologyEdge',
           'FDO_E_CANNOT_SEND_TRANSMISSION', 'IDEGeoDataServerType',
           'FDO_E_VERSION_REDEFINED', 'SimpleDataConverter',
           'ITopologyGraph2', 'IGeoDatabaseBridge2', 'esriAllTypes',
           'esriLocator', 'IDEDatasetType', 'IMultiuserWorkspaceEdit',
           'GPMessages', 'FDO_E_SE_INVALID_COLUMN_VALUE',
           'esriGeometryStorageLOB', 'IDynamicTrafficData',
           'esriTRTLineNoIntersectOrInteriorTouchLine',
           'FDO_E_SE_INVALID_COORDREF_OBJECT',
           'FDO_E_SE_NO_ROWS_UPDATED', 'FDO_E_SE_DELETE_NOT_ALLOWED',
           'FDO_E_INCOMPATIBLE_CLIENT_CANNOT_OPEN_DATASET',
           'JSONConverterGdb', 'FeatureClassName',
           'FDO_E_FIELDS_EMPTY', 'IXMLReplicaDescription',
           'ITinNodeSourceFilter', 'esriNFSBNoBacktrack',
           'esriConfigurationKeywordTopology', 'FDO_E_ROW_BAD_VALUE',
           'esriNetworkFeatureAncillaryRole',
           'esriXMLIndexTagDataTypeString', 'esriSQLDatetimeType',
           'FDO_E_TABLE_NO_OID_FIELD', 'IGeoDBDataTransfer2',
           'IPlugInDatasetLoad', 'esriTinSelectionNew',
           'rstResamplingTypes',
           'esriSQL_CurrentDateRequiresParentheses',
           'esriFeatureType', 'IDERasterDatasetType', 'Relationship',
           'esriSyncModelPerLayer',
           'esriWorkspacePropSupportsArchiving',
           'FDO_E_WORKSPACE_ALREADY_EXISTS',
           'E_TIN_WRONG_ELEMENT_TYPE', 'esriNTACReverse',
           'FDO_E_FEATURE_AREA_LENGTH_UPDATE_FAILED',
           'esriDegreeAspect', 'esriFETEdge',
           'esriSQL_SubstringRequiresCommas',
           'NETWORK_E_UNDEFINED_PROPERTY',
           'FDO_E_QUERYTABLE_OIDCOLUMNHASNULL', 'FeatureQueryName',
           'esriTableNameErrorType', 'IGeometryResultOptions',
           'FDO_E_NO_ASSOCIATED_NETWORK_ELEMENT',
           'FDO_E_SE_TOO_MANY_LAYERS', 'DataStatistics',
           'IEnumInvalidObject', 'IDERepresentationClass',
           'IDatasetFileStat2', 'FDO_E_VERSION_RECONCILE_LOST',
           'IFeatureEvents', 'esriWeightType',
           'FDO_E_TOPOLOGY_ENGINE_OVERPROC_FAILURE',
           'IEventSourceErrors', 'IDETopologyType', 'ITopologyRule',
           'IMetadataSynchronizer', 'FDO_E_EDGE_SET_NOT_CONNECTED',
           'esriTopologySelectionResultSubtract',
           'IDEGlobeServerType', 'IRepresentation', 'GPVersionInfo',
           'FDO_E_SE_PTS_NOT_ADJACENT',
           'FDO_E_CLASS_ALREADY_MEMBER_OF_TOPOLOGY',
           'esriTopologySelectionResultAdd', 'TopologyName',
           'DEGlobeServerType', 'GeometricNetwork',
           'esriTinBoundType',
           'FDO_E_NETWORK_SCHEMA_CHANGES_NOT_SUPPORTED',
           'FDO_E_INVALID_POLYGON_LABEL_DELETED',
           'esriDataXMLReplication', 'IWorkspaceDefinition',
           'esriDTFeatureDataset', 'IConnectivityRule',
           'IEnumEdgeFeature', 'FDO_E_INVALID_Z_DOMAIN',
           'esriLockType', 'DEGeoDataServer', 'IObject',
           'FDO_E_FIELD_CANNOT_DELETE_REQUIRED_FIELD',
           'FDO_E_TOPOGRAPH_NOT_BUILT', 'GPReplicaDescription',
           'FDO_E_SE_INVALID_DATABASE', 'esriNetworkElevationModel',
           'IDEGeometricNetwork2', 'IGPReplica2',
           'esriSQL_STDDEV_SAMP', 'EnumFieldError', 'esriNTTImplicit',
           'RelQueryTableSelectionSet',
           'FDO_E_SE_INVALID_ANNO_OBJECT', 'IRandomAccessTable',
           'esriLocatorQuery', 'FDO_E_SE_INVALID_SPATIAL_CONSTRAINT',
           'E_TIN_WRONG_EDGE_TYPE', 'ObjectClassName',
           'FDO_E_REPLICA_NAME_ALEARDY_EXISTS',
           'esriTinSelectionType',
           'FDO_E_SPLIT_POINT_YIELDS_ZERO_LENGTH_POLYLINE',
           'esriTinAll', 'esriNETGeometry', 'IFeatureElementEdit',
           'IEnumSchemaLockInfo', 'esriRasterCompressionLZ77',
           'FDO_E_EVALUATOR_SYNTAX_ERROR',
           'FDO_E_SE_RASTERCOLUMN_INUSE', 'E_TIN_INVALID_NAME',
           'ILocatorWorkspace', 'INetWeightAssociationEdit',
           'E_DATACONVERTER_FLUSHINSERTCURSORFAILED',
           'esriFGDBStandardDatafile', 'esriNCARNone',
           'IStreetNameFields', 'E_DATACONVERTER_OPENTABLEFAILED',
           'FDO_E_SE_STATES_ARE_SAME', 'esriTRTLineNoDangles',
           'IXMLIndex', 'FDO_E_SE_INVALID_STORAGE_TYPE',
           'esriFETAnnotation', 'NETWORK_E_INVALID_ENGINE_FSTAR',
           'NETWORK_E_CANNOT_OPEN_TABLE',
           'NETWORK_E_INVALID_WEIGHT_DEFINITIONS',
           'esriNCARSourceSink', 'esriReplicaTypeParent',
           'GeometryResultOptions', 'IRelClassSchemaEdit',
           'esriTin80001', 'esriSQL_CURRENTDATE', 'IEnumDatasetType',
           'REP_E_CANT_ACQUIRE_SCHEMA_LOCK',
           'INetworkClassDescription',
           'FDO_E_SE_SYSTEM_IS_CLIENT_ONLY',
           'esriGeoDatabaseServerMessageCode',
           'FDO_E_FEATURE_ELEMENT_MISSING_POINT_GEOMETRY',
           'JunctionConnectivityRule', 'ITinFilter', 'esriSQL_AS',
           'FDO_E_SE_INVALID_LOGINFO_OBJECT',
           'FDO_E_FEATURETYPE_UNKNOWN', 'FDO_E_SE_NOT_TABLE_OWNER',
           'FDO_E_DATASET_NOT_FOUND', 'INetworkEvaluatorSetup',
           'FDO_E_SE_CONNECTION_LOCKED', 'FGDCSynchronizationHelper',
           'IRelQueryTableSelectionSet', 'esriCheckOutTypeParent',
           'esriNaturalNeighborInterpolation',
           'FDO_E_NO_SYSTEM_TABLES', 'FeatureDatasetName',
           'FDO_E_SE_ROWLOCK_MASK_CONFLICT', 'esriSQL_VAR_POP',
           'IVersionInfo2', 'esriSelectionOptionEmpty',
           'FDO_E_FIELD_NOT_FOUND', 'ISurfaceIntersectionEvents',
           'IGeometricNetworkReconcileProperties',
           'esriRelNotificationForward', 'ICodedValueDomain',
           'IDatasetName2', 'esriSQLPrivilege',
           'FDO_E_NO_OPERATION_LICENSE',
           'esriGPMessageTypeProcessStop',
           'FDO_E_SPATIALREF_Z_MISMATCH', 'IGraph',
           'esriWorkspaceType', 'esriTinQualification',
           'esriFGDBDatafileFormat', 'FDO_E_SPATIALFILTER_INVALID',
           'esriNAUMilesPerHour', 'E_TIN_XML_CORRUPTED', 'esriDTGeo',
           'E_TIN_NOT_PROJECTED_SYSTEM',
           'FDO_E_OBJECTCLASS_COULD_NOT_CREATE_CLASS_INSTANCE',
           'ITopologyElement', 'IDEFeatureClass',
           'esriExclusiveSchemaLock',
           'FDO_E_SE_INVALID_LAYERINFO_OBJECT',
           'esriMCTAttributeMapping', 'esriServerClassPersonal',
           'esriTRTLineInsideArea',
           'E_DATACONVERTER_CANNOT_CREATE_FEATURE_DATASET',
           'FDO_E_OPERATION_REQUIRES_EDIT_SESSION', 'IVersion',
           'FDO_E_CREATE_LOGICAL_NETWORK', 'esriSQL_EscapeKeySuffix',
           'IFeatureDatasetName', 'IReplicaDatasetEdit',
           'FDO_E_OPERATION_CANNOT_BE_UNDONE',
           'FDO_E_TABLE_DUPLICATE_COLUMN',
           'FDO_E_INVALID_NETWORK_FEATURE_CLASS',
           'FDO_E_DATASET_INVALID_ID', 'esriRCMajorRoad',
           'esriXSPAReplaceIfExists', 'IRasterDatasetContainerName',
           'FDO_E_TURN_GEOM_NO_FEATURES', 'INetTopologyEdit',
           'esriPlaneReferenceBelow',
           'esriDatasetFileStatAccessReadOnly', 'IFieldInfo2',
           'IFieldInfo3', 'IEnumTinEdge', 'IRelQueryTableName',
           'DEMapServer', 'FDO_E_SE_INVALID_ENTITY_TYPE',
           'FDO_E_CADASTRAL_FABRIC_PACKET_MISSING_DATA',
           'IFeatureClassUtil', 'IEnumTinTriangle',
           'FDO_E_INVALID_EVALUATOR_FOR_SHAPEFILE_NETWORK_DATASET',
           'FDO_E_SE_INSTANCE_NOT_AVAILABLE',
           'FDO_E_RECONCILE_FAILED', 'FDO_E_SE_INVALID_RELEASE',
           'FDO_E_SE_INVALID_GRANT_REVOKE',
           'FDO_E_COULD_NOT_LOAD_CLASS_EXTENSION_PROPERTIES',
           'IVersionEdit4', 'IDERelationshipClassType',
           'IVersionEdit2', 'esriTinHardEdge',
           'FDO_E_CANNOT_DELETE_NETWORK_ATTRIBUTES',
           'IDERelationshipClassEx2', 'IEnumGPName',
           'esriTinZLessSoftLine', 'esriNaturalNeighborZaverage',
           'FDO_E_SE_RASTERBAND_NOEXIST', 'esriNDSEmpty',
           'FDO_E_NETWORK_DATASET_NOTURNS', 'GPDatasetExtension',
           'esriGPMessageTypeError', 'ITopology',
           'FDO_E_SE_INSTANCE_TOO_EARLY', 'IFeatureSimplify',
           'NETWORK_E_INVALID_NETWORK_ACCESS', 'IRelationshipChanges',
           'FDO_E_NETWORK_SOURCE_ALREADY_EXISTS',
           'esriLockTypeShared', 'esriReplicaBothReadWrite',
           'FDO_E_CANNOT_CREATE_UNIVERSE_LABEL',
           'FDO_E_DEFAULT_DOMAIN_NOT_FOUND', 'IWorkspaceReplicas2',
           'FDO_E_RECONCILE_VERSION_NOT_ANCESTOR', 'INetworkEdge2',
           'IPlugInWorkspaceFactoryHelper',
           'FDO_E_FEATURECLASS_CANT_OPEN_GEOMETRICNETWORK',
           'FDO_E_CADASTRAL_FABRIC_PACKET_POST_REQUIRES_EDIT_SESSION',
           'FDO_E_NON_FORWARD_COMPATIBLE_CONNECTION',
           'NetworkDataset', 'esriNETDuplicateElements',
           'esriTinSuperNode', 'IDEServerConnectionType',
           'ITopologyNode', 'esriXSPAAddDuplicate',
           'FDO_E_INVALID_REPLICA_NAME', 'IFIDSet',
           'FDO_E_IMPLEMENTATION', 'esriRasterCompressionJPEG',
           'IFeatureClassDescription', 'ITopologyClass',
           'FDO_E_GEOMETRY_HAS_NULL_Z_VALUES', 'TinEdgeEnumerator',
           'FDO_E_FEATURECLASS_SUBTYPE_EXISTS', 'IPnt',
           'FDO_E_NETWORK_SOURCE_INVALID_ELEMENT_TYPE',
           'IRepresentationRules', 'DERelationshipClass',
           'esriSQL_POSITION',
           'E_DATACONVERTER_ACQUIRESCHEMALOCKFAILED',
           'FDO_E_REPLICA_RECEIVER_CANNOT_REEXPORT_CHANGES',
           'INetWeightAssociation', 'TopologyRule',
           'esriRegisterXMLReplica', 'IFeatureElement', 'esriSQL_EQ',
           'FDO_E_NETWORK_INVALID_TYPE',
           'FDO_E_FIELD_EVALUATOR_AS_DEFAULT_EVALUATOR',
           'esriTinNodeLineTouch', 'FDO_E_RECONCILE_CANNOT_BE_UNDONE',
           'FDO_E_SE_NO_ARCSDE_LICENSE',
           'FDO_E_DATASET_TYPE_NOT_PRESENT',
           'FDO_E_INVALID_USAGE_OR_UNIT_TYPE_FOR_EVALUATOR',
           'FDO_E_SUBTYPE_CANNOT_ADD', 'esriSQL_COSH',
           'FDO_E_SE_VERSION_HAS_MOVED',
           'FDO_E_CANNOT_CREATE_EMPTY_REPLICA',
           'FDO_E_SUBTYPE_CODE_HAS_ASSOCIATED_TOPOLOGY_RULE',
           'esriNetworkClassAncillaryRole',
           'esriNetworkTurnParticipationType', 'IGPName',
           'IGPControllerMembership', 'FDO_E_SUBTYPE_CODE_INVALID',
           'FDO_E_CLASS_EXISTS_WITH_ORPHAN_JUNCTION_CLASS_NAME',
           'FDO_E_QUERYDESCRIPTION_OUTOFSYNC',
           'IRemoteDatabaseWorkspace',
           'FDO_E_CANNOT_REMOVE_LAST_LABEL', 'esriMergePolicyType',
           'IGPDomain', 'FDO_E_NETWORK_DATASET_INVALID_ACCESS',
           'FDO_E_UNKNOWN_CATALOG_TYPE',
           'FDO_E_CANNOT_REPLICATE_LOW_PRECISION_DATA', 'IVersion2',
           'IVersion3', 'FDO_E_SE_READ_ONLY_COLUMN',
           'FDO_E_SE_LOG_EXISTS', 'ITopologyFeature', 'fdoError',
           'esriSQL_ROUND',
           'FDO_E_MULTIGEN_REPLICAS_NOT_SUPPORTED_IN_WORKSPACE',
           'FDO_E_INTEGER_REQUIRES_64BITS',
           'FDO_E_INVALID_TOPOLOGY_ID',
           'esriGeodatabaseServerClassType',
           'FDO_E_TABLE_READONLY_HISTORICAL',
           'FeatureClassDescription', 'IEnumTinNode',
           'FDO_E_PERSONAL_GEODATABASE_NOT_SUPPORTED_ON_SERVER',
           'IRangeDomain', 'IGPNetworkDatasetMembership',
           'FDO_E_SE_INVALID_OUTER_SHELL',
           'FDO_E_INVALID_EXPRESSION_FOR_EVALUATOR',
           'esriTablePropBindCursor', 'esriSelectionTypeHybrid',
           'FDO_E_REQUIRED_CONNECTION_POINT_NOT_FOUND',
           'IEnumAttributedRelationship',
           'FDO_E_SCHEMA_LOCK_CONFLICT', 'FDO_E_TABLE_NO_ATTACHMENTS',
           'FDO_E_SE_TYPE_MISMATCH', 'esriXPTBinaryEnclosure',
           'IGPDataType', 'FDO_E_SE_SQL_PARENTHESIS_MISMATCH',
           'esriTinSingleEdge', 'esriFTSimpleEdge',
           'FDO_E_NETWORK_INVALID_GEOMETRY_TYPE',
           'ISqlKeywordDictionary', 'esriDataExtraction',
           'esriReplicaStateSendingData', 'ISchemaLockInfo',
           'IGPMessage', 'FDO_E_NETWORK_ALREADY_EXISTS',
           'esriSQL_TRANSLATE', 'TrafficFeedDirectory',
           'esriRuleType', 'NETWORK_E_INVALID_WEIGHT_ASSOCIATION',
           'FDO_E_CODED_VALUE_DOMAIN_VALUE_NOT_COMPATIBLE',
           'esriMPTSumValues',
           'FDO_E_TOPOLOGIES_SCHEMA_CHANGES_NOT_SUPPORTED_IN_RELEASE',
           'ILocator', 'FDO_E_RELCLASS_COULD_NOT_GET_ORIG_FOR_KEY',
           'esriRasterizationType', 'INetTopology',
           'E_TIN_WRONG_GEN_SEED',
           'FDO_E_REPLICA_SCHEMA_CHANGES_WRONG_DIRECTION',
           'FDO_E_INVALID_DATA_FOR_THIS_OPERATION',
           'FDO_E_TOPOLOGY_INVALID_WEIGHT', 'DEGeometricNetwork',
           'EnumConflictClass', 'DirectionsAttributeMapping',
           'IDEDataset2', 'FDO_E_INCONSISTANT_MERGE_PARENTS',
           'INetworkDataset2', 'esriSelectionTypeSnapshot',
           'FDO_E_SPATIAL_CACHE_EMPTY_EXTENT', 'FeatureClass',
           'ITinEdgeArray', 'INetworkClass',
           'FDO_E_QUERYDESCRIPTION_OIDFIELDSMISSING',
           'esriNaturalNeighborIDW', 'IDERasterDatasetEx',
           'IDEGdbTable', 'IResultPortionInfo',
           'esriDifferenceTypeDeleteNoChange',
           'FDO_E_CANNOT_ADD_STANDALONE_CLASS_TO_TOPOLOGY',
           'esriNAATScale', 'FDO_E_DOMAIN_DOES_NOT_MATCH_WORKSPACE',
           'FDO_E_TOPOLOGY_INVALID_RANK', 'esriXPTPicture',
           'esriNDTShapefile', 'FDO_E_SE_LOG_NOACCESS',
           'esriNetworkErrorType', 'IUserInfo',
           'ISpatialCacheManager3', 'ISpatialCacheManager2',
           'FDO_E_SE_LAYER_NOEXIST', 'ISqlDefaultConnectionInfo',
           'DETopologyType',
           'FDO_ONEWAY_REPLICA_USING_ARCHIVING_NOT_SUPPORTED_IN_NAMED_VERSIONS',
           'FDO_E_ROW_NO_OBJCLASS', 'IDERelationshipClassEx',
           'DEMapServerType', 'ITinEdgeTypeFilter2',
           'FDO_E_INVALID_RELEASE', 'IWorkspaceExtensionControl',
           'esriNETAssociatedFeatures', 'IFeatureClassStorage2',
           'IEnumWorkspace',
           'esriTRTFeatureLargerThanClusterTolerance',
           'FDO_E_TABLE_ARCHIVING', 'esriSQL_MAX',
           'JSONDeserializerGdb', 'IGPReplicaOptions2',
           'esriFTSimpleJunction', 'IReplicaDescription3',
           'IReplicaDescription2', 'IReplicaDescription4',
           'INameMapping', 'FDO_E_REQUIRED_XML_ELEMENT_NOT_FOUND',
           'IXmlPropertySet', 'FDO_E_SE_NO_ROWS_DELETED',
           'NETWORK_E_INVALID_WEIGHT_VALUE', 'FDO_E_SE_OUT_OF_LOCKS',
           'FDO_E_TABLE_NOT_FOUND', 'ISetDefaultConnectionInfo',
           'IEvaluatedNetworkAttribute', 'esriSQL_ABS',
           'FDO_E_TERRAIN_NOT_FOUND', 'DirectionsLandmarkSource',
           'IEnumFeature', 'FDO_E_GEOMETRICNETWORK_ALREADY_EXISTS',
           'FDO_E_NO_EDIT_LICENSE', 'FDO_E_SE_INVALID_REGINFO_OBJECT',
           'esriConfigurationKeywordType',
           'esriGPMessageTypeProcessStart', 'INetElementDescription',
           'FDO_E_FIELDS_MULTIPLE_GEOMETRIES', 'INetTopologyEditGEN',
           'EnumTableVersionChanges',
           'FDO_E_FIELD_UNSUPPORTED_OPERATION', 'ITin',
           'IObjectClassInfo2', 'FDO_E_SE_LOG_NOEXIST',
           'esriTinClassBreaks', 'IDataElements',
           'INetworkForwardStarAdjacencies',
           'FDO_E_TABLE_INVALID_NAME',
           'FDO_E_WORKSPACE_NO_SPATIAL_TYPE',
           'FDO_E_INVALID_GEOMETRY_TYPE_FOR_TOPOLOGY_RULE',
           'esriTinNode', 'FDO_E_SE_ZERO_AREA_POLYGON',
           'FDO_E_CUTTER_YIELDS_ZERO_AREA_POLYGON', 'esriSQL_LN',
           'FDO_E_ON_CHANGED_MESSAGE_FAILED', 'INetworkWorkspace2',
           'esriTDFrom', 'FDO_E_FIELD_IS_ASSOCIATED_WITH_INDEX',
           'NETWORK_E_INVALID_NETWORK_NAME', 'esriTinNodeUnknown',
           'esriTinSimpleBounds', 'esriLockTypeExclusive',
           'FDO_E_NETWORK_SOURCE_INVALID_ELAVATION_MODEL', 'Record',
           'esriCheckOutTypeChild',
           'FDO_E_NON_SIMPLE_DATASET_ARCHIVING',
           'FDO_E_CADASTRAL_FABRIC_XML_PARSER_NOT_FOUND',
           'FDO_E_CURSOR_FINISHED', 'ObjectClassDescription',
           'FDO_E_WORKSPACE_EXTENSION_DATASET_DELETE_FAILED',
           'ReplicaDataset', 'esriTinHardErase', 'esriSQL_LT',
           'FDO_E_TURN_INVALID_EDGE_DESCRIPTOR', 'TinNode',
           'FDO_E_NETWORK_ATTRIBUTE_ALREADY_EXISTS',
           'IEnumTopologyNode', 'IFieldInfo',
           'FDO_E_NETWORK_FUNCTION_EVALUATOR_PARAMETER_MISSING',
           'IPlugInMetadataPath', 'FDO_E_SE_PTABLE_LOCKED',
           'PT_UCHAR', 'FDO_E_ESRI_PROVIDER_CONNECT_INVALID',
           'INetworkBuild', 'esriFieldTypeInteger',
           'FDO_E_NETWORK_ELEMENT_NOT_INITIALIZED',
           'FDO_E_SE_VERSION_TBL_EXISTS',
           'FDO_E_SE_INVALID_EXTERNAL_LAYER_OPTION',
           'EdgeConnectivityRule',
           'esriDatasetFileStatAccessReadWrite',
           'FDO_E_SE_TABLE_NOT_MULTIVERSION',
           'REP_E_COMPRESSED_FEATURE_CLASS', 'IClassSchemaEdit3',
           'IClassSchemaEdit2', 'IReplicaFilterDescriptionEdit',
           'esriNAReadOnly', 'IClassSchemaEdit4',
           'esriNSTNetworkSource', 'FDO_E_SPATIALREF_MISMATCH',
           'FDO_E_SE_PTABLE_IN_USE',
           'FDO_E_INVALID_SOURCES_FOR_SHAPEFILE_NETWORK_DATASET',
           'IEnumJunctionFeature', 'esriSQL_COUNT',
           'FDO_E_SE_NULL_VALUE', 'ISqlWorkspace',
           'FDO_E_SE_INVALID_CAD_OBJECT',
           'FDO_E_INVALID_TOPOLOGY_RULE_TYPE',
           'esriDatasetFileStatTimeLastModification',
           'esriNetworkSourceType', 'FDO_E_SE_TRACE_ON', 'TinEdge',
           'FDO_E_SE_INSTANCE_ALREADY_RUNNING',
           'esriReplicaRoleParent',
           'FDO_E_INVALID_CLASS_FOR_WEIGHT_ASSOCIATION',
           'esriRelDirectionForward', 'FDO_E_SE_LOGIN_NOT_ALLOWED',
           'IEnumObject', 'IItemInfoImpl', 'ITrafficData',
           'esriInvalidCharacter',
           'FDO_E_DEFINITION_MISSING_CONTROLLER_MEMBERSHIP',
           'IObjectClassValidation', 'INetworkAttribute',
           'esriMultiuserEditSessionMode', 'DEGeometryServerType',
           'FDO_E_INVALID_NETWORK_SOURCE_FEATURE_TYPE',
           'esriReplicaType', 'GPMessageManager', 'esriRSPUseDefault',
           'esriRelDirectionBoth', 'esriTinNothing',
           'IDataElementType', 'FDO_E_REPLICATION_NOT_SUPPORTED',
           'FDO_E_INVALID_NETWORK_SOURCE',
           'esriNaturalNeighborZnearest', 'esriTSUnanalyzed',
           'DEFeatureDatasetType',
           'IFeatureDatasetExtensionContainer', 'esriNRCAny',
           'NETWORK_E_REACHED_MEMORY_QUOTA', 'esriRoadClass',
           'FDO_E_CANNOT_CREATE_HIGH_PREC_DATASET_IN_LOW_PREC_DB',
           'IRelClassEnumRowPairs', 'PT_DCOMPLEX', 'esriTinEdge',
           'IObjectClassName', 'esriDifferenceTypeDeleteUpdate',
           'esriRelExtractDirectionForward', 'Field',
           'INetworkFeatureEvents', 'IValidate', 'esriNAUMinutes',
           'esriRasterCompressionJPEG2000', 'esriTinNodeEditInfo',
           'esriFDIndeterminate',
           'FDO_E_SE_UNSUPPORTED_NORMALIZED_OPERATION', 'PT_CLONG',
           'esriDTMosaicDataset',
           'esriGPMessageTypeProcessDefinition',
           'FDO_E_SE_BLOB_SIZE_TOO_LARGE',
           'esriReplicaResolveConflictsInFavorOfImportedChanges',
           'ITopologyGraphEvents', 'REP_E_INVALID_REP_RULE_ID',
           'IWorkspaceFactorySchemaCache', 'JunctionFeatureSource',
           'ITopologyClassEvents', 'IGeometricNetworkName',
           'esriSQL_Date', 'ISetDefaultConnectionInfo2',
           'ISetDefaultConnectionInfo3', 'IRasterWorkspaceEx',
           'FDO_E_SE_INVALID_PART_OFFSET', 'IWorkspaceDomains3',
           'IWorkspaceDomains2', 'FDO_E_SE_VERSION_NOEXIST',
           'IEnumFieldError', 'FDO_E_TURN_GEOM_NO_FIRST_FEATURE',
           'IClassSchemaEdit', 'FDO_E_SE_ROW_NOEXIST',
           'esriTinDoubleEdges',
           'FDO_E_CLASS_NOT_IN_TOPOLOGIES_FEATURE_DATASET',
           'FDO_E_CLASS_IN_NETWORK_REQUIRES_EDIT_SESSION',
           'esriNaturalNeighborZmax', 'ISurface',
           'esriVersionAccessPrivate', 'INetworkDatasetProtectNames',
           'INetworkQuery3', 'ITopologyWorkspace',
           'FDO_E_WORKSPACE_NOT_CONNECTED', 'esriTTRotate',
           'FDO_E_OBJECTCLASS_COULD_NOT_INITIALIZE_CLASS_EXTENSION',
           'esriDTRasterBand', 'esriMetadataChangeType',
           'FDO_E_SE_NOT_A_SELECT_STATEMENT', 'E_TIN_IN_EDIT_MODE',
           'esriRemoteDatabaseLocatorWorkspace', 'esriDTAny',
           'ITinWorkspace', 'esriDBMS_Unknown',
           'FDO_E_OBJECT_NOT_LOCKED', 'esriXMLIndexType',
           'E_TIN_FAILED_UPDATE_SEED', 'FDO_E_SE_NO_SPATIAL_MASKS',
           'FDO_E_MUST_BE_VERSION_OWNER_TO_SYNC', 'IDatasetName',
           'esriRelDirection', 'INetworkGlobalTurnDelayEvaluator',
           'IIndexType', 'RasterCatalogName',
           'FDO_E_SE_TOO_FEW_POINTS',
           'FDO_E_TOPOCLASSES_SYSTEM_TABLE_INCONSISTENCY',
           'esriXMLIndexTagDataTypeDouble',
           'FDO_E_GEOMETRICNETWORK_CANNOT_RENAME',
           'esriFieldTypeDouble', 'LOCATING_E_CANT_FIND_EXTENT',
           'FDO_E_INVALID_CARDINALITY', 'IRelationshipRule',
           'esriRasterTableInvalid', 'FDO_E_USER_NOACCESS',
           'esriWorkspacePropSupportsExtensionDatasets',
           'E_TIN_NUMERIC_LIMIT', 'FDO_E_UPGRADE_NEEDS_WRITE_ACCESS',
           'IEditorTrackingInfo', 'FDO_E_SE_SDE_NOT_STARTED',
           'IDEGdbFeatureClass', 'FDO_E_OTHER_ACTIVE_CONNECTIONS',
           'esriTRTAreaBoundaryCoveredByAreaBoundary', 'NetworkEdge',
           'RepairConnectivityProgress', 'esriNAUMeters',
           'IConfigurationKeyword2', 'IGUIDGenerator',
           'esriTinTrianglePropertyType', 'ThumbnailInfo',
           'FDO_E_SE_INVALID_ENVELOPE', 'INetworkDatasetName',
           'esriMESMVersioned', 'IRowChanges',
           'IWorkspaceFactoryStatus', 'IXYEventProperties',
           'esriNAUFeet',
           'FDO_ONEWAY_REPLICA_PARENT_READONLY_NOT_SUPPORTED_IN_LOCAL_CHILD_WORKSPACES',
           'NETWORK_E_NETWORK_ALREADY_EXISTS',
           'PlugInWorkspaceFactory', 'esriTableComponents',
           'FDO_E_EDGE_ENDPOINT_NOT_COINCIDENT',
           'FDO_E_INVALID_NETWORK_LANDMARK_SOURCE_FIELD',
           'FDO_E_RELCLASS_COULD_NOT_GET_DEST_PRIM_KEY',
           'FDO_E_SE_NO_LOCKS', 'FDO_E_TOPOLOGY_INVALID_NAME',
           'FDO_E_LOCK_CONFLICT', 'FDO_E_INDEX_NOT_ALLOWED',
           'IDERasterDataset', 'esriNAUKilometers',
           'IWorkspaceDomains', 'HistoricalVersionMarker',
           'NETWORK_E_DELETE_WEIGHT_HAS_ASSOCIATIONS', 'IAttachment',
           'ISQLPrivilege', 'NETWORK_E_UNKNOWN_ERROR',
           'FDO_E_CHILD_PARENT_REPLICA_CANNOT_EXIST_IN_SAME_GEODATABASE',
           'esriSchemaLock', 'WorkspaceEditEvents',
           'FDO_E_SE_NOT_IN_RASTER',
           'E_DATACONVERTER_CREATEFEATURECLASSFAILED',
           'E_TIN_WORKSPACE_ALREADY_CONNECTED',
           'NETWORK_E_INVALID_ENGINE', 'esriNEMZCoordinates',
           'FDO_E_SE_NO_REQUEST_STATUS', 'FDO_E_SE_LAYER_EXISTS',
           'esriWorkspacePropCanEdit', 'esriRelClassKey',
           'esriNETZeroLengthGeometry', 'esriNAUCentimeters',
           'FDO_E_SPLIT_NOT_SUPPORTED_ON_GEOMETRY_TYPE',
           'FDO_E_JOB_DOES_NOT_BELONG_TO_FABRIC',
           'IReplicaDescription', 'esriNTStreetNetwork',
           'DERasterDataset', 'NETWORK_E_INVALID_WEIGHT_ID',
           'FDO_E_OBJECT_IN_USE', 'esriNETEmptyGeometry',
           'ITopologyContainer', 'IDifferenceCursor', 'esriSyncModel',
           'IRowSubtypes', 'XYEVENT_E_INVALID_Y_NAME',
           'FDO_E_DOMAIN_NOT_FOUND', 'INetworkForwardStarSetup',
           'esriSyncDirectionBiDirectional',
           'FDO_E_VALIDATION_NOT_SUPPORTED', 'INetDiagnostics',
           'esriFTComplexJunction',
           'FDO_E_LOW_PRECISION_SR_NOT_SUPPORTED',
           'FDO_E_TIME_ZONE_ATTRIBUTE_IS_REQUIRED',
           'IWorkspaceEvents2', 'FDO_E_FIELD_INVALID_GEOMETRY_TYPE',
           'IQueryFilter2',
           'FDO_E_FEATURECLASS_SUBTYPE_FIELD_CANNOT_RENAME',
           'FDO_E_COMPRESSED_DATASET_NOT_SUPPORTED',
           'FDO_E_CADASTRAL_FABRIC_DATA_CORRUPTION',
           'esriDataExtractionType',
           'FDO_E_CODED_VALUE_DOMAIN_VALUE_INCONSISTENT',
           'IWorkspaceProperty', 'FDO_E_FEATURE_NO_ANNO',
           'FDO_E_DATASET_CANNOT_DELETE',
           'FDO_E_SE_INVALID_RASTERBAND_NUMBER',
           'DEGeoDataServerType', 'esriTRTAny',
           'ISynchronizationHelper', 'esriLeftOuterJoin',
           'FDO_E_LICENSE_NOT_INITIALIZED',
           'FDO_E_CADASTRAL_FABRIC_ALREADY_EXISTS',
           'esriSQL_StringConcatenate', 'NetWeight',
           'FDO_E_TABLE_NOT_VERSIONED', 'IVersionEdit',
           'esriSplitPolicyType', 'FDO_E_FIELD_IS_RELKEY_FIELD',
           'FDO_E_NETWORK', 'esriReplicaReconcilePolicyType',
           'IObjectClassInfo', 'esriBusinessTable',
           'FDO_E_SE_TABLE_REGISTERED', 'DERasterCatalogType',
           'IRouteEventProperties2', 'esriTinEdgeType',
           'esriRasterSdeCompressionTypeJPEG',
           'FDO_E_INVALID_NETWORK_LANDMARK_SOURCE',
           'FDO_E_SE_INVALID_VERSION_NAME', 'IFeatureBuffer',
           'ITinSurface3', 'ITinSurface2',
           'EvaluatedNetworkAttribute', 'esriFDUninitialized',
           'IFeatureWorkspaceManage3', 'IFeatureWorkspaceManage2',
           'esriNSTJunctionFeature', 'IOleDBConnectionInfo',
           'DETopology', 'esriDTLocator',
           'FDO_E_EVALUATOR_NOT_VALIDATED', 'esriTinNodesWithZeroTag',
           'FDO_E_DATASETTYPE_UNKNOWN', 'INetworkJunction2',
           'NETWORK_E_CANNOT_OPEN_LOGICAL_NETWORK',
           'FDO_E_WORKSPACE_EXTENSION_NO_REG_PRIV',
           'FDO_E_SE_FILE_IO_ERROR', 'esriFieldTypeSingle',
           'FDO_E_XML_EXPORT_DATASET_NOT_FOUND',
           'FDO_E_FIELDINFO_SYSTEM_TABLE_INCONSISTENCY',
           'IMetadataSynchronizerManager',
           'FDO_E_NO_DEFAULT_EDGE_EVALUATOR',
           'esriWorkspaceTablePropertyType',
           'esriNetworkEdgeConnectivityPolicy',
           'REP_E_REP_USES_REP_RULE', 'TopologyWorkspaceExtension',
           'IVersionedWorkspace', 'INameMapping2',
           'XYEVENT_E_INVALID_Y_TYPE', 'esriRCStreet',
           'esriSOExportDataChanges', 'esriRelClassKeyUndefined',
           'FDO_E_SE_LOCK_CONFLICT',
           'FDO_E_CONNECTIVITY_RULES_NOT_SUPPORTED',
           'IPlugInFastRowCount', 'esriNETMismatchedZValue',
           'FDO_E_SE_TABLE_SCHEMA_IS_LOCKED', 'esriTCMesh',
           'GPReplicaOptions',
           'FDO_E_FEATURECLASS_NETWORK_CANNOT_DELETE',
           'IRasterDatasetName', 'esriGeodatabaseVersion101',
           'RepresentationWorkspaceExtension',
           'esriGeodatabaseVersion102', 'IItemInfo',
           'ISimpleJunctionFeature', 'Objects',
           'esriGeometryStorageWKB',
           'IRepresentationWorkspaceExtension', 'IDEGeoDatasetType',
           'esriMCTChangeTolerance', 'ITopologyProtectNames',
           'esriSpatialRelIndexIntersects',
           'FDO_E_CADASTRAL_FABRIC_OPERATION_CANCELLED',
           'ITrafficFeedDirectory',
           'FDO_E_INVALID_NETWORK_ATTRIBUTE_ID',
           'IWorkspaceDefinition2', 'esriTTProgrammatic',
           'rstPixelType', 'esriGPMessageTypeInformative',
           'FDO_E_SE_PASSWORD_EXPIRED', 'E_TIN_LICENSE_NOT_AVAILABLE',
           'E_TIN_MUST_BE_DELAUNAY', 'esriModelTypeFullGeodatabase',
           'FDO_E_SE_SPATIALREF_IN_USE', 'IEnumRelationshipClassInfo',
           'NETWORK_E_OLD_WORKSPACE_VERSION', 'esriXPTText',
           'DERasterDatasetType', 'NETWORK_E_CANNOT_CREATE_TABLE',
           'ISelectionSet', 'esriRelKeyRoleOriginForeign',
           'NETWORK_E_ADD_WEIGHT_HAS_ELEMENTS',
           'FDO_E_TURN_NOT_PRESENT', 'RasterCatalogHelper',
           'esriReplicaTypeChild', 'FDO_E_SE_INVALID_FILTER_TYPE',
           'esriNAUTDescriptor', 'FDO_E_SE_ATTR_NOEXIST',
           'esriNETAssociatedWithMissingFeatures',
           'esriXMLIndexTypeTemplate',
           'esriWorkspacePropIsGeoDatabase',
           'esriNetworkEdgeDirection', 'esriPlaneReferenceType',
           'FDO_E_FEATURECLASS_BAD_DEFAULT_SUBTYPE_CODE',
           'ComplexEdgeFeature', 'FDO_E_SE_INVALID_PART_SEPARATOR',
           'ISpatialCacheManager', 'REP_E_NO_REP_RULES',
           'IPlugInIndexManager',
           'esriNFSBAtDeadEndsAndIntersections',
           'esriSyncModelPerReplica',
           'esriTopologySelectionResultXOR', 'SpatialFilter',
           'FDO_E_TURN_NDS_INTERIOR_EXTERIOR_CONFLICT',
           'esriRasterCompressionRLE', 'FDO_E_FEATURE_EMPTY_GEOMETRY',
           'ITimeQueryFilter',
           'E_DATACONVERTER_OPENFEATUREDATASETFAILED',
           'FDO_E_NETWORK_COVERING_HYPEREDGE_DOES_NOT_EXIST',
           'INetworkElement64', 'NETWORK_E_OVERFLOW_USER_SUB_ID',
           'FDO_E_SE_INVALID_DBA_PASSWORD',
           'FDO_E_SE_INVALID_DISTINCT_TYPE', 'WorkspaceProperty',
           'IGPHistoricalMarker', 'FDO_E_SE_INVALID_SHAPE_OBJECT',
           'ITinAdvanced3', 'ITinAdvanced2', 'esriFETConnectionPoint',
           'FDO_E_SE_INVALID_RASTER_NUMBER', 'IClassSchemaEditEx',
           'FDO_E_TOPOGRAPH_CORRUPT', 'esriFieldTypeGUID',
           'IXMLFilterDef', 'GPWorkspaceExtension',
           'FDO_E_FSTAR_INVALID_FROM_EDGE_FORWARD',
           'IRelQueryTableSettings',
           'FDO_E_WORKSPACE_EXTENSION_DATASET_MODIFY_FAILED',
           'IEnumGPValue', 'esriTinHardLine', 'SimpleJunctionFeature',
           'FDO_E_CADASTRAL_FABRIC_PACKET_LOAD_FAILED',
           'esriReplicaAccessType', 'esriSharedSchemaLock',
           'LOCATING_E_ROUTE_SHAPE_EMPTY',
           'FDO_E_ON_DELETE_MESSAGE_FAILED', 'IAttachmentInfo',
           'INetworkEvaluator2', 'FDO_E_TURN_GEOM_NOT_POLYLINE',
           'FDO_E_CANNOT_DELETE_POPULATED_FEATURE_CLASS',
           'FDO_E_RELATIONSHIPCLASS_ALREADY_EXISTS',
           'FDO_E_CANNOT_CONNECT_TO_SERVER', 'INetworkForwardStar',
           'esriTablePropSupportsMultiColumnIndexes',
           'esriNetworkRoadCategory',
           'FDO_E_MISSING_SYSTEM_JUNCTION_CLASS_ELEV_FIELD',
           'esriIsSQLReservedWord', 'esriWorkspacePropertyType',
           'FDO_E_CANNOT_DELETE_DOMAIN',
           'FDO_E_TABLE_CANNOT_ANALYZE_TABLE_VIEW',
           'esriNTPTInterior', 'PT_U1', 'AttachmentInfo',
           'GPTopologyMembership', 'IMetadataEdit', 'PT_U4',
           'IEnumNetworkFeature', 'GPReplicaDataset',
           'esriGPMessageTypeAbort', 'DENetworkDatasetType',
           'esriTinZLessContour',
           'E_TIN_UNSUPPORTED_SPATIAL_REFERENCE',
           'FDO_E_SE_OUTER_SHELLS_OVERLAP',
           'IReplicaDescriptionExtension', 'EnumDatasetType', 'IRow',
           'esriSQL_FLOOR', 'EnumInvalidObject', 'IIndexEdit',
           'FDO_E_INVALID_GRID_SIZE', 'esriXPTLink',
           'IGPReplicaOptions', 'esriSynchronizationOperations',
           'FDO_E_SE_LOG_IO_ERROR', 'esriXMLIndexTypeAuto',
           'esriRelNotificationBoth', 'esriDBMS_DB2',
           'DERepresentationClass',
           'FDO_REGISTER_NULLABLE_GLOBALID_NOT_SUPPORTED',
           'FDO_E_PENDING_BACKGROUND_PROCESSES',
           'FDO_E_TRAFFIC_DOWNLOAD_TIMEOUT', 'TableQueryName',
           'E_TIN_CANNOT_CREATE_OBJ', 'INativeTypeSearch',
           'INetworkTurn2', 'FDO_E_SE_LAYER_INUSE',
           'esriGeometryStorageMSSQLGeometry',
           'ITopologyErrorFeature', 'IWorkspaceName2',
           'FDO_E_SE_DBMS_DOES_NOT_SUPPORT',
           'FDO_E_ADD_FEATURE_TO_NETWORK', 'FDO_E_SYNTAX_ERROR',
           'FDO_E_BAD_TYPE_SYSTEM_JUNCTION_CLASS_ELEV_FIELD',
           'esriTinZLessSoftClip', 'IDEWorkspace2', 'IDEWorkspace3',
           'IPlugInDatasetInfo', 'XYEVENT_E_CANT_DELETE_FIELD',
           'esriRasterWriteErase', 'AttachmentManager', 'esriNETAll',
           'esriSpatialRelEnum', 'RowBuffer',
           'IReplicaFilterDescription', 'FDO_E_SE_TRACE_OFF',
           'IXYEventSourceName', 'esriFileSystemWorkspace',
           'FDO_E_FIELD_IS_NETWORK_ANCILLARY_FIELD', 'esriTSEmpty',
           'esriLocalSystemLocatorWorkspace',
           'FDO_E_SE_INVALID_SEARCH_METHOD', 'INetworkFieldEvaluator',
           'FDO_E_CANNOT_ALTER_SPATIALREF', 'esriNAUDecimeters',
           'IDEServerObject', 'esriSQL_SIN',
           'NETWORK_E_NO_EDIT_OPERATION_IN_PROGRESS',
           'NetworkDatasetFDExtension', 'FDO_E_INVALID_M_DOMAIN',
           'FDO_E_CANNOT_MODIFY_TOPOLOGY_ERROR_FEATURE',
           'FDO_E_SE_ROWLOCKING_NOT_ENABLED',
           'FDO_E_ROTATE_RELATED_FEATURES_FAILED', 'esriFTDimension',
           'FDO_E_SE_PROCESS_NOT_FOUND', 'esriMPTDefaultValue',
           'FDO_E_CURSOR_WRONG_TYPE', 'IIdentityXform',
           'FDO_E_REPLICA_NO_UNACKNOWLEDGED_GENERATIONS',
           'esriFETConnectorPoint', 'IDEBrowseOptions',
           'REP_E_WORKSPACE_DOESNT_SUPPORT_REP_EXTENSION',
           'FDO_E_CADASTRAL_FABRIC_JOB_ALREADY_EXISTS',
           'FDO_E_GEOMETRICNETWORK_ELEMENT_INCONSISTENCY',
           'E_TIN_FILE_EXISTS', 'OwnershipBasedAccessControl',
           'ITableFields', 'esriWorkspaceTablePropertyGroup',
           'RasterDatasetName', 'FDO_E_SE_INVALID_NUM_OF_PTS',
           'esriTinSurfaceType', 'FDO_E_DATASET_INVALID_DEFINITION',
           'IRasterValue2', 'esriEditDataChangesType',
           'EnumNetworkElement', 'esriFieldType',
           'IPlugInWorkspaceHelper', 'esriRegisterReplica',
           'FDO_E_FEATURECLASS_NETWORK_DATASET_CANNOT_DELETE',
           'FDO_E_SE_BINARY_TOO_SMALL', 'IFeatureProject',
           'FDO_E_SE_MULTIPLE_SPATIAL_COLS',
           'esriTSAnalyzedWithErrors', 'IExternalDeserializerGdb',
           'EnumVersionInfo', 'esriFeatureElementType', 'ObjectClass',
           'IRasterDataset3', 'IRasterDataset2', 'IModelInfo',
           'IReplica', 'esriNRCLocal', 'INetworkFunctionEvaluator',
           'esriSQL_TANH', 'FDO_E_TOPOLOGY_CANNOT_RENAME',
           'esriNAUNauticalMiles', 'DifferenceCursor', 'esriNTPTNone',
           'FDO_E_QUERYCLASS_INVALIDWHERE', 'Fields',
           'FDO_E_SIGNPOST_TABLE_NOT_REGISTERED',
           'FDO_E_REPLICA_CAN_ONLY_IMPORT_ACKNOWLEDGMENT',
           'TopologyGraph', 'esriRTJunctionConnectivity',
           'TopologyNode', 'esriReplicaModelType',
           'FDO_E_REQUIRED_INTERFACE_NOT_FOUND',
           'esriModelTypeSimple', 'ILocatorUI',
           'esriSelectionOptionNormal',
           'esriWorkspacePropLastCompressStatus',
           'FDO_E_NETWORK_DATASET_ALREADY_EXISTS',
           'E_TIN_POLYGON_NOT_DEFINED', 'esriNFARNone',
           'E_TIN_SUPER_NODE', 'FDO_E_GEOMETRY_CANNOT_HAVE_Z_VALUES',
           'esriDEExpandNone', 'QueryDef',
           'ISqlInvalidCharacterDictionary', 'ILocatorWorkspace2',
           'FDO_E_NETWORK_FUNCTION_EVALUATOR_OVERFLOW', 'ITableName',
           'FDO_E_SE_INVALID_NUM_PARTS', 'FDO_E_INVALID_SQL',
           'FDO_E_JOB_UNJOINED_PARCEL_PRESENT',
           'FDO_E_NO_SCRIPT_CONTROL', 'IGPCodedValueDomain2',
           'IFeatureProgress', 'TinTriangleFilter',
           'FDO_E_SE_INVALID_DATA_SOURCE', 'RelationshipClassName',
           'FDO_E_TURN_GEOM_NO_LAST_FEATURE',
           'FDO_E_INVALID_NETWORK_EDGE_DIRECTION',
           'esriSyncDirection', 'CoverageAnnotationFeature',
           'IGeoDatasetSchemaEdit2',
           'FDO_E_RESOLUTION_DOES_NOT_MATCH_PERMISSIBLE_VALUE',
           'IThumbnailInfo', 'INetElementDescriptionEdit',
           'FDO_E_REPLICA_IN_SENDING_DATA_STATE', 'esriNAUHours',
           'FDO_E_NETWORK_SOURCE_INCONSISTENT_ELEVATION_SPECIFICATION',
           'IReplicaDescriptionExtensionManager',
           'FDO_E_SE_INVALID_RASTERINFO_OBJECT', 'IFeatureWorkspace',
           'esriMSACreated', 'IWorkspaceReplicaSyncEvents',
           'E_TIN_FILTER_REQUIRED', 'AttachmentInfoArray',
           'esriSQL_CorrelationNameAllowsASKeyword',
           'esriTablePropCanAddField',
           'FDO_E_CONNECTED_FEATURE_DOES_NOT_EXIST',
           'FDO_E_FAILED_TO_CREATE_DELTA_WORKSPACE',
           'IXmlPropertySetEdit', 'FDO_E_CANNOT_BREAK_TOPOLOGY',
           'FDO_E_VERSION_NOT_RECONCILED',
           'FDO_E_DATASET_CANNOT_RENAME_NOT_SUPPORTED',
           'E_DATACONVERTER_INVALID_INPUT_DATASET_NAME',
           'FDO_E_RELATIONSHIP_ATTRIBUTES_INVALID',
           'IComplexJunctionFeature', 'IEnumProperty',
           'FDO_E_SE_OUT_OF_CONTEXT', 'esriDTCadDrawing',
           'FDO_E_INVALID_XY_DOMAIN', 'FDO_E_READONLY_REPLICA',
           'esriServerClassWorkgroup', 'IEnumSpatialReferenceInfo',
           'FDO_E_ZCOORDINATES_NOT_SUPPORTED_IN_RELEASE',
           'esriNRCNone', 'IDEFeatureDatasetType',
           'FDO_E_SUBTYPE_CODE_IS_NULL', 'IndexType',
           'FDO_E_FEATURECLASS_FD_NOT_EDITABLE',
           'FDO_E_INVALID_GEOMETRY_TYPE_FOR_NETWORK_FEATURE_CLASS',
           'esriWorkspacePropCanGetConfigurationKeywords',
           'FDO_E_INVALID_NETWORK_ATTRIBUTE_USAGE_TYPE',
           'esriTinTriangle', 'FDO_E_RECONCILE_VERSION_NOT_AVAILABLE',
           'FDO_E_OVERLAPPING_NETWORK_GLOBAL_TURN_DELAY_CATEGORIES',
           'IHistoricalTravelTimeEvaluator', 'ITinEdgeTypeFilter',
           'esriFieldTypeRaster', 'ITinSurfaceElement',
           'FDO_E_HISTORICAL_TRAFFIC_DATA_CANNOT_CHANGE',
           'FDO_E_NO_SPATIALREF', 'INetAttributes', 'INetworkUpdate',
           'IGPCodedValueDomain', 'esriDifferenceTypeUpdateNoChange',
           'FDO_E_QUERYTABLE_QUERYMISSING', 'esriSQL_VAR',
           'IEnumRelationship', 'FDO_E_SE_UNCHANGED',
           'FDO_E_INVALID_JUNCTION_INDEX', 'esriRasterStorage',
           'RecordSet', 'esriRTSpatial', 'WorkspaceFactory',
           'FDO_E_DIRECTIONAL_EVALUATOR_WITH_JUNCTION_SOURCE',
           'esriRelNotificationNone', 'NETWORK_E_OVERFLOW_USER_ID',
           'esriTRTPointCoveredByAreaBoundary', 'PT_LONG',
           'FDO_E_BINDING', 'FDO_E_SUBTYPES_REQUIRED', 'esriDTTable',
           'esriRSPPreserveOnLargest',
           'FDO_E_SUBTYPE_CODE_DOES_NOT_EXIST',
           'IWorkspaceExtensionManager',
           'esriRasterResamplingUpsampling',
           'esriEditDataChangesWithinSession', 'esriTRTAreaNoOverlap',
           'FDO_E_RELATIONSHIPCLASS_ORIGIN_DEST_NOT_FOUND',
           'FDO_E_VERSION_INVALID_STATE', 'FDO_E_TABLE_IN_USE',
           'FDO_E_COULD_NOT_ENCODE_INFO_ITEM', 'ITopologyProperties',
           'FDO_E_VERSION_NOT_HISTORICAL',
           'FDO_E_CODED_VALUE_DOMAIN_VALUE_ALREADY_EXISTS',
           'E_TIN_FIELD_ERROR', 'esriFieldTypeSmallInteger', 'Object',
           'FDO_E_CANNOT_LOCK_DOMAIN_AS_NOT_OWNER', 'ITopologyGraph4',
           'E_TIN_BAD_CLASS_CODES', 'FDO_E_TABLE_INVALID_KEYWORD',
           'esriNTACRight', 'FDO_E_FIELD_ALIAS_EXCEEDS_MAX_LENGTH',
           'ITopologyGraph3', 'IFeatureDatasetManage',
           'IDEEditorTracking', 'GPReplicas', 'esriSQL_SOUNDEX',
           'FDO_E_HISTORICAL_MARKER_ALREADY_EXISTS', 'DEGPServer',
           'FDO_E_SE_NO_ANNOTATION', 'IRasterValue',
           'esriGeoDatabaseServerMessageCode_InfoMessage', 'IIndexes',
           'IOverride',
           'FDO_E_WORKSPACEFACTORY_BAD_CONNECTIONPROPERTY',
           'E_TIN_NOT_IN_EDIT_MODE', 'ITinSelection',
           'FDO_E_SE_SHAPE_TEXT_TOO_LONG',
           'NETWORK_E_INVALID_ENGINE_CONNECTION',
           'IWorkspaceEditControl', 'FDO_E_FEATURE_DELETED',
           'FDO_E_SE_NO_CPGHOME', 'IEnumWorkspaceEx',
           'FDO_E_FIELD_NOT_NULLABLE', 'esriFTRasterCatalogItem',
           'REP_E_REP_RULE_NAME_ALREADY_EXISTS',
           'FDO_E_SE_INVALID_ALTER_OPERATION', 'RepresentationClass',
           'ISelectionSet2', 'esriTinNodeSourceType',
           'UtilityNetwork', 'IAttachmentManager',
           'MetadataCopyHelper',
           'FDO_E_DATASET_NOT_SUPPORTED_AT_WORKSPACE_LEVEL',
           'Representation', 'IDataElementHelper', 'IDERasterCatalog',
           'esriWorkspacePropSupportsMoveEditsToBase',
           'esriDBMS_Teradata', 'esriSyncDirectionUpload',
           'FDO_E_CANNOT_DELETE_SYSTEM_JUNCTION_SOURCE',
           'esriSQL_IS_NOT_NULL', 'E_TIN_HAS_VOID_Z',
           'FDO_E_TURN_GEOM_MULTIPART', 'esriTRTAreaCoveredByArea',
           'IEnumNetEID', 'esriTDTo',
           'FDO_E_DELETE_RELATIONSHIPS_FAILED', 'INetAttributesEdit',
           'ISQLSyntax', 'IUtilityNetworkGEN', 'FDO_E_SE_FAILURE',
           'ConfigurationParameter', 'FDO_E_NO_SCHEMA_LICENSE',
           'FDO_E_SPATIALREF_PRECISION_MISMATCH',
           'FDO_E_SE_INVALID_SPATIAL_COL_NAME',
           'FDO_E_CANNOT_SET_ENABLED_FIELD', 'RelQueryTableName',
           'DERasterBand',
           'FDO_E_NETWORK_FEATURES_HAVE_HOMOGENEOUS_Z_SUPPORT',
           'FDO_E_SE_INVALID_NUM_MEASURES', 'TinNodeArray',
           'FDO_E_SE_READ_ONLY_SHAPE', 'FDO_E_OLD_MESSAGE',
           'esriTCLoop', 'FDO_E_CADASTRAL_FABRIC_JOB_INVALID_STATUS',
           'FDO_E_RELATIONSHIPCLASS_INVALID_NAME',
           'TurnFeatureSource', 'FDO_E_QUERYCLASS_INVALIDSRID',
           'NETWORK_E_BAD_TURN_SELF_LOOP', 'StreetNameFields',
           'IObjectClass', 'IRasterDatasetEdit',
           'FDO_E_NETWORK_SOURCE_INVALID_FULLNAME', 'FieldType',
           'SystemJunctionSource', 'ITinTriangleFilter',
           'esriDEExpandDescendants',
           'XYEVENT_E_SOURCENAME_NOT_SETUP',
           'esriDTRelationshipClass',
           'FDO_E_QUERYCLASS_INVALIDSPATIALREFERENCE',
           'REP_E_GEODATABASE_DOESNT_SUPPORT_REPRESENTATIONS',
           'FDO_E_NO_PERMISSION', 'esriDatasetFileStatAccessMode',
           'FDO_E_DOMAIN_FIELD_TYPE_DOESNT_MATCH',
           'esriFieldTypeGeometry', 'IFeatureClassContainer',
           'FDO_E_OBJECT_IS_READONLY', 'INetWeightEdit',
           'E_TIN_BELOW_V8', 'NETWORK_E_COPY_OVERFLOW_USER_CLASS_ID',
           'FDO_E_FEATURE_BAD_SHAPE', 'DataElements',
           'FDO_E_INVALID_UNITS', 'FDO_E_DOMAIN_OWNER_DOESNT_MATCH',
           'FDO_E_STOP_EDITING_WITH_SAVE', 'esriTinNodeLineEnforce',
           'esriTinZLessHardLine', 'esriSQL_SIMILAR_TO',
           'IEnumGeometryBind', 'FDO_E_FEATURECLASS_LOAD_MODE',
           'FDO_E_CANNOT_SYNCHRONIZE', 'FDO_E_TURN_INVALID_MAX_EDGES',
           'ITrafficData2', 'ReplicaDescription',
           'IGPGeometricNetworkMembership',
           'FDO_E_QUERYTABLE_WORKSPACEMISSING',
           'esriWorkspacePropCanAnalyze',
           'FDO_E_SE_INVALID_LAYER_NUMBER', 'esriReplicaRole',
           'FDO_E_DATASET_UNEDITABLE', 'esriSPTDefaultValue',
           'E_TIN_FATAL', 'E_DATACONVERTER_ERROR_READ_ROWS',
           'FDO_E_GEOMETRY_HAS_NO_M_VALUES', 'esriDataXMLCheckOut',
           'esriReplicaStateWaitingForData', 'FDO_E_SE_INVALID_SQL',
           'ItemInfo', 'IVersionEvents', 'FDO_E_FIELD_ALREADY_EXISTS',
           'FDO_E_CUSTOM_COMPLEX_JUNCTION_NOT_IMPLEMENTED',
           'FDO_E_OPERATION_NOT_SUPPORTED_IN_EDIT_SESSION',
           'FDO_E_SE_FINISHED', 'DocumentationInfo',
           'esriNETMultipartGeometry', 'esriSQL_SIGN',
           'FDO_E_CLASS_FD_NOT_EDITABLE', 'WorkspaceEditEvents2',
           'IDatabaseConnectionInfo2', 'IDatabaseConnectionInfo3',
           'FDO_E_SE_AMBIGUOUS_NIL_SHAPE',
           'FDO_E_FEATURECLASS_NO_SUBTYPE_FIELD',
           'IDatabaseConnectionInfo4',
           'FDO_E_SE_INCOMPATIBLE_COORDREFS',
           'FDO_E_FIELD_MISSING_GEOMETRY_DEF', 'ResultPortionInfo',
           'FDO_E_NOT_SUPPORTED', 'TinPolygon', 'IRasterCursor',
           'esriSQL_IS_NULL', 'esriSQL_LOG10',
           'FDO_E_TURN_NO_EDGE_SOURCES', 'NetworkSource',
           'E_TIN_OUT_OF_MEMORY', 'E_TIN_POLYLINE_NOT_DEFINED',
           'esriDBMS_Hana', 'esriFTCoverageAnnotation', 'esriSQL_LOG',
           'GeometricNetworkName', 'esriTinDensified',
           'esriRegisterXMLCheckOut', 'GPNetworkDatasetMembership',
           'ITinAdvanced', 'IDirectionsLandmarkSource',
           'esriSelectPrivilege', 'FDO_E_OUT_OF_PHYSICAL_MEMORY',
           'FDO_E_OBJECTCLASS_NOT_REGISTERED',
           'esriTRTPointCoveredByLineEndpoint',
           'FDO_E_FIELD_IS_ASSOCIATED_WITH_DOMAIN',
           'FDO_E_SE_SPATIALREF_EXISTS', 'RecordNumberSet',
           'DEGeometryServer', 'DETableType',
           'FDO_E_GRID_SIZE_TOO_SMALL', 'FDO_E_NOT_ENOUGH_SPACE',
           'IEnumTable', 'esriSQL_ATAN',
           'FDO_E_GEOMETRY_TYPE_NOT_SUPPORTED',
           'FDO_E_VERSION_ALREADY_EXISTS', 'FDO_E_SE_STATE_INUSE',
           'NetWeightAssociation', 'esriFGDBCompressedDatafile',
           'IEnumTinElement', 'IMosaicDatasetName',
           'FDO_E_LOADING_RESOURCE', 'FDO_E_SE_INVALID_QUERY_TYPE',
           'NetworkEdgeTrafficEvaluator',
           'FDO_E_SE_INVALID_RASCOLINFO_OBJECT', 'IFieldEdit2',
           'FDO_E_SE_SHAPE_INTEGRITY_ERROR',
           'E_TIN_CANNOT_CREATE_GEOMETRY', 'esriDSInvalid',
           'IEnumNameMapping', 'E_TIN_FAILED_TO_OPEN',
           'FDO_E_DATASET_PASTE_NOT_SUPPORTED_IN_RELEASE',
           'esriTablePropCanDeleteField', 'ItemInfos',
           'IVersionedWorkspace2', 'FDO_E_FIELDS_NOT_FOUND',
           'FDO_E_GLOBALID_FIELD_REFERENCED_BY_REPLICA_CANNOT_BE_DELETED',
           'esriExtensionLocatorWorkspace',
           'FDO_E_NETWORK_FUNCTION_EVALUATOR_PARAMETER_NOT_NUMERIC',
           'AttributedRelationship', 'FDO_E_ITEM_RELATIONSHIP_EXISTS',
           'esriRowsType', 'esriNAUInches', 'esriSQL_LEADING',
           'ITinEdit2', 'FDO_E_WORKSPACE_NO_KEYSETTABLEMANAGER',
           'FDO_E_SE_SPATIALREF_NOEXIST', 'IFeatureClassEdit',
           'esriFTAnnotation',
           'FDO_E_VERSION_REQUIRES_PARENT_RECONCILE',
           'FDO_E_RELCLASS_INVALID_CURSOR',
           'esriSQLSpecialCharacters', 'NETWORK_E_DUPLICATE_PROPERTY',
           'ILocatorStyle', 'NetElementClass',
           'RasterCatalogClassDescription', 'XmlPropertySetEdit',
           'IVersionEdit3', 'FDO_E_NOT_EDITABLE_EDITSESSIONMODE',
           'FDO_E_INVALID_NETWORK_TIME_USAGE_TYPE', 'IXYEventSource',
           'esriRasterTableTypeEnum', 'FDO_E_QUERYCLASS_INVALIDNAME',
           'FDO_E_DRAWPHASE_UNKNOWN', 'ArchiveRegistrationInfo',
           'FDO_E_CHECKOUTS_CANNOT_REEXPORT_CHANGES', 'esriSQL_GE',
           'IObjectClass2', 'FDO_E_CADASTRAL_FABRIC_COMMIT_NO_NAME',
           'FDO_E_TURN_INVALID_CUR_MAX_EDGES',
           'INetworkConstantEvaluator', 'IEnumDatasetName',
           'ComplexJunctionFeature',
           'FDO_E_NO_NETWORK_ANCILLARY_ROLE',
           'FDO_E_BUILD_INSIDE_EDIT_SESSION',
           'FDO_E_CADASTRAL_FABRIC_JOB_CURRENTLY_EDITED',
           'FilterDefs', 'NetElementDescription',
           'esriTinNodeOriginal', 'esriTinSelectionAdd',
           'esriSPTGeometryRatio',
           'FDO_E_NETWORK_FUNCTION_EVALUATOR_OPERATOR_NOT_SUPPORTED',
           'IRasterFieldInfo', 'IFileDataLock',
           'esriTopologySelectionResultEnum',
           'esriNFSBAtDeadEndsOnly', 'FDO_E_NEGATIVE_RESOLUTION',
           'FDO_E_DATASET_ALREADY_EXISTS', 'FDO_E_VERSION_NOT_OWNER',
           'esriGeometryStorageMSSQLGeography',
           'esriGeometryStorageBinary', 'IVersionedView',
           'esriTRTAreaAreaCoverEachOther', 'DERasterBandType',
           'FDO_E_SERVER_NOT_AVAILABLE', 'IRasterDatasetEdit3',
           'IRasterDatasetEdit2', 'esriSQL_EXTRACT',
           'esriTinSurfacePerimeter', 'esriWTBitGate',
           'E_TIN_DIFFERENT_TIN', 'esriConfigurationKeywordNetwork',
           'FDO_E_FSTAR_INVALID_FROM_EDGE',
           'FDO_E_SE_INVALID_PARTNUM', 'FDO_E_CANNOT_EDIT_ZS',
           'TinImporter', 'esriVersionAccess', 'esriSQL_GT',
           'ILocatorUI2', 'esriRTRelationship',
           'esriGeometryStorageSDO', 'esriElevationAsRaster',
           'IRasterCatalog', 'esriSearchOrderSpatial',
           'esriSelectionOption', 'esriEditSearchBoth',
           'esriConfigurationKeywordMosaic',
           'FDO_E_WORKSPACE_EXTENSION_NOT_SUPPORTED', 'IRecordArray',
           'FDO_E_SE_INVALID_REGISTERED_LAYER_OPTION', 'TrafficData',
           'FDO_E_FIELDS_INVALID', 'esriSetOperation',
           'FDO_E_SE_INVALID_COORDSYS_DESC', 'esriReplicaState',
           'FDO_E_LICENSE_FAILURE', 'esriDTString', 'esriDomainType',
           'FDO_E_NETWORK_FEATURES_HAVE_HOMOGENEOUS_M_SUPPORT',
           'IEnterpriseWorkspaceFactory', 'IDatasetComponent2',
           'IReplica2', 'IReplica3', 'IForwardStar',
           'esriDTFeatureClass', 'esriSQL_POWER',
           'esriMESMNonVersioned', 'IDatasetNameFileStat',
           'ISpatialFilter',
           'FDO_E_CADASTRAL_FABRIC_COPY_WITH_TOPOLOGY_NOT_SUPPORTED_IN_RELEASE',
           'IFeatureSimplify2', 'IFieldsEdit',
           'esriRasterResamplingDownsampling',
           'FDO_E_INVALID_NETWORK_ATTRIBUTE_NAME',
           'FDO_E_TABLE_NOT_ARCHIVING',
           'FDO_E_INVALID_HIERARCHY_RANGES',
           'FDO_E_SE_INVALID_SPATIAL_COLUMN',
           'esriDegreeAspectAsRaster', 'IEnumReplicaDataset',
           'INetworkAttribute2', 'IExternalSerializerGdb2',
           'IObjects', 'FDO_E_QUERYDESCRIPTION_INVALIDGEOMETRYTYPE',
           'esriSQL_Time', 'FDO_E_SE_INVALID_PARAM_VALUE',
           'FDO_E_DOMAIN_FIELD_TYPE_MISMATCH', 'TableName',
           'FDO_E_GEOMETRY_NOT_SIMPLE',
           'FDO_E_SE_INVALID_INDICATOR_VALUE', 'XMLFilterDef',
           'FDO_E_CANT_MERGE_VERTICALEDGES',
           'esriDifferenceTypeInsert', 'IVersionedWorkspace4',
           'esriSQL_TRUNCATE', 'esriSQL_SUM', 'ITinFeatureSeed',
           'DEServerConnection', 'IExternalSerializerGdb',
           'FDO_E_XML_PARSE_ERROR', 'esriRelExtractDirectionNone',
           'FDO_E_INDEX_OUT_OF_RANGE', 'RelQueryCursor',
           'LOCATING_E_CANT_FIND_ROUTE', 'IGPMessageManager',
           'IDEGeometricNetwork', 'esriNETIdenticalStartStopVertex',
           'FDO_E_NO_INTEGRATEABLE_LAYERS', 'IVersionedWorkspace3',
           'FDO_E_SPATIALREL_NOT_SUPPORTED',
           'esriSQL_PositionRequiresCommas', 'FDO_E_FIELD_INVALID',
           'FDO_E_CADASTRAL_FABRIC_JOB_NOT_COMMITTED',
           'esriDatasetFileStatTimeLastAccess',
           'esriTinIgnoredElementType', 'E_TIN_WRONG_VARIANT_TYPE',
           'FDO_E_VERSION_CANNOT_BE_RECONCILED', 'IDEGeoDataset',
           'IEnumDataElement', 'FDO_E_CANNOT_CHANGE_ITEM_PROPERTY',
           'FDO_E_MODIFIED_GEOMETRY_MUST_BE_COPY',
           'FDO_E_NETWORK_SOURCE_DATASET_NOT_FOUND',
           'IRasterCatalogHelper', 'FDO_E_SPATIALREL_UNKNOWN',
           'NetworkFunctionEvaluator', 'esriFieldTypeGlobalID',
           'IGeodataXform', 'ICursor', 'DataElementHelper',
           'EnumFeatureGeometry',
           'FDO_E_NETWORK_DATASET_NO_TIME_ZONE', 'esriNRCPrimary',
           'IPlugInMetadata2', 'esriRelCardinalityOneToOne',
           'IGPDataTypeName',
           'FDO_E_TOPOLOGY_WORKSPACE_EXTENSION_NOT_FOUND',
           'FDO_E_BAD_SYSTEM_JUNCTION_SOURCE', 'FDO_E_VERSION_IN_USE',
           'FDO_E_INVALID_CLUSTER_TOLERANCE',
           'esriNetworkAttributeAdjustmentType',
           'esriTRTAreaCoveredByAreaClass', 'FDO_E_SERVER_NOT_FOUND',
           'IMemoryRelationshipClassFactory', 'FDO_E_COERCING',
           'FDO_E_CADASTRAL_FABRIC_SCHEMA_CORRUPTION',
           'E_TIN_FAILED_TO_COPY', 'IDETopology', 'esriWCSAvailable',
           'IFeatureClassWrite',
           'FDO_E_CANNOT_CREATE_LOW_PREC_DATASET_IN_HIGH_PREC_DB',
           'ISystemJunctionSource',
           'FDO_E_TURN_GEOM_NOT_ENOUGH_VERTICES',
           'IRepresentationClassName',
           'FDO_E_TURN_ILLEGAL_START_END_POS',
           'esriTRTPointCoincidePoint',
           'FDO_E_ALTERING_RULE_NOT_SUPPORTED', 'IGeoDBProtectNames',
           'FDO_E_SPLITTING_POLYLINES_REQUIRES_POINT',
           'IEnumHierarchyRange', 'LOCATING_E_NULL_EXTENT',
           'IThumbnailInfoImpl',
           'FDO_E_INVALID_NETWORK_ATTRIBUTE_ADJUSTMENT_VALUE',
           'IRandomAccessCursor', 'IDEFeatureClassType',
           'FDO_UNREGISTER_GLOBALID_NOT_SUPPORTED',
           'esriSyncDirectionSnapshot', 'esriFieldTypeDate',
           'FDO_E_CANNOT_ADD_NON_VERSIONED_CLASS_TO_VERSIONED_TOPOLOGY',
           'IDirectionsFieldMapping', 'IJunctionConnectivityRule',
           'ITinImporter', 'esriDTRepresentationClass',
           'FDO_E_SE_INVALID_VERSIONINFO_OBJECT',
           'IComplexNativeType',
           'FDO_E_DIRECTIONAL_EVALUATOR_WITH_TURN_SOURCE',
           'FDO_E_TOPOLOGY_ERROR_OVERFLOW', 'esriRelExtractDirection',
           'esriXMLIndexTypeAutoString', 'esriNTTExplicit',
           'esriDTTin', 'IValidation', 'INativeType',
           'esriTRTLineNoIntersectOrInteriorTouch',
           'FDO_E_SE_INVALID_STATEINFO_OBJECT',
           'E_TIN_WRONG_GEOMETRY_TYPE', 'XmlPropertySet', 'ISubtypes',
           'IGxFilterInfo', 'IDataset', 'E_TIN_OBJECT_NOT_EMPTY',
           'RSP_BilinearInterpolation', 'IGPReplicaDescription',
           'IPlugInFileSystemDataset', 'esriVersionAccessProtected',
           'FDO_E_SE_INDEX_EXISTS',
           'NETWORK_E_INVALID_ELEMENT_CLASSES', 'FeatureDataset',
           'esriSetIntersection', 'esriMSAAccessed',
           'FDO_E_INVALID_DIRECTIONS_LENGTH_UNIT',
           'NETWORK_E_UNKNOWN_NETWORK_TYPE', 'esriArchive',
           'esriMetadataSyncAction', 'FDO_E_SE_RASTER_NOEXIST',
           'E_TIN_FAILED_TO_SWAP', 'ITableCapabilities',
           'FDO_E_SPATIALFILTER_INVALID_SPATIAL_RELATION',
           'esriNAUDecimalDegrees',
           'FDO_E_CANNOT_RESET_CLUSTER_TOLERANCE',
           'FDO_E_NETWORK_CANNOT_RENAME', 'esriEditSearchBasicOnly',
           'IWorkspaceEvents', 'FDO_E_FIELD_IS_WEIGHT_FIELD',
           'FDO_E_SE_NO_CPGCVT', 'FDO_E_SE_NO_CAD', 'esriTTMove',
           'FDO_E_SE_STREAM_IN_PROGRESS', 'IVirtualTable',
           'FDO_E_CADASTRAL_FABRICS_NOT_SUPPORTED_IN_RELEASE',
           'esriSQL_CONVERT', 'esriTRTLineNoIntersectLine',
           'esriSQL_EscapeKeyPrefix',
           'FDO_E_CANNOT_EDIT_TABLE_WITH_UNIQ_USER_INDEX',
           'esriWorkspacePropertyGroup',
           'FDO_E_INVALID_CONNECTIVITY_CANNOT_BE_CORRECTED',
           'IWorkspaceStatus', 'FDO_E_SE_LOAD_ONLY_LAYER', 'IDETable',
           'FDO_E_INVALID_NETWORK_ANCILLARY_ROLE',
           'IWorkspaceFactory2', 'esriTRTAreaNoGaps',
           'IHistoricalTrafficData',
           'FDO_E_INVALID_NETWORK_SOURCE_FOR_EVALUATOR',
           'IEnumReplicaLog', 'ForwardStar', 'RSP_Majority',
           'esriNoFieldError', 'E_TIN_WRONG_FIELD_TYPE',
           'FDO_E_MISSING_ACKNOWLEDGEMENT', 'esriWTSingle',
           'esriTinNodeSnap', 'NetworkTurn',
           'FDO_E_SUBTYPE_CODE_NOT_INTEGER', 'FDO_E_SE_SDE_WARNING',
           'IGeometricNetworkConnectivity2', 'esriTinIntersection',
           'IEnumSubtype', 'esriDTRasterCatalog',
           'ITrafficFeedGPService', 'esriNETAssociatedElements',
           'FieldValue', 'esriSQL_TAN', 'esriSearchOrderAttribute',
           'E_TIN_WORKSPACE_EXISTS', 'NETWORK_E_INVALID_ELEMENT_ID',
           'INetworkQuery', 'IGeoDatabaseBridge',
           'NETWORK_E_INVALID_ELEMENT_TYPE', 'esriETJunction',
           'FDO_E_FEATURECLASS_TOPOLOGY_CANNOT_DELETE',
           'esriRelRoleDestination', 'esriNTPTExterior',
           'esriDTPlanarGraph', 'RasterValue',
           'esriTRTLineEndpointCoveredByPoint',
           'IGPWorkspaceExtension', 'IRelQueryTableManage',
           'IRemoteDatabaseWorkspaceFactory2',
           'FDO_E_NODIRECTIONAL_EVALUATOR_WITH_EDGE_SOURCE',
           'IFeatureChanges', 'esriRelRoleAny',
           'FDO_E_INVALID_NETWORK_SOURCE_GEOMETRY_TYPE',
           'NETWORK_E_INVALID_WEIGHT_TYPE',
           'FDO_E_SE_ROWLOCKING_ENABLED',
           'FDO_E_CADASTRAL_FABRIC_DATUM_MISMATCH',
           'ITinNodeCollection', 'IFeatureConnect',
           'FDO_E_EVALUATOR_CANNOT_BE_DEFAULT_EVALUATOR',
           'FDO_E_VERSION_BEING_RECONCILED',
           'FDO_E_CANNOT_UPDATE_COMPRESSED_DATASET',
           'esriTopologyFace', 'esriSpatialRelOverlaps',
           'E_TIN_FAILED_TO_DELETE_FILE', 'IDEMapServer',
           'IDEGeoDataServer', 'IDERasterBand', 'XYEventSource',
           'FDO_E_NETWORK_FUNCTION_EVALUATOR_REFERENCED_NETWORK_ATTRIBUTE_NOT_NUMERIC',
           'FDO_E_CANNOT_RENAME_WHILE_EDITING',
           'FDO_E_SE_INVALID_SERVER', 'esriRCHighway',
           'IForwardStarGEN', 'esriServerClassUnknown', 'Names',
           'FDO_E_CANT_STORE_VERTICAL_SEGMENT',
           'FDO_E_SE_SDEHOME_NOT_SET', 'IDocumentationInfo',
           'IDERasterCatalogType', 'INetworkScriptEvaluator',
           'IWorkspaceEdit', 'IEnumLocator', 'IFeatureClassManage',
           'FDO_E_ROW_NO_SETUPINTERFACE', 'IRasterDataset',
           'esriTinError', 'FDO_E_FEATURECLASS_MEMBER_OF_CONTROLLER',
           'IGeodatabaseRelease', 'FDO_E_NOT_PSEUDONODE',
           'MemoryRelationshipClassFactory',
           'FDO_E_UNSUPPORTED_TOPOLOGY_RULE', 'RSP_NearestNeighbor',
           'FDO_E_ITEM_DOES_NOT_HAVE_DEFINITION',
           'esriPlaneReferenceAbove',
           'E_DATACONVERTER_WRITEROWSFAILED',
           'FDO_E_SPATIALREF_INVALID',
           'FDO_E_GEOMETRICNETWORK_INVALID_NAME',
           'FDO_E_DATABASE_NOT_AVAILABLE', 'esriDEExpandType',
           'INetworkScriptEvaluator2',
           'FDO_E_INVALID_GEOMETRY_FOR_COMPLEX_JUNCTION',
           'IDatasetComponent', 'LOCATING_E_FROM_PARTIAL_MATCH',
           'FDO_E_INVALID_SCHEMA_UPDATE', 'IAttachmentManager2',
           'esriRasterResamplingHint',
           'FDO_E_CANNOT_ADD_REGISTERED_CLASS_TO_TOPOLOGY',
           'esriDuplicatedFieldName', 'ITinPolygon',
           'E_TIN_NULL_FIELD_VALUE', 'esriNETEdge',
           'FDO_E_SOURCE_DIRECTIONS_NOT_SUPPORTED',
           'FDO_E_NO_ATTRIBUTE_RECORD', 'IDEServerObjectType',
           'IObjectClassExtension', 'ISaveAs2', 'IGPVersionInfo',
           'FDO_E_METADATA_ADDING_FEATURECLASS', 'IDomain',
           'FDO_E_FEATURE_DATASET_CONTAINERS_NOT_SUPPORTED',
           'FDO_E_CADASTRAL_FABRIC_JOB_LOCK_ALREADY_EXISTS',
           'E_TIN_WRONG_SURFACE_TYPE', 'esriSQL_CURRENTUSER',
           'IRecordSet2', 'esriAddsTable', 'RSP_BilinearGaussBlur',
           'IWorkspaceDataElements2', 'IPlugInFileOperationsClass',
           'FDO_E_EVALUATOR_CREATE', 'FDO_E_SE_NO_SHAPES',
           'FDO_E_SE_ATTR_CONV_ERROR',
           'FDO_E_WORKSPACE_EXTENSION_DUP_NAME', 'EnumIDs',
           'esriRelClassCodeTypeInteger', 'esriTopologyState',
           'FDO_E_INVALID_NAME', 'FDO_E_SE_STATE_USED_BY_VERSION',
           'E_TIN_FIELD_ALREADY_EXISTS', 'esriNAUUnknown',
           'RepresentationClassName', 'SimpleRelationship',
           'FDO_E_TABLE_VERSIONED',
           'FDO_E_OBJECTCLASS_IN_CONTROLLER_DATASET',
           'FDO_E_DATASET_INVALID_TYPE',
           'FDO_E_DOMAIN_USED_AS_DEFAULT_DOMAIN', 'IVersionedObject',
           'IGeodatabaseRelease4', 'IGeodatabaseRelease2',
           'IGeodatabaseRelease3',
           'FDO_E_INVALID_FIELD_FOR_WEIGHT_ASSOCIATION',
           'WorkspaceDefinition', 'esriWorkspacePropIsReadonly',
           'FDO_E_SE_CORRIDOR_OUT_OF_BOUNDS',
           'FDO_E_DEFAULT_VALUE_NOT_NULLABLE',
           'FDO_E_SE_SSA_FUNCTION_ERROR',
           'FDO_E_FIELD_IS_REQUIRED_FIELD', 'FDO_E_VERSION_BAD_NAME',
           'IWorkspaceSpatialReferenceInfo',
           'FDO_E_FIELD_INVALID_TYPE', 'esriTinSoftValueFill',
           'LOCATING_E_MULTIPLE_LOCATION',
           'FDO_E_TOPOLOGY_EMPTY_GEOMETRY', 'FDO_E_SE_STABLE_LOCKED',
           'IFeatureClassLoad', 'esriNEMNone', 'NamesEnumerator',
           'FDO_E_INVALID_CONSTANT_FOR_NETWORK_ATTRIBUTE',
           'esriFETVertex', 'IQueryFilter',
           'FDO_E_NETWORK_ELEVATION_MODEL_CANNOT_CHANGE',
           'esriNRCMajor', 'IFeatureWorkspaceSchemaEdit',
           'IReplicaFilterDescription2', 'IObjectClassDescription',
           'esriNETTurn', 'IEvaluatedNetworkAttribute2',
           'FDO_E_SELECTION_NO_SELECTABLE_LAYERS',
           'esriTinNodeModified', 'esriDatasetFileStatTimeMode',
           'QueryTableName', 'FDO_E_STOP_EDITING_WITH_DISCARD',
           'PT_UNKNOWN', 'FDO_E_FSTAR_INVALID_FROM_EDGE_BACKWARD',
           'esriTinNodeIntersection', 'esriRowsTypeAll',
           'ITinTriangleArray', 'FDO_E_SE_INVALID_FUNCTION_ID',
           'E_TIN_MEMORY_TIN', 'IFieldChecker', 'Row', 'GPSubtype',
           'esriLinearInterpolation', 'NETWORK_E_READ_ONLY_NETWORK',
           'IEdgeFeature', 'esriRasterTableValue',
           'FDO_E_NETWORK_DATASET_INVALID_NAME',
           'FDO_E_INVALID_GEOMETRY', 'IMosaicDatasetName2', 'IIndex',
           'INetworkSourceDirections', 'TinEdgeArray',
           'FDO_E_CURSOR_DIFF_OPENED_IN_FRACTIONAL_SECONDS',
           'esriRTEdgeConnectivity', 'ISimpleEdgeFeature',
           'FDO_E_NETWORK_DATASET_NEEDS_UPGRADE',
           'IRepresentationClass', 'FDO_E_GEOMETRY_HAS_NO_Z_VALUES',
           'FDO_E_SE_LOG_IS_OPEN', 'FDO_E_SE_ROW_EXISTS',
           'IDEGeometryServerType', 'esriTinNodeDensified',
           'INetworkSourceDirections3', 'INetworkSourceDirections2',
           'IRasterCatalogHelper2', 'esriNTUtilityNetwork',
           'FDO_E_DATASET_EXTENSION_CREATE_FAILED', 'PT_SHORT',
           'FDO_E_SE_INVALID_GEOMETRY_TYPE',
           'esriTopologyElementType', 'NETWORK_E_CORRUPT_DATA',
           'esriSQLPredicates', 'NETWORK_E_INVALID_BITGATE_SIZE',
           'ITransactionsOptions', 'esriSQL_NOT_IN', 'ITableUtil',
           'FDO_E_SE_IOMGR_NO_DBMS_CONNECT', 'IDatasetEditEx',
           'FDO_E_OBJECT_IS_LOCKED', 'GeoDBDataTransfer', 'RasterDef',
           'IRasterDef2', 'IRasterDef3', 'FDO_E_SE_LAYER_CACHE_FULL',
           'PT_U2', 'IConfigurationParameter', 'esriDatasetType',
           'esriSpatialRelWithin',
           'FDO_E_OBJECTCLASS_REQUIRES_AN_EDIT_SESSION',
           'FDO_E_TOPOLOGY_OPERATION_CANCELLED', 'IGPRangeDomain2',
           'MosaicDatasetName', 'esriNSTEdgeFeature',
           'esriNEDAlongDigitized', 'esriSQL_ALL', 'IGPToolTip',
           'ITinPolyline', 'FDO_E_SE_PASSWORD_TIMEOUT',
           'IEnumTableVersionChanges', 'esriRelationshipSplitPolicy',
           'esriTCChain', 'TinTriangle', 'esriWTBoolean',
           'ICompressionInfo', 'esriSQL_OCTETLENGTH', 'IXMLIndexTags',
           'esriRasterWriteMode', 'IRasterLODInfos2',
           'esriTopologyParent', 'IAttachmentInfo2',
           'FDO_E_NETWORK_ATTRIBUTE_NOT_COST_USAGE',
           'FDO_E_GEOMETRY_MISSING_SPATIAL_REFERENCE',
           'esriSQL_NOT_SIMILAR_TO',
           'FDO_E_FEATURE_VALUE_TYPE_MISMATCH', 'XMLIndex',
           'esriTopologyRuleType', 'IDEGPServer',
           'FDO_E_TURN_CANNOT_CHANGE_SUPPORT',
           'FDO_E_QUERYDESCRIPTION_COLUMNEXISTS', 'IEnumRule',
           'FDO_E_CONNECTION_CANCELLED',
           'FDO_E_SE_IOMGR_NOT_AVAILABLE', 'IConflictClass',
           'FDO_E_CADASTRAL_FABRIC_JOB_NOT_FOUND',
           'esriGPMessageTypeWarning', 'IWorkspaceReplicaDatasets',
           'FDO_E_DATASET_INVALID_NAME', 'E_TIN_HAS_NO_VALUE',
           'FDO_E_DOMAIN_NAME_ALREADY_EXISTS', 'DEFeatureClassType',
           'FDO_E_INVALID_TOPOLOGY_RULE_CLASS_ASSIGNMENT',
           'GPVersionInfos',
           'FDO_E_CANNOT_DELETE_ORPHAN_JUNCTION_CLASS',
           'esriTinVersion', 'NetworkScriptEvaluator',
           'FDO_E_FEATURECLASS_INVALID_NAME', 'XMLIndexTag',
           'FDO_E_CADASTRAL_FABRIC_ILLEGAL_RECONCILE',
           'IGeoDatabaseErrorRecords', 'esriSOImportDataChanges',
           'TopologyErrorFeature', 'IVersionedObject2',
           'IVersionedObject3', 'FDO_E_INDEX_NOT_FOUND',
           'FDO_E_MISSING_ORIGIN_OR_DESTINATION_OBJECT',
           'NETWORK_E_BAD_TURN_UNCONNECTED_EDGES', 'RelQueryRow',
           'FDO_E_SE_TABLE_NOEXIST', 'esriSpatialRelContains',
           'TableSort', 'IEnumXMLIndexTemplate',
           'NETWORK_E_CANNOT_CLOSE_TABLE', 'esriTinInsideTin',
           'FDO_E_SE_INVALID_SHAPE_BUF_SIZE', 'esriTopoSide',
           'ILocalDatabaseCompact', 'IEventSource', 'VersionEvents',
           'IRowCompare', 'esriRasterCompressionPackBits',
           'NETWORK_E_EDIT_SESSION_IN_PROGRESS',
           'FDO_E_SE_MOSAIC_NOT_ALLOWED', 'FeatureConstruction',
           'FDO_E_NOT_SUPPORTED_ON_TOPOLOGY_ERROR_FEATURE',
           'FDO_E_SE_POLYGON_HAS_VERTICAL_LINE', 'IRasterBandName',
           'esriTinUniqueValue', 'FDO_E_INVALID_REPLICA',
           'FDO_REGISTER_VERSIONED_GLOBALID_NOT_SUPPORTED',
           'FDO_E_TOPOLOGY_SCHEMA_LOCK_CONFLICT', 'esriDSNormal',
           'IHistoricalClass', 'IRemoteDatabaseWorkspaceFactory',
           'FDO_E_SE_INVALID_POLYGON_CLOSURE',
           'FDO_E_CANNOT_MOVE_LABEL_OUT_OF_POLYGON',
           'IConfirmSendRelatedObjectEvents',
           'FDO_E_SE_INVALID_MVTABLE_INDEX',
           'esriGPMessageSeverityWarning', 'IQueryTableName',
           'FDO_E_ZERO_LENGTH_EDGE_ELEMENT', 'FieldChecker',
           'FDO_E_VERSION_UNEDITABLE',
           'FDO_E_OBJECTCLASS_MODEL_NAME_ALREADY_EXISTS',
           'IVersionedTable', 'NETWORK_E_BAD_TURN_UNCONNECTED_ANCHOR',
           'IFilterDefs', 'INetworkGlobalTurnDelayCategory',
           'FDO_E_RELCLASS_INCOMPATIBLE_WITH_EXISTING_RELCLASS',
           'FDO_E_DATASET_EXTENSION_INIT_FAILED',
           'FDO_E_FEATURECLASS_INSUFFICIENT_PRIVILEGE',
           'FDO_E_SE_PT_NO_EXIST', 'Index',
           'esriTinSimpleBoundsExclude',
           'FDO_E_WORKSPACE_EXTENSION_DATASET_RENAME_FAILED',
           'IReplicaDataset2', 'ReplicaDescriptionExtension',
           'E_TIN_BAD_VALUE', 'IFeature',
           'FDO_E_DOMAIN_VALUE_EXCEEDS_FIELD_LENGTH',
           'IWorkspaceReplicaEvents', 'IFields', 'IRule',
           'esriWorkspacePropertyGroupType',
           'DERelationshipClassType', 'FDO_E_USER_INVALID',
           'IFeatureWorkspaceAnno', 'IHistoricalMarker',
           'esriFDAgainstFlow', 'ITrafficDataManager',
           'INetworkAttribute3', 'IResultPortion',
           'LOCATING_E_FROM_TO_PARTIAL_MATCH',
           'NETWORK_E_UPDATE_SESSION_IN_PROGRESS',
           'FDO_E_MULTIPART_EDGE_FEATURE_NOT_SUPPORTED',
           'FDO_E_COMPARE_TYPE_MISMATCH',
           'REP_E_FEATURE_TYPE_NOT_SUPPORTED',
           'esriDifferenceTypeUpdateUpdate',
           'FDO_E_SE_TRANS_IN_PROGRESS',
           'FDO_E_EVALUATOR_INITIALIZE_QUERY',
           'FDO_E_SE_FUNCTION_SEQUENCE_ERROR',
           'FDO_E_NETWORK_ELEMENT_EVALUATOR_ERROR',
           'IDatasetMigration', 'esriRasterCompressionJPEGYCbCr',
           'esriSQL_SUBSTRING',
           'FDO_E_SPATIALFILTER_INVALID_GEOMETRY', 'esriRasterTable',
           'esriReplicaParentReadOnly', 'E_TIN_FAILED_RESET_EXTENT',
           'IField2', 'ITinClock', 'esriNSCannotOpenTables',
           'FGDCSynchronizer', 'INetworkElement',
           'IEnumNetworkElement', 'esriSelectionOptionOnlyOne',
           'esriRSPPreserveOnAll', 'esriGPMessageTypeGDBError',
           'FDO_E_CADASTRAL_FABRIC_COMMIT_NOT_DEFAULT',
           'NETWORK_E_MISSING_PROPERTY', 'FDO_E_SE_OUT_OF_MUTEXES',
           'esriRCUnknown', 'FDO_E_FIELD_IS_SUBTYPE_FIELD',
           'FDO_E_SE_TEMP_IO_ERROR', 'FDO_E_SELECTION_MISMATCH',
           'esriRasterStorageLOB', 'esriTRTLineNoSelfIntersect',
           'esriNetworkTurnType', 'FDO_E_SE_INVALID_MID_PT',
           'FDO_E_CANNOT_ADD_ORPHAN_JUNCTION_ON_EXISTING_JUNCTION',
           'IFeatureDataConverter',
           'FDO_E_NETWORK_SOURCE_MISSING_FEATURE_CLASS',
           'IGeometricNetworkErrorDetection',
           'FDO_E_WORKSPACE_ALREADY_CONNECTED',
           'FDO_E_SE_NO_STATE_SET', 'IFeatureClassExtension',
           'IDataChangesEx', 'XYEVENT_E_INVALID_Z_NAME',
           'EnumHistoricalMarker', 'FDO_E_SE_PROJECTION_ERROR',
           'FDO_E_PERSONAL_SDE_ONE_EDITOR', 'ITinDynamicFilter',
           'LOCATING_E_INVALIDRID', 'IGeometricNetwork',
           'GPRelationshipClassKey', 'E_TIN_NEED_TRIANGLE_SEED',
           'esriSQLOperator', 'REP_E_REP_CLASS_NAME_ALREADY_EXISTS',
           'Pnt', 'esriReplicaParentOrChildReadOnly',
           'INetworkJunction', 'FDO_E_SE_NO_ROWID_COLUMN',
           'esriMCTDeleteRule', 'FDO_E_SE_INVALID_CONNECTION',
           'NetworkWorkspace', 'NetworkJunction',
           'E_DATACONVERTER_OPENFEATURECLASSFAILED',
           'esriMSASelective', 'esriNADTFloat', 'esriTCStar',
           'FDO_E_REPLICA_SYNC_VERSION_NOT_YET_POSTED',
           'FDO_E_EVALUATOR_NOT_SUPPORTED',
           'FDO_E_CLASS_NOT_REPLICABLE', 'IReplicaEdit2',
           'esriNTACStraight',
           'esriWorkspacePropSupportsQualifiedNames',
           'FDO_E_VERSION_IS_PROTECTED',
           'FDO_E_SE_TOO_MANY_DISTINCTS',
           'FDO_E_SE_INVALID_BYTE_ORDER',
           'FDO_E_NETWORK_EVALUATOR_CREATE_FAILED',
           'NETWORK_E_NO_EDIT_SESSION_IN_PROGRESS', 'esriWTInteger',
           'XYEVENT_E_CANT_SELECT', 'FDO_E_SE_NIL_SHAPE_NOT_ALLOWED',
           'FDO_E_INSTANCE_DOES_NOT_SUPPORT_XML_TYPE',
           'IPlugInIndexInfo', 'esriNJCPOverride',
           'E_TIN_GEOMETRY_HAS_NO_Z', 'FDO_E_EVALUATOR_QUERY',
           'FDO_E_SE_TOO_MANY_RASTERS', 'esriTinSoftClip',
           'esriRemoteDatabaseWorkspace', 'FDO_E_FILE_IO',
           'tagFieldValue', 'NETWORK_E_DUPLICATE_TURN',
           'FDO_E_INVALID_NETWORK_EDGE_ATTRIBUTE_ADJUSTMENT',
           'INetElements', 'Feature', 'IWorkspaceName',
           'esriNSCannotCreateTables',
           'FDO_E_REPLICA_INVALID_OUTPUT_XML_FILE',
           'esriNAPUTRestriction', 'FDO_E_SE_NO_TRACE_LIBRARY',
           'IGPRelationshipClassKey', 'FDO_E_SE_TOO_MANY_RASTERBANDS',
           'esriDeletesTable', 'esriRelKeyRoleDestinationForeign',
           'esriWorkspacePropHasPrivateEditSession',
           'FDO_E_CANNOT_EDIT_DATASET_WITH_UNIQ_USER_INDEX',
           'esriRasterCompressionType', 'ISQLCheck',
           'esriGPMessageSeverityError', 'ISaveAs',
           'E_DATACONVERTER_UNLOADFAILED', 'esriTSLeft',
           'IInvalidObjectInfo', 'esriTinInsideDataArea',
           'IVersionEvents2', 'FDO_E_SE_INVALID_ETYPE_MASK',
           'FDO_E_INVALID_IMPORT_XML', 'ITableNameSet',
           'esriConfigurationKeywordNetworkDataset',
           'FDO_E_FIELDS_NO_OID', 'FDO_E_SE_INVALID_STREAM_SPEC',
           'FDO_E_TURN_NDS_EXTERIOR_LOOP',
           'FDO_E_DEFAULT_JUNCTIONS_NOT_SUPPORTED_IN_RELEASE',
           'MemoryRelationshipClassName',
           'FDO_E_INVALID_OPERATION_FOR_EDITSESSIONMODE',
           'FDO_E_OPERATION_NOT_SUPPORTED_IN_EDIT_OPERATION',
           'INetworkFeature', 'esriNaturalNeighborZmin',
           'INetworkForwardStarEx', 'FDO_E_SE_INVALID_SDEHOME',
           'FDO_E_SE_SELF_INTERSECTING',
           'FDO_E_FIELD_IS_ENABLED_FIELD', 'LOCATING_OK',
           'esriGPMessageSeverityAbort',
           'FDO_E_NETWORK_ATTRIBUTE_REFERENCES_SELF',
           'FDO_E_DRAWPHASE_NOT_SUPPORTED',
           'IWorkspaceFactoryFileExtensions', 'FDO_E_NOT_EDITING',
           'esriTTStretch', 'E_TIN_FAILED_TO_SAVE', 'esriNAUYards',
           'FDO_E_FIELD_INVALID_NAME', 'ConfigurationKeyword',
           'esriSQL_NOT_EXISTS', 'IJunctionFeature', 'IDEDataset',
           'esriTinDegreeSlope', 'ITableSortCallBack',
           'XMLIndexTemplate', 'FDO_E_SE_SCL_SYNTAX_ERROR',
           'FDO_E_CLOSED_POLYLINE', 'IXMLIndexEdit',
           'FDO_E_FAILED_TO_SET_TARGET_NAME', 'ITableSort',
           'esriDifferenceTypeUpdateDelete', 'MetadataSynchronizer',
           'esriRelDirectionBackward',
           'FDO_E_COULD_NOT_CLEAN_COVERAGE',
           'esriEditSearchNewDeltaOnly', 'esriGPMessageTypeEmpty',
           'esriLeftInnerJoin', 'INetworkCollection',
           'IRelationshipClassName', 'FDO_E_SE_ETYPE_CHANGED',
           'IField', 'IQueryName2',
           'FDO_E_NETWORK_SOURCE_NAME_DOESNT_EXIST', 'XMLIndexTags',
           'esriTopoConfiguration',
           'FDO_E_CANNOT_ADD_RULE_TO_VERSIONED_TOPOLOGY',
           'NETWORK_E_INVALID_USER_CLASS_ID', 'FDO_E_SE_SQL_TOO_LONG',
           'REP_E_FIELD_NAME_ALREADY_EXISTS',
           'IWorkspaceReplicasAdmin2', 'IWorkspaceReplicasAdmin3',
           'FDO_E_SE_INVALID_END_PT',
           'FDO_E_NO_DEFAULT_JUNCTION_EVALUATOR', 'IDatasetContainer',
           'esriNTUBeforeTraversal', 'IRasterStorageDef',
           'esriNETEdgeTooSmall', 'esriSQL_SUBSTRINGBYTES',
           'IWorkspaceFactory',
           'esriGeoDatabaseServerMessageCode_DebugMessage',
           'E_DATACONVERTER_OPENFEATUREWORKSPACEFAILED',
           'esriNAUMiles', 'FDO_E_NO_SYSTEM_JUNCTION_SOURCE',
           'esriRelClassKeyClassID', 'INativeTypeInfo',
           'E_TIN_NEED_VALUE', 'esriNDTGeodatabase',
           'NetworkSourceDirections', 'AttachmentData',
           'IGPMessagesCallback', 'Replica',
           'FDO_E_VERSION_NOT_FOUND', 'FDO_E_SE_VIEW_EXISTS',
           'IEnumLocatorName', 'ITinNodeArray', 'FDO_E_SE_READ_ONLY',
           'GPCodedValueDomain2', 'GPMessage', 'GPReplica',
           'IClassEx', 'FDO_E_CANNOT_ALTER_PRECISION',
           'IDatabaseCompact',
           'FDO_E_MISSING_NETWORK_SOURCE_FOR_EVALUATOR',
           'FDO_E_DATASETTYPE_NOT_SUPPORTED',
           'FDO_E_CANNOT_REGISTER_EMPTY_REPLICA',
           'LOCATING_E_INVALIDMEASURE', 'esriTinNodeCoincident',
           'esriRasterStorageBinary', 'esriTinSoftEdge',
           'RSP_BilinearInterpolationPlus', 'esriSpatialRelCrosses',
           'FDO_E_TOPOLOGY_ALREADY_EXISTS',
           'esriLocalDatabaseWorkspace',
           'FDO_E_NETWORK_SOURCE_NOT_SIMPLE_FEATURE_CLASS',
           'esriRelCardinalityOneToMany', 'esriTinHardReplace',
           'IWorkspaceHelper', 'esriFETWholeFeature', 'ITransactions',
           'FDO_E_FEATURECLASS_BAD_EXTENT',
           'FDO_E_EVALUATOR_NOT_VALID', 'FDO_E_CANNOT_SPLIT_JUNCTION',
           'FDO_E_QUERYTABLE_OIDMAPPEDCOLUMNHASNULL', 'TinNativeType',
           'esriNAATAdd', 'esriTinSoftReplace',
           'esriTRTLineCoveredByAreaBoundary', 'S_DATACONVERTER_OK',
           'FDO_E_SE_INVALID_POINTER',
           'FDO_E_INVALID_NETWORK_ELEMENT_ID', 'EnumAttachment',
           'IRowEdit', 'IHistoricalTrafficData2',
           'esriNetworkDatasetType', 'NetworkFieldEvaluator',
           'esriSQL_WildcardSingleMatch', 'IEnumConflictClass',
           'IWorkspaceEditEvents', 'IXMLIndexUtil',
           'FDO_E_SE_STATE_HAS_CHILDREN', 'IFIDSet2',
           'IWorkspaceProperties', 'CodedValueDomain',
           'esriRelNotificationBackward', 'FDO_E_SE_INVALID_SHAPE',
           'FDO_E_SE_OUT_OF_LICENSES', 'IGPValue',
           'IGPSystemToolboxLocation', 'IRelationshipClass2',
           'IRelationshipClass3', 'esriFieldNameErrorType',
           'FDO_E_DOMAIN_RECORD_NOT_FOUND',
           'esriSurfaceInterpolationType', 'INetwork',
           'LOCATING_E_ROUTE_MS_NULL', 'esriDTCadastralFabric',
           'DEGlobeServer', 'FDO_E_NETWORK_ATTRIBUTE_NOT_TIME_UNITS',
           'IFeatureDatasetName2', 'esriRepresentationError',
           'esriTinNodeSuperNode', 'esriEditSearchDeltaOnly',
           'esriNetworkForwardStarBacktrack',
           'FDO_E_GEOMETRICNETWORK_NOT_FOUND',
           'FDO_E_GENERATION_OUT_OF_ORDER', 'INetSchema',
           'FDO_E_REPLICA_NOT_FOUND', 'esriSQL_CAST',
           'FDO_E_CADASTRAL_FABRIC_ALREADY_UPGRADED',
           'ILocatorDataset', 'IRouteEventProperties',
           'IUtilityNetwork2',
           'FDO_NO_MATCH_DATASETS_FOUND_FOR_REGISTER_REPLICAS',
           'FDO_E_SE_LICENSE_FAILURE', 'esriNACreate',
           'NETWORK_E_INVALID_USER_ID', 'esriTRTAreaContainOnePoint',
           'E_DATACONVERTER_WRITEFEATURESFAILED',
           'FDO_E_INVALID_TIME_SLICE_FIELD_NAME',
           'IXYEvent2FieldsProperties', 'FDO_E_ITEM_WITH_PATH_EXISTS',
           'esriTin70001', 'E_DATACONVERTER_ERROR_READ_ALL_ROWS',
           'FDO_E_WORKSPACE_INVALID_KEYSETID', 'esriReplicaTypeAny',
           'XYEVENT_E_INVALID_X_NAME', 'esriSQL_VAR_SAMP',
           'FDO_E_FEATURECLASS_CANT_OPEN_TOPOLOGY',
           'esriWorkspacePropLastCompressDate',
           'FDO_E_SE_ETYPE_NOT_ALLOWED',
           'FDO_E_INVALID_GEOMETRY_TYPE_FOR_TOPOLOGY', 'esriDTRange',
           'esriNETAssociatedWithInvalidElements',
           'NETWORK_E_BAD_TURN_DUPLICATED_FIRST_LAST_EDGES',
           'TinEdgeTypeFilter', 'esriLocatingError',
           'NETWORK_E_OVERFLOW_ELEMENT_ID',
           'EnumNetWeightAssociation', 'INetworkEvaluator',
           'FDO_E_SE_INVALID_RASTERCOLUMN_NUMBER',
           'FDO_E_USER_DOES_NOT_HAVE_UPGRADE_PRIVILIGES',
           'FDO_E_ROW_ALREADY_EXISTS', 'IGPTopologyMembership',
           'esriRelRole', 'FDO_E_SE_STABLE_IN_USE', 'IFields2',
           'FDO_E_EDIT_OPERATION_REQUIRED', 'VersionInfo',
           'FDO_E_SE_RASTER_EXISTS', 'FDO_E_TABLE_ALREADY_EXISTS',
           'esriRasterSdeCompressionTypeEnum', 'WorkspaceExtension',
           'GeometryServer', 'E_TIN_NAN', 'esriNEMElevationFields',
           'GPRangeDomain2', 'IEnumTopologyParent',
           'FDO_E_MUST_BE_REPLICA_OWNER', 'IAttributeRule',
           'FDO_E_DOMAIN_USED_BY_ATTRIBUTE_RULE',
           'esriRasterCompressionUncompressed',
           'FDO_E_INVALID_TOPOLOGY_RULE', 'ITopologyClassName',
           'E_TIN_UPDATE_ERROR', 'NETWORK_E_INVALID_USER_SUB_ID',
           'esriDTGeometricNetwork', 'IDEGeometryServer',
           'INetworkAttributeParameter2', 'esriSQL_NOT_EQ',
           'FDO_E_QUERYDESCRIPTION_NOSPATIALCOLUMN',
           'FDO_E_TOPOLOGIES_NOT_SUPPORTED_IN_RELEASE',
           'FDO_E_NETWORK_NOT_FOUND', 'esriTRTLineCoveredByLineClass',
           'FDO_E_SE_INVALID_STREAM_TYPE', 'IFeatureDraw',
           'IQueryFilterDefinition', 'esriNFSBAllowBacktrack',
           'IClassExtension', 'TinTriangleArray',
           'DEServerConnectionType', 'FDO_E_QUERYCLASS_OIDUNKNOWN',
           'FDO_E_DELETE_PART_OBJECTS_FAILED', 'ITurnFeatureSource',
           'FDO_E_FEATURECLASS_NO_SHAPE_COLUMN', 'esriFieldTypeXML',
           'IDatasetContainerName', 'FDO_E_NO_POLYGONS_CREATED',
           'TinNodeSourceFilter', 'IArchivableObject',
           'IEnumAttachment',
           'esriNetworkAttributeParameterUsageType', 'esriDTTool',
           'IPlugInCreateDataset', 'esriNAUTRestriction',
           'IEnumEventError', 'FDO_E_TABLE_COLUMN_NOT_FOUND',
           'esriSPTDuplicate',
           'FDO_E_SE_NO_ARCSDE_LICENSE_SQLEXPRESS', 'FieldError',
           'FDO_E_METADATA_ADDING_DATASET', 'ICancelOperation',
           'FDO_E_FEATURE_SHAPE_UPDATE_BLOCKED',
           'esriSQL_NOT_BETWEEN', 'FDO_E_RELATIONSHIPCLASS_NOT_FOUND',
           'FDO_E_RELCLASS_CANNOT_RESET_FKEYS',
           'esriNSInvalidElementClasses', 'IClass',
           'FDO_E_EMPTY_ENVELOPE_FOR_CLEAN', 'esriGPMessageType',
           'esriSQL_CURRENTTIME', 'IFeatureClassDraw',
           'esriTRTPointCoveredByLine', 'esriNSNetworkAlreadyExist',
           'esriRasterResamplingFinest', 'JSONSerializerGdb',
           'IEnumConfigurationKeyword', 'QueryFilter', 'IMetadata',
           'NETWORK_E_CANNOT_DELETE_TABLE', 'IEnumFeatureSetup',
           'FDO_E_SE_LOCK_EXISTS', 'E_TIN_METADATA_ERROR',
           'IRelatedObjectClassEvents2',
           'FDO_E_SE_INVALID_STATS_TYPE', 'esriETEdge',
           'FDO_E_QUERYCLASS_NULLGEOMETRYTYPE',
           'FDO_E_CADASTRAL_FABRIC_COMMIT_JOB_LOCKED',
           'FDO_E_SE_NORM_DIM_TAB_VALUE_NOT_FOUND',
           'FDO_E_SELECTION_INVALID_TYPE', 'FDO_E_SE_VERSION_EXISTS',
           'esriNDSBuilt', 'esriTinSelectionFlip',
           'FDO_E_QUERYDESCRIPTION_INVALIDFIELDTYPE', 'IFeatureSnap',
           'esriFieldTypeOID', 'FDO_E_SE_INVALID_COLUMN_TYPE',
           'FDO_E_SE_TABLE_EXISTS', 'IDirectionsAttributeMapping',
           'esriSQL_MIN', 'esriXMLIndexTagDataType',
           'FDO_E_BUILD_NOT_SUPPORTED', 'esriVersionAccessPublic',
           'FDO_E_TOPOLOGY_HAS_NO_CLASSES',
           'FDO_E_OPEN_LOGICAL_NETWORK', 'FDO_E_SE_INVALID_NOT_NULL',
           'FDO_E_RELATIONSHIP_VISIBILITY_INVALID',
           'ISimpleDataConverter', 'FDO_E_TURN_MISSING_EDGE',
           'E_TIN_FAILED_TO_OPEN_FILE',
           'FDO_E_DATASET_EXTENSION_TYPE_NOT_FOUND', 'DEFeatureClass',
           'FDO_E_NO_PARTIAL_REBUILD', 'DERasterCatalog',
           'IConfigurationKeyword', 'esriFieldTypeBlob',
           'FDO_E_SERVER_MAX_CONNECTIONS', 'IWorkspaceProperties2',
           'FDO_E_TABLE_SIZE_EXCEEDED',
           'FDO_E_PENDING_GEOPROCESSING_INPUT', 'esriETTurn',
           'INetworkSource', 'FDO_E_WORKSPACE_EXTENSION_INIT_FAILED',
           'FDO_E_RELCLASS_INVALID_FKEY', 'IFieldEdit',
           'esriNDTUnknown', 'FDO_E_CANNOT_MOVE_UNIVERSE_LABELS',
           'XYEVENT_E_INVALID_X_TYPE', 'E_TIN_NODE_UNDELETABL',
           'esriFDWithFlow', 'IHistoricalVersion', 'ITinNode2',
           'FDO_E_QUERYDESCRIPTION_OIDNOTMAPPEDCOLUMN', 'ClassHelper',
           'FDO_E_TURN_GEOM_TOO_MANY_VERTICES',
           'esriReplicaAccessNone', 'FDO_E_SE_NO_REQUEST_RESULTS',
           'IPlugInNetworkDatasetContainer',
           'FDO_E_SE_NO_SDE_ROWID_COLUMN',
           'FDO_E_INVALID_TIME_ZONE_NAME',
           'esriNetworkAttributeUnits',
           'esriReplicaResolveConflictsNone',
           'FDO_E_TURN_GEOM_INVALID_SEQUENCE', 'FDO_E_REPLICA_LOCKED',
           'FDO_E_SE_RASTERCOLUMN_NOEXIST', 'esriRelKeyTypeDual',
           'IEnumUserInfo', 'TransformGroup',
           'NETWORK_E_PROPERTY_IS_ALREADY_SET',
           'esriDatasetFileStatAccessUnknown',
           'FDO_E_PROPERTY_NO_SUBTYPE',
           'FDO_E_CANNOT_COPY_CLASS_WITHOUT_ALL_CONTROLLERS',
           'FDO_E_RELATED_DATASET_IS_REFERENCED_BY_REPLICA',
           'FDO_E_TURN_NOT_VALID', 'AttachmentDataArray',
           'DirectionsFieldMapping', 'FDO_E_INVALID_TIME_VALUE',
           'REP_E_NO_REP_SYSTEM_TABLES', 'PT_CSHORT',
           'esriDTContainer', 'esriETNone', 'esriSQL_ASCII',
           'IFeatureDatasetExtension2', 'FDO_E_FIELD_NOT_EDITABLE',
           'IPlugInMetadataPath2', 'FDO_E_SE_VIEW_NOEXIST',
           'esriWTNull', 'IPlugInCursorHelper', 'IGPMessages',
           'FDO_E_SYNCHRONIZATION_HAS_CONFLICTS',
           'E_TIN_FAILED_TO_RENAME', 'IWorkspaceEdit2',
           'IRelQueryTableInfo',
           'FDO_E_CODED_VALUE_DOMAIN_NAME_EMPTY',
           'esriNetworkElementType', 'IEnumWorkspaceStatus',
           'esriFileSystemLocatorWorkspace', 'ITopologyContainer2',
           'IDEWorkspace', 'E_TIN_NO_SPATIALREF_INFO', 'IEnumIndex',
           'REP_E_MUST_BE_THE_OWNER',
           'FDO_E_METADATA_TABLE_NOT_FOUND',
           'NETWORK_E_CANNOT_WRITE_TABLE', 'esriNEDNone',
           'FDO_E_ONLY_SIMPLE_FEATURES_SUPPORTED',
           'AttributedRelationshipClass',
           'esriXMLIndexTagDataTypeVarChar', 'ITopologyName',
           'FDO_E_SE_COLUMN_NOT_BOUND', 'FDO_E_SE_TOO_MANY_PARTS',
           'RangeDomain', 'IGPMessage2',
           'FDO_E_FIELD_CANNOT_DELETE_LAST_FIELD', 'IRecordSet',
           'IRelationshipClassEvents', 'esriNECPEndVertex',
           'IPlugInFileOperations',
           'FDO_E_TABLE_RECORD_LENGTH_EXCEEDED',
           'FDO_E_ITEM_RELATIONSHIP_NOT_FOUND',
           'IRelationshipClassContainer', 'ITopology2',
           'FDO_E_METADATA_BAD_CLSID',
           'FDO_E_NETWORK_DATASETS_NOT_SUPPORTED_IN_RELEASE',
           'FDO_E_CANT_MERGE_BRANCHINGEDGES',
           'FDO_E_WORKSPACE_EXTENSION_DUP_GUID', 'GPDataTypeName',
           'esriPercentageSlope', 'FDO_E_SIGNPOSTS_NOT_SUPPORTED',
           'esriWorkspacePropSupportsHighPrecisionStorage',
           'IFeatureCursor', 'IWorkspaceDataElements',
           'esriDatasetFileStatAccessWrite', 'IGPReplicas',
           'esriTinUnknown', 'esriGeometryStoragePostGIS',
           'IXMLIndexTag', 'FDO_E_INCOMPATIBLE_CLIENT_VERSION',
           'INetworkTurn', 'IEnumRelationshipClass',
           'XYEventSourceName', 'esriSQL_LOWER',
           'esriNSTSystemJunction', 'FDO_E_FLIPPED_POLYLINE',
           'esriXSPAAddOrReplace', 'esriXSPAAddIfNotExists',
           'tagesriTopologyParent', 'E_TIN_IN_MEMORY_EDIT',
           'UnknownDatasetName', 'WorkspaceName',
           'FDO_E_CURSOR_LOCKED', 'esriTopologyNode',
           'ISimpleRelationshipChanges', 'IStringDomain',
           'E_TIN_FAILED_TO_CREATE_FILE', 'esriDegreeSlope',
           'FDO_E_NETWORK_OBJECT_EVALUATOR_ERROR',
           'esriRasterSdeCompressionTypeRunLength',
           'NetworkGlobalTurnDelayCategory', 'WorkspaceHelper',
           'FDO_E_CANNOT_CHECKOUT_HIGH_PREC_DATA_IN_LOW_PREC_DATASET',
           'RelationshipClass', 'esriTinRegularEdge',
           'DEGeometricNetworkType',
           'FDO_E_ATTRIBUTES_WITHOUT_SOURCES',
           'TopologyGraphEventsHelper', 'FDO_E_ROW_NOT_FOUND',
           'FDO_E_TABLE_MOVINGEDITSTOBASE',
           'IConfigurationParameter2',
           'FDO_E_FIELD_CANNOT_DELETE_SUBTYPE_FIELD',
           'esriNetworkAttributeDataType', 'IEnumVersionInfo2',
           'esriSQL_CHARLENGTH', 'E_TIN_EMPTY_OBJECT',
           'FDO_E_MODIFY_EDGE_ENDPOINT', 'IRelQueryTableName2',
           'esriMSAOverwrite', 'FDO_E_SE_TOO_MANY_STATES',
           'esriTSAnalyzedWithoutErrors', 'esriSetUnion',
           'esriTablePropCanAddIndex',
           'NETWORK_E_INVALID_FORMAT_NUMBER',
           'FDO_E_SE_ERROR_LOADING_SSA', 'esriTSRight',
           'FDO_E_SE_SHAPE_TEXT_ERROR',
           'FDO_E_INVALID_NETWORK_ATTRIBUTE',
           'FDO_E_SE_INCOMPATIBLE_SHAPES',
           'esriRasterSdeCompressionTypeUncompressed',
           'IPlugInLicense', 'IObjectClassEvents',
           'IDENetworkDataset', 'esriDTLayer',
           'esriTRTLineNoSelfOverlap', 'FDO_E_SE_NET_TIMEOUT',
           'IPlugInGxIntegration',
           'FDO_E_ATTACHMENTS_ONLY_ON_GEODATABASES',
           'IWorkspaceProgressTracker', 'IFeatureClassName',
           'esriNetworkTimeUsage', 'esriTRTLineNoMultipart',
           'IDataElementInfo',
           'FDO_E_INVALID_CONNECTION_POINT_GEOMETRY', 'IFeatureEdit',
           'IDatasetContainer2', 'IDatasetContainer3', 'IGPVariable',
           'ILocatorName', 'FeatureCursor',
           'FDO_E_FEATURE_NO_GEOMETRY', 'PT_USHORT',
           'FDO_E_FIELD_CANNOT_DELETE_WEIGHT_FIELD',
           'FDO_E_SE_IOMGR_NOT_FOUND', 'IQueryDef', 'IEnumTGHitInfo',
           'esriSQL_UPPER', 'ISimpleNetworkFeature',
           'GPHistoricalMarker', 'esriSQL_SINH',
           'RepresentationRules', 'IFilterDef', 'IDataStatistics',
           'IFeatureClassStorage', 'esriNETJunction',
           'esriNSReadOnlyNetwork', 'NetworkGlobalTurnDelayEvaluator',
           'esriTinContour', 'FDO_E_SE_INVALID_SYSTEM_UNITS',
           'esriRelClassCodeTypeString', 'SimpleEdgeFeature',
           'FDO_E_CURSOR_INVALIDATED', 'IPlugInWorkspaceHelper2',
           'FDO_E_INVALID_POSITION_RANGE',
           'FDO_E_NETWORK_SOURCE_INVALID_NAME',
           'FDO_E_SE_GSIZE_TOO_SMALL', 'esriTinPercentageSlope',
           'IRecord', 'esriRasterWriteMosaic',
           'esriDTSchematicDataset', 'esriTRTAreaNoOverlapArea',
           'Attachment', 'IGPDomain2', 'esriSQL_ORDER_BY',
           'esriNSInvalidWeights', 'E_TIN_EXTENSION_DISABLED',
           'IAttachment2', 'esriDataXMLExport',
           'FDO_E_SE_INVALID_STREAM', 'MemoryRelationshipClass',
           'FDO_E_HIGH_PRECISION_SR_NOT_SUPPORTED',
           'ITopologyRuleContainer',
           'FDO_E_CANNOT_ALTER_NON_EXISTANT_RULE',
           'FDO_E_TOPOLOGY_ENGINE_FAILURE', 'esriDataConverterError',
           'IDEGdbUtilities', 'FDO_E_SE_BIND_CONFLICT',
           'esriRasterSdeCompressionTypeJPEG2000',
           'IDENetworkDataset2',
           'FDO_E_TOPOLOGY_RULE_NOT_SUPPORTED_IN_RELEASE',
           'IDatasetEditInfo', 'RelQueryTableFactory',
           'esriSQL_DelimitedIdentifierPrefix',
           'NETWORK_E_INVALID_FEATURE_WORKSPACE',
           'esriSyncDirectionDownload', 'ITrafficFeedLocation',
           'FDO_E_CANNOT_SET_WEIGHT_FIELD', 'esriRelCardinality',
           'esriRelClassKeyClassCode',
           'FDO_E_SE_TOO_MANY_RASTERCOLUMNS',
           'FDO_E_FORWARDSTAR_ADD_CACHED_ATTRIBUTE_DEPRECATED',
           'esriSQL_TRAILING', 'IGPReplicaDatasets',
           'REP_E_REP_CLASS_NOT_FOUND', 'FIDSet', 'DENetworkDataset',
           'Workspace', 'FDO_E_TURN_NOT_ENOUGH_PARTS',
           'FDO_E_CONNECT_PARAMETERS_CONFLICT',
           'esriWorkspacePropCanExecuteSQL', 'IPlugInDatasetLoader',
           'esriTRTLineNoIntersection', 'IDENetworkDatasetType',
           'NETWORK_E_INVALID_NETWORK', 'INetworkWorkspace',
           'E_TIN_UNHANDLED_EXCEPTION', 'esriSQLReservedWord',
           'esriLocalDatabaseLocatorWorkspace', 'IRowEvents',
           'LOCATING_E_CANT_FIND_LOCATION', 'ISchemaLock',
           'NetworkForwardStarAdjacencies',
           'FDO_E_DRAWSTYLE_NOT_SUPPORTED',
           'FDO_E_SE_INVALID_STATE_ID',
           'FDO_E_EVALUATOR_INITIALIZE_DATA', 'PT_FLOAT',
           'RSP_CubicConvolution', 'FDO_E_INCONSISTENT_TOPOLOGY_RULE',
           'esriWorkspacePropSupportsMetadata', 'esriNRCSecondary',
           'INetworkDirections', 'E_DATACONVERTER_INSERTCURSORFAILED',
           'IDEGlobeServer', 'E_DATACONVERTER_CREATETABLEFAILED',
           'esriSQL_CHAR', 'E_TIN_BAD_CLASS_BREAKS', 'IStreetNetwork',
           'FDO_E_OBJECT_MAX_REACHED', 'IProperty', 'IAttachmentData',
           'IFeatureDataConverter2', 'esriTopologySelectionResultNew',
           'FDO_E_SE_NORM_DIM_INFO_NOT_FOUND',
           'FDO_E_TURN_GEOM_AMBIGUOUS_FEATURES', 'RasterBandName',
           'FDO_E_RELATIONSHIPCLASS_INVALID_SPEC',
           'FDO_E_CANNOT_ADD_VERSIONED_CLASS_TO_NON_VERSIONED_TOPOLOGY',
           'esriNDSUnbuilt', 'FDO_E_SE_INVALID_LAYER_NAME',
           'esriSpatialRelEnvelopeIntersects', 'IReplicaEdit',
           'ICodedValueDomain2',
           'FDO_E_INVALID_FEATURE_TYPE_FOR_TOPOLOGY',
           'IErrorFeatureContainer', 'IQueryFilterDefinition2',
           'ILockInfo', 'FDO_E_INVALID_CONNECTIVITY_GROUP_NAME',
           'FDO_E_SUBTYPES_UNSPECIFIED_CONN_POLICY',
           'GPGeometricNetworkMembership', 'FDO_E_SE_ALL_SLIVERS',
           'IDEServerConnection', 'IEnumVersionInfo',
           'IGeoDatasetSchemaEdit', 'FDO_E_FIELDS_MULTIPLE_GLOBALIDS',
           'INetworkEdge', 'RecordArray', 'esriSQL_EXISTS',
           'FDO_E_FAILED_FILTERING_CONFLICTS',
           'FDO_E_SE_PARENT_NOT_CLOSED', 'esriSQL_BETWEEN',
           'FDO_E_EVALUATOR_NOT_INITIALIZED', 'esriFETPart',
           'esriNETInvalidSubtypeValue', 'FDO_E_ABORT_EDITS_FAILED',
           'IQueryDef2', 'TinNodeEnumerator',
           'FDO_E_SE_WRONG_COLUMN_TYPE', 'ITransformGroup',
           'esriSQL_DISTINCT', 'IFeatureClassCreation',
           'FDO_E_CURSOR_INVALID', 'VersionedWorkspace',
           'esriNEDAgainstDigitized', 'FDO_E_CORUPTED_COVERAGE',
           'IGPVersionInfos', 'REP_E_NAME_HAS_INVALID_CHARACTERS',
           'esriSQLClauses', 'esriTablePropOIDIsRecordNumber',
           'DEGdbUtilities', 'FDO_E_OBJECT_IS_DELETED',
           'NetworkForwardStar', 'FDO_E_INVALID_CATALOG_PATH',
           'GeometryDef', 'esriRasterTableIndex',
           'FDO_E_NON_SIMPLE_DATASET_CANNOT_BE_REGISTERED_BY_REPLICA',
           'EnumNetEIDArray', 'FDO_E_SE_UNSUPPORTED_ON_VIEW',
           'E_DATACONVERTER_CANCELLED', 'esriTinHardClip',
           'ITinValueFilter2', 'esriWCSUp',
           'FDO_E_OBJECT_NOT_INITIALIZED', 'esriDTMap',
           'GPReplicaDatasets', 'FDO_E_TRAFFIC_DATA_NOT_SUPPORTED',
           'esriRTTopology', 'FDO_E_DBMS_ERROR', 'esriXPTPictureX',
           'esriSpatialRelIntersects', 'esriSQL_HEX', 'ITableWrite2',
           'FDO_DATA_CANNOT_BE_REGISTERED_AS_REPLICAS_IN_TRANSPORT_FGDB',
           'IOwnershipBasedAccessControl',
           'FDO_E_VERSIONING_NOT_SUPPORTED', 'IDEGdbTable2',
           'LOCATING_E_ROUTE_NOT_MAWARE',
           'FDO_E_DATASET_TYPE_NOT_SUPPORTED_IN_RELEASE',
           'IPlugInMetadata',
           'FDO_E_SE_INVALID_SPATIALREFINFO_OBJECT',
           'esriRegisterCheckOut', 'IFeatureDatasetExtension',
           'esriSyncDirectionNone', 'esriGPMessageSeverity',
           'FDO_E_SE_TABLE_NOREGISTERED',
           'FDO_E_NETWORK_FUNCTION_EVALUATOR_ARGUMENT2_INVALID',
           'INetworkScriptEvaluatorFunctions',
           'esriNETMissingAllElements', 'IValidation2',
           'ICollectionTableVersionChanges',
           'ICoverageAnnotationFeature',
           'FDO_E_CADASTRAL_FABRIC_OBJECT_ALREADY_MODIFIED',
           'esriGeoDatabaseServerMessageCode_ErrorMessage',
           'IQueryDescription', 'esriMPTAreaWeighted',
           'IPersistCustomFeaturesExtension',
           'FDO_E_INCORRECT_DATA_ELEMENT_TYPE',
           'esriDatasetFileStatTimeCreation']
from comtypes import _check_version; _check_version('501')
